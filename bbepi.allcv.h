/*
 *  bbepi.allcv.h
 *
 *  Do not edit this file. It is automatically generated by EPIC.
 *
 *  Date : Oct  9 2013
 *  Time : 17:18:52
 */

#ifndef h_bbepi_allcv_h
#define h_bbepi_allcv_h

long _firstcv = 0;
/* *************************************************
   REQUIRED CVS
   ************************************************ */

int opresearch = 0 






;

/* ****************************
   Patient/Study Parameters 
   ************************** */
float opweight = 50 






;

/* ****************************
   Patient Position Parameters 
   ************************** */

int oplandmark = PSD_OFF 






;

int optabent = 0 






;

int opentry = 1 






;

int oppos = 1 






;

int opplane = PSD_AXIAL 






;

int opphysplane = PSD_AXIAL 






;

int opobplane = PSD_AXIAL 






;

int opimode = PSD_2D 






;

int oppseq = 1 






;

/* opgradmode says which coil is active in TRM_COIL (twin gradient) (Gili) */
int opgradmode = 0 






;


/* ************************** 
   Imaging Options CVs 
   *************************** */
int piimgoptlist = 0 






;

int opcgate = 0 






;

int opexor = 0 






;

int opcmon = 0 






;

int opfcomp = 0 






;

int opgrx = 0 






;

int opgrxroi = 0 






;

int opnopwrap = 0 






;

int opptsize = 2 






;

int oppomp = 0 






;

int opscic = 0 






;

int oprect = 0 






;

int opsquare = 0 






;

int opvbw = 0 






;

int opblim = 0 






;

int opfast = 0 






;

int opcs = 0 






;

int opdeprep = 0 






;

int opirprep = 0 






;

int opmph = 0 






;

int opdynaplan = 0 






;

/*  Black Blood Suppression */
int opbsp = 0 






;

int oprealtime = 0 






;

int opfluorotrigger = 0 






;

int opET = 0 






;

int opmultistation = 0 






;

int opepi = 0 






;

int opflair = 0 






;


int optlrdrf = 0 






;

int opfulltrain = 0 






;

int opirmode = SIRMODE 






;

int opmt = 0 






;

int opzip512 = 0 






;

int opzip1024 = 0 






;

int opslzip2 = 0 






;

int opslzip4 = 0 






;

int opsmartprep = 0 






;

int opssrf = 0 






;

int opt2prep = 0 






;

int opspiral = 0 






;

int opnav = 0 






;

int opfmri = 0 






;

/* ECTRICKS CVS */
int opectricks = 0 






;

int optricksdel = 1000000 





;

int optrickspause = 1 





;

int opfr = 0 






;

int opcube = 0 






;

int ophydro = 0 






;

/* Added for enabling fiesta-c psd is selected.: HK */
int opphasecycle = 0 






;

int oplava = 0 






;

int opbrava = 0 






;

int opcosmic = 0 






;

int opvibrant = 0 






;


int opbravo = 0 






;

/* PROMO CV */
int oppromo = 0 






;

int opallowedrescantime = 0 






;

int opbreastmrs = 0 






;

int opjrmode = 0 






;

int opssfse = 0 






;

int t1flair_flag = 0 






;
                                                                        
int opbilateral = 0 






;

/*
   AF MRIge65182 03/22/01 Add condition parameter for Phase Sensitivity
   Reconstruction function when Phase Sensitivity radio button is selected
   on the Imaging Option page
*/

int opphsen = 0 






;

int opbc = 0 






;

int opfatwater = 0 






;

int oprtbc = 0 






;

int opnseg = 1 






;

int opnnex = 0 






;

int opsilent = 0 






;

int opsilentlevel = 1 






;

int opmerge = 0 






;

int opswan = 0 






;

int opphaseimage = 0 






;

int opdixon = 0 






;

/*----------------------------------------------------------------
Bit pattern for opdixproc
-------------------------
bit 0 used for indicating water image to be reconstructed
bit 1 used for indicating fat image to be reconstructed
bit 2 used for indicating in-phase image to be reconstructed
bit 3 used for indicating out-of-phase image to be reconstructed
bit 4 used for indicating field map image to be reconstructed
bit 5 used for indicating the original images to be reconstructed
bit 6 used for indicating fat fraction image to be reconstructed
bit 7 used for indicating R2* Map to be reconstructed
----------------------------------------------------------------*/
int opdixproc = 0 






;

int opmedal = 0 






;

int oplavade = 0 






;

int opvibrantde = 0 






;

int opquickstep = 0 






;

int opidealiq = 0 






;

int opsilentmr = 0 






;

/* ************************************
   added for Zoom Gradient limitations
   ************************************ */
float opzoom_fov_xy = 440.0 






;

float opzoom_fov_z = 350.0 






;

float opzoom_dist_ax = 120.0 






;

float opzoom_dist_cor = 120.0 






;

float opzoom_dist_sag = 150.0 






;

int app_grad_type = 0 






;

int opzoom_coil_ind = 0 






;

int pizoom_index = 0 






;


/* *****************
   SAT CVs 
   **************** */
int opsat = 0 
;

int opsatx = 0 






;

int opsaty = 0 






;

int opsatz = 0 






;

float opsatxloc1 = 9999 






;

float opsatxloc2 = 9999 






;

float opsatyloc1 = 9999 






;

float opsatyloc2 = 9999 






;

float opsatzloc1 = 9999 






;

float opsatzloc2 = 9999 






;

float opsatxthick = 40.0 






;

float opsatythick = 40.0 






;

float opsatzthick = 40.0 






;

int opsatmask = 0 






;

int opfat = 0 






;

int opwater = 0 






;

int opccsat = 0 






;

int opfatcl = 0 





;


int opspecir = 0 





;

/* ***************************
   These are for graphic sats.
   *************************** */
int opexsatmask = 0 






;

float opexsathick1 = 40.0 






;

float opexsathick2 = 40.0 






;

float opexsathick3 = 40.0 






;

float opexsathick4 = 40.0 






;

float opexsathick5 = 40.0 






;

float opexsathick6 = 40.0 






;

float opexsatloc1 = 9999 






;

float opexsatloc2 = 9999 






;

float opexsatloc3 = 9999 






;

float opexsatloc4 = 9999 






;

float opexsatloc5 = 9999 






;

float opexsatloc6 = 9999 






;

int opexsatparal = 0 






;

/*
   The opexsatoff<> cvs are for future use when targeted sat pulses
   are implemented 
*/
int opexsatoff1 = 0 






;

int opexsatoff2 = 0 






;

int opexsatoff3 = 0 






;

int opexsatoff4 = 0 






;

int opexsatoff5 = 0 






;

int opexsatoff6 = 0 






;

int opexsatlen1 = 480 






;

int opexsatlen2 = 480 






;

int opexsatlen3 = 480 






;

int opexsatlen4 = 480 






;

int opexsatlen5 = 480 






;

int opexsatlen6 = 480 






;
/* end of unused targeted sat cvs */

/* default sat band thicknesses */
float opdfsathick1 = 40.0 






;

float opdfsathick2 = 40.0 






;

float opdfsathick3 = 40.0 






;

float opdfsathick4 = 40.0 






;

float opdfsathick5 = 40.0 






;

float opdfsathick6 = 40.0 






;

/* **********************************************************************
   MRIge66622: Pseudo-header variables. These values keep the following
   information for manual inclusion in the header -- that is, the PSD
   needs to copy the information to someplace else, like opusers, in
   order for the data to be included in the header. These values are
   calculated by Scan and are not used internally. Not OP, IH, PI, or RH.

   Thickness = sqrt(normth_R^2 + normth_A^2 + normth_S^2)
   Normal vector = [normth_R, normth_A, normth_S]/Thickness
   Sat center = dist * Normal vector.
   ********************************************************************** */

float exsat1_normth_R = 0;
float exsat1_normth_A = 0;
float exsat1_normth_S = 0;
float exsat2_normth_R = 0;
float exsat2_normth_A = 0;
float exsat2_normth_S = 0;
float exsat3_normth_R = 0;
float exsat3_normth_A = 0;
float exsat3_normth_S = 0;
float exsat4_normth_R = 0;
float exsat4_normth_A = 0;
float exsat4_normth_S = 0;
float exsat5_normth_R = 0;
float exsat5_normth_A = 0;
float exsat5_normth_S = 0;
float exsat6_normth_R = 0;
float exsat6_normth_A = 0;
float exsat6_normth_S = 0;
float exsat1_dist = 0;
float exsat2_dist = 0;
float exsat3_dist = 0;
float exsat4_dist = 0;
float exsat5_dist = 0;
float exsat6_dist = 0;

/* Graphic IR Bands */
int pigirscrn = 0;      /* To control Graphic IR screen */
int piautoirbands = 0;  /* To control Auto IR Bands button */
float pigirdefthick = 200.0;    /* Graphic IR Bands default thickness in mm */

int pinumgir = MAX_NUM_GIR 





;

int opnumgir = 0 





;

int pigirmode = 3 





;

int opgirmode = 0 





;

/* Cardiac Tagging */
int optagging = 0 






;

int optagspc = 7 





;

/*MRIge92928 Allow Tagging angles of 0 and 90 degrees 
with default as 45 degrees. The CV taggingangle in 
Tagging.e has been replaced with optagangle and moved
to epic.h */

float optagangle = 45.0 





;


/* *****************
   Vascular CVs
   ***************** */
float opvenc = 50.0 





;

int opflaxx = 0 





;

int opflaxy = 0 





;

int opflaxz = 0 





;

int opflaxall = 0 





;

int opproject = 0 





;

int opcollapse = 1 





; 

int oprlflow = 0 





;

int opapflow = 0 





;

int opsiflow = 0 





;

int opmagc = 1 





;

int opflrecon = 0 





;

int oprampdir = 0 





;

int project = 0 





;

int vas_ovrhd = 0 





;

int slice_col = 1 





; 

int phase_col = 0 





;

int read_col = 0 





;

int mag_mask = 1 





;

int phase_cor = 1 





;

int extras = 0 





;

int mag_create = 1 





;

int rl_flow = 0 





;

int ap_flow = 0 





;

int si_flow = 0 





;

int imagenum = 1 





;

int motsa_ovrhd = 0 





;

int opslinky = 0 





;

int opinhance = 0 






;

int opmavric = 0 






;



/********************************************************/
/*      AUTO SUBTRACT                                   */
/********************************************************/

int opautosubtract = 0 






;

int opsepseries = 0 






;

/* **********************
   op user CVs
   ********************* */
int pititle = 0 ;
float opuser0  = 0 ;
float opuser1  = 0 ;
float opuser2  = 0 ;
float opuser3  = 0 ;
float opuser4  = 0 ;
float opuser5  = 0 ;
float opuser6  = 0 ;
float opuser7  = 0 ;
float opuser8  = 0 ;
float opuser9  = 0 ;
float opuser10 = 0 ;
float opuser11 = 0 ;
float opuser12 = 0 ;
float opuser13 = 0 ;
float opuser14 = 0 ;
float opuser15 = 0 ;
float opuser16 = 0 ;
float opuser17 = 0 ;
float opuser18 = 0 ;
float opuser19 = 0 ;
float opuser20 = 0 ;
float opuser21 = 0 ;
float opuser22 = 0 ;
float opuser23 = 0 ;
float opuser24 = 0 ;
float opuser25 = 0 ;
float opuser26 = 0 ;
float opuser27 = 0 ;
float opuser28 = 0 ;
float opuser29 = 0 ;
float opuser30 = 0 ;
float opuser31 = 0 ;
float opuser32 = 0 ;
float opuser33 = 0 ;
float opuser34 = 0 ;
float opuser35 = 0 ;
/* Do not use the following UserCVs. They are reserved for common purposes. */
float opuser36 = 0 ;
float opuser37 = 0 ;
float opuser38 = 0 ;
float opuser39 = 0 ;
float opuser40 = 0 ;
float opuser41 = 0 ;
float opuser42 = 0 ;
float opuser43 = 0 ;
float opuser44 = 0 ;
float opuser45 = 0 ;
float opuser46 = 0 ;
float opuser47 = 0 ;
float opuser48 = 0 ;

/********************************************************/
/*   Multi-Station cvs                                  */
/********************************************************/

int opnostations = 1 





;

int opstation = 1 





;

/* MRIge66833 */ /*MRIge71796*/
int oploadprotocol = 0 





;

/* MRIge66740 */
int opmask = 0 





;

int opvenous = 0 





;

/* Added to indicate whether Procol/Scan mode -TAA */
int opprotRxMode = 0 





;

/********************************************************/
/*   Multi-Phase cvs				        */
/********************************************************/

int opacqo = 1 





;

int opfphases = PHASES_MIN 





;

int opsldelay = 50000 





;

int avminsldelay = 50000 





;

/* ECTRICKS CVS */
int optphases = PHASES_MIN 





;

int opdynaplan_nphases = 1 





;

/********************************************************/
/*   EPI DWI/TENSOR cvs				        */
/********************************************************/

int opdiffuse = 0 






;

int opsavedf = 0 





;
	
int opmintedif = 1 





;

int opdfaxx = 0;        /*   diffusion direction variables      */
int opdfaxy = 0;
int opdfaxz = 0;
int opdfaxall = 0;
int opdfaxtetra = 0;
int opdfax3in1 = 0;

int opbval = 0 





;

int opnumbvals = 1 





;

int opautonumbvals = 0 





;


float opdifnext2 = 1 





;

int opautodifnext2 = 0 





;

int optensor = 0 





;

int opdifnumdirs = 1 





;

int opdifnumt2 = 1 





;

int opautodifnumt2 = 0 





;

int opdualspinecho = 0 





;

int opdifproctype = 0 





;

int opdifnumbvalues = 1 





;

int dti_plus_flag = 0 





;

/***********************************/
/*   MR-TOUCH CVs                  */
/***********************************/
int optouch = 0 






;

int optouchfreq = 60 





;

int optouchmegfreq = 60 





;

int optouchamp = 30 





;

int optouchtphases = 4 





;

int optouchcyc = 3 





;

int optouchax = 4 





;

/*********************
    Silenz-ASL CVs
 ********************/
int opaslprep = 0 






;
 
/* ********************
   3dASL CVs
   ********************/
int opasl = 0 






;
      
float oppostlabeldelay = 1525.0 






;

int rhchannel_combine_method = 0 






;

int rhasl_perf_weighted_scale = 32 






;

/* ****************************************
   Acoustic Reduction Technology (ART) CVs
   **************************************** */
float cfslew_artmedium = 2.0 





;

float cfgmax_artmedium = 3.3 





;

float cfslew_arthigh = 2.0 





;

float cfgmax_arthigh = 3.3 





;

int cfnumartlevels = 0 





;

int pinumartlevels = 0 





;

/* *********************
   fMRI CVs
   ******************** */
int oprep_active = 1 





;

int oprep_rest = 1 





;

int opdda = 0 





;

int opinit_state = 0 





;

int opfMRIPDTYPE = SIMPLE_BLOCK 





;

int opview_order = 1 





;

int opslice_order = 0 





;

int oppsd_trig = 0 





;

int oppdgm_str = -1 





;

int opbwrt = 0 





;

int cont_flag = PSD_OFF 





;

/* *******************
   Scan Timing CVs 
   ******************* */

/* Show opnecho by default for all PSDs */
int opautonecho = 1 





;

int opnecho = 1 






;

int opnshots = 1 





;

int opautote = 0 





;

int opte = 25000 





;

int opte2 = 50000 





;

/* cv for Faster sequence TE selection */
int optefw = 0 





;

int opti = TI_MIN 





;

int opbspti = TI_MIN 






;

int opautoti = 0 





;

int opautobti = 0 





;

int optrecovery = TRECOVERY_MIN 





;

int optlabel = TLABEL_DEF 





;

int opt2prepte = 25000 





;

int opautotr = 0 





;

int opnspokes = 128 





;

float opoversamplingfactor = 1.0 





;

int opinrangetr = 0 





;

int optr = 400000 





;

float opflip = 90 





;

int opautoflip = 0 





;

int opautoetl = 0 





;

int opetl = 8 





;

int opautorbw = 0 





;

/* oprbw is receive bw for echoes 2-4 for 1.5 T, receive bw for 1st echo
for 0.5 T */

float oprbw = 16.0 





;

float oprbw2 = 16.0 





;

/* *******************
   Scanning Range CVs 
   ******************* */		

float opfov = FOV_MAX 





;

float opphasefov = 1 





;

float opfreqfov = 1 





;

int opautoslquant = 0 





;

int opslquant = 1 





;

int opsllocs = 1 





;

float opslthick = 5 





;

float opslspace = 10 





;

int opileave = 0 





;

/* 0 is non coaxial
   1 is coaxial through isocenter
   2 is coaxial not through isocenter */

int opcoax = 1 





;

float opvthick = 320 





;

int opvquant = 1 





;

int opovl = 0 





;

/* ***********************
   Graphic ROI CVs
   ********************** */

float oplenrl = 0 





;

float oplenap = 0 





;

float oplensi = 0 





;

float oplocrl = 0 





;

float oplocap = 0 





;

float oplocsi = 0 





;

float oprlcsiis = 1 





;

float opapcsiis = 2 





;

float opsicsiis = 3 





;

/* SmartPrep CVs */

float opmonfov = 200 





;

float opmonthick = 20 





;

float opinittrigdelay = 1000000 





;

/* ***********************
   Acquisition Time CVs 
   ********************** */

int opxres = 256 





;

int opyres = 128 





;

int opautonex = 0 





;

float opnex = 1 





;

int opslicecnt = 0 





;

int opspf = 0 





;

int opcfsel = 2 





;

int opfcaxis = 0 





;

int opphcor = 0 





;

float opdose = 0 





;


/* ****************
   Regular CINE CVs 
   **************** */

int opchrate = 100 






;

int opcphases = 1 






;

int opclocs = 1 






;

/* **************
   Cardiac CVs 
   ************** */

int ophrate = 60 






;

int oparr = 10 





;

int ophrep = 1 





;

int opautotdel1 = 0 





;

int optdel1 = 20000 





;

int optseq = 1 





;

int opphases = 1 





;

int opcardseq = 0 





;

int opmphases = 0 





;

int oparrmon = 1 





;

int opvps = 8 





;

int opcgatetype = CARDIAC_GATE_TYPE_NONE 





;

int opadvgate = 0 





;

/* Fast CINE */
int opfcine = 0 






;

/* **************************
   CineIR CVs
   ************************** */
int opcineir = 0 





;

/* **************************
   STRESS/CREATIV Feature CVs
   ************************** */

/* CREATIV feature activation CV */
int opstress = 0 





;

/* Number of R-R Intervals */
int opnrr = 0 





;

/* DisDaqs for Monitor Mode */
int opnrr_dda = 8 





;

/* ********************
   Resp Trig CVs
   ******************** */

int oprtcgate = 0 






;

int oprtrate = 12 





;

int oprtrep = 1 





;

int oprttdel1 = 20000 





;

int oprttseq = 1 





;

int oprtcardseq = 0 





;

int oprtarr = 10 





;

int oprtpoint= 10 





;

/* ********************
 *    Navigator CVs
 * ******************** */

int opnavrrmeas = 0 





;

int opnavrrmeastime = 20 





;

int opnavrrmeasrr = 12 





;

int opnavsltrack = 0 





;

int opnavautoaccwin = 0 





;

float opnavaccwin = 2.0 





;

int opnavautotrigtime = 10 





;

int opnavpsctime = 10 





;

int opnavmaxinterval = 200 





;

int opnavtype = PSD_NAV_TYPE_90_180 





;

int opnavpscpause = 0 





;

int opnavsigenhance = 0 





;


/* MRIge92386 */
int opasset = 0 





;
/* END - MRIge92386 */

int opassetcal = 0 






;

int opassetscan = 0 






;

int rhcoilno = 0 





;


/* MRIge92386 */
int rhasset = 0 





;
/* END - MRIge92386 */

int rhasset_calthresh = 10000 





;

float rhasset_R = 0.5 





;

int rhasset_phases = PHASES_MIN 





;

float rhscancent = 0.0 





;

int rhasset_alt_cal = 0 






;

int rhasset_torso = 0 






;

int rhasset_localTx = 0 






;

/* *******************
 * PURE cvs
 * MRIge91361
 * ******************* */
int oppure = 0 






;

int rhpure = 0 






; 

int oppurecal = 0 






;

int rhpurechannel = 0 






;

/*MRIge93538 PURE filter selection*/ 
int rhpurefilter= 0 






;


float rhpure_scale_factor = 1.0 






;

int cfpure_filtering_mode = 1 






;

int rhpure_filtering_mode = 1 






;

float rhpure_lambda = 10.0 






;

float rhpure_tuning_factor_surface = 0.0 






;

float rhpure_tuning_factor_body = 1.0 






;

float rhpure_derived_cal_fraction = 0.0 






;

float rhpure_cal_reapodization = 12.0 






;

int opcalmode = CAL_MODE_STANDARD 






;

int opcaldelay = 5000000 






;

int rhcal_pass_set_vector = 12 






;

int rhcal_nex_vector = 101 






;

int rhcal_weight_vector = 101 






;

int sifsetwokey = 0 





;

int opautosldelay = PSD_OFF 





;

/* *******************
    Spectroscopy CVs
   ******************* */
int specnuc = 1 






;

int specpts = 256 






;

int specwidth = 2000 






;

int specnavs = 1 






;

int specnex = 2 






;

int specdwells = 1 






;

int acquire_type = 0 






;

/* ********************
   Spectro Hardware 
   ******************** */

int pixmtband = AMP_ERBTEC 






;

int pibbandfilt = 0 






;


/* *********************
   Prescan CVs
   ********************* */

/* Flag for warm up mode CF prescan on Profile *//* MFO 10/16/98 YI */
int opwarmup = 0 





;

int pscahead = 0 





;

int opprescanopt = 0 





;

int autoadvtoscn = 0 





;

int opapa = 0 





;

int oppscapa = 0 





;

/* MRIge90312 - moved Prescan{+}.e */
int PSslice_ind = 0 






; 

/* *********************
   Autoshim CVs
   ********************* */
float asfov = FOV_MAX 





;

int asslquant = 1 





;

float asflip = 20 





;

float asslthick = 10 





;

int asxres = 256 





;

int asyres = 128 





;

int asbaseline = 8 





;

int asrhblank = 4 





;

int asptsize = 4 





;

int opascalcfov = 0 





;

/* ************************
   Transmit Gain CVs 
   ************************ */
float tgfov = FOV_MAX 





;

int tgcap = 200 





;

int tgwindow = 200 





;

/* ************************
   Multi-Volume Prescan CVs
   ************************ */

int oppscvquant = 0 





;

/* ************************
   Dual Drive CVs
   ************************ */
int opdrivemode = 1 





;

int pidrivemodenub = 7 





;

/* Excitation Mode CV */
int opexcitemode = 0 





;

/* ***************************
   Low power parameters  (GE)
   *************************** */
float lp_stretch = 2.0 






;

int lp_mode = 0 






;

float derateb1_body_factor = 1.0 






;

float SAR_bodyNV_weight_lim = 110.0 






;

float derateb1_NV_factor = 1.0 






;

float jstd_multiplier_body = 0.145 






;

float jstd_multiplier_NV = 0.0137 






;

float jstd_exponent_body = 0.763 






;

float jstd_exponent_NV = 1.154 






;


int pidiffmode = 0;

int pifmriscrn = 0; /* To control fmri screen */

/* pi values for spiral */
int piresol = 0 





;

int pioverlap = 0 





;

int piforkvrgf = 0;  /*  1 causes scan to spawn the vrgf process upon download */
int pinofreqoffset = 0; /*  1 disables fov offset in frequency direction */
/* Needed picvs for fmri */

int pirepactivenub = 0;
int pireprestnub = 0;
int piddanub = 0;
int piinitstatnub = 0;
int piviewordernub = 0;
int pisliceordnub = 0;
int pipsdtrignub = 0;

int pispssupnub = 1;  /* for water suppression button on Spectro Prescan UI */

/* **********************
   Lx: FMPVAS/FGRE CVs
   ********************** */
int pi_neg_sp = 0 





;

float piisvaldef = 2.0 





;

/* FGRE/2DMDE CV */
int pi2dmde = 0 





;

/* **********************
   Clock Operation CVs 
   ********************** */
int pidmode = 0 





;

int piviews = 0 





;

int piclckcnt = 1 





;

float avmintscan = 0.0 





;

float pitslice = 0.0 





;

float pitscan = 0.0 





;

/* ECTRICKS */
float pimscan = 0.0 





;

/* AKR:  MRIhc28206 Recon Lag Model output */
float pireconlag = -3.0 





;



float pitres = 0.0 





;

/* **********************
   Image Creation CVs 
   ********************** */
int pisaveinter = 0 





;

int pivextras = 0 





;

int pinecho = 0 





;

/* *****************************
   TGT Needs for Table Position 
   ***************************** */
float piscancenter = 0.0 





;

/* ******************
   Service CVs
   ***************** */
int pismode = 0 





;

int pishldctrl = PSD_OFF 





;

int pinolr = PSD_ON 





;

int pinoadc = PSD_OFF 





;

int pimixtime = 0 





;

/* High order shim CVs */

int pishim2 = HO_SHIM_NO 





;

int pi1stshimb = HO_SHIM_1ST_BUTTON_ON 





;

/* Added for SNR Index */
float pifractecho = 1.0 





;

int nope = PSD_OFF 





;

/* *******************
   Custom Scan Schema CVs
   ****************** */
int opuser_usage_tag = 0x00000000 





;

int rhuser_usage_tag = 0x00000000 





;

int rhFillMapMSW = 0x00000000 





;

int rhFillMapLSW = 0x00000000 





;

/* *******************
   Recon Header CVs
   ****************** */
int rhbline = 0 





;

int rhblank = 4 





;

int rhnex  = 1 





;

int rhnavs = 1 





;

int rhnslices = 1 





;

int rhnrefslices = 0 





;

int rhnframes = 256 





;

int rhfrsize = 256 





;

int rhnecho = 1 





;

int rhnphases = 1 





;

int rhmphasetype = 0 





;

/* More bits may be added in the future*/
int rhtrickstype = 0 





;

/* ********************************
   Bit patterns for rhtype 
   ------------------------------
   RHTYPCHP       1
   bit 0  Set if chopper data
   RHTYPCINE      2
   bit 1  Set if CINE
   RHTYPSHIM      4
   bit 2  Set if SHIM
   RHTYPGR        8
   bit 3  Set if GRASS
   RHTYPFRACTNEX  16
   bit 4  Set for fractional processing
   RHTYPSTRIP     32
   bit 5  Set for strip scan Y
   RHTYP3D        64
   bit 6  Set for 3-D processing
   RHTYPXOR       128
   bit 7  Set if exorcist
   RHTYPNPW       256
   bit 8  Set if NPW
   RHTYPNFW       512
   bit 9  Set if NFW
   RHTYPXSTRIP    1024
   bit 10 Set if strip scan X.
   RHTYPFRACTECHO 2048
   bit 12 No longer used.
   RHTYP75NEX     8192
   bit 13 Set if 3/4 nex.
   RHTYPPOMP      16384
   bit 14 Set if pomp
   RHTYPTURBO     32768
   ****************************** */
int rhtype = 0 





;

/* ********************************
   Bit patterns for rhtype1
   ------------------------------
   RHTYP1HOMODYNE      1
   bit 0  Unset (0) if regular recon, set (1) if homodyne recon
   RHTYP1NEXA          2
   bit 1  Set if nex table per echo is required
   RHTYP1CINEODDNEX    4
   bit 2  Set if odd NEX CINE
   RHTYP1SFRAME        8
   bit 3  Set if mulit-coil superframe
   RHTYP13DM           16
   bit 4  Set if 3D multi-slab
   RHTYP1MAXOVL        32
   bit 5 on, bit 6 off  Maximum intersity pixel collapse overlap processing
   RHTYP1MINOVL        64
   bit 5 off, bit 6 on  Minimum intersity pixel collapse overlap processing
   RHTYP1AVEOVL        96
   bit 5 on, bit 6 on   Average intersity pixel collapse overlap processing
   RHTYP1FPHASEOFF     128
   bit 7  Set for "fast phase off" in phase-contrast scans
   RHTYP1AUTOPASS      256
   bit 8  Set if automatic scan/pass detection scheme is enabled.  If set,
   *      then data acquisition will assert scan and pass packets based on
   *      frame counter limits.  These limits are set by:
   *      rhrefframes and rhrefframep for reference scan acquisitions
   *      rhscnframe and repasframe for other entry points (except prescan)
   RHTYP1IMGNEX        512
   bit 9
   RHTYP1SPIRAL        1024
   bit 10 Set if Spiral acquisition matrix
   RHTYP1FVRGF         2048
   bit 11 Set if Fast VRGF recon required
   RHTYP1RCALLPASS     4096
   bit 12 Set to instruct recon to allocate as many passes as possible
   *      in the BAM. BAM is also recycled in this case.
   RHTYP1LINE          8192
   RHTYP1LSDI          8192
   bit 13 Set to indicate Line Scan diffusion
   RHTYPECTRICKS       16384
   bit 14 Set for ECTRICKS reconstruction
   RHTYP1PCORVRGF      32768
   bit 15 Set so recon performs VRGF processing AFTER phase correction
   RHTYP10ROWENDS      65536
   bit 16 Set to zero out the ends of edges of kspace (fine line fix)
   RHTY1PRETRO_PC      131072
   bit 17 Set to do retrospective phase correction (FSE)
   RHTYP1BAM0FILL      262144
   bit 18 Set to zero-fill BAM before start of acquisition
   RHTYP13DGRADWARP    4194304
   bit 22 Set to 3d Gradwarp (0 off, 1 on) 
   ******************************** */
int rhtype1 = 0 





;

/* merged 55 bch into vmx.  YH  10/13/94 */
/* ******************************
   Bit patterns for rhformat
   -----------------------------
 RHF_NO_GRADWARP            1- bit 0 set if no grad warp is desired
 RHF_NO_FERMI               2- bit 1 set if no fermi filtering is desired
 RHF_ZCHOP                  4- bit 2 For 3D, set if RF is chopped Z-encode
 RHF_YCHOP                  8- bit 3 For 3D, set if RF is chopped on Y encode
 RHF_IIC                   16- bit 4 set if IIC (opscic == RHF_ON)
 RHF_CSI                   32- bit 5 set if acquiring spectroscopic data
 RHF_HS                    64- bit 6 set if epi dab packet is used
 RHF_SPECTRO              128- bit 7 set if acquiring non-CSI
                               spectroscopic data (Single voxel)
 RHF_IMAGE_CHECKSUM       256- bit 8 set if using image checksum
 RHF_NOREC_CHECKSUM       512- bit 9 set if using norec checksum
 RHF_GRADWARP_USE_FILE   1024- bit 10 set if using extern gradwarp file
 RHF_USE_FLIPTABLE       2048- bit 11 set if row flip file
                               (/usr/g/bin/rowflip.param) is used
 RHF_CERD_USE_FLIP_SSP   4096- bit 12 set if ??
 RHF_PSIR_CORRECTION     8192- bit 13 set if opphsen is set to 1
 RHF_SINGLE_PHASE_INFO  16384- bit 14 For > 1024 im/ser. Set if
                               data_acq_order table is filled only 
                               for a single phase in a multiphase scan.

   ********************************************* */
int rhformat = 0 





;

int rhptsize = 2 





;

int rhnpomp = 1 





;

/* ******************************
   Bit patterns for rhrcctrl
   ------------------------------
   bit 0 set for magnitude images   ; RHRCMAG  = 1
   bit 1 set for phase images       ; RHRCPHS  = 2
   bit 2 set for I magnitude images ; RHRCIMAG = 4
   bit 3 set for Q magnitude images ; RHRCQMAG = 8
   bit 4 set for compressed images  ; RHRCCOMP = 16
   bit 7 set for raw image recon    ; RHRCRAW  = 128
   changed for 7.0 from 17 to 1..gp
                                      RHRCGRID_ON           = 32
                                      RHRCSKIP_ALL_RECON    = 128
                                      RHRCSKIP_ROW_FFT      = 256
                                      RHRCSKIP_COL_FFT      = 512
                                      RHRCSKIP_HALF_FOURIER = 1024
                                      RHRCSKIP_FERMI        = 2048
                                      RHRCSKIP_NEX_SCALE    = 4096
                                      RHRCSKIP_IMAGE_SCALE  = 8192
                                      RHRCSKIP_3DJOB_FFT    = 16384
   ********************************************* */
int rhrcctrl = 1 





;

/* ******************************
   bit patterns for rhdacqctrl
   ----------------------------
   bit 0	0= NO_REC data, 1=RAW data
   bit 1	Set if even echo phase flip desired.
   bit 2	Set if odd echo phase flip desired.
   bit 3	Set if even echo frequency flip desired.
   bit 4	Set if odd echo frequency flip desired.
   bit 5	Set if RAW collection without DAB SSP packets is desired.
   bit 6	Set if RAW collection should wrap around to the top of the
		buffer if overflow occurs.
   bit 10       set if fcine echotrain data acq. mode is used.
                MRIge56094                RH_FCINE_ET = 1024
   bit 11       Set if passthrough data acq. mode is used.; 
                                          RH_PASS_THROUGH_CERD_FLAG = 2048
   ********************************************* */
int rhdacqctrl = 2 





;

/* ******************************
   bit patterns for rhexecctrl
   ------------------------------
RHXC_AUTO_DISPLAY               1- Set if Auto display desired
RHXC_AUTO_LOCK                  2- Set if auto lock of raw/no_rec files desired
RHXC_AUTO_PERM                  4- Set if auto perm desired
                                   (BAM memory not released )
RHXC_XFER_IM                    8- Set if images should be transferred to disk
RHXC_SAVE_IM                    16- Set if images should be saved in BAM memory
RHXC_TAPE_LOCK                  32- Don't use
RHXC_INTERMEDIATE               64- Set if intermediate multi coil images
                                    are to be saved
RHXC_OVERRIDE_BROADCAST         128
RHXC_OVERRIDE_IMG_INSTALL       256
RHXC_OVERRIDE_AUTODISPLAY       512
RHXC_RTD_XFER_IM_REMOTE         1024
RHXC_RTD_SCAN                   2048
RHXC_REF_SCAN                   4096
RHXC_DONT_WRITE_OR_INSTALL      8192
RHXC_RTD_XFER_ALL_IM_PER_PASS   16384
RHXC_XFER_IMG_RIR               32768

 * ********************************************** */
int rhexecctrl = 9 





;

/* *********************************
   bit patterns for FEEDER control
   ---------------------------------
   bit 0	0= feed DAB, 1= feed filters.
   bit 1	0= locked, 1= unlocked
   bit 2	0= see bit 1, 1= use algorithm
   bit 3	Set if timing simulation desired
 * ********************************************** */
int rhfdctrl = 0 





;

float rhxoff = 0.0 





;

float rhyoff = 0.0 





;

int rhrecon = 0 





;

int rhdatacq = 0 





;

int rhvquant = 0 





;

int rhslblank = 2 





;

int rhhnover = 0 





;

/* RV: Needed for IDEAL minTE processing */
int rhfeextra = 0 





;

int rhheover = 0 





;

int rhoscans = 0 





;

int rhddaover = 0 





;

float rhzeroph = 128.5 





;

float rhalpha = 0.46 





;

float rhnwin = 0.0 





;

float rhntran = 2.0 





;

int rhherawflt = 0 





;

float rhherawflt_befnwin = 1.0 





;

float rhherawflt_befntran = 2.0 





;

float rhherawflt_befamp = 1.0 





;

float rhherawflt_hpfamp = 1.0 





;

float rhfermw = 10.0 





;

float rhfermr = 128.0 





;

float rhferme = 1.0 





;

float rhclipmin = 0.0 





;

float rhclipmax = 16383.0 





;

float rhdoffset = 0.0 





;

int rhudasave = 0 





;

int rhsspsave = 0 





;

float rh2dscale = 1.0 





;
 
float rh3dscale = 1.0 





;
 
int rhnpasses = 1 





;

int rhincrpass = 1 





;

int rhinitpass = 1 





;

int rhmethod = 0 





;

int rhdaxres = 256 





;

int rhdayres = 256 





;

int rhrcxres = 256 





;

int rhrcyres = 256 





;

int rhimsize = 256 





;

int rhnoncart_dual_traj = 0 





;

int rhnoncart_traj_kmax_ratio = 8 






;

int rhnspokes_lowres = 8192 






;

int rhnspokes_highres = 8192 






;

int rhnoncart_traj_merge_start = 3 






;

int rhnoncart_traj_merge_end = 5 






;

float rhoversamplingfactor = 1.0 





;

float rhnoncart_grid_factor = 2.0 





;

float rhuser0  = 0 ;
float rhuser1  = 0 ;
float rhuser2  = 0 ;
float rhuser3  = 0 ;
float rhuser4  = 0 ;
float rhuser5  = 0 ;
float rhuser6  = 0 ;
float rhuser7  = 0 ;
float rhuser8  = 0 ;
float rhuser9  = 0 ;
float rhuser10 = 0 ;
float rhuser11 = 0 ;
float rhuser12 = 0 ;
float rhuser13 = 0 ;
float rhuser14 = 0 ;
float rhuser15 = 0 ;
float rhuser16 = 0 ;
float rhuser17 = 0 ;
float rhuser18 = 0 ;
float rhuser19 = 0 ;
float rhuser20 = 0 ;
float rhuser21 = 0 ;
float rhuser22 = 0 ;
float rhuser23 = 0 ;
float rhuser24 = 0 ;
float rhuser25 = 0 ;
float rhuser26 = 0 ;
float rhuser27 = 0 ;
float rhuser28 = 0 ;
float rhuser29 = 0 ;
float rhuser30 = 0 ;
float rhuser31 = 0 ;
float rhuser32 = 0 ;
float rhuser33 = 0 ;
float rhuser34 = 0 ;
float rhuser35 = 0 ;
float rhuser36 = 0 ;
float rhuser37 = 0 ;
float rhuser38 = 0 ;
float rhuser39 = 0 ;
float rhuser40 = 0 ;
float rhuser41 = 0 ;
float rhuser42 = 0 ;
float rhuser43 = 0 ;
float rhuser44 = 0 ;
float rhuser45 = 0 ;
float rhuser46 = 0 ;
float rhuser47 = 0 ;
float rhuser48 = 0 ;

int rhdab0s = 0 





;

int rhdab0e = 0 





;

float rhctr = 1.0 





;

float rhcrrtime = 1.0 





;

int rhcphases = 1 





;

int rhovl = 0 





;

/* **********************************
   Vascular Recon CVs 
   ********************************** */

/* **********************************
   Vascular Recon Types
   1: vascular
   2: phase contrast scan
   4: unused
   8: 2 set processing
   16: anti alias algorithm
   32: phase contrast bit 1
   64: phase contrast bit 2
   128: apply noise suppression mask
   256: display magnitude image
   512: display physical x location
   1024: display physical y location
   2048: display physical z location
   4096: collapse logical z
   8192: collapse logical x
   16384: collapse logical y
   32768: vinnie 1 slice, 2 set
   65536: vinnie 1 slice, 4 set
   131072: vinnie 2 slice, 2 set
   ****************************************** */
int rhvtype = 0 





;

float rhvenc = 0.0 





;

float rhvcoefxa = 0.0 





;

float rhvcoefxb = 0.0 





;

float rhvcoefxc = 0.0 





;

float rhvcoefxd = 0.0 





;

float rhvcoefya = 0.0 





;

float rhvcoefyb = 0.0 





;

float rhvcoefyc = 0.0 





;

float rhvcoefyd = 0.0 





;

float rhvcoefza = 0.0 





;

float rhvcoefzb = 0.0 





;

float rhvcoefzc = 0.0 





;

float rhvcoefzd = 0.0 





;

/* The following are flow to static translation for phase contrast 
   scans if the phase correction bits are set or noise suppression or display
   magnitude bits are set. */

float rhvmcoef1 = 0.0 





;

float rhvmcoef2 = 0.0 





;

float rhvmcoef3 = 0.0 





;

float rhvmcoef4 = 0.0 





;

/* *********************
   Asymmetric FOV cvs
   ********************* */
float rhphasescale = 1.0 





;

float rhfreqscale = 1.0 





;

/* Raw image recon */
int rawmode = 0 





;
						   
/* ****************************
   Reference Scan/EPI recon cvs
   **************************** */

int rhileaves = 1 





;

int rhkydir = 0 





;

int rhalt = 0 





;

int rhreps = 1 





;

int rhref = 1 





;

/****************************************/
/* EPI Phase Correction recon header CVs */
/****************************************/

int rhpcthrespts = 2 





;

int rhpcthrespct = 15 





;

int rhpcdiscbeg = 0 





;

int rhpcdiscmid = 0 





;

int rhpcdiscend = 0 





;

int rhpcileave = 0 





;

int rhpcextcorr = 0 





;

int rhrefframes = 0 





;

/* to avoid compiling error on IFCC   3/17/95 YI */
int rhpcsnore = 0 





;
                                     
int rhpcspacial = 0 





;

int rhpctemporal = 0 





;

float rhpcbestky = 64.0 





;

int rhhdbestky = 0 





;

/* to avoid compiling error on IFCC   3/17/95 YI */
int rhpcinvft = 0 





;

int rhpcctrl = 0 





;

/* to avoid compiling error on IFCC   3/17/95 YI */
int rhpctest = 0 





;

int rhpcgraph = 0 





;

int rhpclin = 0 





;

int rhpclinnorm = 0 





;

int rhpclinnpts = 0 





;

int rhpclinorder = 2 





;

int rhpclinfitwt = 0 





;

int rhpclinavg = 0 





;

int rhpccon = 0 





;

int rhpcconnorm = 0 





;

int rhpcconnpts = 2 





;

int rhpcconorder = 2 





;

int rhpcconfitwt = 0 





;

/****************************************/
/* VRGF recon header CVs */
/****************************************/
 
int rhvrgfxres = 128 





;

int rhvrgf = 0 





;

/****************************************/
/* Bandpass correction recon header CVs */
/****************************************/
 
int rhbp_corr = 0 





;

float rhrecv_freq_s = 0.0 





;

float rhrecv_freq_e = 0.0 





;

int rhhniter = 0 





;

int rhfast_rec = 0 





;


/*************************************/
/* Spiral gridding recon related CVs */
/*************************************/
int rhgridcontrol = 0 





;

int rhb0map = 0 





;

int rhtediff = 0 





;

float rhradiusa = 0 





;

float rhradiusb = 0 





;

float rhmaxgrad = 0.0 





;

float rhslewmax = 0.0 





;

float rhscanfov = 0.0 





;

float rhtsamp = 0.0 





;

float rhdensityfactor = 0.0 





;

float rhdispfov = 0.0 





;

int rhmotioncomp = 0 





;

int grid_fov_factor = 2 





;

/***************************************/
/* Dynamic Frequency Monitor Recon CVs */
/***************************************/

int rhte = 25000 





;

int rhte2 = 50000 





;

int rhdfm = 0 





;

int rhdfmnavsperpass = 1 





; 

int rhdfmnavsperview = 1 





;

float rhdfmrbw = 4.0 





;

int rhdfmptsize = 2 





;

int rhdfmxres = 32 





;

int rhdfmdebug = 0 





;

float rhdfmthreshold = 0.0 





;

/* Following CVs are Added for Image Enhance */
int rh_rc_enhance_enable = 0 





;

int rh_ime_scic_enable = 0 





;

float rh_ime_scic_edge = 0.0 





;

float rh_ime_scic_smooth = 0.0 





;

float rh_ime_scic_focus = 0.0 





;

int rh_ime_clariview_type = 0 





;

float rh_ime_clariview_edge = 0.0 





;

float rh_ime_clariview_smooth = 0.0 





;

float rh_ime_clariview_focus = 0.0 





;

float rh_ime_scic_reduction = 0.0 





;

float rh_ime_scic_gauss = 0.0 





;	

float rh_ime_scic_threshold = 0.0 





;

/* For PSMDE feature */
int rhphsen_pixel_offset = 0 





;

/* For SCIC++ Feature */

int rhapp = 0 






;

int rhapp_option = 0 






;

/* For N-coil selection routines in recon */

int rhncoilsel = 0 






;

int rhncoillimit = 45 






;

int rhrefframep = 0 






;

int rhscnframe = 0 






;

int rhpasframe = 0 






;

int rhpcfitorig = 1 






;

int rhpcshotfirst = 0 






;

int rhpcshotlast = 0 






;

int rhpcmultegrp = 0 






;

int rhpclinfix = 1 






;

float rhpclinslope = 0.0 






;

int rhpcconfix = 1 






;

float rhpcconslope = 0.0 






;

int rhpccoil = 1 






;

float rhmaxcoef1a = 0 






;

float rhmaxcoef1b = 0 






;

float rhmaxcoef1c = 0 






;

float rhmaxcoef1d = 0 






;

float rhmaxcoef2a = 0 






;

float rhmaxcoef2b = 0 






;

float rhmaxcoef2c = 0 






;

float rhmaxcoef2d = 0 






;

float rhmaxcoef3a = 0 






;

float rhmaxcoef3b = 0 






;

float rhmaxcoef3c = 0 






;

float rhmaxcoef3d = 0 






;

int rhdptype = 0 






;

int rhnumbvals = 1 





;

int rhdifnext2 = 1 





;

int rhnumdifdirs = 1 





;

int rhutctrl = 0 






;

float rhzipfact = 0 






;

int rhfcinemode = 0 






;

int rhfcinearw = 10 






;

int rhvps = 8 






;

int rhvvsaimgs = 1 






;

int rhvvstr = 0 






;

int rhvvsgender = 0 






;

/* to get opgradmode value into the raw header */
int rhgradmode = 0;

int rhfatwater = 0 






;

int rhfiesta = 0 






;

int rhlcfiesta = 0 






;

float rhlcfiesta_phase = 0.0 






;

/* *************************************************
   Recon Header CVs for Navigator Echo Correction on DW-EPI
   ************************************************ */
int rhdwnavview = 0 






;

int rhdwnavcorecho = 2 






;

int rhdwnavsview = 1 






;

int rhdwnaveview = 1 






;

int rhdwnavsshot = 1 






;

int rhdwnaveshot = 2 






;

float rhdwnavcoeff = 0.5 






;

/* ********************************
   Bit patterns for rhtype 
   ------------------------------
   bit 0  Set if navigator echo correction is on
   bit 1  Set if phase shifted navigator echo correction is on
   ****************************** */
int rhdwnavcor = 0 






;

/* Added new CVs for Slice ASSET */ 
float rhassetsl_R = 1.0 






;

float rhasset_slwrap = 0.0 






;

/* Added new CVs for FIESTA - C */

int rh3dwintype = 0 






;

float rh3dwina = 0.1 






;

float rh3dwinq = 0.0 






;

/* Recon Header CV's for TRICKS recon */
int rhectricks_num_regions = 0;

int rhectricks_input_regions = 0;

/* ************************************************* */
/* HFO3 merge 02/18/2003 YI */
/* FSE retrospective phase correction - MRIge79845 - RDP
   Bit patterns for rhretro_control
   ---------------------------------
   bit 0 set for Ahn/Cho fitting method
   bit 1 set for Least Squares fitting method
   bit 2 set for zeroth-order coefficient correction
   bit 3 set for first-order coefficient correction
   bit 4 set for one extra etl reference set
   bit 5 set for second extra etl reference set
   ***************************************************** */
int rhretro_control = 0 






;

int rhetl = 0 






;

/* MRIge81511 - RDP - rh CVs for fine line correction */
int rhleft_blank = 0 






;

int rhright_blank = 0 






;


/* Standardize spectroscopy recon header variables */

float rhspecwidth = 0.0 






;

int rhspeccsidims = 0 






;

int rhspecrescsix = 0 






;

int rhspecrescsiy = 0 






;

int rhspecrescsiz = 0 






;

float rhspecroilenx = 0.0 






;

float rhspecroileny = 0.0 






;

float rhspecroilenz = 0.0 






;

float rhspecroilocx = 0.0 






;

float rhspecroilocy = 0.0 






;

float rhspecroilocz = 0.0 






;

int rhexciterusage = 1 






;

int rhexciterfreqs = 1 






;

/* rh values for MART deblurring (NDG) */
int rhwiener = 0 





;

float rhwienera = 0.0 





;

float rhwienerb = 0.0 





;

float rhwienert2 = 0.0 





;

float rhwieneresp = 0.0 





;

int rhflipfilter = 0 





;

int rhdbgrecon = 0 





;

int rhech2skip = 0 





;

/* Recon header CVs for IDEAL processing */
/*----------------------------------------------------------------*/
/* Bit pattern for rhrcideal
bit 0 used for turning on/off IDEAL processing
bit 1 used for turning on/off IDEAL half-nex processing
bit 2 used for turning on/off IDEAL half-echo processing
bit 3 is on to indicate reversal of echo2 and echo3 order to recon
bit 4 is on to indicate that minTE is Rx'ed; this prompts recon to
center the echo in the readout direction during zero-filled recon
bit 5 used for turning on/off T2* correction
bit 6 used for turning on/off multi peak processing
bit 7 used for turning on/off magnitude based fitting
----------------------------------------------------------------*/
int rhrcideal = 0 






;

/*----------------------------------------------------------------*/
/* Bit pattern for rhrcdixproc
bit 0 is ON by default, indicating water image to be reconstructed
bit 1 used for indicating fat image to be reconstructed
bit 2 used for indicating in-phase image to be reconstructed
bit 3 used for indicating out-of-phase image to be reconstructed
bit 4 used for indicating field map image to be reconstructed
bit 5 used for indicating the original images to be reconstructed
bit 6 used for indicating fat fraction image to be reconstructed
bit 7 used for indicating R2* Map to be reconstructed
bit 8 used for indicating water fraction image to be reconstructed
bit 9 used for indicating water image before correction to be reconstructed
bit 10 used for indicating fat image before correction to be reconstructed
bit 11 used for indicating in-phase image before correction to be reconstructed
bit 12 used for indicating out-of-phase image before correction to be reconstructed
bit 13 used for indicating field map image before correction to be reconstructed
bit 14 used for indicating fat fraction image before correction to be reconstructed
bit 15 used for indicating water fraction image before correction to be reconstructed
bit 16 used for indicating the coil combined complex images to be reconstructed
----------------------------------------------------------------*/
int rhrcdixproc = 0 







;

/*----------------------------------------------------------------*/
/* Bit pattern for rhrcidealctrl
bit 0 used for dumping the raw data that is going to be used by IDEAL
bit 1 used for loading the raw data that is going to be used by IDEAL
bit 2 used for controlling IDEAL output before post-checker
bit 3 used for controlling IDEAL output after post-checker
bit 4 used for controlling the gradwarp operation that will be performed on each image before we perform the receiver combined
This operation is expensive but takes us closer the host recon implementation
bit 5 used for storing the data in shorts that will be used by IDEAL. This saves BAM as data is in BAM 
bit 6 used for performing IDEAL processing on receiver-combined images
bit 7 used for peforming clipping operation on the images that will be used by IDEAL
bit 8 used for performing gradwarp after receiver combine operation
bit 9 used for calling a function that does a chopper operation and a scaling  
bit 10 used for turning on/off post processing
bit 11 used for disabling chemical shift
bit 12 used for debugging image numbering
bit 13 used for disabling new finding CF
bit 14 used to reverse frequency axis direction
bit 15 used to reverse phase axis direction
bit 16 used to reverse homodyne
bit 17 used to reverse frequency direction
bit 18 used for generic debug
bit 19 used to choose type of multi-peak processing. 0:pre cal 1:self cal
----------------------------------------------------------------*/
int rhrcidealctrl = 0 







;

int rhdf = FATWATER_DIXFREQ_1_5T 





;

int rhmedal_mode = 0 






;

int rhmedal_nstack_size = 54 






;

int rhmedal_echo_order = 0 






;

int rhmedal_up_kernel_size = 15 






;

int rhmedal_down_kernel_size = 8 






;

int rhmedal_smooth_kernel_size = 8 






;

int rhmedal_starting_slice = 0 






;

int rhmedal_ending_slice = 10 






;

int rhvibrant = 0 






;

int rhkacq_uid = 0 






;

/* NEX for unacquired encodes for when zero-fill BAM is enabled */
int rhnex_unacquired = 1 





;

/* Acquisition to Disk Control Bitmask
   Bit 0 (=1) is used to enable/disable acquisition to disk feature
   Bit 1 (=2) is used to capture raw frame and control data to disk
*/
int rhdiskacqctrl = 0 






;

/* IDEAL IQ Phase Correction Recon Header CV */
int rhechopc_extra_bot = 0 






;

int rhechopc_ylines = 0 






;

int rhechopc_primary_yfirst = 0 






;

int rhechopc_reverse_yfirst = 0 






;

int rhechopc_zlines = 0 






;

int rhechopc_yxfitorder = 1 






;

int rhechopc_ctrl = 0 






;

int rhchannel_combine_filter_type = RHCHANNEL_COMBINE_FILTER_TYPE_NONE 






;

float rhchannel_combine_filter_width = 0.3 






;

float rhchannel_combine_filter_beta = 2 






;

float rh_low_pass_nex_filter_width = 8.0 





;

/* ******************
   Image header CVs
   ****************** */
int ihtr = TR_MIN 





;

int ihti = 0 





;

int ihtdel1 = MIN_TDEL1 





;

float ihnex = 1 





;

float ihflip = 90 





;

int ihte1 = 0 





;

int ihte2 = 0 





;

int ihte3 = 0 





;

int ihte4 = 0 





;

int ihte5 = 0 





;

int ihte6 = 0 





;

int ihte7 = 0 





;

int ihte8 = 0 





;

int ihte9 = 0 





;

int ihte10 = 0 





;

int ihte11 = 0 





;

int ihte12 = 0 





;

int ihte13 = 0 





;

int ihte14 = 0 





;

int ihte15 = 0 





;

int ihte16 = 0 





;

int ihdixonte = 0 





;

int ihdixonipte = 0 





;


int ihdixonoopte = 0 





;

float ihvbw1 = 16.0 





;

float ihvbw2 = 16.0 





;

float ihvbw3 = 16.0 





;

float ihvbw4 = 16.0 





;

float ihvbw5 = 16.0 





;

float ihvbw6 = 16.0 





;

float ihvbw7 = 16.0 





;

float ihvbw8 = 16.0 





;

float ihvbw9 = 16.0 





;

float ihvbw10 = 16.0 





;

float ihvbw11 = 16.0 





;

float ihvbw12 = 16.0 





;

float ihvbw13 = 16.0 





;

float ihvbw14 = 16.0 





;

float ihvbw15 = 16.0 





;

float ihvbw16 = 16.0 





;

int ihnegscanspacing = 0 






;

int ihoffsetfreq = 1200 






;

int ihbsoffsetfreq = 4000 






;

int iheesp = 0 






;

int ihfcineim = 0 






;

int ihfcinent = 0 






;

int ihbspti = TI_MIN 






;

float ihtagfa = 180.0 






;

float ihtagor = 45.0 






;

/* RV: IDEAL debug ihCV's */
float ih_idealdbg_cv1 = 0 ;
float ih_idealdbg_cv2 = 0 ;
float ih_idealdbg_cv3 = 0 ;
float ih_idealdbg_cv4 = 0 ;
float ih_idealdbg_cv5 = 0 ;
float ih_idealdbg_cv6 = 0 ;
float ih_idealdbg_cv7 = 0 ;
float ih_idealdbg_cv8 = 0 ;
float ih_idealdbg_cv9 = 0 ;
float ih_idealdbg_cv10 = 0 ;
float ih_idealdbg_cv11 = 0 ;
float ih_idealdbg_cv12 = 0 ;
float ih_idealdbg_cv13 = 0 ;
float ih_idealdbg_cv14 = 0 ;
float ih_idealdbg_cv15 = 0 ;
float ih_idealdbg_cv16 = 0 ;
float ih_idealdbg_cv17 = 0 ;
float ih_idealdbg_cv18 = 0 ;
float ih_idealdbg_cv19 = 0 ;
float ih_idealdbg_cv20 = 0 ;
float ih_idealdbg_cv21 = 0 ;
float ih_idealdbg_cv22 = 0 ;
float ih_idealdbg_cv23 = 0 ;
float ih_idealdbg_cv24 = 0 ;
float ih_idealdbg_cv25 = 0 ;
float ih_idealdbg_cv26 = 0 ;
float ih_idealdbg_cv27 = 0 ;
float ih_idealdbg_cv28 = 0 ;
float ih_idealdbg_cv29 = 0 ;
float ih_idealdbg_cv30 = 0 ;
float ih_idealdbg_cv31 = 0 ;
float ih_idealdbg_cv32 = 0 ;

/* 3dASL CVs for dicom header  */
int ihlabeltime = 0 






;

int ihpostlabeldelay = 0 






;

int ihnew_series = 0 






;

/* added for Multiple dB/dt Operation Modes - March 25, 2001 */

int dbdt_option_key_status = 0 






;

int dbdt_mode = 0 






;

int cfdbdttype = 0 






;

float cfrinf = 23.4 






;

int cfrfact = 334 






;

float cfdbdtper_norm = 80.0 






;

float cfdbdtper_cont = 100.0 






;

float cfdbdtper_max = 200.0 






;


/* AKR MRIhc28206 : Recon Lag Model input Parameters */

int cfnumicn = 1 






;  

int cfdppericn = 4 






;

/* ***********************
   System configuration CVs
   *********************** */

int cfgradcoil = 2;  /* Indicate gradient coil type : 1:CRD 2:Roemer
                        101:HGC 102:Vectra 103:Permanent */

/* dynamic Gradient Digitization Period CVs */
int cfswgut    = 4;
int cfswrfut   = 2;
int cfswssput  = 1;
                             
int cfhwgut    = 4;
int cfhwrfut   = 2;
int cfhwssput  = 1;

int cfoption = SEC_CODE_INIT 






;


/******************** 03/06/2003 YI  for DCERD support
 * RF Board Type
 *  0 : Remote RF
 *  1 : DCERD
 *******************/
int cfrfboardtype = RF_BOARD_RRF 






;

/* psd_board_type is the set of SSP commands to use for the current
 * hardware architecture.  For hardware introduced for DVMR, use
 * PSDDVMR.  For hardware introduced for 10.0-14.0, use PSDCERD */
int psd_board_type = PSDDVMR 






;

/* ********************************
   Dynamic Frequency Monitoring CVs
   ******************************** */
int opdfm         = 0 






;

int opdfmprescan  = 0 






;

int  cfdfm   =  0  






;

int  cfdfmTG = 70  






;

int  cfdfmR1 = 13  






;

int  cfdfmDX = 0   






;

/* For ACGD Compensation Feature */
int derate_ACGD = 0 






;

/* MRIge89403: rh cvs for EPI internal ref scan */ 
int rhextra_frames_top = 0 






;

int rhextra_frames_bot = 0 






;

int rhpc_ref_start = 0 






;
int rhpc_ref_stop = 0 






;

int rhpc_ref_skip = 0 






;

int opaxial_slice=0 






;

int opsagittal_slice =0 






;

int opcoronal_slice=0 






;

int opvrg = 0 






;

int opmart = 0 






;

/* FOR MRIge93583 */
int piassetscrn = 0 






;

/*For multistation no. of station */
int opseriessave = 0 






;

/* T2Map CV */
int opt2map = 0 






;

/* R2* CV */
int opmer2 = 0 






;

/* New RH CVs for New WW/WL algorithm used by RECON */
int rhnew_wnd_level_flag = 1 






;

int rhwnd_image_hist_area = 60 






;

float rhwnd_high_hist = 1.0 






;

float rhwnd_lower_hist = 1.0 






;

/*DLH, New RH variables for MAVRIC-SL*/
int rhrcmavric_control = 0 






;
/*Definitions of rhrcmavric_control(Debugging and Research):
 *rhrcmavric_control bit 0: MAVRIC Recon ON/OFF
 *rhrcmavric_control bit 1: MAVRIC Recon with De-Blurring Algorithm
 *rhrcmavric_control bit 2: MAVRIC Recon with Jocobian Algorithm
 */
int rhrcmavric_image = 0 






;
/*Definitions of rhrcmavric_image(Debugging and Research):
 * rhrcmavric_image bit 0:    Echo Images (Bin Images)
 * rhrcmavric_image bit 1:    SOS Corrected Images (Default)
 * rhrcmavric_image bit 2:    Initial SOS Images
 * rhrcmavric_image bit 3:    FieldMap Image
 * rhrcmavric_image bit 4:    Threshold FieldMap Image
 * rhrcmavric_image bit 5:    FieldMap Blurred Image
 * rhrcmavric_image bit 6:    Gradient Ratio Image
 * rhrcmavric_image bit 7:    Blurred Gradient Ratio Image
 * rhrcmavric_image bit 8:    Capped & Normalized Blurred Gradient Map
 * */
int rhrcmavric_bin_separation = 1000 






;

/* New RF related Definitions.*/
int cfrfupa = -50 






;

int cfrfupd = 50 






;

int cfrfminblank = 200 






;

int cfrfminunblk = 200 






;

int cfrfminblanktorcv = 50 






;

float cfrfampftconst = 0.784 






;

float cfrfampftlinear = 0.0 






;

float cfrfampftquadratic = 15.125 






;

int optracq = 0 






;

/* Additions for SWIFT */
int opswift = 0 






;

int rhswiftenable = 0 





;

int rhnumCoilConfigs = 0 





;

int rhnumslabs = 1 





;

/* The number of coil configurations in coilInfo and volRecCoilInfo */
int opncoils = 1 





;

/* MRIhc14655 - New cvs for RT SAR Feature Move to @reqcv from @reqexport */
/* MRIhc14436 - New cvs for RT SAR Feature */

int rtsar_first_series_flag = 0 





;

int rtsar_enable_flag = 0 





;

int measured_TG = -1 





;

int predicted_TG = -1 





;

float sar_correction_factor = 1.0 





;

int gradHeatMethod = PSD_OFF 






;

int gradHeatFile = PSD_OFF 






;

int gradCoilMethod = GRADIENT_COIL_METHOD_AUTO  






;

int gradHeatFlag = PSD_OFF 






;

int xgd_optimization = PSD_ON 






;

int gradChokeFlag = PSD_OFF 






;

/* Burst Mode */
int piburstmode = PSD_OFF 






;

int opburstmode = PSD_OFF 






;

int burstreps = 1 






;

float piburstcooltime = 0.0 






;

/* Parallel Imaging UI */
float opaccel_ph_stride = 1.0 






;

float opaccel_sl_stride = 1.0 






;

float opaccel_t_stride = 1.0 






;

int oparc = PSD_OFF 






;

int op3dgradwarp = 0 






;

int opauto3dgradwarp = 1 






;

/* -250000 Hz for HD, 0 for DV */
int cfreceiveroffsetfreq = 0 






;

/* See COIL_SWITCH defines for bit definitions */
int cfcoilswitchmethod = COIL_SWITCH_SSP_HUB_INDEX 






;

int cfreceivertype = CFG_VAL_RECEIVER_RRX   






;

int cfreceiverswitchtype = CFG_VAL_RCV_SWITCH_RF_HUB 






;

int cfEllipticDriveEnable = 0 






;

int pi3dgradwarpnub = 1 






;

int cfDualDriveCapable = 0 






;

/* TRIP addition */
int optrip = 0 






;

/* HOEC correction flag */
int ophoecc = 0 






;

/* recon cv for HOEC correction */
int rhhoecc = 0 






;

/* recon cv for fit order of HOEC */
int rhhoec_fit_order = 3 






;

/* recon cv for echo spacing */
int rhesp = 500 






;

/* RG calibration mode */
int oprgcalmode = RG_CAL_MODE_MEASURED 






;

/* ************************************************************
 * CVs
 * Certain CVs are not necessary for Scan/PSD communication
 * but are essential intermediate calculations for determining 
 * recon CV values and pulsegen values.
 * ********************************************************* */

int prevent_scan_under_emul = 0 






;

/* MRIhc18338 */
int acqs = 1 






;

int avround = 1 






;

int baseline = 0 






;

/* CV nex has value 1 for .5 nex and .75 nex scans */
int nex = 1 






;

/* ***************
 * fn 1 full kspace
 *    .5 half nex
 *    .75 3/4 nex 
 **************** */
float fn = 1.0 






;

int enablfracdec = 1 






;

float nop = 1 






;

int acq_type = TYPSPIN 






;

int seq_type = TYPNCAT 






;

int num_images = 1 






;

/* Image Type CVs */
int mag = 1 






;

int pha = 0 






;

int imag = 0 






;

int qmag = 0 






;


int slquant1 = 1 






;

int psd_grd_wait = 56 






;

int psd_rf_wait = 0 






;

/* pos_moment_start holds the time in us from the start of the sequence
   to the middle of the alpha pulse.  This is used to automate flow
   compensation and zeroth moment graphing tests.   */
int pos_moment_start = 0 






;

/* mps1rf1_inst and scanrf1_inst are used to hold the index into
   the rf1 instruction for scan and mps1. This allows the code
   for MPS1Prescan to simply copy the rf1 waveform used in scan.
   Thus, MPS1 is simplified for non-typical rf pulses  */

int mps1rf1_inst = 0 






;

int scanrf1_inst = 0 






;

/* cfcarddelay holds the delay of the cardiac hardware  */
int cfcarddelay = 10 






;


int psd_card_hdwr_delay = 0 






;

/*Default to proton at 4257.59 */
float GAM = GAMMA_PROTON 






;

int off90 = 80 






;

int TR_SLOP = 2000 






;

int TR_PASS = 50000 






;

int TR_PASS3D = 550000 






;

int csweight= 100 






;

/* Nex can not be accumulated with exorcist running.  exnex
 * calculates the number of frames/view that must be stored in BAM */
int exnex = 1 






;

float truenex = 0.0 






;

int eg_phaseres = 128 






;

int sp_satcard_loc = 0 






;

int min_rfdycc = 0; /* minimum seq time based on duty cycle (us) */

int min_rfavgpow = 0; /* minimum seq time based on avg. power (us) */

int min_rfrmsb1 = 0; /* minimum seq time based on rms B1 limitation (us). */

int coll_prefls = 1 






;

/* following parameters are new for 55.  YH  10/14/94 */
int maxGradRes = 1 






;

float dfg = 2 






;

float pg_beta = 1.0 






;
     
int split_dab = 0 






;
 
float freq_scale = 1.0 






;

int numrecv = 1 






;
 
/* for phase encoding */
int pe_on = 1 






;
 
float psd_targetscale = 1.0; /* %fullscale for amps-set in obloptimize */
 
float psd_zero = 0.0 






;

/* gram pulse modulation width time per logical axis */
int lx_pwmtime = 0; 
int ly_pwmtime = 0;
int lz_pwmtime = 0;

/* gram pulse modulation width time per physical axis  */
int px_pwmtime = 0; 
int py_pwmtime = 0;
int pz_pwmtime = 0;

int min_seqgrad = 0;  /* minimum sequence time based on Gradient subsystem */
int min_seqrfamp = 0; /* minimum sequence time based on RF amplifier */

/* per axis loading in units of A^2*uSec */
float xa2s = 0;
float ya2s = 0;
float za2s = 0;

int minseqcoil_t = 0;  /* minseq time based on coil heating  */
int minseqcoilburst_t = 0; /* minseq time based on Burst Mode coil limit */
int minseqgram_t = 0;  /* minseq time based on gram heating  */
int minseqchoke_t = 0;
int minseqcable_t = 0;
int minseqcableburst_t = 0; /* minseq time based on Burst Mode cable limit */
int minseqbusbar_t = 0;

/* min seq time based on gradient driver heating  */
int minseqgrddrv_t = 0;      /* minseqtime based on gradient driver heating */
int minseqgrddrvx_t = 0;     /* minseqtime based on X gradient driver heating */
int minseqgrddrvy_t = 0;     /* minseqtime based on Y gradient driver heating */
int minseqgrddrvz_t = 0;     /* minseqtime based on Z gradient driver heating */
float powerx = 0;             /* total scaled power in X in Ampere^2 usec     */
float powery = 0;             /* total scaled power in Y in Ampere^2 usec     */
float powerz = 0;             /* total scaled power in Z in Ampere^2 usec     */
float pospowerx = 0;          /* positive scaled power in X in Ampere^2 usec  */
float pospowery = 0;          /* positive scaled power in Y in Ampere^2 usec  */
float pospowerz = 0;          /* positive scaled power in Z in Ampere^2 usec  */
float negpowerx = 0;          /* negative scaled power in X in Ampere^2 usec  */
float negpowery = 0;          /* negative scaled power in Y in Ampere^2 usec  */
float negpowerz = 0;          /* negative scaled power in Z in Ampere^2 usec  */
float amptrans_lx = 0;          /* logical X ampere trans in (Amp/usec)*usec   */
float amptrans_ly = 0;          /* logical Y ampere trans in (Amp/usec)*usec   */
float amptrans_lz = 0;          /* logical Z ampere trans in (Amp/usec)*usec   */
float amptrans_px = 0;        /* physical X ampere trans in (Amp/usec)*usec   */
float amptrans_py = 0;        /* physical X ampere trans in (Amp/usec)*usec   */
float amptrans_pz = 0;        /* physical Y ampere trans in (Amp/usec)*usec   */
float abspower_lx = 0;          /* logical Z abs avrg ampere in Ampere * usec   */
float abspower_ly = 0;          /* logical Y abs avrg ampere in Ampere * usec   */
float abspower_lz = 0;          /* logical Z abs avrg ampere in Ampere * usec   */
float abspower_px = 0;        /* physical X abs avrg amperere in Amp * usec   */
float abspower_py = 0;        /* physical Y abs avrg amperere in Amp * usec   */
float abspower_pz = 0;        /* physical Y abs avrg amperere in Amp * usec   */

/* SGD gradient heating */
int minseqpwm_x = 0;
int minseqpwm_y = 0;
int minseqpwm_z = 0;
int minseqgpm_t = 0;

int time_pgen = 0;       /* timing variable added to monitor pulsegen execution time RK 6/11/96 */

int cont_debug = 0 






;

/* CVs added for Maxwell correction for phase-contrast */
int maxpc_cor = 0 






;

int maxpc_debug = 0 






;

int maxpc_points = 500 






;

/* Added for MGD for pass through filter */
int pass_thru_mode = 0 






;

/* Universally used timing CVs */
int tmin = 0 






;

int tmin_total = 0 






;

int psd_tol_value = 0 






;

/* Universally used board index CV */
int bd_index = PSD_XCVR2 






;

/* Error message data base flag */
int use_ermes = 0 






;

/* Added field strength CV to be able to use RSP.MFO 05/31/00 AY*/
float fieldstrength = 15000;

int asymmatrix = 0 






;

int psddebugcode = 0 






;

int psddebugcode2 = 0 






;

int serviceMode = 0 






;

/* UPM bit mask for disabling cross terms */
int upmxdisable = 16 






;

/*
 * MRIge47485 - Improved Gradient Duty Cycle
 */

/* Linear segment heating model */
int tsamp = 4 






;

int seg_debug = 0 






;

int CompositeRMS_method = PSD_OFF 






;

int gradDriverMethod = PSD_OFF 






;


/* gradDCsafeMethod selects Safe DC model for coil heating calculation MRIhc16090 */
int gradDCsafeMethod = PSD_ON 






;

/* stopwatchFlag for debugging */
int stopwatchFlag = 0 






;

int seqEntryIndex = 0 






;

/* dB/dtOpt CVs - RJF */
int dbdt_debug = 0 






;

int reilly_mode = 0 






;

/* Use this cv to manually turn on/off dB/dt feature */

int dbdt_disable = 0 






;

/* Add the following cv as a logic flag.  This depends on 3 conditions:
   1)Reilly Model being used, 2)CRM is present, 3)dB/dt feature is turned on.*/

int use_dbdt_opt = 1 






;

float srderate =  1.0 






;

int config_update_mode = 0 






;

int phys_record_flag = 0 






;

int phys_rec_resolution = 25 






;

/***********************************************************************
 * Bit control of channel selection for physiological data recording 
 * --------------------------------------------------------------
 * Bit 0 (1): respiratory trigger recording 
 * Bit 1 (2): respiratory waveform data recording
 * Bit 2 (4): PG trigger recording
 * Bit 3 (8): PG waveform data recording
 * Bit 4 (16): ECG 3 trigger recording
 * Bit 5 (32): ECG 3 waveform data recording 
 * Bit 6 (64): ECG 2 trigger recording 
 * Bit 7 (128): ECG 2 waveform data recording 
 ***********************************************************************/
int phys_record_channelsel = 15 






;

/* MRIge91983 */
int rotateflag = 0 






;

/* MRIge93114 */
int rhpcspacial_dynamic = 0 






;

int rhpc_rationalscale = 0 






;

int rhpcmag = 0 






;

int mild_note_support = 0 






;

int save_grad_spec_flag = 0 






;

int grad_spec_change_flag = 0 






;

int value_system_flag = 0 






;

int rectfov_npw_support = 0 






;

int pigeosrot = 0 






;

int minseqrf_cal = 1 






;

int min_rfampcpblty = 0 






;

int b1derate_flag = 0 






;

int oblmethod_dbdt_flag = 0 






; 

/* Non PGOH DC model CV parameters MRIhc16090 */
int minseqcoil_esp = 1000 






;

int aspir_flag = 0 






;

int rhrawsizeview = 0 






;

int chksum_scaninfo_view = 0 






;

int chksum_rhdacqctrl_view = 0 






;

float fnecho_lim = 1.0 






;

int psdcrucial_debug = 0 






;

int disable_exciter_unblank = 0 






;
/* This file simply contains the new macro definition EP_TRAIN_NAME */
/* which is used to set up the spin-echo reference scan code */
int cs_sat = 0;
int cs_satstart = 0, cs_sattime = 0;
float a_rfcssatcfh = 0, flip_rfcssatcfh = 0;
int pw_rfcssatcfh = 0, ia_rfcssatcfh = 0;
int ChemSatPulse=CSM_PULSE;
float area_gxkcs = 0;
float area_gykcs = 0;
float area_gyakcs = 0;
float area_gzkcs = 0;
int csk_derate_factor = 1 ;

/* creating rf waveform directly, so need to declare these */
int pw_rfcssat = 0, pw_omega_hs_rfcssat = 0;
int off_rfcssat = 0;
int ia_rfcssat = 0, ia_omega_hs_rfcssat = 0; /* vmx 3/13/95 YI */
float cyc_rfcssat = 0;
float a_rfcssat = 0, a_omega_hs_rfcssat = 0;
float alpha_rfcssat = 0;
float gscale_rfcssat = 0;
float flip_rfcssat = 0;

/* SPSP fat sat pulse */
float a_gzrfcssat = 0;
int ia_gzrfcssat = 0;
int pw_gzrfcssat = 0;
int res_gzrfcssat = 0;
float a_gzrfcssat_wrf = 0;

float a_thetarfcssat = 0;
int ia_thetarfcssat = 0;
int pw_thetarfcssat = 0;
int res_thetarfcssat = 0;
int off_thetarfcssat = 0;

int bw_rfcssat = 0;

/* variables for selective Chemsat - Used with 3dtof */
int selectiveChemsat = 0 ;
int numSlabs = 1;
float selectiveChemsatBWscaler = 1.0;
int bw_rfchemsat = 0;

int num_gzrfcssat_lobe = 0;
int pw_gzrfcssat_lobe = 0;
int pw_gzrfcssat_constant = 0;
int pw_gzrfcssat_rampz = 0;

int num_gzrfcssat_lobe_norf = 0;
int pw_gzrfcssat_lobe_norf = 0;
int pw_gzrfcssat_constant_norf = 0;
int pw_gzrfcssat_rampz_norf = 0;

int ext_pw_rfcssat = 0;
int ext_res_rfcssat = 0;
int ext_isodelay = 0;
int ext_water_freq_flag = 0;
int ext_pw_grad_sub_lobe = 0;
int ext_pw_grad_sub_lobe_ramp = 0;
int ext_num_grad_sub_lobe = 0;
int ext_pw_grad_sub_lobe_norf = 0;
int ext_pw_grad_sub_lobe_ramp_norf = 0;
int ext_num_grad_sub_lobe_norf = 0;
float ext_abswidth = 0;
float ext_effwidth = 0;
float ext_area = 0;
float ext_dtycyc = 0;
float ext_maxpw = 0;
float ext_max_b1 = 0;
float ext_max_int_b1_sq = 0;
float ext_max_rms_b1 = 0;
float ext_nom_fa = 0;
float ext_nom_pw = 0;
float ext_nom_bw = 0;
float ext_gzrfcssat_scale_fac = 0;
float ext_fatsat_min_slthick = 0;

/* FATSAT FACTOR addition - HH June 2005 */
float fatsat_factor = 1.0 ;

/* vmx 3/13/95 YI */
 int csat_rfupa    = -600 ;
 int csat_sys_type = 0  ;
/* end vmx */

/* AMR - FOR MRIhc27960 */
/* Adiablatic Spectral Inversion Recovery : SW/RFB 03-Nov-06, 27-Feb-07 */
int aspir_delay    = 0;
int aspir_cfoffset = 0;
int aspir_minti = 0;
float aspir_T1 = 0;
float aspir_TI = 0;
float aspir_TI_null = 0;
float aspir_TI_extra = 0;
float aspir_TI_min = 0;
float aspir_eff = 0;

int fatFlag = 0;
int cs_isodelay = 0;
int cs_delay = 0;
int recovery_time = 0;
float flip_sat = 0;		/* CV created to calculate ChemSat flip angle in SCAN, SGT */
float flip_satcfh = 0;	/* CV created to set ChemSat flip angle in CFH, SGT */
int   fStrength = 0;        /* FEC : Field strength temp variable for RF calculations */

/* SPSP fat sat pulse */
int use_spsp_fatsat = 0 ;
int debug_spsp_fatsat = 0;
float spsp_fatsat_slthick = 30.0 ;
int spsp_fatsat_pulse_extra_time = 0 ;
int spsp_fatsat_spatial_mode = 0 ;
float spsp_fatsat_spatial_offset = 0.0 ;
int spsp_fatsat_pulse_override = 0 ;

/* Omega Scale (8 bit shift = 256)*/
float spsp_fatsat_omega_scale= 256.0 ;

int aspir_fa_scaling_flag = 0 ;
float max_aspir_fa = 0; /* max allowed flip angle for aspir pulse */

int fa_scale_debug = 0;


float   ccs_dead = 3000000 ;
int     ccs_relaxers = 0;		/* number of ccs_relaxers sequences to play */
int     ccs_relaxtime = 0;		/* Time per scan to add for relaxers */
int     ccs_relaxseqtime = 0;		/* Time of a relaxer sequence */
int     SatRelaxers = 0;

    /* Pulse widths, sinc cylces and scaling for rf pulses */
float   gsat_scale = 0; 
float   cyc_rfs = 0;
int     pw_rfs = 0;
int     pw_satrampx = 0, pw_satrampy = 0, pw_satrampz = 0;

int     sat_rot_ex_num = 0;  /* number of explicit sats */
int     sat_rot_df_num = 0;  /* number of default sats */
int     sat_rot_index = 0;   /* index into sat rotation matrice array */
int     pw_isisat= 200   ;/* duration of isi interrupt */
int     pw_rotupdate = 12   ;   /* duration of rotation matrix update signal for WARP */
int     isi_satdelay = 100   ;    /* time back from end of killer decay ramp for ISI */
int     rot_delay = 12   ;       /* time back from end of killer decay ram for matrix
                            update signal for WARP */
int     isi_extra = 32   ;

int     sat_debug = 0;
int     spsat_host_debug = 0 ;
int     sp_first_scan = 0;  /* To determine if this is the first scan or not */

int     sat_obl_debug = 0;
int     sat_newgeo = 1;

/* vmx 3/13/95 YI */
 int spsat_rfupa    = -600 ;
 int spsat_sys_type = 0 ;
/* end vmx */

int     xkiller_set = 0;
int     maxkiller_time = 0;

    /* These are unlocked per applications 7/9/92 */
float   satgapxpos= 0 
;
float   satgapxneg= 0 
;
float   satgapypos= 0 
;
float   satgapyneg= 0 
;
float   satgapzpos= 0 
;
float   satgapzneg= 0 
;

    /* Sat spacing for use with Hadamard rf pulses */
float   satspacex1 = 0,   
        satspacex2 = 0,
        satspacey1 = 0,
        satspacey2 = 0,
        satspacez1 = 0,
        satspacez2 = 0,
        satspace1 = 0,
        satspace2 = 0,
        satspace3 = 0,
        satspace4 = 0,
        satspace5 = 0,
        satspace6 = 0;

   /* Sat thickness. x1, x2, y1, y2, z1, z2 are the default sats
                     e1, e2, e3, e4, e5, e6 are the explicit sats */
float   satthickx1 = 0, 
        satthickx2 = 0,
        satthickdfx = 0,
        satthicky1 = 0, 
        satthicky2 = 0,
        satthickdfy = 0,
        satthickz1 = 0, 
        satthickz2 = 0, 
        satthickdfz = 0,
        exsatthick1 = 0, 
        exsatthick2 = 0,
        exsatthick3 = 0, 
        exsatthick4 = 0,
        exsatthick5 = 0, 
        exsatthick6 = 0;

   /* Location of sat bands. 
         xlocneg, xlocpos, ylocneg, ylocpos, zlocneg, zlocpos are default sats
         loce1, loce2, loce3, loce4, loce5, loce6 are explicit sats */ 
           
float   satxlocpos = 0,
        satxlocneg = 0, 
        satylocpos = 0, 
        satylocneg = 0,
        satzlocpos = 0, 
        satzlocneg = 0,
        satzloca = 0,
        satzlocb = 0,
        satloce1 = 0,
        satloce2 = 0,
        satloce3 = 0,
        satloce4 = 0,
        satloce5 = 0,
        satloce6 = 0;

float   area_rfsx1 = 0 ;
float   area_rfsx2 = 0 ;
float   area_rfsy1 = 0 ;
float   area_rfsy2 = 0 ;
float   area_rfsz1 = 0 ;
float   area_rfsz2 = 0 ;
float   area_rfse1 = 0 ;
float   area_rfse2 = 0 ;
float   area_rfse3 = 0 ;
float   area_rfse4 = 0 ;
float   area_rfse5 = 0 ;
float   area_rfse6 = 0 ;

float area_gyksx1 = 0,area_gyksx2 = 0,area_gyksy1 = 0,area_gyksy2 = 0,area_gyksz1 = 0,
          area_gyksz2 = 0,area_gykse1 = 0,area_gykse2 = 0,area_gykse3 = 0,area_gykse4 = 0,
          area_gykse5 = 0,area_gykse6 = 0;

float area_gxksx1 = 0,area_gxksx2 = 0,area_gxksy1 = 0,area_gxksy2 = 0,area_gxksz1 = 0,
          area_gxksz2 = 0,area_gxkse1 = 0,area_gxkse2 = 0,area_gxkse3 = 0,area_gxkse4 = 0,
          area_gxkse5 = 0,area_gxkse6 = 0;

int     sp_sattime = 0 ;
int     sp_satstart = 0 ;

int     vrgsat = 2 ;
int     numsatramp = 0 ;
int     had_sat = 0 ;

float rtia3d_sat_flip = 70 
;

float rtia3d_sat_pos = 100.0 
;

int sat_pulse_type  = REAL_RF ;
/***************************************************************************/

int autolock = 0 





; /* vmx 10/13/94 YI */

int blank = 4 





; /* vmx 10/3/94 YI */

int nograd = 0 





; /* vmx 10/13/94 YI */

int nofermi = 0 





; /* vmx 10/13/94 YI */

int rawdata = 0 





; /* vmx 10/13/94 YI */

int saveinter = 0 





; /* vmx 10/13/94 YI */

int zchop = 1 





;/* vmx 10/13/94 YI */

int eepf = 0 





; /* vmx 10/13/94 YI */

int oepf = 0 





; /* vmx 10/13/94 YI */

int eeff = 0 





; /* vmx 10/13/94 YI */

int oeff = 0 





; /* vmx 10/13/94 YI */

int cine_choplet = 0 





; /* vmx 10/13/94 YI */

/*** CVs for Fermi Filter ***/
float fermi_rc = 0.5 





;

float fermi_wc = 1.0 





;


int rcvinput = PSD_RP_SURFACE 


;
int rcvbias  = PSD_RB_SURFACE 

 ;
int trdriver = PSD_RP_HEAD 


;
int rcvband = PSD_BROADBANDOFF 
;

 int cv_rfupa          = -600 ;
 int system_type = 0  ;
 int cvlock = 1 ;
 int psd_taps = -1 
;
 int fix_fermi = 0 
;
 int grad_spec_ctrl = 0 
  ;
 float srate = 1.651 ;
 float glimit = 1.0 ;
 float save_gmax = 1.0;
 float save_srate = 2.551;
 int save_cfxfull = 32752;
 int save_cfyfull = 32752;
 int save_cfzfull = 32752;
 float save_cfxipeak = 194.0;
 float save_cfyipeak = 194.0;
 float save_cfzipeak = 194.0;
 int save_ramptime = 600;
 int debug_grad_spec = 0 ;
 float act_srate=1.651;
 int val15_lock = 0 
  ;
 
/*********************************************************************
 *                     PRESCAN.E HOST SECTION                        *
 *                             PScvs                                 *
 *                                                                   *
 * Standard C variables of _limited_ types common for both the Host  *
 * and Tgt PSD processes. Declare here all the simple types, e.g,    *
 * int, float, and C structures containing the min and max values,   *
 * and ID description, etc.                                          *
 *                                                                   *
 * NOTE FOR Lx:                                                      *
 * Since the architectures between the Host and the Tgt sides are    *
 * different, the memory alignment for certain types varies. Hence,  *
 * the following types are "forbidden": short, char, and double.     *
 *********************************************************************/
float PSsr_derate_factor = 1.0 ;
float PSassr_derate_factor = 1.0 ;

/* ezi (GE) */
float mpsfov = 100  ;

int fastprescan = 0 ;
int pre_slice = 0 ;
int PSslice_num = 0;
float xmtaddAPS1 = 0, xmtaddCFL = 0, xmtaddCFH = 0, xmtaddFTG = 0, xmtadd = 0, xmtaddRCVN = 0;
float ps1scale = 0, cflscale = 0, cfhscale = 0, ftgscale = 0;
float extraScale = 0;  /* for external PSD use */
int PSdebugstate = 0 ;
int PSfield_strength = B0_5000 ;
int PScs_sat = 1 ;
int PSir = 1 ;
int PSmt = 1 ;
int ps1_rxcoil = 0 ;

/* vmx 06/14/95 YI */
int tg_1_2_pw = 1 ;
int tg_axial = 1 ;
float coeff_pw_tg = 1.0;
float fov_lim_mps = 350.0 ;
/* end vmx */

int TGspf = 0 ;

float flip_rf2cfh = 0;
float flip_rf3cfh = 0; /* For presscfh MRIhc08321 */
int ps1_tr=2000000;
int cfl_tr=398000;
int cfh_tr=398000;
int rcvn_tr=398000;

float cfh_ec_position = (16.0/256.0) ;
				/* vmx 05/02/95 YO */
int cfl_dda = 4 ;
int cfl_nex = 2 ;
int cfh_dda = 4 ;
int cfh_nex = 2 ;
int rcvn_dda = 0 ;
int rcvn_nex = 1 ;

/* presscfh  cvs -  For  MRIhc08321 */ 
/* Definitions in epic.h
 * PRESSCFH_SLICE 1      
 * PRESSCFH_SLAB 2                                              
 * PRESSCFH_SHIMVOL 3
 * PRESSCFH_NONE 4
 * */
int presscfh_override = 0  ;
int presscfh = PRESSCFH_NONE  ;
int presscfh_ctrl = PRESSCFH_NONE  ;
int presscfh_outrange = 0;
int presscfh_cgate = 0;
int presscfh_debug = 0 ;
int presscfh_wait_rf12 = 0;
int presscfh_minte = 20000;
float presscfh_fov = 0.0;
float presscfh_fov_ratio = 1.0;
float presscfh_pfov_ratio = 1.0;
float presscfh_slab_ratio = 1.0;
float presscfh_pfov = 0.0; 
float presscfh_slthick = 10.0;
float presscfh_ir_slthick = 10.0;
int presscfh_ir_noselect = 1;
/* SXZ: change from 0.5 to 0.3 to make sure presscfh is more probably
 * used for PRESSCFH_SLICE mode */
float presscfh_minfov_ratio = 0.3; /* SXZ: change from 0.5 to 0.3 */ 

/* steam_flag */
int cfh_steam_flag = 0;
int steam_pg_gap = 8;

float area_gykcfl = 0;
float area_gykcfh = 0;
float area_xtgzkiller = 0;
float area_xtgykiller = 0;
int PSoff90=80  ;
int dummy_pw = 0;
int min180te = 0;

float PStloc = 0;
float PSrloc = 0;
float PSphasoff = 0;
int PStrigger = 0;

/* begin aps1_mod changes (GE) */
float PStloc_mod = 0;
float PSrloc_mod = 0;
float thickPS_mod = 0;
/* end aps1_mod changes (GE) */

float asx_killer_area = 840.0; /* based on 5.4:  .7 * ( 800 + 400 ) */
float asz_killer_area = 840.0; /* based on 5.4:  .7 * ( 800 + 400 ) */
float cfhir_killer_area = 4086.0; /* based on 5.4:  .9 * ( 4000 + 540 ) */
float ps_crusher_area = 714.0; /* based on 5.4:  .7 * ( 600 + 420 ) */
float cfh_crusher_area = 4000.0; /* MRIhc57311: increased crusher area to kill signal from outside slice */
float target_cfh_crusher = 0;
float target_cfh_crusher2 = 0;  /* For presscfh MRIhc08321 */ 

int cfh_newmode = 1;
float cfh_rf2freq = 0 ;
float cfh_rf3freq = 0 ; /* For presscfh MRIhc08321 */
float cfh_rf1freq = 0 ;
float cfh_fov = 0 ;
int cfh_ti = CFHTI_1HT;
int eff_cfh_te = CFHTE_1HT;

/**** FastTG CVs   *******/
float FTGslthk = 20 ;

float FTGopslthickz1=80 ;
float FTGopslthickz2=80 ;
float FTGopslthickz3=20 ;
int   ftgtr = 2000000 ;
float FTGfov = 480.0 ;
float FTGau  = 4 ;
float FTGtecho = 4 ;
int FTGtau1   = 8192   ;
int FTGtau2   = 32768   ;
int FTGacq1   = 0 ;
int FTGacq2   = 1 ;
int epi_ir_on = 0 ;	/* ypd */
int ssfse_ir_on = 0 ;	/* MRIge66767 */
int ftg_dda = 0 ;

float FTGecho1bw = 3.90625 ;
int FTGtestpulse  = 0 
;
int FTGxres    = 256 ;
float FTGxmtadd = 0;
int pw_gxw2ftgleft = 4096; /* HCSDM00161809: time of 2nd readout window to S1 echo */

/**** eXpressTG CVs   *******/
int   xtgtr = 200000 ;
int XTGtau1   = 8192   ;
float XTGfov = 480.0 ;
int pw_bsrf = 4000;
int xtg_volRecCoil = 0 ;
int xtg_offres_freq = 2000; /* 2kHz off-resonance */
float XTGecho1bw = 15.625 ;
int XTGxres    = 256 ;
float xmtaddXTG = 0, xtgscale = 0;
int xtg_dda = 0 ;
int XTGacq1   = 0 ;
float XTGopslthick = 10 ;


/**** CFL/CFH CVs   *******/
int CFLxres = 256 ; /* MRIhc54366 */
 
float echo1bwcfl = 2.016129 ;
float echo1bwcfh = 0.50 ;

int echo1ptcfh = 256 ;  /* MRIhc08595 */

float echo1bwrcvn = 15.625 ;
int   rcvn_xres   = 4096 ;
int   rcvn_loops  = 10;  /* number of iterations RCVN entry point will loop */

/**** AutoShim CVs *******/

float echo1bwas = 15.625 ;

int off90as  = 80   ;
int td0as  = 4 ;
int t_exaas = 0 ;
int time_ssias = 400   ;
int tleadas = 25   ;

int te_as = 0;
int tr_as = 0;
int as_dda = 4 ;

/**** Receive Gain CVs ****/

int rgfeature_enable  = PSD_OFF ;

/********** Required for mrsaps/opt prescan ****************/
/********** pimrsapsflg must be on *************************/
float aslenap = 200 ;
float aslenrl = 200 ;
float aslensi = 200 ;

float aslocap = 0 ;
float aslocrl = 0 ;
float aslocsi = 0 ;
/***********************************************************/

/* temp crusher amplitudes */
float area_gxwas = 0;                  /* readout pulse area */
float area_gz1as = 0;
float area_readrampas = 0;             /* area of left readout ramp */
int avail_pwgx1as = 0;                 /* avail time for gx1as pulse */
int avail_pwgy1as = 0;                 /* avail time for gy1as pulse */
int avail_pwgz1as = 0;               /* avail time for gz1as pulse */
int bw_rf1as = 0;                    /* bandwidth of rf pulses */

/* filter info for 1st, 2nd echo */
float flip_pctas=1.0;                 /* flip angle % for rf scaling */

int dix_timeas = 0;              /* dixon delay for even excitations */
float xmtaddas = 0,xmtlogas = 0;     /* rf attenuation */
int ps1obl_debug = 0 
;
int asobl_debug = 0 
;
int ps1_newgeo = 1;

int as_newgeo = 1;
int pw_gy1as_tot = 0;
int endview_iampas = 0;
float endview_scaleas = 0;

/* YMSmr09211  04/26/2006 YI */
int cfh_newgeo = 1; 
int cfhobl_debug = 0 
;

float deltf = 1.0 ;

int IRinCFH = 0 ;
int cfh_each = 0 ;
int cfh_slquant = 0 ;

int noswitch_slab_psc = 0 ;
int noswitch_coil_psc = 0 ;
int PStest_slab = 1 ;
/******************** Communication cv's (Prescan)**********/
int pimrsapsflg = 0 ;
int pimrsaps1 = MRSAPS_CFL 


;
int pimrsaps2 = MRSAPS_FTG 


;
int pimrsaps3 = MRSAPS_AS 


;
int pimrsaps4 = MRSAPS_TR 


;
int pimrsaps5 = MRSAPS_RCVN 


;
int pimrsaps6 = MRSAPS_CFH 


;
int pimrsaps7 = MRSAPS_OFF 


;
int pimrsaps8 = MRSAPS_OFF 


;
int pimrsaps9 = MRSAPS_OFF 


;
int pimrsaps10 = MRSAPS_OFF 


;
int pimrsaps11 = MRSAPS_OFF 


;
int pimrsaps12 = MRSAPS_OFF 


;
int pimrsaps13 = MRSAPS_OFF 


;
int pimrsaps14 = MRSAPS_OFF 


;
int pimrsaps15 = MRSAPS_OFF 


;

/* MRIhc15304: CVs related to coil switching
 * By changing the hub index for the coil and sending
 * it through SSP packet (RFHUB ssp packet)
 */
int pw_contrfhubsel = 4 ;
int delay_rfhubsel = 20;
int pw_contrfsel = 4 ;
int csw_tr = 0 ;
int csw_wait_sethubindeximm = 250000 
;
int csw_wait_setrcvportimm = 100000 
;
int csw_wait_before = 10000 ;
int csw_time_ssi = 50   
;

/* MRIhc47602/MRIhc47515/GEHmr03545 : Killer gradient in the RCVN sequence */
float area_gxkrcvn = 10000;
float area_gykrcvn = 10000;
float area_gzkrcvn = 10000;
int pre_rcvn_tr = 20000 ;
int rcvn_flag = 1 ;

/***********************************************************/


float yk0_killer_area = 4140.0;
/* based on 5.4 .9*4600us */
int ir_on        = 0 ;
int ir_start     = 0 ;
int irk_start    = 0 ;
int ir_grad_time = 0 ;
int ir_time      = 0 ;
int ir_time_total= 0 ;
int ext_ir_pulse = 1 ;
float rf0_phase  = 0 ;
int non_tetitime = 0 ;
int irslquant = 0;
int irinterval = 0 ;
int bw_rf0     = 0 ;
int hrf0       = 0 ;
int pos_ref = 0; 
int pos_start_rf0 = 0 ;

/* T1FLAIR, SGT */
int titime     = 0 ;
int seq_shift  = 0 ;
int time_to_rf1 = 0;
int inner_spacing = 0;
int post_spacing = 0;

int silver_hoult = 1 ;
float tmpslthick = 0; 
float csf_fact=0.5;   /* gscale_rf0 scale factor for FLAIR */
float invthick = 0;    /* Only used for FLAIR. Size of inversion slice (mm) for f/lair */
int invThickOpt = 0 ;
int invThickOpt_seqtime = 0;
int enht2flairflag = 0 ;
int invseqlen = 0;     /* min time played out for inversion sequence */
int invseqlen2 = 0;    /* accounts for shift of FSE sequence start time for pack2 */
int flair_on = 0;                    /* flag to turn on the Flair feature*/
int ir_index = 0 ;

/* MRIhc13638 - Substituting sh3t2 for shNvrg5b when 3T field is selected. */
int ir3t_flag = 0;

/* **********************************************************
 These cvs are defined by sliceselz, and trapezoid macro in epic.h 
int pw_rf0        "Pulse width of IR pulse"
float a_rf0       "Amplitude of RF0 for IR"
float cyc_rf0     "# of cyc of RF0 for IR"
int pw_gzrf0      "Pulse width of GZ for IR"
int pw_gzrf0a     "Pulse width of ramps on GZ for IR"
int pw_gzrf0d     "Pulse width of ramps on GZ for IR"
float a_gzrf0     "Amplitude of GZ for IR"
short res_rf0     "Resolution of IR pulse"  
float gscale_rf0  "G scale factor for SLR-IR pulse"
int pw_gyk0       "Pulse width of killer for IR on Y"
int pw_gyk0a      "Pulse width of ramps for IR killer"
int pw_gyk0d      "Pulse width of ramps for IR killer"
float a_gyk0      "Amplitude of killer for IR on Y"
********************************************************** */

/* vmx 3/13/95 YI */
 int ir_rfupa    = -600 ;
 int ir_sys_type = 0  ;
/* end vmx */

int t2flair_extra_ir_flag = 0 ;


int ss_rf1 = 0 ;
int fat_flag = 0 ;
float fat_delta = -230.0 
; 
int fat_offset = -386 ;
int sszchop = 0 
;
int pw_gzrf1lobe = 0;  /* pw of gradient lobe in ss_pulse */
int pw_constant = 0;
int num_rf1lobe = 0;        /* number of lobes in ss_pulse */
int gradient_mode = 1 ;
int ss_rf_wait = 0 
;
int pw_ss_rampz = 0;
int ss_override = 0 ;
int whichss = 0;
float nbw_ssrf = 0;         /* nominal bandwidth of spectral spacial rf pulse */
float ss_min_slthk = 0, ss_maxoff = 0, ss_minslthk1 = 0;

int ss_convolution_flag = 0 ;

int breast_spsp_flag = 0 ;
int ss_fa_scaling_flag = 0 ;
float max_ss_fa = 0; /* max allowed flip angle for spsp pulse */

int ss_maxoffex = 0;
int off90minor = 0;
float omega_amp = 0;
float gz1_zero_moment = 0;
float gz1_first_moment = 0;

/* BJM: added freqSign so the freq offset can be modulated */
/* in in the core section if the gradient is flipped       */
int freqSign = 1;

/******************************ssIPGexport*******************************/
/* Inline this section in a ipgexport section of your source, e.g.
@ipgexport
@inline ss.e ssIPGexport
*/

int rtd_on = 0 ;


/* BJM - added Maxwell compensation phase encode also */
int maxwell_flag = PSD_ON;    /* user variable for turning on maxwell correction (read) */	
int maxwell_blip = PSD_ON;    /* user variable for turning on maxwell correction (phase) */	
float B0_field = 0;         /* B0 field in Gauss */
float pw_gxw_MAX_l = 0;     /* total Maxwell timing for the left half of trapezoid */
float pw_gxw_MAX_r = 0;     /* total Maxwell timing for the right half of trapezoid */
float pw_gyb_MAX_l = 0;     /* total Maxwell timing for the left half of phase trapezoid */
float pw_gyb_MAX_r = 0;     /* total Maxwell timing for the right half phase trapezoid */
int max_debug=0;        /* print flag  */


int nodelay=0;                  
int nodelayesp=0;
int b0dither_new = 1 ;

int nob0dither=0;	        /* File existence flags for b0_dither.cal and delay.dat */
int nob0dither_interpo=0;       /* File existence flags for b0vectors.dat.body<head>.
				   b0vectors.dat.body<head> is created during the 
				   B0 dither calibration procedure. It holds the phase 
				   dither values for each axis for 30 different esp 
				   values. The epi psd reads this file to determine 
				   how much phase dither to apply to the receiver to 
				   count act the uncompensated short time constant 
				   B0 eddy current effects. */

				/* bcrvf1.dat: Created during Bandpass Asymmetry cal.
				   It comtains mag. and phase correction vector data 
				   that is applied to epi raw data after the first FFT 
				   to correct for mag. and phase asymmetries induced
				   by the 100kHz LPF in the faster receiver.

                                   bcrvs1.dat: Created during Bandpass Asymmetry cal.
                                   It comtains mag. and phase correction vector data 
                                   that is applied to epi raw data after the first FFT 
                                   to correct for mag. and phase asymmetries induced
                                   by the standard receiver 0. */

int nobcfile=0;		

int number_of_bc_files = 0;                  
int activeReceivers=-1;                  
int flagWarning = TRUE;

int refScanTe = 0;        /* This is the equivalent spin-echo TE */
int minTeFrac_ref = 0;
int minTeFull_ref = 0;
int tempTe_ref = 0;
int se_ref = 0; /* 1: use spin echo ref scan */
int reMap = 1;  /* 0: dont fit correction values vs. Ky */

/* Setup all the rh variable related to pahse correction */
/* MRIge92386 */
/* AssetCVs  inlined from Asset.e */
float asset_factor = 0.5 ;
float assetsl_factor = 1.0 ;
int assetph_flag = PSD_OFF ;
int assetsl_flag = PSD_OFF ;
int asset_supported_direction = ASSET_SUPPORT_PHASE 





;

/* AssetCVs  inlined from Asset.e */



int rtb0_flag = 0 ;
int rtb0_first_skip = 20 ;
int rtb0_last_skip = 20 ;
int rtb0_movAvg = 5 ;
int rtb0_min_points = 10 ;
int rtb0DebugFlag = PSD_OFF;
int rtb0SaveRaw = PSD_OFF;

int rtb0_comp_flag = 0 ;
int rtb0_acq_delay = 0 ;
int rtb0_midsliceindex = -1 ;
float rtb0_outlier_threshold = 10.0 ;
float rtb0_outlier_duration = 30.0 ;
int rtb0_outlier_nTRs = 0;
int rtb0_minintervalb4acq = 0;

/* MRIhc44418 */
int epiespopt_flag = 0 ;
int epiRTespopt_flag = 0 ;
int epiminesp_flag = 0 ;
int epiRTminesp_flag = 0 ;

/* MRIhc50643 */
int epira3_flag = 0 ;
int epiRTra3_flag = 0 ;

/* These two CVs function only for type-in PSDs epira3 and epiRTra3 */
int ra3_minesp_flag = 0 ;
int ra3_sndpc_flag = 0 ;

int dbdt_model = 0 ;
float dbdtper_new = 0; /* new dbdtper parameter for epigradopt */
int esprange_check = 0 ;
int espopt = 1 ;
int espincway = 0 ;
int no_gy1_ol_gxw = 0 ;

int epigradopt_debug = 0;
int epigradopt_output = 0;

int saved_tmin_total = 0;
int tr_corr_mode = 1 ;

/* ZL::MRIhc08588 */
int num_passdelay = 1 ;

/* ZL::MRIhc06466, MRIhc06308 */
int temp_rhpcspacial = 0 ;

/* SXZ::MRIge72411: top area vs. total area ratio */
float taratio = 0.0 ;
int rampopt = 1 ;
int taratio_override = PSD_OFF ;

/* SXZ::MRIge72411: following cvs show useful info */
float totarea = 0; /* G*usec/cm */
float actratio = 0;

int fmri_coil_limit = 1.0;

/* internref: internal reference scan */
int iref_etl = 0 ;
int iref_frames = 0;

int MinFram2FramTime = 30  ;

float phase_dither = 0.0 ;
int spgr_flag = 0 ;

int newyres=0;		/* New yres if opnshots/opte/opyres is incompatible. */

int avmintefull = 0 ;   
int cvrefindex1 = 0;
int avmintetemp = 0;

int cfh_crusher = 0 ;   

int fast_rec = 0 ;

/* Given n baselines, use bl_acq_tr1 for first n-1 baselines, bl_acq_tr2
   for nth baseline.  This is to minimize baseline acq. time while
   avoiding sequence preparation failures for the scan that follows. */

int bl_acq_tr1 = 100000 ;
int bl_acq_tr2 = 300000 ;

float fecho_factor = 0; /*SNR*/
float tsp = 8.0 ;
int intleaves = 1 ;

int ky_dir = 2 ;

int dc_chop   =  1 ;
/*	  0 = same start polarity (+) for all intleaves.
 	  1 = odd intleaves start +, even start -
 	  2 = 1st half of intleaves start +, second half interleaves start -
 	  3 = 1st & 3rd quarters start +, 2nd & 4th quarters start -.  */
int kx_dir = 0 ;

int etot = 0 ;
int emid = 0 ;
int e1st = 0 ;

/*    Allow ram function in SCAN.  Use only w/RAWDATA=1 (ie.no DAB sort). */
int seq_data  = 0 ;

float msamp = 0.0 ;
float dsamp = 0.0 ;
float delpw = 0;
 
/* Number of repeated scans at each slice */
/* LX TPS has 8M bytes and allows at least 512 passes. ypd */
int reps        = 1 ;
int pass_reps   = 1 ;
int max_dsht    = 8 ;

int rf_chop = 1 ;

 /*spsp*/
int rftype = 1 ;
int thetatype = 0 ;
int gztype = 1 ;

int hsdab   = 1 ;

/* LX TPS has 8M bytes and allows at least 512 passes. ypd */
int slice_num = 1 ; /* YMSmr06515 */
int rep_num = 1 ;

int endview_iamp = 0;  /* end instruction phase amp */
int endview_scale = 0; /* ratio of last instruction amp to maximum value */

int gx1pos   = 1 ;
int gy1pos   = 1 ;

int eosxkiller  = 0 ;
int eosykiller  = 1 ;
int eoszkiller  = 1 ;
int eoskillers  = 1 ;
int eosrhokiller  = 1 ;

int gyctrl = 1 ;
int gxctrl = 1 ;
int gzctrl = 1 ;

int ygmn_type = 0;   /* specifies degree of FC on Y */
int zgmn_type = 0;   /* specifies degree of FC on Z */

/* VGRF CVs */
int vrgfsamp  = 0 ;
int autovrgf = 1 ;
float vrgf_targ = 2.0 ;

float fbhw = 1.0 ;
int vrgf_reorder = 1 ;

/* MRIge66374 - this get applied in epigradopt (needs to be 0) */
int   osamp     = 0 ;

int   esp       = 0 ;
int   etl       = 1 ;
int   eesp      = 0 ;
int   nblips = 0, blips2cent = 0;   /* total number of blips and number of blips
							  to the center of ky offset */
int ep_alt = 0 ;

int tia_gx1 = 0, tia_gxw = 0, tia_gxk = 0;     /*temp internal amps that flip in polarity*/
float ta_gxwn = 0;                     /* temp value for negative a_gxw value */
float rbw = 0;                         /* rbw in Hz */

/* MinTE Calculation CV's */
int   avminxa = 0, avminxb = 0, avminx = 0, avminya = 0, avminyb = 0, avminy = 0;
int   avminza = 0, avminzb = 0, avminz = 0, avminssp = 0;
float avminfovx = 0, avminfovy = 0;

int hrdwr_period = 4   ;
int samp_period = 8   ;
int pwmin_gap = 2*4  ; /*=2*GRAD_UPDATE_TIME*/

float frqx = 200.0 ;
float frqy = 2.0   ;

int dacq_offset = 0   ;
int   pepolar = 0 ;

int   tdaqhxa = 0, tdaqhxb = 0;
float delt = 0;

/* sliding data acquisition window control: */
int   tfon = 1 ;

/* Homodyne (minTE) scan, ky_offset - moves echo to flow-comp echo group*/
int fract_ky = PSD_FULL_KY ;
float ky_offset = 0.0 ;
float gy1_offset = 0.0 ;
int rhhnover_max=0;	/* Maximum allowed rhhnovers due to physical space on the boards */
int rhhnover_min = 8;   /* minimum number of overscans */
int num_overscan = 8;   /* BJM: this was added for multi-shot EPI */
int fract_ky_topdown = 1 ;

int smart_numoverscan = 0 ;

/* MRIhc57297  06/15/2011 YI */
int ky_offset_save = 0;
int rhhnover_save = 0;
int rhnframes_tmp = 0;

/* needed for Inversion.e */
int satdelay = 0000 ;

int   td0       = 4 ;
int   t_exa     = 0 ;
int   te_time   = 0 ;
int   pos_start = 0 ;
int   post_echo_time = 0 ;
int   psd_tseq = 0 ;
int   time_ssi  = 1000   ;

float dacq_adjust = 0.0 ;

int watchdogcount = 15 ;

int dabdelay = 0 ;

int long_hrdwr_period = 1 ;

int tlead     = 25   ;
int tleadssp  = 25   ;
int act_tr    = 0 ;
/*jwg change rfconf initialization for broadband*/
/*int rfconf = ENBL_RHO1 | ENBL_RHO2 | ENBL_THETA;*/
int rfconf = ENBL_RHO1 + ENBL_THETA + ENBL_OMEGA + ENBL_OMEGA_FREQ_XTR1;
int ctlend = 0 ;
int ctlend_last = 0 ;
int ctlend_fill = 0 ;
int ctlend_unfill = 0 ;
int dda = 0 ;
int debug = PSD_OFF ;
int debugipg = PSD_OFF ;
int debugepc = PSD_OFF ;
int debugRecvFrqPhs= PSD_OFF ;
int debugdither = PSD_OFF ;
int debugdelay = PSD_OFF ;
int debugileave = PSD_OFF ; 
int dex = 0 ;
int gating = 0 ;
int ipg_trigtest = 1 ;
int gxktime = 0 ;
int gyktime = 0 ;
int gzktime = 0 ;
int gktime = 0 ;
int gkdelay = 100   ;

int   scanslot = 0 ;/*LX - 4 in epi2*/

/* temp crusher amplitudes */
float gx1_area = 0;                  /* readout dephaser pulse area */
float area_gz1 = 0, area_gzrf2l1 = 0; 
float area_std = 0;                   /* crusher calcs */

/* gradient echo refocus */
int avail_pwgz1 = 0;		/* avail time for gz1 pulse */

int   prescan1_tr = 2000000 ;
int   ps2_dda     =  0 ;
int   avail_pwgx1 = 0;               /* avail time for gx1 pulse */
int   avail_image_time = 0;          /* act_tr for norm scans*/
int   avail_zflow_time = 0;          /* time available for gz1, gzmn pulses */

int test_getecg = 1; 
int premid_rf90 = 0 ;

int sar_amp = 0;  /* debug variable for power monitor */
int sar_cycle = 0;
int sar_width = 0;
/*    min sequence times based on coil heating */
int   max_seqtime = 0;               /* nax time/slice for max av panel routines */
int   max_slicesar = 0;              /* min slices based on sar */
float myrloc = 0 ;
int   other_slice_limit = 0;         /* temp av panel value */

float target_area = 0;      /* temp area */
float start_amp = 0;       /* temp amp */
float end_amp = 0;         /* temp amp */

int pre_pass  = 0 ;
int nreps     = 0 ;
int max_num_pass = 512 ;

/* Scaling CVs */
float xmtaddScan = 0;

/* needed for Inversion.e */
float rfscale = 1.0 ;

/* Offset from end of excitation pulse to magnetic isocenter */
int rfExIso = 0;

/* Inner volume flag */
int innerVol = 0 ;
float ivslthick = 5 ;

/* These CVs are used to override the triggering scheme in testing. */
int psd_mantrig = 0 ;
int trig_mps2 = TRIG_LINE ;
int trig_aps2 = TRIG_LINE ;
int trig_scan = TRIG_LINE ;
int trig_prescan = TRIG_LINE ;
int read_truncate = 1 ;

int trigger_time = 0 ;
int use_myscan = 0 ;

/* needed for Inversion.e */
int t_postreadout = 0;

int initnewgeo = PSD_ON;     /* for initialization of obloptimize_epi in cvinit() */
int obl_debug = PSD_OFF ;
int obl_method = 1 ;
int debug_order = 0 ;
int debug_tdel = 0 ;
int debug_scan = 0 ;
int postsat = 0;
int order_routine = 0 ;
int scan_offset = 0;		 /* adds 'x' mm to all scan locations */

int dither_control = 0;		 /* 1 means turn dither on  */
int dither_value = 0 ;

int slquant_per_trig = 0 ;
int xtr_offset = -56 ;

int non_tetime = 0;                  /* time outside te time */
int slice_size = 0;                  /* bytes per slice */
int max_bamslice = 0;                /* max slices that can fit into bam */
int bw_rf1 = 0, bw_rf2 = 0;             /* bandwidth of rf pulses */

/* x dephaser attributes */
float a_gx1 = 0;
int ia_gx1 = 0;
int pw_gx1a = 0;
int pw_gx1d = 0;
int pw_gx1 = 0;
int single_ramp_gx1d = 0;      /* "bridge" decay ramp of gx1 into echo train */

/* y dephaser attributes */
float area_gy1 = 0;

/* Blip attributes */
float area_gyb = 0;

/* Omega Pulse Attributes */
float a_omega = 0;
int ia_omega = 0;

/* dummy pulse width */
int pw_dummy = 0;

float bline_time = 0;  /* time to play baseline acquistions */
float scan_time = 0;   /* time to play out scan (without burst recovery) */

int pw_gx1_tot = 0;
int pw_gy1_tot = 0;
int pw_gymn1_tot = 0, pw_gymn2_tot = 0;
float gyb_tot_0thmoment = 0;
float gyb_tot_1stmoment = 0;

int pw_gz1_tot = 0;
int pw_gzrf2l1_tot = 0;
int pw_gzrf2r1_tot = 0;

int ia_hyperdab=0;
int ia_hyperdabbl=0;

int dab_offset = 0;
int rcvr_ub_off = -100;  /* receiver unblank offset from beg of echo0000 packet */

int temprhfrsize = 0;

/* variables used in gradient moment nulling */
float zeromoment = 0;
float firstmoment = 0;
float zeromomentsum = 0;
float firstmomentsum = 0;
int pulsepos = 0;
int invertphase = 0;

float xtarg = 1.0 ;
float ytarg = 1.0 ;

/* slice reset - ability to perform multi-slice scans all at a single
   location.  Needed for testing. */
int slice_reset = 0 ;
float slice_loc = 0.0 ;

int ditheron = 1 ;
float dx = 0.0 ;
float dy = 0.0 ;
float dz = 0.0 ;

int b0calmode = 0 ;
int delayon = 1 ;

int pkt_delay = 0   ;
int   gxdelay = 0   ;
int   gydelay = 0   ;
float gldelayx = 0   ;
float gldelayy = 0   ;
float gldelayz = 0   ;
float pckeeppct = 100.0 ;

/* multi-phase */
int mph_flag = 0 ;
int acqmode = 0 ;
int max_phases  = 0;
int opslquant_old = 1 ;
int piphases  = 0;

/* echo spacing and gap */
int reqesp = 0 ;
int autogap = 0 ;
int minesp = 0;

/* reduced image size */
int fft_xsize = 0 ;
int fft_ysize = 0 ;
int image_size = 0 ;
             
/* off-center FOV control */
float xtr_rba_control = 1 ;
float xtr_rba_time = XTRSETLNG + XTR_TAIL ;
float frtime = 0.0 ;
int readpolar = 1 ;
int blippolar = 1 ;

/* ref scan control */
int ref_mode = 1 ;
int refnframes = 256 ;

/* ref correction */
/* This variable is pass to epiRecvFrqPhs() and enables/disables the freq offset in the */
/* receiver (to offset the FOV) for ref scanning */
int ref_with_xoffset = 1 ;
int RefDatCorrection = 0 ;
float phaseScale = 2.0 ;
int setDataAcqDelays = 1 ;
int xtr_calibration = 0 ;
int refSliceNum = -1 ;

/* Value1.5T May 2005 KK */
int ghost_check = 0 ;
int gck_offset_fov = 1 ;

int core_shots = 0;
int disdaq_shots = 0;
int pass_shots = 0;
int passr_shots = 0;
int pass_time = 0;    /* total time for pass packets */

int pw_gxwl1 = 0;
int pw_gxwl2 = 0;
int pw_gxwr1 = 0;
int pw_gxwr2 = 0;
int pw_gxw_total = 0 ;

int pass_delay = 1   ;

int nshots_locks  = 1 ;
int min_nshots = 1 ;

/* phase-encoding blip oblique correction (for oblique scan planes) cvs */
float da_gyboc = 0.0 ;
float oc_fact = 2.0 ;
int oblcorr_on = 1 ;

/* default oblcorr_perslice off because tgt sequence update times become
   prohibitively long when updating blip instruction amplitudes on a per-slice
   basis */
int oblcorr_perslice = 1 ;
int debug_oblcorr = 0 ;
float bc_delx = 0.0 ;
float bc_dely = 0.0 ;
float bc_delz = 0.0 ;
float percentBlipMod = 0.0;

int   cvxfull = MAX_PG_IAMP;
int   cvyfull = MAX_PG_IAMP;
int   cvzfull = MAX_PG_IAMP;

/* cvs for modified rbw annotation for vrgf */
float bw_flattop = 0;
float area_usedramp = 0;
float pw_usedramp = 0;
float area_usedtotal = 0;

/* Spec PSD Flag */
int epispec_flag = 0 ;

/* Omega Scale (8 bit shift = 256)*/
float omega_scale= 256.0 ;
int start_pulse = 0;

/* MRIge91983 - RDP - scan plane rotation CVs */
float my_alpha = 0.0 ;
float my_beta = 0 ;
float my_gamma = 0.0 ;

/* EXT TRIGGER */
int ext_trig = 0 ;

float rup_factor = 2.0; /* MRIhc19114: round factor for asset */

/* high patient weight */
int override_fatsat_high_weight = 0 ;
int bigpat_warning_flag = PSD_ON;

/* for DVw gradient test */
int epigradspec_flag = 0 ;
int dvw_grad_test = 0 ;

int fullk_nframes = 1;

/*jwg bb external rf cvs*/
/*for external RF pulses. All values will be overwritten*/
int   specspat_temp        = 1;
int   res_temp             = 320;
int   nom_pw_temp          = 1280;
float nom_flip_temp        = 90;
float abswidth_temp        = 0.32058;  
float effwidth_temp        = 0.21609;  
float area_temp            = 0.24701;  
float dtycyc_temp          = 0.39062;  
float maxpw_temp           = 1.0;  
float max_b1_temp          = 0.11607;  
float max_int_b1_sqr_temp  = 0.00596;  
float max_rms_b1_temp      = 0.05396;
float nom_bw_temp = 0; 
int   isodelay_temp = 0; 
float a_gzs_temp = 0;
float nom_thk_temp = 0;
int   extgradfile_temp = 0;
float nom_thk_rf1 = 0;
float target = 0;

int thetaflag = 0; /*jwg bb this is for phase modulation of RF pulse*/

/*for troubleshooting shift in PE direction*/
float phase_mod = 10.5 ;

/*for shifting the metabolites into the passband*/
float sw_freq = 0 ;
float sw = 0;

/*for user control of BW for ramp sampled EPI*/
int user_bw = 0;

/*for disabling internal reference etl, opuser24*/
int enable_iref_etl = 0;
/*enable vfa schemes, opuser25*/
int vfa_flag = 0;
/*enable SAKE schemes, opuser26*/
int sake_flag = 0;
int sake_max_blip = 1;
int rtime = 0, ftime = 0;

/*cvs for multi-frequency acquisition*/
float df1 = 0, df2 = 0, df3 = 0, df4 = 0, df5 = 0;
float df1_ppm = 0 ;
float df2_ppm = 12 ;
float df3_ppm = -8 ;
float df4_ppm = 8 ;
float df5_ppm = 6 ;
float met_ppm = 0;
int num_frames = 1;
int num_mets = 1;

/*CV for readout modulation*/
int wg_omegaro1 = TYPOMEGA;
/*jwg end*/

/* Define MRE CVs */
/* Start inline from touch.e TouchCV */
int touch_flag = PSD_OFF ;
float touch_target = 2.2 ;
int touch_rt = 4 ;
int touch_time = 0 ;
int touch_gnum = 1 ;
int touch_period = 0 ;
int touch_lobe = 0 ;
int touch_delta = 0 ;
float touch_act_freq = 60.0 ;
int touch_pwcon = 0 ;
int touch_pwramp = 0 ;
float touch_gdrate = 1.0 ;
float touch_gamp = 1.76 ;
float touch_gamp2 = -1 ;
int touch_xdir = PSD_OFF ;
int touch_ydir = PSD_OFF ;
int touch_zdir = PSD_OFF ;
int touch_burst_count = 60 ;
int touch_ndir = 2 ;
int touch_sync_pw = 50 ;
int touch_fcomp = 2 ;
float touch_menc = 0 ;
int touch_tr_time = 0 ;
int touch_driver_amp = 30 ;

int touch_period_motion = 0;
int touch_period_meg = 0; /* period of the motion and the MEG (us) */
int touch_lobe_motion = 0;
int touch_lobe_meg = 0; /* half-period of the motion and the MEG (us) */
float touch_act_freq_motion = 0;
float touch_act_freq_meg = 0; /* actual frequency of motion and MEG based on gradient resolution (Hz) */
int touch_pos_sync = 0;
int touch_pos_encode = 0;
int cont_drive_ssp_delay = 0; /* time shift (us) to use on SSP board when placing trigger pulses to help avoid overlapping other waveforms */

/*   multiphase variables added based what was in 120m4 gremre.e */
int multiphase_flag = 0 ;
int multi_phases = 1 ;

int rf2_time = 0;
int pw_gz2_tot = 0;
int M_half_periods = 0;
int meg_mode = 0; /* variables affecting MEGs around RF2 */
int grad_axis = 7; /* variables affecting which axes the MEGs are on */

int touch_maxshots = 1; /* max number of shots, currently only single shot EPI supported*/

/* End inline from touch.e TouchCV */


/****************************************************************************/


  int pw_x_td0 = 0;
  int wg_x_td0  = 0;


  int pw_y_td0 = 0;
  int wg_y_td0  = 0;


  int pw_z_td0 = 0;
  int wg_z_td0  = 0;


  int pw_rho_td0 = 0;
  int wg_rho_td0  = 0;


  int pw_theta_td0 = 0;
  int wg_theta_td0  = 0;


  int pw_omega_td0 = 0;
  int wg_omega_td0  = 0;


  int pw_ssp_td0 = 0;
  int wg_ssp_td0  = 0;


    float a_gzrf0 = 0;
    int ia_gzrf0 = 0;
    int pw_gzrf0a = 0;
    int pw_gzrf0d = 0;
    int pw_gzrf0 = 0;
    int res_gzrf0 = 0;
    float a_rf0 = 0;
    int ia_rf0 = 0;
    int pw_rf0 = 0;
    int res_rf0 = 0;
    float cyc_rf0 = 0;
    int off_rf0 = 0;
    float alpha_rf0 = 0.46;
    float thk_rf0 = 0;
    float gscale_rf0 = 1.0;
    float flip_rf0 = 0;
    int wg_rf0 = TYPRHO1 
;


  float a_omegarf0 = 0;
  int ia_omegarf0 = 0;
  int pw_omegarf0 = 0;
  int res_omegarf0 = 0;
  int off_omegarf0 = 0;
  int rfslot_omegarf0 = 0;

  float gscale_omegarf0 = 1.0;
  int n_omegarf0 = 0;
  int wg_omegarf0  = 0;


  float a_gyk0 = 0;
  int ia_gyk0 = 0;
  int pw_gyk0a = 0;
  int pw_gyk0d = 0;
  int pw_gyk0 = 0;
  int wg_gyk0  = 0;


    float a_gzrf1 = 0;
    int ia_gzrf1 = 0;
    int pw_gzrf1a = 0;
    int pw_gzrf1d = 0;
    int pw_gzrf1 = 0;
    int res_gzrf1 = 0;
    float a_rf1 = 0;
    int ia_rf1 = 0;
    int pw_rf1 = 0;
    int res_rf1 = 0;
    float cyc_rf1 = 0;
    int off_rf1 = 0;
    float alpha_rf1 = 0.46;
    float thk_rf1 = 0;
    float gscale_rf1 = 1.0;
    float flip_rf1 = 0;
    float a_thetarf1 = 0;
    int ia_thetarf1 = 0;
    int pw_thetarf1 = 0;
    int res_thetarf1 = 0;
    int off_thetarf1 = 0;
    int wg_rf1 = TYPRHO1 
;
    int wg_omegarf1 = TYPOMEGA;


  float a_phaserf1 = 0;
  int ia_phaserf1 = 0;
  int pw_phaserf1 = 0;
  int res_phaserf1 = 0;
  int off_phaserf1 = 0;
  int wg_phaserf1  = 0;


  float a_gzrf2 = 0;
  int ia_gzrf2 = 0;
  int pw_gzrf2a = 0;
  int pw_gzrf2d = 0;
  int pw_gzrf2 = 0;
  float a_rf2 = 0;
  int ia_rf2 = 0;
  int pw_rf2 = 0;
  int res_rf2 = 0;
  float cyc_rf2 = 0;
  int off_rf2 = 0;
  float alpha_rf2 = 0.46;
  float thk_rf2 = 0;
  float gscale_rf2 = 1.0;
  float flip_rf2 = 0;
  int wg_rf2 = TYPRHO1 
;


  int res_rf2se1b4 = 0;
  int wg_rf2se1b4  = 0;


  float a_gyrf2iv = 0;
  int ia_gyrf2iv = 0;
  int pw_gyrf2iva = 0;
  int pw_gyrf2ivd = 0;
  int pw_gyrf2iv = 0;
  int wg_gyrf2iv  = 0;


  float a_gzrf2l1 = 0;
  int ia_gzrf2l1 = 0;
  int pw_gzrf2l1a = 0;
  int pw_gzrf2l1d = 0;
  int pw_gzrf2l1 = 0;
  int wg_gzrf2l1  = 0;


  float a_gzrf2r1 = 0;
  int ia_gzrf2r1 = 0;
  int pw_gzrf2r1a = 0;
  int pw_gzrf2r1d = 0;
  int pw_gzrf2r1 = 0;
  int wg_gzrf2r1  = 0;


  float a_gxcl = 0;
  float a_gxw = 0;
  float a_gxcr = 0;
  float a_gyb = 0;
  int   ia_gxcl = 0;
  int   ia_gxw = 0;
  int   ia_gxcr = 0;
  int   ia_gyb = 0;
  int   pw_gxcla = 0;
  int   pw_gxcl = 0;
  int   pw_gxcld = 0;
  int   pw_gxwl = 0;
  int   pw_gxw = 0;
  int   pw_gxwr = 0;
  int   pw_gxwad = 0;
  int   pw_gxgap = 0;
  int   pw_gxcra = 0;
  int   pw_gxcr = 0;
  int   pw_gxcrd = 0;
  int   pw_gyba = 0;
  int   pw_gyb = 0;
  int   pw_gybd = 0;
  int   pw_iref_gxwait = 0; 


  int ia_rec_unblank = 0;


  int filter_rtb0echo = 0;


  int ia_rec_unblank2 = 0;

   


  float a_gy1 = 0;
  float a_gy1a = 0;
  float a_gy1b = 0;
  int ia_gy1 = 0;
  int ia_gy1wa = 0;
  int ia_gy1wb = 0;
  int pw_gy1a = 0;
  int pw_gy1d = 0;
  int pw_gy1 = 0;
  int wg_gy1  = 0;


  float a_gymn2 = 0;
  int ia_gymn2 = 0;
  int pw_gymn2a = 0;
  int pw_gymn2d = 0;
  int pw_gymn2 = 0;
  int wg_gymn2  = 0;


  float a_gymn1 = 0;
  int ia_gymn1 = 0;
  int pw_gymn1a = 0;
  int pw_gymn1d = 0;
  int pw_gymn1 = 0;
  int wg_gymn1  = 0;


  float a_gz1 = 0;
  int ia_gz1 = 0;
  int pw_gz1a = 0;
  int pw_gz1d = 0;
  int pw_gz1 = 0;
  int wg_gz1  = 0;


  float a_gzmn = 0;
  int ia_gzmn = 0;
  int pw_gzmna = 0;
  int pw_gzmnd = 0;
  int pw_gzmn = 0;
  int wg_gzmn  = 0;


  int res_rf2se1 = 0;
  int wg_rf2se1  = 0;


  float a_gxk = 0;
  int ia_gxk = 0;
  int pw_gxka = 0;
  int pw_gxkd = 0;
  int pw_gxk = 0;
  int wg_gxk  = 0;


  float a_gyk = 0;
  int ia_gyk = 0;
  int pw_gyka = 0;
  int pw_gykd = 0;
  int pw_gyk = 0;
  int wg_gyk  = 0;


  float a_gzk = 0;
  int ia_gzk = 0;
  int pw_gzka = 0;
  int pw_gzkd = 0;
  int pw_gzk = 0;
  int wg_gzk  = 0;


  int ia_sync_on_2 = 0;


  int ia_sync_off_2 = 0;


  int pw_wgx = 0;
  int wg_wgx  = 0;


  int pw_wgy = 0;
  int wg_wgy  = 0;


  int pw_wgz = 0;
  int wg_wgz  = 0;


  int pw_wssp = 0;
  int wg_wssp  = 0;


  int pw_sspdelay = 0;
  int wg_sspdelay  = 0;


  int pw_omegadelay = 0;
  int wg_omegadelay  = 0;


  int pw_womega = 0;
  int wg_womega  = 0;


  int pw_sspshift = 0;
  int wg_sspshift  = 0;


  int pw_ssp_pass_delay = 0;
  int wg_ssp_pass_delay  = 0;


  int pw_jwg_delay = 0;
  int wg_jwg_delay  = 0;


  int pw_touch_wssp = 0;
  int wg_touch_wssp  = 0;


  int ia_rec_unblankref = 0;


  float refa_gxcl = 0;
  float refa_gxw = 0;
  float refa_gxcr = 0;
  float refa_gyb = 0;
  int   refia_gxcl = 0;
  int   refia_gxw = 0;
  int   refia_gxcr = 0;
  int   refia_gyb = 0;
  int   refpw_gxcla = 0;
  int   refpw_gxcl = 0;
  int   refpw_gxcld = 0;
  int   refpw_gxwl = 0;
  int   refpw_gxw = 0;
  int   refpw_gxwr = 0;
  int   refpw_gxwad = 0;
  int   refpw_gxgap = 0;
  int   refpw_gxcra = 0;
  int   refpw_gxcr = 0;
  int   refpw_gxcrd = 0;
  int   refpw_gyba = 0;
  int   refpw_gyb = 0;
  int   refpw_gybd = 0;

   


  int ia_bline_unblank = 0;


  int filter_blineacq1 = 0;

   


  float a_gxtouchu2 = 0;
  int ia_gxtouchu2 = 0;
  int pw_gxtouchu2a = 0;
  int pw_gxtouchu2d = 0;
  int pw_gxtouchu2 = 0;
  int wg_gxtouchu2  = 0;


  float a_gytouchu2 = 0;
  int ia_gytouchu2 = 0;
  int pw_gytouchu2a = 0;
  int pw_gytouchu2d = 0;
  int pw_gytouchu2 = 0;
  int wg_gytouchu2  = 0;


  float a_gztouchu2 = 0;
  int ia_gztouchu2 = 0;
  int pw_gztouchu2a = 0;
  int pw_gztouchu2d = 0;
  int pw_gztouchu2 = 0;
  int wg_gztouchu2  = 0;


  float a_gxtouchu = 0;
  int ia_gxtouchu = 0;
  int pw_gxtouchua = 0;
  int pw_gxtouchud = 0;
  int pw_gxtouchu = 0;
  int wg_gxtouchu  = 0;


  float a_gytouchu = 0;
  int ia_gytouchu = 0;
  int pw_gytouchua = 0;
  int pw_gytouchud = 0;
  int pw_gytouchu = 0;
  int wg_gytouchu  = 0;


  float a_gztouchu = 0;
  int ia_gztouchu = 0;
  int pw_gztouchua = 0;
  int pw_gztouchud = 0;
  int pw_gztouchu = 0;
  int wg_gztouchu  = 0;


  float a_gxtouchd2 = 0;
  int ia_gxtouchd2 = 0;
  int pw_gxtouchd2a = 0;
  int pw_gxtouchd2d = 0;
  int pw_gxtouchd2 = 0;
  int wg_gxtouchd2  = 0;


  float a_gytouchd2 = 0;
  int ia_gytouchd2 = 0;
  int pw_gytouchd2a = 0;
  int pw_gytouchd2d = 0;
  int pw_gytouchd2 = 0;
  int wg_gytouchd2  = 0;


  float a_gztouchd2 = 0;
  int ia_gztouchd2 = 0;
  int pw_gztouchd2a = 0;
  int pw_gztouchd2d = 0;
  int pw_gztouchd2 = 0;
  int wg_gztouchd2  = 0;


  float a_gxtouchd = 0;
  int ia_gxtouchd = 0;
  int pw_gxtouchda = 0;
  int pw_gxtouchdd = 0;
  int pw_gxtouchd = 0;
  int wg_gxtouchd  = 0;


  float a_gytouchd = 0;
  int ia_gytouchd = 0;
  int pw_gytouchda = 0;
  int pw_gytouchdd = 0;
  int pw_gytouchd = 0;
  int wg_gytouchd  = 0;


  float a_gztouchd = 0;
  int ia_gztouchd = 0;
  int pw_gztouchda = 0;
  int pw_gztouchdd = 0;
  int pw_gztouchd = 0;
  int wg_gztouchd  = 0;


  float a_gxtouchf2 = 0;
  int ia_gxtouchf2 = 0;
  int pw_gxtouchf2a = 0;
  int pw_gxtouchf2d = 0;
  int pw_gxtouchf2 = 0;
  int wg_gxtouchf2  = 0;


  float a_gytouchf2 = 0;
  int ia_gytouchf2 = 0;
  int pw_gytouchf2a = 0;
  int pw_gytouchf2d = 0;
  int pw_gytouchf2 = 0;
  int wg_gytouchf2  = 0;


  float a_gztouchf2 = 0;
  int ia_gztouchf2 = 0;
  int pw_gztouchf2a = 0;
  int pw_gztouchf2d = 0;
  int pw_gztouchf2 = 0;
  int wg_gztouchf2  = 0;


  float a_gxtouchf = 0;
  int ia_gxtouchf = 0;
  int pw_gxtouchfa = 0;
  int pw_gxtouchfd = 0;
  int pw_gxtouchf = 0;
  int wg_gxtouchf  = 0;


  float a_gytouchf = 0;
  int ia_gytouchf = 0;
  int pw_gytouchfa = 0;
  int pw_gytouchfd = 0;
  int pw_gytouchf = 0;
  int wg_gytouchf  = 0;


  float a_gztouchf = 0;
  int ia_gztouchf = 0;
  int pw_gztouchfa = 0;
  int pw_gztouchfd = 0;
  int pw_gztouchf = 0;
  int wg_gztouchf  = 0;


  int res_rfcssat = 0;
  int wg_rfcssat  = 0;


  int res_omega_hs_rfcssat = 0;
  int wg_omega_hs_rfcssat  = 0;


  float a_gzrfcs = 0;
  int ia_gzrfcs = 0;
  int pw_gzrfcsa = 0;
  int pw_gzrfcsd = 0;
  int pw_gzrfcs = 0;
  int wg_gzrfcs  = 0;


  float a_gykcs = 0;
  int ia_gykcs = 0;
  int pw_gykcsa = 0;
  int pw_gykcsd = 0;
  int pw_gykcs = 0;
  int wg_gykcs  = 0;


  float a_gxkcs = 0;
  int ia_gxkcs = 0;
  int pw_gxkcsa = 0;
  int pw_gxkcsd = 0;
  int pw_gxkcs = 0;
  int wg_gxkcs  = 0;


  float a_gzkcs = 0;
  int ia_gzkcs = 0;
  int pw_gzkcsa = 0;
  int pw_gzkcsd = 0;
  int pw_gzkcs = 0;
  int wg_gzkcs  = 0;


  int pw_isi_cardiacsat = 0;
  int wg_isi_cardiacsat  = 0;


  int pw_rot_update_cardiacsat = 0;
  int wg_rot_update_cardiacsat  = 0;


  float a_gzrfse1 = 0;
  int ia_gzrfse1 = 0;
  int pw_gzrfse1a = 0;
  int pw_gzrfse1d = 0;
  int pw_gzrfse1 = 0;
  float a_rfse1 = 0;
  int ia_rfse1 = 0;
  int pw_rfse1 = 0;
  int res_rfse1 = 0;
  int temp_res_rfse1 = 0;
  float cyc_rfse1 = 0;
  int off_rfse1 = 0;
  float alpha_rfse1 = 0.46;
  float thk_rfse1 = 0;
  float gscale_rfse1 = 1.0;
  float flip_rfse1 = 0;
  int wg_rfse1 = TYPRHO1 
;


  int pw_isi_sate1 = 0;
  int wg_isi_sate1  = 0;


  int pw_rot_update_e1 = 0;
  int wg_rot_update_e1  = 0;


  float a_gykse1 = 0;
  int ia_gykse1 = 0;
  int pw_gykse1a = 0;
  int pw_gykse1d = 0;
  int pw_gykse1 = 0;
  int wg_gykse1  = 0;


  float a_gxkse1 = 0;
  int ia_gxkse1 = 0;
  int pw_gxkse1a = 0;
  int pw_gxkse1d = 0;
  int pw_gxkse1 = 0;
  int wg_gxkse1  = 0;


  int pw_isi_satek1 = 0;
  int wg_isi_satek1  = 0;


  int pw_rot_update_ek1 = 0;
  int wg_rot_update_ek1  = 0;


  float a_gzrfse2 = 0;
  int ia_gzrfse2 = 0;
  int pw_gzrfse2a = 0;
  int pw_gzrfse2d = 0;
  int pw_gzrfse2 = 0;
  float a_rfse2 = 0;
  int ia_rfse2 = 0;
  int pw_rfse2 = 0;
  int res_rfse2 = 0;
  int temp_res_rfse2 = 0;
  float cyc_rfse2 = 0;
  int off_rfse2 = 0;
  float alpha_rfse2 = 0.46;
  float thk_rfse2 = 0;
  float gscale_rfse2 = 1.0;
  float flip_rfse2 = 0;
  int wg_rfse2 = TYPRHO1 
;


  int pw_isi_sate2 = 0;
  int wg_isi_sate2  = 0;


  int pw_rot_update_e2 = 0;
  int wg_rot_update_e2  = 0;


  float a_gykse2 = 0;
  int ia_gykse2 = 0;
  int pw_gykse2a = 0;
  int pw_gykse2d = 0;
  int pw_gykse2 = 0;
  int wg_gykse2  = 0;


  float a_gxkse2 = 0;
  int ia_gxkse2 = 0;
  int pw_gxkse2a = 0;
  int pw_gxkse2d = 0;
  int pw_gxkse2 = 0;
  int wg_gxkse2  = 0;


  int pw_isi_satek2 = 0;
  int wg_isi_satek2  = 0;


  int pw_rot_update_ek2 = 0;
  int wg_rot_update_ek2  = 0;


  float a_gzrfse3 = 0;
  int ia_gzrfse3 = 0;
  int pw_gzrfse3a = 0;
  int pw_gzrfse3d = 0;
  int pw_gzrfse3 = 0;
  float a_rfse3 = 0;
  int ia_rfse3 = 0;
  int pw_rfse3 = 0;
  int res_rfse3 = 0;
  int temp_res_rfse3 = 0;
  float cyc_rfse3 = 0;
  int off_rfse3 = 0;
  float alpha_rfse3 = 0.46;
  float thk_rfse3 = 0;
  float gscale_rfse3 = 1.0;
  float flip_rfse3 = 0;
  int wg_rfse3 = TYPRHO1 
;


  int pw_isi_sate3 = 0;
  int wg_isi_sate3  = 0;


  int pw_rot_update_e3 = 0;
  int wg_rot_update_e3  = 0;


  float a_gykse3 = 0;
  int ia_gykse3 = 0;
  int pw_gykse3a = 0;
  int pw_gykse3d = 0;
  int pw_gykse3 = 0;
  int wg_gykse3  = 0;


  float a_gxkse3 = 0;
  int ia_gxkse3 = 0;
  int pw_gxkse3a = 0;
  int pw_gxkse3d = 0;
  int pw_gxkse3 = 0;
  int wg_gxkse3  = 0;


  int pw_isi_satek3 = 0;
  int wg_isi_satek3  = 0;


  int pw_rot_update_ek3 = 0;
  int wg_rot_update_ek3  = 0;


  float a_gzrfse4 = 0;
  int ia_gzrfse4 = 0;
  int pw_gzrfse4a = 0;
  int pw_gzrfse4d = 0;
  int pw_gzrfse4 = 0;
  float a_rfse4 = 0;
  int ia_rfse4 = 0;
  int pw_rfse4 = 0;
  int res_rfse4 = 0;
  int temp_res_rfse4 = 0;
  float cyc_rfse4 = 0;
  int off_rfse4 = 0;
  float alpha_rfse4 = 0.46;
  float thk_rfse4 = 0;
  float gscale_rfse4 = 1.0;
  float flip_rfse4 = 0;
  int wg_rfse4 = TYPRHO1 
;


  int pw_isi_sate4 = 0;
  int wg_isi_sate4  = 0;


  int pw_rot_update_e4 = 0;
  int wg_rot_update_e4  = 0;


  float a_gykse4 = 0;
  int ia_gykse4 = 0;
  int pw_gykse4a = 0;
  int pw_gykse4d = 0;
  int pw_gykse4 = 0;
  int wg_gykse4  = 0;


  float a_gxkse4 = 0;
  int ia_gxkse4 = 0;
  int pw_gxkse4a = 0;
  int pw_gxkse4d = 0;
  int pw_gxkse4 = 0;
  int wg_gxkse4  = 0;


  int pw_isi_satek4 = 0;
  int wg_isi_satek4  = 0;


  int pw_rot_update_ek4 = 0;
  int wg_rot_update_ek4  = 0;


  float a_gzrfse5 = 0;
  int ia_gzrfse5 = 0;
  int pw_gzrfse5a = 0;
  int pw_gzrfse5d = 0;
  int pw_gzrfse5 = 0;
  float a_rfse5 = 0;
  int ia_rfse5 = 0;
  int pw_rfse5 = 0;
  int res_rfse5 = 0;
  int temp_res_rfse5 = 0;
  float cyc_rfse5 = 0;
  int off_rfse5 = 0;
  float alpha_rfse5 = 0.46;
  float thk_rfse5 = 0;
  float gscale_rfse5 = 1.0;
  float flip_rfse5 = 0;
  int wg_rfse5 = TYPRHO1 
;


  int pw_isi_sate5 = 0;
  int wg_isi_sate5  = 0;


  int pw_rot_update_e5 = 0;
  int wg_rot_update_e5  = 0;


  float a_gykse5 = 0;
  int ia_gykse5 = 0;
  int pw_gykse5a = 0;
  int pw_gykse5d = 0;
  int pw_gykse5 = 0;
  int wg_gykse5  = 0;


  float a_gxkse5 = 0;
  int ia_gxkse5 = 0;
  int pw_gxkse5a = 0;
  int pw_gxkse5d = 0;
  int pw_gxkse5 = 0;
  int wg_gxkse5  = 0;


  int pw_isi_satek5 = 0;
  int wg_isi_satek5  = 0;


  int pw_rot_update_ek5 = 0;
  int wg_rot_update_ek5  = 0;


  float a_gzrfse6 = 0;
  int ia_gzrfse6 = 0;
  int pw_gzrfse6a = 0;
  int pw_gzrfse6d = 0;
  int pw_gzrfse6 = 0;
  float a_rfse6 = 0;
  int ia_rfse6 = 0;
  int pw_rfse6 = 0;
  int res_rfse6 = 0;
  int temp_res_rfse6 = 0;
  float cyc_rfse6 = 0;
  int off_rfse6 = 0;
  float alpha_rfse6 = 0.46;
  float thk_rfse6 = 0;
  float gscale_rfse6 = 1.0;
  float flip_rfse6 = 0;
  int wg_rfse6 = TYPRHO1 
;


  int pw_isi_sate6 = 0;
  int wg_isi_sate6  = 0;


  int pw_rot_update_e6 = 0;
  int wg_rot_update_e6  = 0;


  float a_gykse6 = 0;
  int ia_gykse6 = 0;
  int pw_gykse6a = 0;
  int pw_gykse6d = 0;
  int pw_gykse6 = 0;
  int wg_gykse6  = 0;


  float a_gxkse6 = 0;
  int ia_gxkse6 = 0;
  int pw_gxkse6a = 0;
  int pw_gxkse6d = 0;
  int pw_gxkse6 = 0;
  int wg_gxkse6  = 0;


  int pw_isi_satek6 = 0;
  int wg_isi_satek6  = 0;


  int pw_rot_update_ek6 = 0;
  int wg_rot_update_ek6  = 0;


  float a_gxrfsx1 = 0;
  int ia_gxrfsx1 = 0;
  int pw_gxrfsx1a = 0;
  int pw_gxrfsx1d = 0;
  int pw_gxrfsx1 = 0;
  float a_rfsx1 = 0;
  int ia_rfsx1 = 0;
  int pw_rfsx1 = 0;
  int res_rfsx1 = 0;
  int temp_res_rfsx1 = 0;
  float cyc_rfsx1 = 0;
  int off_rfsx1 = 0;
  float alpha_rfsx1 = 0.46;
  float gscale_rfsx1 = 1.0;
  float thk_rfsx1 = 0;
  float flip_rfsx1 = 0;
  int wg_rfsx1 = TYPRHO1 
;


  int pw_isi_satx1 = 0;
  int wg_isi_satx1  = 0;


  int pw_rot_update_x1 = 0;
  int wg_rot_update_x1  = 0;


  float a_gyksx1 = 0;
  int ia_gyksx1 = 0;
  int pw_gyksx1a = 0;
  int pw_gyksx1d = 0;
  int pw_gyksx1 = 0;
  int wg_gyksx1  = 0;


  float a_gxksx1 = 0;
  int ia_gxksx1 = 0;
  int pw_gxksx1a = 0;
  int pw_gxksx1d = 0;
  int pw_gxksx1 = 0;
  int wg_gxksx1  = 0;


  int pw_isi_satxk1 = 0;
  int wg_isi_satxk1  = 0;


  int pw_rot_update_xk1 = 0;
  int wg_rot_update_xk1  = 0;


  float a_gxrfsx2 = 0;
  int ia_gxrfsx2 = 0;
  int pw_gxrfsx2a = 0;
  int pw_gxrfsx2d = 0;
  int pw_gxrfsx2 = 0;
  float a_rfsx2 = 0;
  int ia_rfsx2 = 0;
  int pw_rfsx2 = 0;
  int res_rfsx2 = 0;
  int temp_res_rfsx2 = 0;
  float cyc_rfsx2 = 0;
  int off_rfsx2 = 0;
  float alpha_rfsx2 = 0.46;
  float gscale_rfsx2 = 1.0;
  float thk_rfsx2 = 0;
  float flip_rfsx2 = 0;
  int wg_rfsx2 = TYPRHO1 
;


  int pw_isi_satx2 = 0;
  int wg_isi_satx2  = 0;


  int pw_rot_update_x2 = 0;
  int wg_rot_update_x2  = 0;


  float a_gyksx2 = 0;
  int ia_gyksx2 = 0;
  int pw_gyksx2a = 0;
  int pw_gyksx2d = 0;
  int pw_gyksx2 = 0;
  int wg_gyksx2  = 0;


  float a_gxksx2 = 0;
  int ia_gxksx2 = 0;
  int pw_gxksx2a = 0;
  int pw_gxksx2d = 0;
  int pw_gxksx2 = 0;
  int wg_gxksx2  = 0;


  int pw_isi_satxk2 = 0;
  int wg_isi_satxk2  = 0;


  int pw_rot_update_xk2 = 0;
  int wg_rot_update_xk2  = 0;


  float a_gyrfsy1 = 0;
  int ia_gyrfsy1 = 0;
  int pw_gyrfsy1a = 0;
  int pw_gyrfsy1d = 0;
  int pw_gyrfsy1 = 0;
  float a_rfsy1 = 0;
  int ia_rfsy1 = 0;
  int pw_rfsy1 = 0;
  int res_rfsy1 = 0;
  int temp_res_rfsy1 = 0;
  float cyc_rfsy1 = 0;
  int off_rfsy1 = 0;
  float alpha_rfsy1 = 0.46;
  float thk_rfsy1 = 0;
  float gscale_rfsy1 = 1.0;
  float flip_rfsy1 = 0;
  int wg_rfsy1 = TYPRHO1 
;


  int pw_isi_saty1 = 0;
  int wg_isi_saty1  = 0;


  int pw_rot_update_y1 = 0;
  int wg_rot_update_y1  = 0;


  float a_gyksy1 = 0;
  int ia_gyksy1 = 0;
  int pw_gyksy1a = 0;
  int pw_gyksy1d = 0;
  int pw_gyksy1 = 0;
  int wg_gyksy1  = 0;


  float a_gxksy1 = 0;
  int ia_gxksy1 = 0;
  int pw_gxksy1a = 0;
  int pw_gxksy1d = 0;
  int pw_gxksy1 = 0;
  int wg_gxksy1  = 0;


  int pw_isi_satyk1 = 0;
  int wg_isi_satyk1  = 0;


  int pw_rot_update_yk1 = 0;
  int wg_rot_update_yk1  = 0;


  float a_gyrfsy2 = 0;
  int ia_gyrfsy2 = 0;
  int pw_gyrfsy2a = 0;
  int pw_gyrfsy2d = 0;
  int pw_gyrfsy2 = 0;
  float a_rfsy2 = 0;
  int ia_rfsy2 = 0;
  int pw_rfsy2 = 0;
  int res_rfsy2 = 0;
  int temp_res_rfsy2 = 0;
  float cyc_rfsy2 = 0;
  int off_rfsy2 = 0;
  float alpha_rfsy2 = 0.46;
  float thk_rfsy2 = 0;
  float gscale_rfsy2 = 1.0;
  float flip_rfsy2 = 0;
  int wg_rfsy2 = TYPRHO1 
;


  int pw_isi_saty2 = 0;
  int wg_isi_saty2  = 0;


  int pw_rot_update_y2 = 0;
  int wg_rot_update_y2  = 0;


  float a_gyksy2 = 0;
  int ia_gyksy2 = 0;
  int pw_gyksy2a = 0;
  int pw_gyksy2d = 0;
  int pw_gyksy2 = 0;
  int wg_gyksy2  = 0;


  float a_gxksy2 = 0;
  int ia_gxksy2 = 0;
  int pw_gxksy2a = 0;
  int pw_gxksy2d = 0;
  int pw_gxksy2 = 0;
  int wg_gxksy2  = 0;


  int pw_isi_satyk2 = 0;
  int wg_isi_satyk2  = 0;


  int pw_rot_update_yk2 = 0;
  int wg_rot_update_yk2  = 0;


  float a_gzrfsz1 = 0;
  int ia_gzrfsz1 = 0;
  int pw_gzrfsz1a = 0;
  int pw_gzrfsz1d = 0;
  int pw_gzrfsz1 = 0;
  float a_rfsz1 = 0;
  int ia_rfsz1 = 0;
  int pw_rfsz1 = 0;
  int res_rfsz1 = 0;
  int temp_res_rfsz1 = 0;
  float cyc_rfsz1 = 0;
  int off_rfsz1 = 0;
  float alpha_rfsz1 = 0.46;
  float thk_rfsz1 = 0;
  float gscale_rfsz1 = 1.0;
  float flip_rfsz1 = 0;
  int wg_rfsz1 = TYPRHO1 
;


  int pw_isi_satz1 = 0;
  int wg_isi_satz1  = 0;


  int pw_rot_update_z1 = 0;
  int wg_rot_update_z1  = 0;


  float a_gyksz1 = 0;
  int ia_gyksz1 = 0;
  int pw_gyksz1a = 0;
  int pw_gyksz1d = 0;
  int pw_gyksz1 = 0;
  int wg_gyksz1  = 0;


  float a_gxksz1 = 0;
  int ia_gxksz1 = 0;
  int pw_gxksz1a = 0;
  int pw_gxksz1d = 0;
  int pw_gxksz1 = 0;
  int wg_gxksz1  = 0;


  int pw_isi_satzk1 = 0;
  int wg_isi_satzk1  = 0;


  int pw_rot_update_zk1 = 0;
  int wg_rot_update_zk1  = 0;


  float a_gzrfsz2 = 0;
  int ia_gzrfsz2 = 0;
  int pw_gzrfsz2a = 0;
  int pw_gzrfsz2d = 0;
  int pw_gzrfsz2 = 0;
  float a_rfsz2 = 0;
  int ia_rfsz2 = 0;
  int pw_rfsz2 = 0;
  int res_rfsz2 = 0;
  int temp_res_rfsz2 = 0;
  float cyc_rfsz2 = 0;
  int off_rfsz2 = 0;
  float alpha_rfsz2 = 0.46;
  float thk_rfsz2 = 0;
  float gscale_rfsz2 = 1.0;
  float flip_rfsz2 = 0;
  int wg_rfsz2 = TYPRHO1 
;


  int pw_isi_satz2 = 0;
  int wg_isi_satz2  = 0;


  int pw_rot_update_z2 = 0;
  int wg_rot_update_z2  = 0;


  float a_gyksz2 = 0;
  int ia_gyksz2 = 0;
  int pw_gyksz2a = 0;
  int pw_gyksz2d = 0;
  int pw_gyksz2 = 0;
  int wg_gyksz2  = 0;


  float a_gxksz2 = 0;
  int ia_gxksz2 = 0;
  int pw_gxksz2a = 0;
  int pw_gxksz2d = 0;
  int pw_gxksz2 = 0;
  int wg_gxksz2  = 0;


  int pw_isi_satzk2 = 0;
  int wg_isi_satzk2  = 0;


  int pw_rot_update_zk2 = 0;
  int wg_rot_update_zk2  = 0;


  int pw_y_ccs_null = 0;
  int wg_y_ccs_null  = 0;


  float a_gzrf1mps1 = 0;
  int ia_gzrf1mps1 = 0;
  int pw_gzrf1mps1a = 0;
  int pw_gzrf1mps1d = 0;
  int pw_gzrf1mps1 = 0;
  float a_rf1mps1 = 0;
  int ia_rf1mps1 = 0;
  int pw_rf1mps1 = 0;
  int res_rf1mps1 = 0;
  int temp_res_rf1mps1 = 0;
  float cyc_rf1mps1 = 0;
  int off_rf1mps1 = 0;
  float alpha_rf1mps1 = 0.46;
  float thk_rf1mps1 = 0;
  float gscale_rf1mps1 = 1.0;
  float flip_rf1mps1 = 0;
  int wg_rf1mps1 = TYPRHO1 
;


  float a_gz1mps1 = 0;
  int ia_gz1mps1 = 0;
  int pw_gz1mps1a = 0;
  int pw_gz1mps1d = 0;
  int pw_gz1mps1 = 0;
  int wg_gz1mps1  = 0;


  float a_gx1mps1 = 0;
  int ia_gx1mps1 = 0;
  int pw_gx1mps1a = 0;
  int pw_gx1mps1d = 0;
  int pw_gx1mps1 = 0;
  int wg_gx1mps1  = 0;


  float a_gzrf2mps1 = 0;
  int ia_gzrf2mps1 = 0;
  int pw_gzrf2mps1a = 0;
  int pw_gzrf2mps1d = 0;
  int pw_gzrf2mps1 = 0;
  float a_rf2mps1 = 0;
  int ia_rf2mps1 = 0;
  int pw_rf2mps1 = 0;
  int res_rf2mps1 = 0;
  int temp_res_rf2mps1 = 0;
  float cyc_rf2mps1 = 0;
  int off_rf2mps1 = 0;
  float alpha_rf2mps1 = 0.46;
  float thk_rf2mps1 = 0;
  float gscale_rf2mps1 = 1.0;
  float flip_rf2mps1 = 0;
  int wg_rf2mps1 = TYPRHO1 
;


  float a_gzrf2lmps1 = 0;
  int ia_gzrf2lmps1 = 0;
  int pw_gzrf2lmps1a = 0;
  int pw_gzrf2lmps1d = 0;
  int pw_gzrf2lmps1 = 0;
  int wg_gzrf2lmps1  = 0;


  float a_gzrf2rmps1 = 0;
  int ia_gzrf2rmps1 = 0;
  int pw_gzrf2rmps1a = 0;
  int pw_gzrf2rmps1d = 0;
  int pw_gzrf2rmps1 = 0;
  int wg_gzrf2rmps1  = 0;


  float a_gxwmps1 = 0;
  int ia_gxwmps1 = 0;
  int pw_gxwmps1a = 0;
  int pw_gxwmps1d = 0;
  int pw_gxwmps1 = 0;
  int wg_gxwmps1  = 0;


  int filter_echo1mps1 = 0;


  float a_gzrf1cfl = 0;
  int ia_gzrf1cfl = 0;
  int pw_gzrf1cfla = 0;
  int pw_gzrf1cfld = 0;
  int pw_gzrf1cfl = 0;
  float a_rf1cfl = 0;
  int ia_rf1cfl = 0;
  int pw_rf1cfl = 0;
  int res_rf1cfl = 0;
  int temp_res_rf1cfl = 0;
  float cyc_rf1cfl = 0;
  int off_rf1cfl = 0;
  float alpha_rf1cfl = 0.46;
  float thk_rf1cfl = 0;
  float gscale_rf1cfl = 1.0;
  float flip_rf1cfl = 0;
  int wg_rf1cfl = TYPRHO1 
;


  float a_gz1cfl = 0;
  int ia_gz1cfl = 0;
  int pw_gz1cfla = 0;
  int pw_gz1cfld = 0;
  int pw_gz1cfl = 0;
  int wg_gz1cfl  = 0;


  int filter_cfl_fid = 0;


  float a_gykcfl = 0;
  int ia_gykcfl = 0;
  int pw_gykcfla = 0;
  int pw_gykcfld = 0;
  int pw_gykcfl = 0;
  int wg_gykcfl  = 0;


  float a_gxkrcvn = 0;
  int ia_gxkrcvn = 0;
  int pw_gxkrcvna = 0;
  int pw_gxkrcvnd = 0;
  int pw_gxkrcvn = 0;
  int wg_gxkrcvn  = 0;


  float a_gykrcvn = 0;
  int ia_gykrcvn = 0;
  int pw_gykrcvna = 0;
  int pw_gykrcvnd = 0;
  int pw_gykrcvn = 0;
  int wg_gykrcvn  = 0;


  float a_gzkrcvn = 0;
  int ia_gzkrcvn = 0;
  int pw_gzkrcvna = 0;
  int pw_gzkrcvnd = 0;
  int pw_gzkrcvn = 0;
  int wg_gzkrcvn  = 0;


  int pw_rcvn_wait = 0;
  int wg_rcvn_wait  = 0;


  int ia_rcvrbl = 0;


  int filter_rcvn_fid = 0;


  int ia_rcvrbl2 = 0;


  float a_gzrf0cfh = 0;
  int ia_gzrf0cfh = 0;
  int pw_gzrf0cfha = 0;
  int pw_gzrf0cfhd = 0;
  int pw_gzrf0cfh = 0;
  int res_gzrf0cfh = 0;
  float a_rf0cfh = 0;
  int ia_rf0cfh = 0;
  int pw_rf0cfh = 0;
  int res_rf0cfh = 0;
  float cyc_rf0cfh = 0;
  int off_rf0cfh = 0;
  float alpha_rf0cfh = 0.46;
  float thk_rf0cfh = 0;
  float gscale_rf0cfh = 1.0;
  float flip_rf0cfh = 0;
  int wg_rf0cfh = TYPRHO1 
;


  float a_omegarf0cfh = 0;
  int ia_omegarf0cfh = 0;
  int pw_omegarf0cfh = 0;
  int res_omegarf0cfh = 0;
  int off_omegarf0cfh = 0;
  int rfslot_omegarf0cfh = 0;

  float gscale_omegarf0cfh = 1.0;
  int n_omegarf0cfh = 0;
  int wg_omegarf0cfh  = 0;


  float a_gyrf0kcfh = 0;
  int ia_gyrf0kcfh = 0;
  int pw_gyrf0kcfha = 0;
  int pw_gyrf0kcfhd = 0;
  int pw_gyrf0kcfh = 0;
  int wg_gyrf0kcfh  = 0;


  int pw_zticfh = 0;
  int wg_zticfh  = 0;


  int pw_rticfh = 0;
  int wg_rticfh  = 0;


  int pw_xticfh = 0;
  int wg_xticfh  = 0;


  int pw_yticfh = 0;
  int wg_yticfh  = 0;


  int pw_sticfh = 0;
  int wg_sticfh  = 0;


  float a_gzrf1cfh = 0;
  int ia_gzrf1cfh = 0;
  int pw_gzrf1cfha = 0;
  int pw_gzrf1cfhd = 0;
  int pw_gzrf1cfh = 0;
  float a_rf1cfh = 0;
  int ia_rf1cfh = 0;
  int pw_rf1cfh = 0;
  int res_rf1cfh = 0;
  int temp_res_rf1cfh = 0;
  float cyc_rf1cfh = 0;
  int off_rf1cfh = 0;
  float alpha_rf1cfh = 0.46;
  float thk_rf1cfh = 0;
  float gscale_rf1cfh = 1.0;
  float flip_rf1cfh = 0;
  int wg_rf1cfh = TYPRHO1 
;


  float a_rf2cfh = 0;
  int ia_rf2cfh = 0;
  int pw_rf2cfh = 0;
  int res_rf2cfh = 0;
  float cyc_rf2cfh = 0;
  int off_rf2cfh = 0;
  float alpha_rf2cfh = 0;
  int wg_rf2cfh  = 0;


  float a_rf3cfh = 0;
  int ia_rf3cfh = 0;
  int pw_rf3cfh = 0;
  int res_rf3cfh = 0;
  float cyc_rf3cfh = 0;
  int off_rf3cfh = 0;
  float alpha_rf3cfh = 0;
  int wg_rf3cfh  = 0;


  float a_gxrf2cfh = 0;
  int ia_gxrf2cfh = 0;
  int pw_gxrf2cfha = 0;
  int pw_gxrf2cfhd = 0;
  int pw_gxrf2cfh = 0;
  int wg_gxrf2cfh  = 0;


  float a_gyrf2cfh = 0;
  int ia_gyrf2cfh = 0;
  int pw_gyrf2cfha = 0;
  int pw_gyrf2cfhd = 0;
  int pw_gyrf2cfh = 0;
  int wg_gyrf2cfh  = 0;


  float a_gzrf2lcfh = 0;
  int ia_gzrf2lcfh = 0;
  int pw_gzrf2lcfha = 0;
  int pw_gzrf2lcfhd = 0;
  int pw_gzrf2lcfh = 0;
  int wg_gzrf2lcfh  = 0;


  float a_gzrf2rcfh = 0;
  int ia_gzrf2rcfh = 0;
  int pw_gzrf2rcfha = 0;
  int pw_gzrf2rcfhd = 0;
  int pw_gzrf2rcfh = 0;
  int wg_gzrf2rcfh  = 0;


  float a_gyrf3cfh = 0;
  int ia_gyrf3cfh = 0;
  int pw_gyrf3cfha = 0;
  int pw_gyrf3cfhd = 0;
  int pw_gyrf3cfh = 0;
  int wg_gyrf3cfh  = 0;


  float a_gzrf3lcfh = 0;
  int ia_gzrf3lcfh = 0;
  int pw_gzrf3lcfha = 0;
  int pw_gzrf3lcfhd = 0;
  int pw_gzrf3lcfh = 0;
  int wg_gzrf3lcfh  = 0;


  float a_gzrf3rcfh = 0;
  int ia_gzrf3rcfh = 0;
  int pw_gzrf3rcfha = 0;
  int pw_gzrf3rcfhd = 0;
  int pw_gzrf3rcfh = 0;
  int wg_gzrf3rcfh  = 0;


  float a_gy1cfh = 0;
  int ia_gy1cfh = 0;
  int pw_gy1cfha = 0;
  int pw_gy1cfhd = 0;
  int pw_gy1cfh = 0;
  int wg_gy1cfh  = 0;


  float a_gx1cfh = 0;
  int ia_gx1cfh = 0;
  int pw_gx1cfha = 0;
  int pw_gx1cfhd = 0;
  int pw_gx1cfh = 0;
  int wg_gx1cfh  = 0;


  int filter_cfh_fid = 0;


  float a_gykcfh = 0;
  int ia_gykcfh = 0;
  int pw_gykcfha = 0;
  int pw_gykcfhd = 0;
  int pw_gykcfh = 0;
  int wg_gykcfh  = 0;


  int ia_contrfhubsel = 0;


  int ia_contrfsel = 0;


  int pw_csw_wait = 0;
  int wg_csw_wait  = 0;


  float a_gzrf1ftg = 0;
  int ia_gzrf1ftg = 0;
  int pw_gzrf1ftga = 0;
  int pw_gzrf1ftgd = 0;
  int pw_gzrf1ftg = 0;
  float a_rf1ftg = 0;
  int ia_rf1ftg = 0;
  int pw_rf1ftg = 0;
  int res_rf1ftg = 0;
  int temp_res_rf1ftg = 0;
  float cyc_rf1ftg = 0;
  int off_rf1ftg = 0;
  float alpha_rf1ftg = 0.46;
  float thk_rf1ftg = 0;
  float gscale_rf1ftg = 1.0;
  float flip_rf1ftg = 0;
  int wg_rf1ftg = TYPRHO1 
;


  float a_gz1ftg = 0;
  int ia_gz1ftg = 0;
  int pw_gz1ftga = 0;
  int pw_gz1ftgd = 0;
  int pw_gz1ftg = 0;
  int wg_gz1ftg  = 0;


  float a_gzrf2ftg = 0;
  int ia_gzrf2ftg = 0;
  int pw_gzrf2ftga = 0;
  int pw_gzrf2ftgd = 0;
  int pw_gzrf2ftg = 0;
  float a_rf2ftg = 0;
  int ia_rf2ftg = 0;
  int pw_rf2ftg = 0;
  int res_rf2ftg = 0;
  int temp_res_rf2ftg = 0;
  float cyc_rf2ftg = 0;
  int off_rf2ftg = 0;
  float alpha_rf2ftg = 0.46;
  float thk_rf2ftg = 0;
  float gscale_rf2ftg = 1.0;
  float flip_rf2ftg = 0;
  int wg_rf2ftg = TYPRHO1 
;


  float a_gz2ftg = 0;
  int ia_gz2ftg = 0;
  int pw_gz2ftga = 0;
  int pw_gz2ftgd = 0;
  int pw_gz2ftg = 0;
  int wg_gz2ftg  = 0;


  float a_gzrf3ftg = 0;
  int ia_gzrf3ftg = 0;
  int pw_gzrf3ftga = 0;
  int pw_gzrf3ftgd = 0;
  int pw_gzrf3ftg = 0;
  float a_rf3ftg = 0;
  int ia_rf3ftg = 0;
  int pw_rf3ftg = 0;
  int res_rf3ftg = 0;
  int temp_res_rf3ftg = 0;
  float cyc_rf3ftg = 0;
  int off_rf3ftg = 0;
  float alpha_rf3ftg = 0.46;
  float thk_rf3ftg = 0;
  float gscale_rf3ftg = 1.0;
  float flip_rf3ftg = 0;
  int wg_rf3ftg = TYPRHO1 
;


  float a_gz3ftg = 0;
  int ia_gz3ftg = 0;
  int pw_gz3ftga = 0;
  int pw_gz3ftgd = 0;
  int pw_gz3ftg = 0;
  int wg_gz3ftg  = 0;


  float a_gx1ftg = 0;
  int ia_gx1ftg = 0;
  int pw_gx1ftga = 0;
  int pw_gx1ftgd = 0;
  int pw_gx1ftg = 0;
  int wg_gx1ftg  = 0;


  float a_gx1bftg = 0;
  int ia_gx1bftg = 0;
  int pw_gx1bftga = 0;
  int pw_gx1bftgd = 0;
  int pw_gx1bftg = 0;
  int wg_gx1bftg  = 0;


  float a_gxw1ftg = 0;
  int ia_gxw1ftg = 0;
  int pw_gxw1ftga = 0;
  int pw_gxw1ftgd = 0;
  int pw_gxw1ftg = 0;
  int wg_gxw1ftg  = 0;


  float a_postgxw1ftg = 0;
  int ia_postgxw1ftg = 0;
  int pw_postgxw1ftga = 0;
  int pw_postgxw1ftgd = 0;
  int pw_postgxw1ftg = 0;
  int wg_postgxw1ftg  = 0;


  int filter_echo1ftg = 0;


  float a_gz2bftg = 0;
  int ia_gz2bftg = 0;
  int pw_gz2bftga = 0;
  int pw_gz2bftgd = 0;
  int pw_gz2bftg = 0;
  int wg_gz2bftg  = 0;


  float a_gx2ftg = 0;
  int ia_gx2ftg = 0;
  int pw_gx2ftga = 0;
  int pw_gx2ftgd = 0;
  int pw_gx2ftg = 0;
  int wg_gx2ftg  = 0;


  float a_gxw2ftg = 0;
  int ia_gxw2ftg = 0;
  int pw_gxw2ftga = 0;
  int pw_gxw2ftgd = 0;
  int pw_gxw2ftg = 0;
  int wg_gxw2ftg  = 0;


  float a_gx2test = 0;
  int ia_gx2test = 0;
  int pw_gx2testa = 0;
  int pw_gx2testd = 0;
  int pw_gx2test = 0;
  int wg_gx2test  = 0;


  int filter_echo2ftg = 0;


  float a_gzrf1xtg = 0;
  int ia_gzrf1xtg = 0;
  int pw_gzrf1xtga = 0;
  int pw_gzrf1xtgd = 0;
  int pw_gzrf1xtg = 0;
  float a_rf1xtg = 0;
  int ia_rf1xtg = 0;
  int pw_rf1xtg = 0;
  int res_rf1xtg = 0;
  int temp_res_rf1xtg = 0;
  float cyc_rf1xtg = 0;
  int off_rf1xtg = 0;
  float alpha_rf1xtg = 0.46;
  float thk_rf1xtg = 0;
  float gscale_rf1xtg = 1.0;
  float flip_rf1xtg = 0;
  int wg_rf1xtg = TYPRHO1 
;


  float a_gykxtgl = 0;
  int ia_gykxtgl = 0;
  int pw_gykxtgla = 0;
  int pw_gykxtgld = 0;
  int pw_gykxtgl = 0;
  int wg_gykxtgl  = 0;


       /* off-res B1 prep pulse */
       float a_rf3xtg = 0;
       int ia_rf3xtg = 0;
       int pw_rf3xtg = 0;
       int res_rf3xtg = 0;
       int off_rf3xtg = 0;
       float alpha_rf3xtg = 0.46;
       float gscale_rf3xtg = 1.0;
       float flip_rf3xtg = 0;
       int ia_phs_rf3xtg = 0;
       int wg_rf3xtg = TYPRHO1 
;


  float a_gz1xtg = 0;
  int ia_gz1xtg = 0;
  int pw_gz1xtga = 0;
  int pw_gz1xtgd = 0;
  int pw_gz1xtg = 0;
  int wg_gz1xtg  = 0;


  float a_gzrf2xtg = 0;
  int ia_gzrf2xtg = 0;
  int pw_gzrf2xtga = 0;
  int pw_gzrf2xtgd = 0;
  int pw_gzrf2xtg = 0;
  float a_rf2xtg = 0;
  int ia_rf2xtg = 0;
  int pw_rf2xtg = 0;
  int res_rf2xtg = 0;
  int temp_res_rf2xtg = 0;
  float cyc_rf2xtg = 0;
  int off_rf2xtg = 0;
  float alpha_rf2xtg = 0.46;
  float thk_rf2xtg = 0;
  float gscale_rf2xtg = 1.0;
  float flip_rf2xtg = 0;
  int wg_rf2xtg = TYPRHO1 
;


  float a_gz2xtg = 0;
  int ia_gz2xtg = 0;
  int pw_gz2xtga = 0;
  int pw_gz2xtgd = 0;
  int pw_gz2xtg = 0;
  int wg_gz2xtg  = 0;


       /* off-res B1 prep pulse */
       float a_rf4xtg = 0;
       int ia_rf4xtg = 0;
       int pw_rf4xtg = 0;
       int res_rf4xtg = 0;
       int off_rf4xtg = 0;
       float alpha_rf4xtg = 0.46;
       float gscale_rf4xtg = 1.0;
       float flip_rf4xtg = 0;
       int ia_phs_rf4xtg = 0;
       int wg_rf4xtg = TYPRHO1 
;


  float a_gykxtgr = 0;
  int ia_gykxtgr = 0;
  int pw_gykxtgra = 0;
  int pw_gykxtgrd = 0;
  int pw_gykxtgr = 0;
  int wg_gykxtgr  = 0;


  float a_gx1bxtg = 0;
  int ia_gx1bxtg = 0;
  int pw_gx1bxtga = 0;
  int pw_gx1bxtgd = 0;
  int pw_gx1bxtg = 0;
  int wg_gx1bxtg  = 0;


  float a_gxw1xtg = 0;
  int ia_gxw1xtg = 0;
  int pw_gxw1xtga = 0;
  int pw_gxw1xtgd = 0;
  int pw_gxw1xtg = 0;
  int wg_gxw1xtg  = 0;


  int filter_echo1xtg = 0;


  float a_gzrf1as = 0;
  int ia_gzrf1as = 0;
  int pw_gzrf1asa = 0;
  int pw_gzrf1asd = 0;
  int pw_gzrf1as = 0;
  float a_rf1as = 0;
  int ia_rf1as = 0;
  int pw_rf1as = 0;
  int res_rf1as = 0;
  int temp_res_rf1as = 0;
  float cyc_rf1as = 0;
  int off_rf1as = 0;
  float alpha_rf1as = 0.46;
  float thk_rf1as = 0;
  float gscale_rf1as = 1.0;
  float flip_rf1as = 0;
  int wg_rf1as = TYPRHO1 
;


  float a_gz1as = 0;
  int ia_gz1as = 0;
  int pw_gz1asa = 0;
  int pw_gz1asd = 0;
  int pw_gz1as = 0;
  int wg_gz1as  = 0;


  float a_gxwas = 0;
  int ia_gxwas = 0;
  int pw_gxwasa = 0;
  int pw_gxwasd = 0;
  int pw_gxwas = 0;
  int wg_gxwas  = 0;


  int filter_echo1as = 0;


  float a_gx1as = 0;
  int ia_gx1as = 0;
  int pw_gx1asa = 0;
  int pw_gx1asd = 0;
  int pw_gx1as = 0;
  int wg_gx1as  = 0;


  float a_gy1as = 0;
  float a_gy1asa = 0;
  float a_gy1asb = 0;
  int ia_gy1as = 0;
  int ia_gy1aswa = 0;
  int ia_gy1aswb = 0;
  int pw_gy1asa = 0;
  int pw_gy1asd = 0;
  int pw_gy1as = 0;
  int wg_gy1as  = 0;


  float a_gy1ras = 0;
  float a_gy1rasa = 0;
  float a_gy1rasb = 0;
  int ia_gy1ras = 0;
  int ia_gy1raswa = 0;
  int ia_gy1raswb = 0;
  int pw_gy1rasa = 0;
  int pw_gy1rasd = 0;
  int pw_gy1ras = 0;
  int wg_gy1ras  = 0;


  float a_gxkas = 0;
  int ia_gxkas = 0;
  int pw_gxkasa = 0;
  int pw_gxkasd = 0;
  int pw_gxkas = 0;
  int wg_gxkas  = 0;


  float a_gzkas = 0;
  int ia_gzkas = 0;
  int pw_gzkasa = 0;
  int pw_gzkasd = 0;
  int pw_gzkas = 0;
  int wg_gzkas  = 0;


  float a_xdixon = 0;
  int ia_xdixon = 0;
  int pw_xdixon = 0;
  int wg_xdixon  = 0;


  float a_ydixon = 0;
  int ia_ydixon = 0;
  int pw_ydixon = 0;
  int wg_ydixon  = 0;


  float a_zdixon = 0;
  int ia_zdixon = 0;
  int pw_zdixon = 0;
  int wg_zdixon  = 0;


  float a_sdixon = 0;
  int ia_sdixon = 0;
  int pw_sdixon = 0;
  int wg_sdixon  = 0;


  float a_sdixon2 = 0;
  int ia_sdixon2 = 0;
  int pw_sdixon2 = 0;
  int wg_sdixon2  = 0;

long _lastcv = 0;

#endif /* h_bbepi_allcv_h */

