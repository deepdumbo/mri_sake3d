/*
 *  bbepi.host.c
 *
 *  Do not edit this file. It is automatically generated by EPIC.
 *
 *  Date : Oct  9 2013
 *  Time : 17:18:52
 */

#include <values.h>
#include <string.h>
#include "epic_macros.h"
#include "epic_struct.h"
#include "bbepi.global.h"
#include "pgen_tmpl.h"
#include "bbepi.allcv.h"
#include "bbepi.tgtex.h"
#include "bbepi.hostdecl.h"
#include "bbepi.tgtdecl.h"
#include "bbepi.exportstr.h"
#include "bbepi.runtime.h"
/*********************************************************************
 *                        EPI.E HOST SECTION                         *
 *                                                                   *
 * Write here the code unique to the Host PSD process. The following *
 * functions must be declared here: cvinit(), cveval(), cvcheck(),   *
 * and predownload().                                                *
 *********************************************************************/

/* Local function declarations */
STATUS setEpiEsp(void);
STATUS mph_protocol(void);

/* MRIhc44418 */
STATUS optGradAndEsp_conv(void);
STATUS optGradAndEsp_rect(void);
STATUS epigradopt_rect(float, int);
float calcdbdtper_conv(void);
float intercept(float, float, int, int);
STATUS searchEspLonger_rect(int, int);
int getEspOutOfUnwantedRange(int, int, int);
int isGradAndEspReoptNeeded(void);
int getReadoutPhyAxis(void);
int isEspOutOfUnwantedRange(int,int);
void readEspRange(void);
void procNoEspRangeFile(FILE *);
int isCommentOrBlankLine(char *);
void printEpigradoptLog(void);
void printEpigradoptResult(void);
void printCornerPoint(int, int *, float *, float *);
void printDbdtper(float, int nump, int *, float *, float *, float *);
void printEspRange(void);


/* System includes */
#include <stdio.h>
#include <stdlib.h>

/* Local includes */
#include "sokPortable.h"   /* includes for option key functionality */
#include "epic_iopt_util.h"

#include "sar_pm.h"
#include "grad_rf_bbepi.h"
#ifndef SIM
/* Needed for epic_warning() */
#include "epic_rt.h"
#include "psdIF_inc.h"
#include "psdIF_proto.h"
#endif /* !SIM */

#ifdef EMULATE_HW
#define checkOptionKey(x) 0
#endif

#include <printDebug.h>

/* fec : Field strength dependency library */
#include <sysDep.h>
#include <sysDepSupport.h>
#include <psd.h>
#include <ctype.h>
#define BOGUS_ERMES_NUMBER 0

#define SINC_PULSE 0

char  estr[80];

/*jwg bb for reading external waveform and vfa schemes*/
char rf1froot[80]; 
char rf1_datfile[80]; 

int vfa_ctr = 0;
char fileloc_vfa[128];
char vfa_loc_tmp[10];

/*jg bb sake*/
char fileloc_sake[128];
int sake_ctr = 0;

/*jwg end*/

float save_opnex;
int save_fixed;
int save_exist;
int save_newgeo;

FILTER_INFO scan_filt;          /* Used in Inversion.e */
FILTER_INFO echo1_filt;         /* Used by epi.e */

#define Present 1
#define Absent 0

/* Array to hold max B1 for each entry point. */
float maxB1[MAX_ENTRY_POINTS], maxB1Seq;
int   entry, pulse;           /* loop counters */

int hrf1a, hrf1b;               /* location of rf1 center */
int hrf2a, hrf2b;               /* location of rf2 center */
int   crusher_type;             /* Vrg or non vrg type define */
float crusher_scale[NECHO_MAX];  /* reserve space for crusher scale factors*/

int av_temp_int;                 /* temp placement for advisory panel return values */
float av_temp_float;             /* temp placement for advisory panel return values */

OPT_GRAD_INPUT gradin;     /* gradient input paramters */
OPT_GRAD_PARAMS gradout;   /* gradient output paramters for optimal grads */

static char supfailfmt[] = "Support routine %s failed";

int save_dvw_grad_test = -1;
/* MRIhc44418 */
#define DBDTMODELRECT 0
#define DBDTMODELCONV 1
#define DBDT_STEPSIZE 2
#define DBDT_MAXNUMSTEPS 25
#define DBDT_ETL 2 /* 2 is sufficient for calculating dbdtper using convolution model */
#define XAXIS 0x0001
#define YAXIS 0x0002
#define ZAXIS 0x0004
#define MAXNUMESPRANGE 5
#define MAXCHAR 150

int dbdtper_count = 0;
int total_gradopt_count = 0;
int each_gradopt_count = 0;

int no_esprangefile = 0;
int numesprange_x = 0;
int esprange_x[MAXNUMESPRANGE][2];
int numesprange_y = 0;
int esprange_y[MAXNUMESPRANGE][2];
int numesprange_z = 0;
int esprange_z[MAXNUMESPRANGE][2];

int epigradopt_debug_old = -1;
int reopt_flag = PSD_ON;
int dbdt_model_old = -1;
float cfdbdtper_old = -1;
int esprange_check_old = -1;
int espopt_old = -1;
int espincway_old = -1;
int opmph_old = -1;
int rampopt_old = -1;
long rsprot_old[9] = {0,0,0,0,0,0,0,0,0};
OPT_GRAD_INPUT gradin_old = {-1, -1};     

/* MGD inlines */

/* Function Delcaration */
STATUS checkEpiImageOptions(void);

STATUS checkEpiImageOptions( void )
{
    int cardcv;                   /* Cardiac Gating Flag */
    float temp_float;             

    if(exist(opsilent) == PSD_ON && (exist(opfmri) == PSD_ON || exist(opmph) == PSD_ON || exist(opdynaplan) == PSD_ON))
    {
        epic_error( use_ermes, "%s is incompatible with %s ",
                    EM_PSD_INCOMPATIBLE, 2, STRING_ARG, "Acoustic Reduction",
                    STRING_ARG, "fMRI and multiphase EPI" );
        return FAILURE;
    }

    /* Sequence Type Check - SE and GRE Only */
    if ( (exist(oppseq) != 1) && (exist(oppseq) != 2) ) { /* lockout IR,SSFP,SPGR,TOF,PC,TOFSP,PCSP */
	epic_error(use_ermes,
                   "The EPI option is not supported in this scan",
                   EM_PSD_EPI_INCOMPATIBLE, 0);
	return FAILURE;
    }
    
    /* No 3D yet */
    if (exist(opimode) == PSD_3D) {
	epic_error(use_ermes,
		   "EPI is not compatible with the 3D Image Mode.  Please select 2D",
                   EM_PSD_EPI_VOLUME_INCOMPATIBLE, 0);
	return FAILURE;
    }
    
    /* No Spectro-EPI Yet */
    if (exist(opimode) == PSD_SPECTRO) {
	epic_error(use_ermes,
		   "Spectroscopy prescription failed.",
                   EM_PSD_SPECTRO_FAILURE, 0);
	return FAILURE;
    }
    
    /* No CINE EPI */
    if ((exist(opimode) == PSD_CINE) && existcv(opimode)) {
        epic_error(use_ermes,"Cine is not available with this PSD",EM_PSD_CINE_INCOMPATIBLE,0);
        return FAILURE;
    }
    
    /* POMP is not supported with EPI */
    if ((exist(oppomp) == PSD_ON) && existcv(oppomp)) {
        epic_error(use_ermes,"The POMP option is not supported in this scan.", EM_PSD_POMP_INCOMPATIBLE, 0);
        return FAILURE;
    }
    
    /* No PhaseWrap is not Supported */
    if (exist(opnopwrap) == PSD_ON) {
	epic_error(use_ermes, "No Phase Wrap and EPI are incompatible features.",
                   EM_PSD_EPI_NOP_INCOMPATIBLE, 0);
	return FAILURE;
    }
    
    /* Tailored RF is only for FSE-based scans */  
    if (exist(optlrdrf) == PSD_ON) {
	epic_error(use_ermes,
                   "The Tailored RF option is not supported in this scan.",
                   EM_PSD_TLRDRF_INCOMPATIBLE, 0);
	return FAILURE;
    }
    
    /* Resp. Comp Check */
    if (exist(opexor) == PSD_ON) {
	epic_error(use_ermes,
                   "Respiratory Compensation and EPI and incompatible features.",
                   EM_PSD_EPI_RESP_COMP_INCOMPATIBLE, 0);
	return FAILURE;
    }
    
    /* Driven Equilibrium Prep not Supported */
    if (exist(opdeprep) == PSD_ON) {
	epic_error(use_ermes,
                   "The DE Prep Option is not available with this pulse sequence.",
                   EM_PSD_OPDEPREP_INCOMPATIBLE, 0);
	return FAILURE;
    }
    
    /* Resp Triggered Scans are not supported */
    if (exist(oprtcgate) == PSD_ON) {
	epic_error(use_ermes,
                   "Respiratory Triggering and EPI and incompatible features.",
                   EM_PSD_EPI_RESP_TRIG_INCOMPATIBLE, 0);
	return FAILURE;
    }
    
    /* No Mag. Transfer */
    if (exist(opmt)==PSD_ON && existcv(opmt)==PSD_ON) {
        epic_error(use_ermes,"MT not Supported",EM_PSD_MT_INCOMPATIBLE,0);
        return FAILURE;
    }    
    
    /* No Clasic Feature */
    if (exist(opblim) == PSD_ON) {
        epic_error(use_ermes,
                   "Classic is not an option.",
                   EM_PSD_CLASSIC_INCOMPATIBLE, 0);
        return FAILURE;
    }

    /* YMSmr07221, YMSmr07315 */
    if (existcv(opptsize) && (exist(opptsize) > 2)) {
        epic_error(use_ermes,"EDR is not supported in this PSD.",EM_PSD_EDR_INCOMPATIBLE,0);
        return FAILURE;
    }       
 
    /* Can't use a graphic ROI */
    if ((exist(opgrxroi) == PSD_ON) && existcv(opgrxroi)) {
        epic_error(use_ermes,
                   "The Graphic ROI Option is not available with this sequence.",
                   EM_PSD_OPGRXROI_INCOMPATIBLE, 0);
        return FAILURE;
    }
    
    /* EPI and SSFSE are not compatible */
    if (exist(opepi)==PSD_ON && exist(opssfse)==PSD_ON){
	epic_error(use_ermes,
                   "EPI is incompatible with the Single-Shot button. Please use # of Shots = 1 for SS-EPI.",
                   EM_PSD_EPI_SSFSE_INCOMPATIBLE, 0);
	return FAILURE;
    }
    
    /* MRIge53672 - Make Concat SAT and multiphase EPI incompatible */
    if ( (PSD_ON == mph_flag) && (PSD_ON == exist(opccsat)) ) {
        epic_error( use_ermes, "%s is incompatible with %s ",
                    EM_PSD_INCOMPATIBLE, 2, STRING_ARG, "Concat SAT",
                    STRING_ARG, "multiphase EPI" );
        return FAILURE;
    }
    
    /* No rect. FOV */
    if (exist(oprect) == PSD_ON) {
	strcpy(estr, "Rectangular FOV is not allowed with this scan.");
	epic_error(use_ermes, estr, EM_PSD_RECT_NOT_SUPPORTED, EE_ARGS(0));
	return FAILURE; 
    }
    
    /* Caridac Gating Checks */
    cardcv = (exist(opcgate) && existcv(ophrate) && existcv(ophrep) 
              && existcv(opphases) && existcv(opcardseq) && existcv(optdel1)
              && existcv(oparr));
    
    /* MRIge65081 */
    if (exist(opcgate)) {
        if ((exist(opslquant) > avmaxslquant) && existcv(opslquant)) {
            epic_error(use_ermes,"Maximum slice quantity is %-d ",EM_PSD_SLQUANT_OUT_OF_RANGE,1,INT_ARG,avmaxslquant);
            return ADVISORY_FAILURE;
        }
    } 
    
    if (!exist(opcgate)) {
        if ((opautotr == 0) && (exist(optr) < avmintr) && existcv(optr)) {
            epic_error(use_ermes," Minimum TR is %-d ms ",EM_PSD_TR_OUT_OF_RANGE,1,INT_ARG,(avmintr/1000));
            return ADVISORY_FAILURE;
        }
        
        if ((opautotr == 0) && (exist(optr) > avmaxtr) && existcv(optr))
        {
            epic_error(use_ermes," Maximum TR is %-d ms ",EM_PSD_TR_OUT_OF_RANGE2,1,INT_ARG,(avmaxtr/1000));
            return ADVISORY_FAILURE;
        }
    }
    else
    {
        if ((piait < avmintseq) && (existcv(optdel1)))
        {
            epic_error(use_ermes," Improper Avail. Image Time.  Decrease Trigger Window and/or Trigger Delay. ",EM_PSD_AIT_OUT_OF_RANGE,0);
            return FAILURE;
        }
        
        if ((existcv(optdel1))&& ((exist(optdel1) < avmintdel1)
                                  || (exist(optdel1) > 1600000)))
        {
            epic_error(use_ermes," Min. delay after trigger is %-d ms ",EM_PSD_TD_OUT_OF_RANGE,1,INT_ARG,(avmintdel1/1000));
            return FAILURE;
        }
    } 
    
    if (cardcv)
    {
        if (exist(opphases) > avmaxphases)
        {
            epic_error(use_ermes," The number of phases must be reduced to %-d ", 
                       EM_PSD_MAXPHASE_EXCEEDED,1,INT_ARG,avmaxphases);
            return FAILURE;
        }
        if ((psd_tseq < avmintseq) && (existcv(opfov)) && (existcv(opcardseq)))
        {
            epic_error(use_ermes," The minimum inter sequence delay time must be increased to %-d ms due to the FOV/slice thickness selected ",EM_PSD_TSEQ_FOV_OUT_OF_RANGE,1,INT_ARG,(avmintseq/1000));
            return FAILURE;
        }
        
        if ((psd_tseq < avmintseq) && (existcv(opcardseq)))
        {
            epic_error(use_ermes," The minimum inter sequence delay time must be increased to %-d ms. ",EM_PSD_TSEQ_OUT_OF_RANGE,1,INT_ARG,(avmintseq/1000));
            return FAILURE;
        }
        if (seq_type == TYPMPMP)
        {
            temp_float = (float)opphases/(float)opslquant;
            if ((temp_float != 1.0) && (temp_float != 2.0) && 
                (temp_float != 3.0) && (exist(opslquant) > 1))
            {
                epic_error(use_ermes," The number of phases/locations must equal 1, 2, or 3.\n ",EM_PSD_SLCPHA_INCOMPATIBLE,0);
                return FAILURE;
            }
            
            if (exist(opphases)*exist(opslquant)*exist(opfphases) > DATA_ACQ_MAX)
            {
                epic_error(use_ermes," The number of locations*phases has exceeded %-d.\n ",EM_PSD_SLCPHA_OUT_OF_RANGE,1,INT_ARG,DATA_ACQ_MAX);
                return FAILURE;
            }
        }
    }

    /* YMSmr09726 */
    if( exist(opasset) && (val15_lock == PSD_ON) ){
        if(!strcmp( coilInfo[0].coilName, "GE_HDx 8NVARRAY_A")){
            epic_error( use_ermes, "%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE, 2,
                            STRING_ARG, "EPI ASSET",
                            STRING_ARG, "8NVARRAY_A");
            return FAILURE;
        } else if(!strcmp( coilInfo[0].coilName, "GE_HDx 8NVANGIO_A")){ 
            epic_error( use_ermes, "%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE, 2,
                            STRING_ARG, "EPI ASSET",
                            STRING_ARG, "8NVANGIO_A");
            return FAILURE;
        }
    }

   return SUCCESS;

} /* end checkEpiImageOptions( void ) */

STATUS epiCalFileCVInit(void);
STATUS epiCalFileCVCheck(void);

STATUS epiCalFileCVInit(void) {

    FILE *fp;
    char *infile1="b0_dither.cal";
    char *infile2="delay.dat";
    char *infile3="delay.esp";
    char *infile4="b0vectors.dat";

    char *path="/usr/g/caldir/";
    char basefile1[80], basefile2[80], basefile3[80], basefile4[80];
 
    /* Check for the existence of the epi calibration files */
    strcpy(basefile1, path);
    strcat(basefile1, infile1);
    strcpy(basefile2, path);
    strcat(basefile2, infile2);
    strcpy(basefile3, path);
    strcat(basefile3, infile3);
    strcpy(basefile4, path);
    strcat(basefile4, infile4);
    
    /* Determine which coil is being used */
    switch(getTxCoilType()) {
    case TX_COIL_LOCAL:
        strcat(basefile1, ".head");
        strcat(basefile3, "h.xyz");
        strcat(basefile4, ".head");
        break;
    case TX_COIL_BODY:
    default:
        strcat(basefile1, ".body");
        strcat(basefile3, "b.xyz");
        strcat(basefile4, ".body");
        break;
    }
    

    /* Open the b0_dither.cal file */
    if ((fp=fopen(basefile1, "r")) ==NULL) {
        nob0dither = _nob0dither.fixedflag ? ((void)(1), nob0dither) : 1;
    } else {
        fclose(fp);
    }

    /* Open the delay.dat file */
    if ((fp=fopen(basefile2, "r")) ==NULL) {
        nodelay = _nodelay.fixedflag ? ((void)(1), nodelay) : 1;
    } else {
        fclose(fp);
    }

    /* Open the delay.esp.xyz file */
    if ((fp=fopen(basefile3, "r")) ==NULL) {
        nodelayesp = _nodelayesp.fixedflag ? ((void)(1), nodelayesp) : 1;
    } else {
        fclose(fp);
    }

    /* Open the b0vectors.dat file */
    if ((fp=fopen(basefile4, "r")) ==NULL) {
        nob0dither_interpo = _nob0dither_interpo.fixedflag ? ((void)(1), nob0dither_interpo) : 1;
    } else {
        fclose(fp);
    }

    return SUCCESS;
    
} /* end epiCalFileCheck */

 
STATUS epiCalFileCVCheck (void) {

    char calfiles[300];
    char bccalfiles[300];       
    char bcfile[80], bcfile2[80];
    char *bcpath="/usr/g/caldir/";
    int recvnum;		
    FILE *fpbc;

    if(epiCalFileCVInit() != SUCCESS) return FAILURE;

    if (PSDDVMR == psd_board_type)
    {
        /* DVMR does not require B0 dither.  Do not warn user if
         * calibration files are not present */
        nob0dither  = _nob0dither.fixedflag ?  ((void)(0), nob0dither) : 0;
        nob0dither_interpo  = _nob0dither_interpo.fixedflag ?  ((void)(0), nob0dither_interpo) : 0;
        if (30000 == cffield) nodelayesp  = _nodelayesp.fixedflag ?  ((void)(0), nodelayesp) : 0;
    }

    /* epi cal files */
    if (((nodelay==1) || (nob0dither==1 && b0dither_new==0) ||
         (nodelayesp==1) || (nob0dither_interpo==1 && b0dither_new==1)
        ) && (exist(opepi)==PSD_ON) ) {
        strcpy(calfiles, "/usr/g/caldir/");
        if (nodelay==1)
            strcat(calfiles, " delay.dat");
        if (nob0dither==1 && b0dither_new==0) {
            /* strcat filename based on which coil is being used */
            switch(getTxCoilType()) {
                case TX_COIL_LOCAL:
                    strcat(calfiles, " b0_dither.cal.head");
                    break;
                case TX_COIL_BODY:
                default:
                    strcat(calfiles, " b0_dither.cal.body");
                    break;
            }
        }
        if (nodelayesp==1) {
            /* strcat filename based on which coil is being used */
            switch(getTxCoilType()) {
                case TX_COIL_LOCAL:
                    strcat(calfiles, " delay.esph.xyz");
                    break;
                case TX_COIL_BODY:
                default:
                    strcat(calfiles, " delay.espb.xyz");
                    break;
            }
        }
        if (nob0dither_interpo==1 && b0dither_new==1) {
            /* strcat filename based on which coil is being used */
            switch(getTxCoilType()) {
                case TX_COIL_LOCAL:
                    strcat(calfiles, " b0vectors.dat.head");
                    break;
                case TX_COIL_BODY:
                default:
                    strcat(calfiles, " b0vectors.dat.body");
                    break;
            }
        }

#ifndef SIM
        epic_warning( "The following files were not found: %s. "
                      "Using default values.", calfiles );
#endif

        nob0dither  = _nob0dither.fixedflag ?  ((void)(0), nob0dither) : 0;
        nodelay  = _nodelay.fixedflag ?  ((void)(0), nodelay) : 0;
        nodelayesp  = _nodelayesp.fixedflag ?  ((void)(0), nodelayesp) : 0;
        nob0dither_interpo  = _nob0dither_interpo.fixedflag ?  ((void)(0), nob0dither_interpo) : 0;  
        _nob0dither.fixedflag = 1;
        _nodelay.fixedflag = 1;
        _nodelayesp.fixedflag = 1;
        _nob0dither_interpo.fixedflag = 1;
    }

    strcpy(bccalfiles, "/usr/g/caldir/");

    nobcfile  = _nobcfile.fixedflag ?  ((void)(0), nobcfile) : 0;
    for( recvnum = (cfrecvst + 1); recvnum < (cfrecvend + 2); recvnum++ ) {
        sprintf(bcfile,"%sbcrvs%d.dat", bcpath, recvnum);
        if ((fpbc=fopen(bcfile, "r")) ==NULL) {
            nobcfile  = _nobcfile.fixedflag ?    ((void)(nobcfile+1), nobcfile) : nobcfile+1;
            sprintf(bcfile2,"bcrvs%d.dat ", recvnum);
            strcat(bccalfiles, bcfile2);  
        } else {
            fclose(fpbc);
        }
    }        
    number_of_bc_files  = _number_of_bc_files.fixedflag ?        ((void)(cfrecvend-cfrecvst-nobcfile+1), number_of_bc_files) : cfrecvend-cfrecvst-nobcfile+1;
    if(activeReceivers !=  (cfrecvend - cfrecvst + 1)) {
        activeReceivers  = _activeReceivers.fixedflag ?       ((void)((cfrecvend-cfrecvst+1)), activeReceivers) : (cfrecvend-cfrecvst+1); 
        flagWarning  = _flagWarning.fixedflag ?  ((void)(TRUE), flagWarning) : TRUE;
    }


    if ( (cfrecvend - cfrecvst + 1 > number_of_bc_files) && (exist(opepi)==PSD_ON) ) {
    
#ifndef SIM
 
        if((flagWarning == TRUE) && (value_system_flag == NON_VALUE_SYSTEM) && (PSDDVMR != psd_board_type)) {
            epic_warning( "The following files were not found: %s. "
                          "Please have Field Service run bandpass cals.", bccalfiles );
            flagWarning  = _flagWarning.fixedflag ?  ((void)(FALSE), flagWarning) : FALSE;  /* only display error once */
        }

#endif

    }
  
    return SUCCESS;

}

/* MGD: needed for filter changes */
/* Structure definitions for prescan filters*/
FILTER_INFO echo1as_filt;
FILTER_INFO echo1mps1_filt;
FILTER_INFO echo1ftg_filt;
FILTER_INFO echo1xtg_filt;
FILTER_INFO echo1cfl;
FILTER_INFO echo1cfh;
FILTER_INFO echo1rcvn;

/* defines for pimrsaps CVs from op_prescan.h */
#ifndef PSC_MAX_CONTROL_ARRAY
#define PSC_MAX_CONTROL_ARRAY 15
#endif

#define COILLOG_LOG_MAXSIZE 262144 /* quarter-Meg */

int* pimrs[PSC_MAX_CONTROL_ARRAY];

/* YMSmr09211 04/26/2006 YI */
SCAN_INFO cfh_info[MAX_PSC_VQUANT];
SCAN_INFO ps1scan_info[PRESCAN_ROT_MAX];


/* For enabling more than 1024 im/ser -Venkat */
int enable_1024 = 0; 
int max_slice_limit = DATA_ACQ_MAX;

#include <psdiopt.h>
int sequence_iopts[] = {
    PSD_IOPT_CARD_GATE,
    PSD_IOPT_FLOW_COMP,
    PSD_IOPT_SEQUENTIAL,
    PSD_IOPT_MPH,
    PSD_IOPT_SQR_PIX,
    PSD_IOPT_FMRI,
    PSD_IOPT_IR_PREP,
    PSD_IOPT_ASSET,  /* MRIge92386: Added for enabling Asset with EPI for Excite-III */
    PSD_IOPT_DYNPL,
    PSD_IOPT_MILDNOTE
};

long feature_flag = 0;

void
psd_init_iopts( void )
{
    int numopts = sizeof(sequence_iopts)/ sizeof(int);

    psd_init_iopt_activity();

    activate_iopt_list( numopts, sequence_iopts );
    enable_iopt_list( numopts, sequence_iopts );

    set_incompatible( PSD_IOPT_FMRI, PSD_IOPT_MPH );                    
    set_incompatible( PSD_IOPT_FMRI, PSD_IOPT_IR_PREP );                
    set_incompatible( PSD_IOPT_FMRI, PSD_IOPT_CARD_GATE );              
    set_incompatible( PSD_IOPT_FMRI, PSD_IOPT_SEQUENTIAL );             
    set_incompatible( PSD_IOPT_FMRI, PSD_IOPT_DYNPL );             

    /* Disable ART with fMRI and multi-phase EPI */ 
    if(mild_note_support)
    {
        set_incompatible( PSD_IOPT_MPH, PSD_IOPT_MILDNOTE );
        set_incompatible( PSD_IOPT_DYNPL, PSD_IOPT_MILDNOTE );
        set_incompatible( PSD_IOPT_FMRI, PSD_IOPT_MILDNOTE );
    }

    /* MRIge92386: Added for Excite-3: Enabling Asset with EPI but not
     * with fMRI */   
    /* MRIhc06306: for DVMRI, asset is supported for fMRI*/
    /*set_incompatible( PSD_IOPT_FMRI, PSD_IOPT_ASSET); */                  

    /* MRIhc01608: FLOWCOMP and fMRI not compatible in SEPI */
    if (PSD_SE == exist(oppseq)) {
        set_incompatible( PSD_IOPT_FMRI, PSD_IOPT_FLOW_COMP);
    }

    set_incompatible( PSD_IOPT_CARD_GATE, PSD_IOPT_DYNPL );
    set_incompatible( PSD_IOPT_MPH, PSD_IOPT_DYNPL );

    return;
}

STATUS
cvsetfeatures( void )
{
    return SUCCESS;
}

STATUS
cvfeatureiopts( void )
{
    psd_init_iopts();

    /* MRIhc08639  09/01/2005 YI */
    if(exist(opcgate) == PSD_ON){
        deactivate_ioption( PSD_IOPT_DYNPL );
    }

    if(value_system_flag == VALUE_SYSTEM_HDE){
        deactivate_ioption( PSD_IOPT_FMRI );
    }

    if(checkOptionKey( SOK_MPHVAR )){
        deactivate_ioption( PSD_IOPT_DYNPL );
    }

    if(!mild_note_support){
        deactivate_ioption( PSD_IOPT_MILDNOTE );
    }

    if( (val15_lock == PSD_ON) && 
        (!strcmp( coilInfo[0].coilName, "GE_HDx 8NVARRAY_A") || 
         !strcmp( coilInfo[0].coilName, "GE_HDx 8NVANGIO_A"))) 
    {
        disable_ioption( PSD_IOPT_ASSET );
    }
    
    if (exist(optouch)) {
        deactivate_ioption(PSD_IOPT_MPH);
        deactivate_ioption(PSD_IOPT_DYNPL);
        deactivate_ioption(PSD_IOPT_FMRI);
        deactivate_ioption(PSD_IOPT_MILDNOTE);
        deactivate_ioption(PSD_IOPT_IR_PREP);
        deactivate_ioption(PSD_IOPT_SQR_PIX);
        deactivate_ioption(PSD_IOPT_SEQUENTIAL);
        deactivate_ioption(PSD_IOPT_CARD_GATE);
    }
 
    return SUCCESS;
}

STATUS
cvevaliopts( void )
{

    /* Option Key Check */
    int fmri_option_key_status;

    /*MRIhc07637 no longer check for medcam.cfg with VRE*/

    /* Option Key Check */
    fmri_option_key_status = !checkOptionKey( SOK_BRNWAVRT );

    if ((FALSE == fmri_option_key_status) && (value_system_flag != VALUE_SYSTEM_HDE)) {
        set_disallowed_option(PSD_IOPT_FMRI);
    }

   return SUCCESS;
}


















/* load up psd header */
abstract("Spin or gradient recalled echo planar imaging sequence (rev lx 54)");
psdname("EPI");

/* ****************************************
   MYSCAN
   myscan sets up the scan_info table for a hypothetical scan.
   It is controlled by the cv opslquant, and opslthick, and opfov. 
   ************************************** */
STATUS
#ifdef __STDC__ 
myscan( void )
#else /* !__STDC__ */
    myscan()
#endif /* __STDC__ */
{
    int i,j;
    int num_slice;
    float z_delta;		/* change in z_loc between slices */
    float r_delta;		/* change in r_loc between slices */
    double alpha, beta, gamma; /* rotation angles about x, y, z respectively */
    
    num_slice = exist(opslquant);
    
    r_delta = exist(opfov)/num_slice;
    z_delta = exist(opslthick)+exist(opslspace);
    
    scan_info[0].optloc = 0.5*z_delta*(num_slice-1);
    if (myrloc!=0.0)
        scan_info[0].oprloc = myrloc;
    else 
        scan_info[0].oprloc = 0;
    
    for (i=1;i<9;i++)
        scan_info[0].oprot[i]=0.0;
    
    switch (exist(opplane)) {
    case PSD_AXIAL:
        scan_info[0].oprot[0] = 1.0;
        scan_info[0].oprot[4] = 1.0;
        scan_info[0].oprot[8] = 1.0;
        break;
    case PSD_SAG:
        scan_info[0].oprot[2] = 1.0;
        scan_info[0].oprot[4] = 1.0;
        scan_info[0].oprot[6] = 1.0;
        break;
    case PSD_COR:
        scan_info[0].oprot[2] = 1.0;
        scan_info[0].oprot[6] = 1.0;
        scan_info[0].oprot[7] = 1.0;
        break;
    case PSD_OBL:
        alpha = PI/4.0;  /* rotation about x (applied first) */
        beta = 0;   /* rotation about y (applied 2nd) */
        gamma = 0;  /* rotation about z (applied 3rd) */
        scan_info[0].oprot[0] = cos(gamma)*cos(beta);
        scan_info[0].oprot[1] = cos(gamma)*sin(beta)*sin(alpha) -
                                       sin(gamma)*cos(alpha);
        scan_info[0].oprot[2] = cos(gamma)*sin(beta)*cos(alpha) +
                                       sin(gamma)*sin(alpha);
        scan_info[0].oprot[3] = sin(gamma)*cos(beta);
        scan_info[0].oprot[4] = sin(gamma)*sin(beta)*sin(alpha) +
                                       cos(gamma)*cos(alpha);
        scan_info[0].oprot[5] = sin(gamma)*sin(beta)*cos(alpha) -
                                       cos(gamma)*sin(alpha);
        scan_info[0].oprot[6] = -sin(beta);
        scan_info[0].oprot[7] = cos(beta)*sin(alpha);
        scan_info[0].oprot[8] = cos(beta)*cos(alpha);
        break;
    }
    
    for(i=1;i<num_slice;i++) {
        scan_info[i].optloc = scan_info[i-1].optloc - z_delta;
        scan_info[i].oprloc = i*r_delta;
        for(j=0;j<9;j++)
            scan_info[i].oprot[j] = scan_info[0].oprot[j];
    }
    return SUCCESS;
}


/* ****************************************
   RotateScan

   MRIge91983 - RDP - this is based on MyScan from SpectroCommon.e
   ************************************** */
STATUS
#ifdef __STDC__ 
rotatescan( void )
#else  /* !__STDC__ */
    rotatescan()
#endif /* __STDC__ */
{

    int i, j;
    int num_slice;
    float t_delta;
    double alpha, beta, gamma;
    float z_delta;		/* change in z_loc between slices */
    float r_delta;		/* change in r_loc between slices */

    alpha = my_alpha * PI/ 180.0;  /*around X*/
    beta = my_beta * PI/ 180.0;    /*around Y*/
    gamma = my_gamma * PI/ 180.0;  /*around Z*/

    num_slice = exist(opslquant) * exist(opvquant);

    r_delta = exist(opfov)/num_slice;
    z_delta = exist(opslthick)+exist(opslspace);

    t_delta = exist(opvthick);

    short oblpln = PSD_AXIAL;

    if (exist(opplane) == PSD_OBL) {

       setexist(oprlcsiis, PSD_ON);
       setexist(opapcsiis, PSD_ON);
       setexist(opsicsiis, PSD_ON);

       scan_info[0].optloc = 0.5*z_delta*(num_slice-1);

       scan_info[0].oprot[0] = cos(gamma) * cos(beta);
       scan_info[0].oprot[1] = cos(gamma) * sin(beta) * sin(alpha)
                                 - sin(gamma) * cos(alpha);
       scan_info[0].oprot[2] = cos(gamma) * sin(beta) * cos(alpha)
                                 + sin(gamma) * sin(alpha);
       scan_info[0].oprot[3] = sin(gamma) * cos(beta);
       scan_info[0].oprot[4] = sin(gamma) * sin(beta) * sin(alpha)
                                 + cos(gamma) * cos(alpha);
       scan_info[0].oprot[5] = sin(gamma) * sin(beta) * cos(alpha)
                                 - cos(gamma) * sin(alpha);
       scan_info[0].oprot[6] = -sin(beta);
       scan_info[0].oprot[7] = cos(beta) * sin(alpha);
       scan_info[0].oprot[8] = cos(beta) * cos(alpha);

       if( (abs(scan_info[0].oprot[0])
            >= abs(scan_info[0].oprot[1]))
           &&  (abs(scan_info[0].oprot[0])
                >= abs(scan_info[0].oprot[2]))) {
                oblpln = PSD_AXIAL;
       }
       else if( (abs(scan_info[0].oprot[1])
                 > abs(scan_info[0].oprot[0]))
                &&  (abs(scan_info[0].oprot[1])
                     >= abs(scan_info[0].oprot[2]))) {
           oblpln = PSD_SAG;
       }
       else if( (abs(scan_info[0].oprot[2])
                 > abs(scan_info[0].oprot[0]))
                &&  (abs(scan_info[0].oprot[2])
                     > abs(scan_info[0].oprot[1]))) {
           oblpln = PSD_COR;
       }
       opobplane  = _opobplane.fixedflag ?  ((void)(oblpln), opobplane) : oblpln;
       switch (exist(opobplane)) {
       case PSD_AXIAL:
           if(!opspf) {   
               opapcsiis  = _opapcsiis.fixedflag ?  ((void)(2), opapcsiis) : 2;
               oprlcsiis  = _oprlcsiis.fixedflag ?  ((void)(1), oprlcsiis) : 1;
           } else {
               opapcsiis  = _opapcsiis.fixedflag ?  ((void)(1), opapcsiis) : 1;
               oprlcsiis  = _oprlcsiis.fixedflag ?  ((void)(2), oprlcsiis) : 2;
           }  

           opsicsiis  = _opsicsiis.fixedflag ?  ((void)(3), opsicsiis) : 3;
           break;
       case PSD_SAG:
           if(!opspf) {
               opapcsiis  = _opapcsiis.fixedflag ?  ((void)(2), opapcsiis) : 2;
               opsicsiis  = _opsicsiis.fixedflag ?  ((void)(1), opsicsiis) : 1;
           } else {
               opapcsiis  = _opapcsiis.fixedflag ?  ((void)(1), opapcsiis) : 1;
               opsicsiis  = _opsicsiis.fixedflag ?  ((void)(2), opsicsiis) : 2;
           } 
            
           oprlcsiis  = _oprlcsiis.fixedflag ?  ((void)(3), oprlcsiis) : 3;
           break;
       case PSD_COR:
           if(!opspf) {
               oprlcsiis  = _oprlcsiis.fixedflag ?  ((void)(2), oprlcsiis) : 2;
               opsicsiis  = _opsicsiis.fixedflag ?  ((void)(1), opsicsiis) : 1;
           } else {
               opapcsiis  = _opapcsiis.fixedflag ?  ((void)(1), opapcsiis) : 1;
               opsicsiis  = _opsicsiis.fixedflag ?  ((void)(2), opsicsiis) : 2;
           } 
  
           opapcsiis  = _opapcsiis.fixedflag ?  ((void)(3), opapcsiis) : 3;
           break;
       }
           
    
       for(i=1;i<num_slice;i++) {
            scan_info[i].optloc = scan_info[i-1].optloc - z_delta;
            for(j=0;j<9;j++) {
                scan_info[i].oprot[j] = scan_info[0].oprot[j];
            }
       }
    }
    return SUCCESS;
} /* end rotatescan() */

/* 
 * Override coil acceleration capabilties
 */
void epi_asset_override(void)
{
    if(existcv(opasset) && (1 == exist(opassetscan)))
    {
        if( touch_flag )
        {
            /* the acceleration factor of 8ch TORSO/Cardic coil is limited to 2x */
            /* override it to 3x for MR-Touch application*/
            cfaccel_ph_maxstride = FMax(2, 3.0, cfaccel_ph_maxstride);
        }
        else
        {
            /* To replicate legacy behavior, allow ASSET R=2 even if the coil
             * doesn't support it. */
            cfaccel_ph_maxstride = FMax(2, 2.0, cfaccel_ph_maxstride);
        }
    }

    return;
}

/*
 * Setup parallel imaging UI to only show integer step sizes
 */ 
void epi_asset_set_dropdown(void)
{
    if(existcv(opasset) && (1 == exist(opassetscan)))
    {
        if(avmaxaccel_ph_stride > 2.0)
        {
            piaccel_phnub = 4;
            piaccel_phval2 = 1.0;
            piaccel_phval3 = 2.0;
            piaccel_phval4 = avmaxaccel_ph_stride;
        }
        else
        {
            piaccel_phnub = 3;
            piaccel_phval2 = 1.0;
            piaccel_phval3 = 2.0;
        }

        piaccel_ph_step = 1.0;
    }

    return;
}

/****************************************************************************/
/*  CVINIT                                                                  */
/****************************************************************************/
STATUS
cvinit( void )
{
    if ((PSDDVMR == psd_board_type) && (value_system_flag == PSD_OFF))
    {
        /* B0 dither calibration is removed for DVMR hardware */
        ditheron  = _ditheron.fixedflag ?  ((void)(0), ditheron) : 0;
    }
    else
    {
        ditheron  = _ditheron.fixedflag ?  ((void)(1), ditheron) : 1;    
    }

    OpenDelayFile(delay_buffer);
    if (ditheron)
    {
        OpenDitherFile(txCoilInfo[getTxIndex(coilInfo[0])].txCoilType,
                       dither_buffer);
        OpenDitherInterpoFile(txCoilInfo[getTxIndex(coilInfo[0])].txCoilType,
                              ccinx, cciny, ccinz, esp_in, fesp_in, &g0,
                              &num_elements, &file_exist);
    }

    /* RAK: MRIge55889 - removed GRAD_UPDATE_TIME being used during the */
    /*                   initialization of CVs.                         */
    
    pwmin_gap      = _pwmin_gap.fixedflag ?  ((void)(2*GRAD_UPDATE_TIME), pwmin_gap) : 2*GRAD_UPDATE_TIME;
    td0            = _td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), td0) : GRAD_UPDATE_TIME;
    hrdwr_period  = _hrdwr_period.fixedflag ?  ((void)(GRAD_UPDATE_TIME), hrdwr_period) : GRAD_UPDATE_TIME;
     
    /* SXZ::MRIge72411: init the optimization arr */
    taratio_arr[0] = 0.7; 
    taratio_arr[1] = 0.65; 
    taratio_arr[2] = 0.5;
    totarea_arr[0] = 1127.4; /* fov=20; xres=96 */
    totarea_arr[1] = 1503.2; /* fov=20; xres=128 */
    totarea_arr[2] = 2254.8; /* fov=20; xres=192 */

    /* Setup to use ermes database for HW compile */
#ifdef ERMES_DEBUG
    use_ermes  = _use_ermes.fixedflag ?  ((void)(0), use_ermes) : 0;
#else
    use_ermes  = _use_ermes.fixedflag ? ((void)(1), use_ermes) : 1;
#endif
    
    { /* Start of code inlined from vmx.e SysParmInit */
        if( cfpwrmontyp == PMTYP_VMX ) 
        {
            system_type  = _system_type.fixedflag ?  ((void)(1), system_type) : 1;
            rfupa = cv_rfupa;
        }
        if( (cfgradcoil == GCOIL_HGC)||(cfgradcoil == GCOIL_VECTRA) )
        {
            cvdef(opfov, FOV_MAX_VMX);
            cvmax(opfov, FOV_MAX_VMX);
            opfov  = _opfov.fixedflag ?  ((void)(FOV_MAX_VMX), opfov) : FOV_MAX_VMX;
            avmaxfov = FOV_MAX_VMX;
            _opweight.maxval = 150.0;
        }
        else
        {
            cvdef(opfov, cfsystemmaxfov);
            cvmax(opfov, cfsystemmaxfov);
            opfov  = _opfov.fixedflag ?  ((void)(cfsystemmaxfov), opfov) : cfsystemmaxfov;

            cvdef(asfov, cfsystemmaxfov);
            cvmax(asfov, cfsystemmaxfov);
            asfov  = _asfov.fixedflag ?  ((void)(cfsystemmaxfov), asfov) : cfsystemmaxfov;
           
            cvdef(tgfov, cfsystemmaxfov);
            cvmax(tgfov, cfsystemmaxfov);
            tgfov  = _tgfov.fixedflag ?  ((void)(cfsystemmaxfov), tgfov) : cfsystemmaxfov;
            
            cvmax(opmonfov, cfsystemmaxfov);
            
            cvmax(rhscanfov, cfsystemmaxfov);
            
            cvmax(rhdispfov, cfsystemmaxfov);
        }
        if(cffield == 2000)
        {
            cvdef(opfov, FOV_MAX_PROFILE);
            cvmax(opfov, FOV_MAX_PROFILE);
            opfov  = _opfov.fixedflag ?  ((void)(FOV_MAX_PROFILE), opfov) : FOV_MAX_PROFILE;
            avmaxfov = FOV_MAX_PROFILE;
            _opweight.maxval = 180.0;
        }
        if(cffield == 3500)
        {
            cvdef(opfov, FOV_MAX_PROFILE);
            cvmax(opfov, FOV_MAX_PROFILE);
            opfov  = _opfov.fixedflag ?  ((void)(FOV_MAX_PROFILE), opfov) : FOV_MAX_PROFILE;
            avmaxfov = FOV_MAX_PROFILE;
        }
        if(cffield <= 2000)
        {
            _opcfsel.fixedflag = 0;
            opcfsel  = _opcfsel.fixedflag ?  ((void)(PSD_CFPK), opcfsel) : PSD_CFPK;
            _opcfsel.existflag = 1;
            _opcfsel.fixedflag = 1;
        }
        if(cffield == 2000)
        {
            /* Maximum integrated (B1)^2 per pulse (uT^2sec) */
            txCoilInfo[getTxIndex(coilInfo[0])].maxB1Squared = 8.0; 
        }
        {
            char *envvar; envvar = (char *)getenv("PSDDEBUGCODE");
            if(envvar)
            {
                int value = (int)strtol(envvar, (char **)NULL, 10);
                psddebugcode  = _psddebugcode.fixedflag ?  ((void)(value), psddebugcode) : value;
            }
        }
        {
            char *envvar; envvar = (char *)getenv("PSDDEBUGCODE2");
            if(envvar)
            {
                int value = (int)strtol(envvar, (char **)NULL, 10);
                psddebugcode2  = _psddebugcode2.fixedflag ?  ((void)(value), psddebugcode2) : value;
            }
        }

#ifdef VMX_VERSION_MFO
        debug_scan  = _debug_scan.fixedflag ?    /*PSDDEBUG_SCAN*/((void)((int)((psddebugcode2&1)!=0)), debug_scan) : (int)((psddebugcode2&1)!=0);
        debug  = _debug.fixedflag ?    /*PSDDEBUG_IPG*/((void)((int)((psddebugcode2&2)!=0)), debug) : (int)((psddebugcode2&2)!=0);
#endif
        debug_grad_spec  = _debug_grad_spec.fixedflag ?    /*PSDDEBUG_GSPEC*/((void)((int)((psddebugcode2&8)!=0)), debug_grad_spec) : (int)((psddebugcode2&8)!=0);
        if(cffield <= 3500)pisupnub = 0;

        switch (cfsrmode)
        {
            case PSD_SR50:
                value_system_flag  = _value_system_flag.fixedflag ?  ((void)(VALUE_SYSTEM_HDE), value_system_flag) : VALUE_SYSTEM_HDE;
                break;
            case PSD_SR100:
                value_system_flag  = _value_system_flag.fixedflag ?  ((void)(VALUE_SYSTEM_SVEM), value_system_flag) : VALUE_SYSTEM_SVEM;
                break;
            default:
                value_system_flag  = _value_system_flag.fixedflag ?  ((void)(NON_VALUE_SYSTEM), value_system_flag) : NON_VALUE_SYSTEM;
        }

        if( VALUE_SYSTEM_HDE == value_system_flag )
        {
            val15_lock  = _val15_lock.fixedflag ?  ((void)(PSD_ON), val15_lock) : PSD_ON;
        }
        else
        {
            val15_lock  = _val15_lock.fixedflag ?  ((void)(PSD_OFF), val15_lock) : PSD_OFF;
        }

       /* Mild Note */
        if( (VALUE_SYSTEM_HDE == value_system_flag)  ||
            (VALUE_SYSTEM_SVEM == value_system_flag) ||
            (VALUE_SYSTEM_SVDM == value_system_flag) ||
            (VALUE_SYSTEM_SVDMP == value_system_flag) ) {
          mild_note_support  = _mild_note_support.fixedflag ?  ((void)(PSD_ON), mild_note_support) : PSD_ON;
          rectfov_npw_support  = _rectfov_npw_support.fixedflag ?  ((void)(PSD_ON), rectfov_npw_support) : PSD_ON;
        }
        else 
        {
            if (cfnumartlevels == PSD_OFF)
            {
                mild_note_support  = _mild_note_support.fixedflag ?  ((void)(PSD_OFF), mild_note_support) : PSD_OFF;
            }
            else
            {
                mild_note_support  = _mild_note_support.fixedflag ?  ((void)(PSD_ON), mild_note_support) : PSD_ON;
            }
            pinumartlevels  = _pinumartlevels.fixedflag ?  ((void)(cfnumartlevels), pinumartlevels) : cfnumartlevels; /* This parameter will be used by host to manage ART UI */
            rectfov_npw_support  = _rectfov_npw_support.fixedflag ?  ((void)(PSD_OFF), rectfov_npw_support) : PSD_OFF;
            val15_lock  = _val15_lock.fixedflag ?  ((void)(PSD_OFF), val15_lock) : PSD_OFF;
        }
        /* Update default values based on the system configuration */
        configSystem();
    } /* End of code inlined from vmx.e SysParmInit */


    epi_asset_override();

    /* MRIge92386 */
/* AssetCVInit  inlined from Asset.e */
/* This section enables asset scanning only. */
/* Currently, calibration scans are performed */
/* with an fgre sequence. If there is aA need to */
/* enable calibration scans in other sequences, then */
/* the AsseCalCVInit section (below) should be inlined instead */
{
    cvmax(opassetscan, 1);

    /* New flags, originally used in efgre3d , being expanded */
    assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_OFF), assetsl_flag) : PSD_OFF;
    assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_OFF), assetph_flag) : PSD_OFF;

    /* Pick up default step size computed from avmaxaccel_ph_stride
     * and avmaxaccel_sl_stride
     * */

    avmaxaccel_sl_stride = 1.0;
    avmaxaccel_ph_stride = 1.0;
    piaccel_sl_stride = 1.0;
    piaccel_ph_stride = 1.0;

    assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
    if( existcv(opasset) && (1 == exist(opassetscan)) &&
        (cfaccel_sl_maxstride > 1.0) && 
        (ASSET_SUPPORT_SLICE == asset_supported_direction) )
    {
        /* ASSET selected, App & Coil support slice ASSET */

        /* Enable slice ASSET (host no longer sets slices ASSET) */
        cvoverride(opasset, ASSET_SCAN_SLICE, PSD_FIX_ON, PSD_EXIST_ON);
        assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_ON), assetsl_flag) : PSD_ON;
        avmaxaccel_sl_stride = cfaccel_sl_maxstride;

        if( existcv(opaccel_sl_stride) )
        {
            /* If user specified value, display it */
            piaccel_sl_stride = opaccel_sl_stride;
        }
        else
        {
            /* Otherwise default to min of 2.0 or the coil capability */
            piaccel_sl_stride = FMin(2, accel_sl_defstride, avmaxaccel_sl_stride);
        }

        if (exist(opaccel_sl_stride) > 1.0) {
            assetsl_factor  = _assetsl_factor.fixedflag ?    ((void)(FMin(2,1.0,1.0/exist(opaccel_sl_stride))), assetsl_factor) : FMin(2,1.0,1.0/exist(opaccel_sl_stride));
        } else {
            assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
        }
    }

    asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
    if( existcv(opasset) && (1 == exist(opassetscan)) &&
        (cfaccel_ph_maxstride > 1.0) && 
        (ASSET_SUPPORT_PHASE == asset_supported_direction) )
    {
        /* ASSET selected, App & Coil support phase ASSET */

        /* Reset to phase ASSET (host no longer sets slice ASSET ) */
        cvoverride(opasset, ASSET_SCAN_PHASE, PSD_FIX_ON, PSD_EXIST_ON);

        assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_ON), assetph_flag) : PSD_ON;
        avmaxaccel_ph_stride = cfaccel_ph_maxstride;

        if( existcv(opaccel_ph_stride) )
        {
            /* If user specified value, display it */
            piaccel_ph_stride = opaccel_ph_stride;
        }
        else
        {
            /* Otherwise default to min of 2.0 or the coil capability */
            piaccel_ph_stride = FMin(2, accel_ph_defstride, avmaxaccel_ph_stride);
        }

        if (exist(opaccel_ph_stride) > 1.0) {
            asset_factor  = _asset_factor.fixedflag ?    ((void)(FMin(2,1.0,1.0/exist(opaccel_ph_stride))), asset_factor) : FMin(2,1.0,1.0/exist(opaccel_ph_stride));
        } else {
            asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
        }
    }

    /* Set asset_factor */
    /* MRIge92386 */
    if( existcv(opasset) &&  exist(opassetscan) == PSD_ON )
    {
        piaccelscrn = PSD_ON;

        /* Set up the PI pulldown */
        setAccelPulldown (avmaxaccel_ph_stride, avmaxaccel_sl_stride, 
                          &piaccel_phval2, &piaccel_phval3,
                          &piaccel_phval4, &piaccel_phval5,
                          &piaccel_phval6, &piaccel_phnub,
                          &piaccel_phedit, &piaccel_slval2,
                          &piaccel_slval3, &piaccel_slval4,
                          &piaccel_slval5, &piaccel_slval6,
                          &piaccel_slnub, &piaccel_sledit,
                          &piaccel_ph_step, &piaccel_sl_step);
    } 
    else
    {
        asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
        assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
        assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_OFF), assetph_flag) : PSD_OFF;
        assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_OFF), assetsl_flag) : PSD_OFF;
        if(PSD_OFF == exist(oparc))
        {
            piaccel_slnub = 0.0;
            piaccel_phnub = 0.0;
            piaccelscrn = PSD_OFF;
        }        
    }
}

/* AssetCVInit  inlined from Asset.e */

    epi_asset_set_dropdown();

    /* MRIhc19114 */
    if ( (fract_ky == PSD_FRACT_KY) && (intleaves == 1) ) {
        rup_factor  = _rup_factor.fixedflag ?  ((void)(4.0), rup_factor) : 4.0;
    } else {
        rup_factor  = _rup_factor.fixedflag ?  ((void)(2.0), rup_factor) : 2.0;
    }

    if ( existcv(opasset) && (exist(opasset) == ASSET_SCAN_PHASE) ) {
        int temp_nframes;
        if (num_overscan > 0) {
            temp_nframes = (short)(ceilf((float)exist(opyres)*asset_factor/rup_factor)*rup_factor*fn*nop - ky_offset);
            asset_factor  = _asset_factor.fixedflag ?      ((void)(FMin(2,1.0,floorf((temp_nframes+ky_offset)*1.0e5/((float)exist(opyres)*fn*nop))/1.0e5)), asset_factor) : FMin(2,1.0,floorf((temp_nframes+ky_offset)*1.0e5/((float)exist(opyres)*fn*nop))/1.0e5);
        } else {
            temp_nframes = (short)(ceilf((float)exist(opyres)*asset_factor/rup_factor)*rup_factor*fn*nop);
            asset_factor  = _asset_factor.fixedflag ?    ((void)(FMin(2,1.0,floorf(temp_nframes*1.0e5/((float)exist(opyres)*fn*nop))/1.0e5)), asset_factor) : FMin(2,1.0,floorf(temp_nframes*1.0e5/((float)exist(opyres)*fn*nop))/1.0e5);
        }
    } else {
        asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
    }

    opautorbw  = _opautorbw.fixedflag ?  ((void)(PSD_OFF), opautorbw) : PSD_OFF;
         
    /* Initialize B0 field for maxwell compensation */
    B0_field = _B0_field.fixedflag ? ((void)(cffield), B0_field) : cffield;
 
    /* Set specs for EPI */
    if ( !strncasecmp("epispec",psd_name,7) ) {
        epispec_flag  = _epispec_flag.fixedflag ?  ((void)(PSD_ON), epispec_flag) : PSD_ON;
    } else {
        epispec_flag  = _epispec_flag.fixedflag ?  ((void)(PSD_OFF), epispec_flag) : PSD_OFF;
    }

    /* Set DVw gradient test */
    if ( !strncasecmp("epigradspec",psd_name,11) ) {
        epigradspec_flag  = _epigradspec_flag.fixedflag ?  ((void)(PSD_ON), epigradspec_flag) : PSD_ON;
    } else {
        epigradspec_flag  = _epigradspec_flag.fixedflag ?  ((void)(PSD_OFF), epigradspec_flag) : PSD_OFF;
    }

    /* MRIhc44418, convolution dbdt model for readout gradient waveform */
    if ( !strncasecmp("epiespopt",psd_name,9) ) {
        epiespopt_flag  = _epiespopt_flag.fixedflag ?  ((void)(PSD_ON), epiespopt_flag) : PSD_ON;
    } else {
        epiespopt_flag  = _epiespopt_flag.fixedflag ?  ((void)(PSD_OFF), epiespopt_flag) : PSD_OFF;
    }
    if ( !strncasecmp("epiRTespopt",psd_name,11) ) {
        epiRTespopt_flag  = _epiRTespopt_flag.fixedflag ?  ((void)(PSD_ON), epiRTespopt_flag) : PSD_ON;
    } else {
        epiRTespopt_flag  = _epiRTespopt_flag.fixedflag ?  ((void)(PSD_OFF), epiRTespopt_flag) : PSD_OFF;
    }
    if ( !strncasecmp("epiminesp",psd_name,9) ) {
        epiminesp_flag  = _epiminesp_flag.fixedflag ?  ((void)(PSD_ON), epiminesp_flag) : PSD_ON;
    } else {
        epiminesp_flag  = _epiminesp_flag.fixedflag ?  ((void)(PSD_OFF), epiminesp_flag) : PSD_OFF;
    }
    if ( !strncasecmp("epiRTminesp",psd_name,11) ) {
        epiRTminesp_flag  = _epiRTminesp_flag.fixedflag ?  ((void)(PSD_ON), epiRTminesp_flag) : PSD_ON;
    } else {
        epiRTminesp_flag  = _epiRTminesp_flag.fixedflag ?  ((void)(PSD_OFF), epiRTminesp_flag) : PSD_OFF;
    }

    /* MRIhc50643 */
    if ( !strncasecmp("epira3",psd_name,6) ) {
        epira3_flag  = _epira3_flag.fixedflag ?  ((void)(PSD_ON), epira3_flag) : PSD_ON;
    } else {
        epira3_flag  = _epira3_flag.fixedflag ?  ((void)(PSD_OFF), epira3_flag) : PSD_OFF;
    }
    if ( !strncasecmp("epiRTra3",psd_name,8) ) {
        epiRTra3_flag  = _epiRTra3_flag.fixedflag ?  ((void)(PSD_ON), epiRTra3_flag) : PSD_ON;
    } else {
        epiRTra3_flag  = _epiRTra3_flag.fixedflag ?  ((void)(PSD_OFF), epiRTra3_flag) : PSD_OFF;
    }

    if((epispec_flag == PSD_ON) || (epiespopt_flag == PSD_ON) || (epiRTespopt_flag == PSD_ON) ||
       (epiminesp_flag == PSD_ON) || (epiRTminesp_flag == PSD_ON) ||
       (cfgcoiltype == PSD_XRMB_COIL))
    {
        dbdt_model  = _dbdt_model.fixedflag ?  ((void)(DBDTMODELCONV), dbdt_model) : DBDTMODELCONV;
    }
    else
    {
        dbdt_model  = _dbdt_model.fixedflag ?  ((void)(DBDTMODELRECT), dbdt_model) : DBDTMODELRECT;
    }

    if (((value_system_flag == VALUE_SYSTEM_SVEM) ||
         (value_system_flag == VALUE_SYSTEM_SVDM)) &&
        (epispec_flag == PSD_ON))
        dbdt_model  = _dbdt_model.fixedflag ?  ((void)(DBDTMODELRECT), dbdt_model) : DBDTMODELRECT; 

    cvmax(opepi, PSD_ON);  /* enable epi flag selection */
    cvdef(opepi, PSD_ON);
    
    /*MRIge85417*/
    cvdef(opautote, PSD_MINTE);

    cvmax(opirprep, PSD_ON); /* enable ir prep flag selection */
    /* MRIge65081 */
    if(opcgate==PSD_ON)
        setexist(opcgate,PSD_ON); 
    else
        setexist(opcgate,PSD_OFF); 
    
    if( Absent == !checkOptionKey( SOK_EPLI ) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "EPI" );
        return FAILURE;
    }
    

/* Start inline from touch.e TouchInit */
    if( (PSD_ON == exist(optouch)) && (Absent == !checkOptionKey(SOK_TOUCH2D)) )
    {
        epic_error(use_ermes, "%s is not available without the option key.", EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "MR-Touch");
        return FAILURE;
    }

    if( PSD_ON == (exist(optouch) && existcv(optouch)) )
    {
        touch_flag  = _touch_flag.fixedflag ?  ((void)(PSD_ON), touch_flag) : PSD_ON;
    }
    else
    {
        touch_flag  = _touch_flag.fixedflag ?  ((void)(PSD_OFF), touch_flag) : PSD_OFF;
    }
/* End inline from touch.e TouchInit */


    /* MRIge82528 */
    cvmax(opfmri,1);

    opslice_order  = _opslice_order.fixedflag ?  ((void)(1), opslice_order) : 1;
    
    /*
     * To allow 512 passes. As many as 999 passes (or phases in mph)
     * can be allowed by replacing this line with: cvmax(rhreps, max_num_pass);
     * ypd
     */
    /*jwg bb may need to increase this if we want lots of timeframes, but should be ok currently*/      
    cvmax(rhreps, 512);    

    enable_1024 = (mph_flag==PSD_ON ? PSD_ON : PSD_OFF);

    if( enable_1024 )
        max_slice_limit = RHF_MAX_IMAGES_MULTIPHASE;
    else
        max_slice_limit = DATA_ACQ_MAX * SLICE_FACTOR;
        
    cvmod(rhnslices, 0, max_slice_limit, 1, "opslquant*optphases*opfphases.", 0, " ");

    cvmod(rhpcspacial, 0, DATA_ACQ_MAX, 1,
          "temporal index of ref scan slice (0=all slices).",0," ");
    cvmod(rhref, 0, 4, 2, "Ref Alg. 0=old, 1=new, 2=N-N sub, 3=pc_per_img, 4=self_nav_dpc",0," ");
    cvmod(opirmode, 0, 1, 0, "Sequential (1) or interleaved (0) mode.",0," ");
    opirmode  = _opirmode.fixedflag ?  ((void)(0), opirmode) : 0;
    
    scan_offset  = _scan_offset.fixedflag ?  ((void)(0), scan_offset) : 0;
    postsat  = _postsat.fixedflag ?  ((void)(PSD_OFF), postsat) : PSD_OFF;
    
    /* initialize configurable variables */
    /* MRIhc18005 */
    EpicConf();
    inittargets(&loggrd, &phygrd);
    inittargets(&epiloggrd, &epiphygrd);
    

    /* update gradient config  */
    if(cfgcoiltype == PSD_XRMW_COIL && epigradspec_flag == PSD_ON)
    {
        if( existcv(opuser1) && ((exist(opuser1) > 2) || (exist(opuser1) < 0) || (exist(opuser1)!=(int)exist(opuser1)))) 
        {
            strcpy(estr, "%s is out of range");
            epic_error(use_ermes,estr,EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Gradient Test (CV1)");
            return FAILURE;
        }
        dvw_grad_test  = _dvw_grad_test.fixedflag ?  ((void)(exist(opuser1)), dvw_grad_test) : exist(opuser1);
        switch(dvw_grad_test)
        {
            case 1: 
                config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_DVW_AMP20SR150), config_update_mode) : CONFIG_UPDATE_TYPE_DVW_AMP20SR150; 
            break;
            case 2: 
                config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_DVW_AMP34SR120), config_update_mode) : CONFIG_UPDATE_TYPE_DVW_AMP34SR120; 
            break;
            default: 
                config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_DVW_DEFAULT), config_update_mode) : CONFIG_UPDATE_TYPE_DVW_DEFAULT; 
            break;
        }
        inittargets(&loggrd, &phygrd);
        inittargets(&epiloggrd, &epiphygrd);
    }

    /* Silent Mode  05/19/2005 YI */
    /* Save configurable variables after conversion by setupConfig() */
    if(set_grad_spec(CONFIG_SAVE,glimit,srate,PSD_ON,debug_grad_spec) == FAILURE)
    {
      epic_error(use_ermes,"Support routine set_grad_spec failed",
        EM_PSD_SUPPORT_FAILURE,1, STRING_ARG,"set_grad_spec");
        return FAILURE;
    }
    /* Get gradient spec for silent mode */
    getSilentSpec(exist(opsilent), _grad_spec_ctrl.fixedflag ? (_temp0_grad_spec_ctrl=grad_spec_ctrl,&_temp0_grad_spec_ctrl) : &grad_spec_ctrl, _glimit.fixedflag ? (_temp1_glimit=glimit,&_temp1_glimit) : &glimit, _srate.fixedflag ? (_temp2_srate=srate,&_temp2_srate) : &srate);
 
    /* MRIhc56520: for EPI with ART on 750w. */
    if (exist(opsilent) && (cffield == B0_30000) && (cfgcoiltype == PSD_XRMW_COIL))
    {
        srate  = _srate.fixedflag ?  ((void)(XRMW_3T_EPI_ART_SR), srate) : XRMW_3T_EPI_ART_SR;
    }

    /* Update configurable variables */
    if(set_grad_spec(grad_spec_ctrl,glimit,srate,PSD_ON,debug_grad_spec) == FAILURE)
    {
      epic_error(use_ermes,"Support routine set_grad_spec failed",
        EM_PSD_SUPPORT_FAILURE,1, STRING_ARG,"set_grad_spec");
        return FAILURE;
    }
    /* Skip setupConfig() if grad_spec_ctrl is turned on */
    if(grad_spec_change_flag) {
        if(grad_spec_ctrl)config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_SKIP), config_update_mode) : CONFIG_UPDATE_TYPE_SKIP;
        else              config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_ACGD_PLUS), config_update_mode) : CONFIG_UPDATE_TYPE_ACGD_PLUS;
        inittargets(&loggrd, &phygrd);
        inittargets(&epiloggrd, &epiphygrd);
    }
    /* End Silent Mode */

    epiphygrd.xrt = cfrmp2xfs;
    epiphygrd.yrt = cfrmp2yfs;
    epiphygrd.zrt = cfrmp2zfs;
    epiphygrd.xft = cffall2x0;
    epiphygrd.yft = cffall2y0;
    epiphygrd.zft = cffall2z0;
    epiloggrd.xrt = epiloggrd.yrt = epiloggrd.zrt =
        IMax(3,cfrmp2xfs,cfrmp2yfs,cfrmp2zfs);
    epiloggrd.xft = epiloggrd.yft = epiloggrd.zft =
        IMax(3,cffall2x0,cffall2y0,cffall2z0);
    
    /* MRIhc18005 */

    /* always set initnewgeo=1 since cvinit (including inittargets) is */
    /* called on transition to scan ops page in 5.5 */
    initnewgeo  = _initnewgeo.fixedflag ?  ((void)(PSD_ON), initnewgeo) : PSD_ON;
    
    /* BJM: save this for next oblopt call with epi loggrd */
    save_newgeo = initnewgeo;
    if (obloptimize_epi(&loggrd, &phygrd, scan_info, exist(opslquant),
                        exist(opplane), exist(opcoax), obl_method,
                        obl_debug, _initnewgeo.fixedflag ? (_temp3_initnewgeo=initnewgeo,&_temp3_initnewgeo) : &initnewgeo, cfsrmode)==FAILURE) { 
        /* maybe rot matrices not set */
        epic_error(use_ermes, "%s failed in %s", EM_PSD_FUNCTION_FAILURE,
                   EE_ARGS(2), STRING_ARG, "obloptimize_epi",
                   STRING_ARG, "cvinit()");

        return FAILURE;
    }
    
    /* BJM: MRIge47073 derate non readout waveforms */
    dbdtderate(&loggrd, 0);
    
    initnewgeo  = _initnewgeo.fixedflag ?  ((void)(save_newgeo), initnewgeo) : save_newgeo;
    if (obloptimize_epi(&epiloggrd, &epiphygrd, scan_info, exist(opslquant),
                        exist(opplane), exist(opcoax), obl_method,
                        obl_debug, _initnewgeo.fixedflag ? (_temp4_initnewgeo=initnewgeo,&_temp4_initnewgeo) : &initnewgeo, cfsrmode)==FAILURE) { 
        /* maybe rot matrices not set */
        epic_error(use_ermes, "%s failed in %s", EM_PSD_FUNCTION_FAILURE,
                   EE_ARGS(2), STRING_ARG, "obloptimize_epi",
                   STRING_ARG, "cvinit()");

        return FAILURE;
    }

    /* GEHmr01833, GEHmr02647 */
    if( (cfgradamp == 8919) &&
        ((value_system_flag == VALUE_SYSTEM_SVEM) ||
         (value_system_flag == VALUE_SYSTEM_SVDM)) )
    {
        if( exist(oppseq) == PSD_SE )
        {
            cfxfd_power_limit = XFD_POWER_LIMIT_SE;
        }
        else
        {
            cfxfd_power_limit = XFD_POWER_LIMIT_GRE;
        }
    }
    else
    {
        cfxfd_power_limit = XFD_POWER_LIMIT;
    }
  
    /* spsp FL90mc or GR30l for excitation, and se1b4 for 
       refocussing */
    cyc_rf1  = _cyc_rf1.fixedflag ?  ((void)(1), cyc_rf1) : 1;
    cyc_rf2  = _cyc_rf2.fixedflag ?  ((void)(1), cyc_rf2) : 1;
    
    if (SpSatInit(vrgsat) == FAILURE) return FAILURE;

    opautoti  = _opautoti.fixedflag ?  ((void)(PSD_OFF), opautoti) : PSD_OFF;

    /* ZZ, activate ASPIR through SPECIAL fat sat option */
    if( PSD_ON == exist(optouch) ) {
        pichemsatopt = 2;
    }
    else {
        pichemsatopt = 0;
    }
     
    { /* Start of code inlined from ChemSat.e ChemSatInit */
        cyc_rfcssat  = _cyc_rfcssat.fixedflag ?  ((void)(1), cyc_rfcssat) : 1;
        alpha_rfcssat  = _alpha_rfcssat.fixedflag ?  ((void)(0.46), alpha_rfcssat) : 0.46;

        /* vmx 3/13/95 YI */
        if(cfpwrmontyp == PMTYP_VMX) 
        {
            csat_sys_type  = _csat_sys_type.fixedflag ?  ((void)(1), csat_sys_type) : 1;
            rfupa = csat_rfupa;
        }
        /* end vmx */
    } /* Start of code inlined from ChemSat.e ChemSatInit */

    {    /* Code inlined from BroadBand.e BBcvinit */
        
        if(cfbbmod == PSD_ON) {
            cvmax(acquire_type, SPECPSD_SLAVE_MNS);
        } else {
            cvmax(acquire_type, SPECPSD_MASTER_H1);
        }

    }    /* End of code inlined from BroadBand.e BBcvinit */

    { /* Start of code inlined from Prescan.e PScvinit */
        /*********************************************************************
         *                     PRESCAN.E HOST SECTION                        *
         *                           PScvinit                                *
         *                                                                   *
         * Write here the code unique to the Host PSD process. All code to   *
         * be executed in cvinit() must be written here.                     *
         *********************************************************************/
        
        cvdef(mpsfov, cfsystemmaxfov);
        cvdef(FTGfov, cfsystemmaxfov);
        
        FTGfov  = _FTGfov.fixedflag ?  ((void)(cfsystemmaxfov), FTGfov) : cfsystemmaxfov;

        PScvinit();
        FTGcvinit();
        XTGcvinit();
        AScvinit();
        RGcvinit();
     } /* End of code inlined from Prescan.e PScvinit */

      
#include "cvinit.in"
  
    pw_sspshift  = _pw_sspshift.fixedflag ?  ((void)(400), pw_sspshift) : 400;   /* pulsewidth of spring for sspwait, Added by MGH. MRIge24538 */
    a_rfcssat  = _a_rfcssat.fixedflag ?  ((void)(.50), a_rfcssat) : .50;
    
    gscale_rf2  = _gscale_rf2.fixedflag ?  ((void)(0.9), gscale_rf2) : 0.9;

    /* ****************************************************
       Advisory Panel 
       
       If piadvise is 1, the advisory panel is supported.
       pimax and pimin are bitmaps that describe which
       advisory panel routines are supported by the psd.
       Scan Rx will activate cardiac gating advisory panel
       values if gating is chosen from the gating screen onward.
       Scan Rx will display the minte2 and maxte2 values 
       if 2 echos are chosen.
       
       Constants for the bitmaps are defined in epic.h
       *********************************************** */
    piadvise = 1; /* Advisory Panel Supported */
    
    /* bit mask for minimum adv. panel values.
     * Scan Rx will remove TE2 entry automatically if 
     * 1 or 4 echos selected. */
    piadvmin = (1<<PSD_ADVECHO) +
        (1<<PSD_ADVTE) + (1<<PSD_ADVTR) +	(1<<PSD_ADVFOV);
    piadvmax = (1<<PSD_ADVECHO) +
        (1<<PSD_ADVTE) + (1<<PSD_ADVTR) +	(1<<PSD_ADVFOV);
    
    /* bit mask for cardiac adv. panel values */
    piadvcard = (1<<PSD_ADVISEQDELAY)
        + (1<<PSD_ADVMAXPHASES) + (1<<PSD_ADVEFFTR) + (1<<PSD_ADVMAXSCANLOCS)
        + (1<<PSD_ADVAVAILIMGTIME);
    
    /* bit mask for scan time adv. panel values */
    piadvtime = (1<<PSD_ADVMINTSCAN) + (1<<PSD_ADVMAXLOCSPERACQ) +
        (1<<PSD_ADVMINACQS) + (1<<PSD_ADVMAXYRES);
    
    /* Default to axial */
    cvdef(opplane, PSD_AXIAL);
    opplane  = _opplane.fixedflag ?  ((void)(PSD_AXIAL), opplane) : PSD_AXIAL;
    
    /* Single echo only */
    piechnub  = 0;
    opnecho  = _opnecho.fixedflag ?  ((void)(1), opnecho) : 1;
    
    /* Enable only the prescan autoshim button and default on, 
     * always keep phase correction on and grey it out */
    pipscoptnub = 1;
    pipscdef = 3;
    _opphcor.fixedflag = PSD_OFF;
    opphcor  = _opphcor.fixedflag ?  ((void)(PSD_ON), opphcor) : PSD_ON;
    cvdef(opphcor, PSD_ON);
    _opphcor.fixedflag = PSD_ON;
    _opphcor.existflag = PSD_ON;
    
    /**** Number of SHOTS ******/
    if (touch_flag) {
        /* only single-shot allowed for MR-Touch */
        pishotnub=2;
        pishotval2=1;
    }
    else{
        /* MRIge50404 - maximum opnshots must be less than 16 with vrgf */
        if (vrgfsamp == PSD_ON) {
            pishotnub = 63;    /* display "other" + 5 shot buttons (bitmask)*/
            pishotval2 = 1;
            pishotval3 = 2;
            pishotval4 = 4;
            pishotval5 = 8;
            pishotval6 = 14;
        } else {
            pishotnub = 63;    /* display "other" + 5 shot buttons (bitmask)*/
            pishotval2 = 1;
            pishotval3 = 2;
            pishotval4 = 4;
            pishotval5 = 8;
            pishotval6 = 16;
        }
    }

    /***** TE UI Button Control *********/ 
    pite1nub = 63;   /* te button bitmask:
                        1       2          4       8 16 32
                        other, automin, autominfull, x, x, x */
    pite1val2 = PSD_MINIMUMTE;    /* 2nd button is autominte */
    pite1val3 = PSD_MINFULLTE;    /* 3rd button is autominte full */
    pitetype = PSD_LABEL_TE_EFF;  /* label te buttons as
                                     "Effective Echo Time" */
    
    if (exist(oppseq) == PSD_SE) {
        pite1val4 = 20000;
        pite1val5 = 60000;
        pite1val6 = 100000;
        pifanub = 0;
        cvoverride(opflip, 90, PSD_FIX_OFF, PSD_EXIST_ON);
        acq_type  = _acq_type.fixedflag ?  ((void)(TYPSPIN), acq_type) : TYPSPIN;
    } else {
        pite1val4 = 20000;
        pite1val5 = 30000;
        pite1val6 = 40000;
        /* flip angle buttons */
        pifanub = 6;
        pifaval2 = 10;
        pifaval3 = 20;
        pifaval4 = 30;
        pifaval5 = 60;
        pifaval6 = 90;
        acq_type  = _acq_type.fixedflag ?  ((void)(TYPGRAD), acq_type) : TYPGRAD;
    }

    /*MRIhc05898 limit flip angle to 70 degree for longbore 3T with BODY
     * or surface coil with spsp pulse*/
    if ((PSD_CRM_COIL == cfgcoiltype) && 
        (TX_COIL_BODY == txCoilInfo[getTxIndex(coilInfo[0])].txCoilType) && 
        exist(opweight) > 130 && PSD_OFF == exist(opfat)  && 
        cffield == B0_30000) 
    {
        if (PSD_SE == exist(oppseq)) {
            pifanub = 0;
            cvoverride(opflip, 70, PSD_FIX_ON, PSD_EXIST_ON);
        }else {
            cvmax(opflip, 70);
            avmaxflip = 70;    
            cvdef(opflip, 70);
        }

        /* SWL : this is added to prevent multiple advisory pop up */
        if (exist(opflip) > avmaxflip)   
        {
            opflip  = _opflip.fixedflag ?  ((void)(avmaxflip), opflip) : avmaxflip;
        }
    }

    /*
     * MRIhc24435: For epispec PSD, limit flip angle to 50 for 3T
     * TRM and CRM and 100 for all the other system configurations.
     */

    if (PSD_ON == epispec_flag)
    {
        if ((B0_30000 == cffield) && ((PSD_CRM_COIL == cfgcoiltype) || (PSD_TRM_COIL == cfgcoiltype)))
        {
            avmaxflip = 50;
            cvmax(opflip, 50);
            cvdef(opflip, 50);
            if (exist(opflip) > avmaxflip) 
            {
                opflip  = _opflip.fixedflag ?  ((void)(avmaxflip), opflip) : avmaxflip;
            }
        }
        else
        {
            avmaxflip = 80;
            cvmax(opflip, 80);
            cvdef(opflip, 80);
            if (exist(opflip) > avmaxflip)
            {
                opflip  = _opflip.fixedflag ?  ((void)(avmaxflip), opflip) : avmaxflip;
            }
        }
    }

    if( (PSD_ON == epispec_flag)
        && (B0_30000 == cffield)
        && (PSD_XRMB_COIL == cfgcoiltype) )
    {
        avmaxflip = 60;
        cvmax(opflip, 60);
        cvdef(opflip, 60);
        if (exist(opflip)>avmaxflip)
        {
            opflip  = _opflip.fixedflag ?  ((void)(avmaxflip), opflip) : avmaxflip;
        }
    }

    /* Reasonable TE defaults */
    cvdef(opte, 110000);
    cvmin(opte, 100);   
    opte  = _opte.fixedflag ?  ((void)(110000), opte) : 110000;
    
    /* Scan TR Values */
    /* use a large default value for tr */
    cvdef(optr, 10000000);
    optr  = _optr.fixedflag ?  ((void)(10000000), optr) : 10000000;

    avmaxti = TI_MAX;
    avminti = TI_MIN;
    cvmax(opti, TI_MAX);
    cvmin(opti, TI_MIN);
    
    /* RBW Options */
    cvmax(oprbw,RBW_MAX);
    oprbw  = _oprbw.fixedflag ?  ((void)(RBW_MAX), oprbw) : RBW_MAX;
    cvdef(oprbw,62.5);
    oprbw  = _oprbw.fixedflag ?  ((void)(62.5), oprbw) : 62.5;
    pidefrbw = 62.5;
    pircb2nub = 0;  /* turn off 2nd echo rbw buttons */
    
    /*JWG change averaging max values here*/
    cvmax(opnex,1024);
    cvmax(ihnex,1024); /*opnex sets nex, nex sets ihnex...*/
    
    /* MGD: +/- 250 Digital */
    pircbnub = 5;
    pircbval2 = 250.0;
    pircbval3 = 166.6;
    pircbval4 = 125.0;
    pircbval5 = 62.5;
    
    /* XRES & YRES Values */
    /*jwg bb change default values to 16-256 from 32-512*/
    piyresnub = 63;
    piyresval2 = 16;
    piyresval3 = 32;
    piyresval4 = 64;
    piyresval5 = 128;
    piyresval6 = 256;
    cvmin(opyres, 16); /*jwg change from 32 to 16*/
    cvmax(opyres, 512);
    cvdef(opyres, 64);
    opyres  = _opyres.fixedflag ?  ((void)(64), opyres) : 64;
    
    pixresnub = 63; /* bitmask */
    pixresval2 = 16;
    pixresval3 = 32;
    pixresval4 = 64;
    pixresval5 = 128;
    pixresval6 = 256;
    cvmin(opxres, 16); /*jwg change from 32 to 16*/
    cvmax(opxres, 512);
    cvdef(opxres, 64);
    cvmax(opslthick,500); /*jwg make large for c13 testing*/
    opxres  = _opxres.fixedflag ?  ((void)(64), opxres) : 64;

    /* FOV buttons */	
    pifovnub = 6;
    pifovval2 = 220;
    pifovval3 = 240;
    pifovval4 = 260;
    pifovval5 = 280;
    pifovval6 = 300;

    if (PSD_SR200 == cfsrmode)
    {
        if (ss_rf1 == PSD_ON)
        {
            pistnub = 6;
            pistval2 = 4;
            pistval3 = 5;
            pistval4 = 6;
            pistval5 = 7;
            pistval6 = 10;
        }
        else
        {
            pistnub = 6;
            pistval2 = 2;
            pistval3 = 3;
            pistval4 = 4;
            pistval5 = 7;
            pistval6 = 10;
        }
    }


    /* MRIge55604 */
    cvmin(opfov, FOV_MIN);
    cvmax(opfov, FOV_MAX_EPI);
    cvdef(opfov, cfsystemmaxfov);
    oprect  = _oprect.fixedflag ?  ((void)(0), oprect) : 0;
    opfov  = _opfov.fixedflag ?  ((void)(cfsystemmaxfov), opfov) : cfsystemmaxfov;

    opslquant  = _opslquant.fixedflag ?  ((void)(1), opslquant) : 1;
    cvmax(opetl, MAXINT);
    
    switch (cfsrmode) {
    case PSD_SR17:
        cvdef(opnshots, 8);
        opnshots  = _opnshots.fixedflag ?  ((void)(8), opnshots) : 8;
        break;
    case PSD_SR20:
    case PSD_SR25:
        cvdef(opnshots, 8);
        opnshots  = _opnshots.fixedflag ?  ((void)(8), opnshots) : 8;
        break;
    case PSD_SR50:
        cvdef(opnshots, 8);
        opnshots  = _opnshots.fixedflag ?  ((void)(8), opnshots) : 8;
        break;
    case PSD_SR77:
        cvdef(opnshots, 4);
        opnshots  = _opnshots.fixedflag ?  ((void)(4), opnshots) : 4;
        break;
    case PSD_SR100: 
    case PSD_SR120:
    case PSD_SR150:
    case PSD_SR200:
        cvdef(opnshots, 1);
        opnshots  = _opnshots.fixedflag ?  ((void)(1), opnshots) : 1;
        cvmax(iheesp, MAXINT);  /* MRIge41058 - latha@mr */
        break;
    default:
        cvdef(opnshots, 8);
        opnshots  = _opnshots.fixedflag ?  ((void)(8), opnshots) : 8;
        break;
    }
    
    cvdef(opslthick, 10.0);
    opslthick  = _opslthick.fixedflag ?  ((void)(10.0), opslthick) : 10.0;
    
    cvmax(rhfrsize, 8192);
    cvmax(rhdaxres, 8192);
    
    /* Multi-Phase CVs */
    cvmax(opmph,1);
    cvdef(opmph,0); /* default to MPH off */
    cvdef(opacqo,0);  /* default to interleaved */
    opacqo  = _opacqo.fixedflag ?  ((void)(0), opacqo) : 0;
    cvdef(opfphases, PHASES_MIN);
    cvmin(opsldelay, -MAXINT); /* YMSmr07177 */
    cvmax(opsldelay,  MAXINT); /* YMSmr07177 */
    cvdef(opsldelay, 1  );
    opsldelay  = _opsldelay.fixedflag ?    ((void)(1), opsldelay) : 1;
    reps  = _reps.fixedflag ?  ((void)(1), reps) : 1;
 
    if ( mph_flag == PSD_ON ) {
        /* screen for MPH option */
        pimphscrn = 1;
        pifphasenub = 6;
        pifphaseval2 = 1;
        pifphaseval3 = 2;
        pifphaseval4 = 5;
        pifphaseval5 = 10;
        pifphaseval6 = 15;
        
        pisldelnub = 6;
        pisldelval3 = 500000;
        pisldelval4 = 1000000;
        pisldelval5 = 2000000;
        pisldelval6 = 5000000;
	
	/*jwg bb set opfphases to leverage the built-in phase loop*/
	/*NOTE: will return to hard-coding this at a later date*/
	/*
	if (existcv(opuser21) && existcv(opuser22))
	{
		pifphasenub = 0; 
   		opfphases = opuser21 * opuser22;
		_opfphases.fixedflag = 1;
		_opfphases.existflag = 1;		 
	}   	
        */
        /* Changed piacqnub from 2 to 3 for Linux-MGD. WGEbg17457 -Venkat*/
        piacqnub = 3; /* acquisition order buttons */ 
       
        prevent_scan_under_emul  = _prevent_scan_under_emul.fixedflag ?  ((void)(0), prevent_scan_under_emul) : 0;

    } else if (exist(opfmri)==PSD_ON) {

        prevent_scan_under_emul  = _prevent_scan_under_emul.fixedflag ?  ((void)(1), prevent_scan_under_emul) : 1;

        pifmriscrn  = _pifmriscrn.fixedflag ?  ((void)(1), pifmriscrn) : 1;
        pifphasenub = 6;

        /* BJM: reasonable pulldowns for fMRI */
        pifphaseval2 = 50;
        pifphaseval3 = 75;
        pifphaseval4 = 100;
        pifphaseval5 = 125;
        pifphaseval6 = 150;

        pisldelnub = 6;
        pisldelval3 = 500000;
        pisldelval4 = 1000000;
        pisldelval5 = 2000000;
        pisldelval6 = 5000000; 

        pirepactivenub  = _pirepactivenub.fixedflag ?  ((void)(1), pirepactivenub) : 1;
        pireprestnub  = _pireprestnub.fixedflag ?  ((void)(1), pireprestnub) : 1;
        piddanub  = _piddanub.fixedflag ?  ((void)(1), piddanub) : 1;
        piinitstatnub  = _piinitstatnub.fixedflag ?  ((void)(1), piinitstatnub) : 1;
        piviewordernub  = _piviewordernub.fixedflag ?  ((void)(1), piviewordernub) : 1;
        pisliceordnub  = _pisliceordnub.fixedflag ?  ((void)(1), pisliceordnub) : 1;
        pipsdtrignub  = _pipsdtrignub.fixedflag ?  ((void)(1), pipsdtrignub) : 1;

    } else {	
        
        pimphscrn = 0; /* do not display the Multi-Phase Parameter screen */
        pifmriscrn  = _pifmriscrn.fixedflag ?  ((void)(0), pifmriscrn) : 0;

        prevent_scan_under_emul  = _prevent_scan_under_emul.fixedflag ?  ((void)(0), prevent_scan_under_emul) : 0; 
    } 

    /* init epigradopt output structure to point to appropriate CVs */
    fprintf(stderr,"LINE 2355, pw_gyb and a_gyb are %d and %f \n",pw_gyb,a_gyb);
    gradout.agxw = _a_gxw.fixedflag ? (_temp5_a_gxw=a_gxw,&_temp5_a_gxw) : &a_gxw;
    gradout.pwgxw = _pw_gxw.fixedflag ? (_temp6_pw_gxw=pw_gxw,&_temp6_pw_gxw) : &pw_gxw;
    gradout.pwgxwa = _pw_gxwad.fixedflag ? (_temp7_pw_gxwad=pw_gxwad,&_temp7_pw_gxwad) : &pw_gxwad;
    gradout.agyb = _a_gyb.fixedflag ? (_temp8_a_gyb=a_gyb,&_temp8_a_gyb) : &a_gyb;
    gradout.pwgyb = _pw_gyb.fixedflag ? (_temp9_pw_gyb=pw_gyb,&_temp9_pw_gyb) : &pw_gyb;
    gradout.pwgyba = _pw_gyba.fixedflag ? (_temp10_pw_gyba=pw_gyba,&_temp10_pw_gyba) : &pw_gyba;
    gradout.frsize = _temprhfrsize.fixedflag ? (_temp11_temprhfrsize=temprhfrsize,&_temp11_temprhfrsize) : &temprhfrsize;
    gradout.pwsamp = _samp_period.fixedflag ? (_temp12_samp_period=samp_period,&_temp12_samp_period) : &samp_period;
    gradout.pwxgap = _pw_gxgap.fixedflag ? (_temp13_pw_gxgap=pw_gxgap,&_temp13_pw_gxgap) : &pw_gxgap;
  
    /* Turn off EP_TRAIN macro elements we don't want */
    pw_gxcla  = _pw_gxcla.fixedflag ?  ((void)(0), pw_gxcla) : 0;
    pw_gxcl  = _pw_gxcl.fixedflag ?  ((void)(0), pw_gxcl) : 0;
    pw_gxcld  = _pw_gxcld.fixedflag ?  ((void)(0), pw_gxcld) : 0;
    a_gxcl  = _a_gxcl.fixedflag ?  ((void)(0), a_gxcl) : 0;
    pw_gxwl  = _pw_gxwl.fixedflag ?  ((void)(0), pw_gxwl) : 0;
    pw_gxwr  = _pw_gxwr.fixedflag ?  ((void)(0), pw_gxwr) : 0;
    pw_gxgap  = _pw_gxgap.fixedflag ?  ((void)(0), pw_gxgap) : 0;
    pw_gxcra  = _pw_gxcra.fixedflag ?  ((void)(0), pw_gxcra) : 0;
    pw_gxcr  = _pw_gxcr.fixedflag ?  ((void)(0), pw_gxcr) : 0;
    pw_gxcrd  = _pw_gxcrd.fixedflag ?  ((void)(0), pw_gxcrd) : 0;
    a_gxcr  = _a_gxcr.fixedflag ?  ((void)(.0), a_gxcr) : .0;
    
    /* Opuser CV PAGE control */
    piuset |= use0;     
    pititle  = _pititle.fixedflag ?  ((void)(1), pititle) : 1;       /* Since this is MGD - we can always have ramp samp */
    
    cvdesc(pititle, "EPI Advanced Feature Controls:");
    
    /* Only 30 characters per CV are displayed on user CV screen, thats it!
       "123456789012345678901234567890" */
    cvmod(opuser0, 0.0, 1.0, 1.0, "Ramp Sampling (1=on, 0=off)",0," ");
    opuser0  = _opuser0.fixedflag ?  ((void)(1), opuser0) : 1;

    if(epigradspec_flag == PSD_ON && cfgcoiltype == PSD_XRMW_COIL)
    {
        piuset = piuset | use1;     
        cvmod(opuser1, 0.0, 2.0, 0.0, "Gradient Test (0=DEFAULT, 1=GMAX20SR150, 2=GMAX34SR120)",0," ");
        opuser1  = _opuser1.fixedflag ?  ((void)(0), opuser1) : 0;
    }
    else
    {
        piuset = piuset & (~use1);
        cvmod( opuser1, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 1", 0, "" );
        cvoverride(opuser1, _opuser1.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
    }
    
    /* MRIge59852: opuser0 range check */
    /* MRIge71092 */
    if( existcv(opuser0) && ((exist(opuser0) > 1) || (exist(opuser0) < 0) || (exist(opuser0)!=(int)exist(opuser0)))) {
        strcpy(estr, "%s must be set to either 0 or 1.");
        epic_error(use_ermes,estr,EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Ramp Sampling");
        return FAILURE;
    }

    /* Added for spsp fatsat pulse */
    if (B0_30000 == cffield)
    {
        if(PSD_ON == exist(opfat) && (PSD_ON == exist(opmph) || PSD_ON == exist(opfmri) || PSD_ON == exist(opdynaplan)))
        {
    	    piuset = piuset | use4;
            cvmod(opuser4, 0.0, 1.0, 0.0, "Spectral-Spatial FatSat (1=on, 0=off)",0," ");
            opuser4  = _opuser4.fixedflag ?  ((void)(0), opuser4) : 0;

            if( existcv(opuser4) && ((exist(opuser4) > 1) || (exist(opuser4) < 0) || (exist(opuser4)!=(int)exist(opuser4)))) 
            {
                strcpy(estr, "%s must be set to either 0 or 1.");
                epic_error(use_ermes,estr,EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Spectral-Spatial FatSat");
                return FAILURE;
            }
            use_spsp_fatsat  = _use_spsp_fatsat.fixedflag ?  ((void)((int)exist(opuser4)), use_spsp_fatsat) : (int)exist(opuser4);
        }
        else
        {
    	    piuset = piuset & (~use4);
            cvmod( opuser4, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 4", 0, "" );
            cvoverride(opuser4, _opuser4.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            use_spsp_fatsat  = _use_spsp_fatsat.fixedflag ?  ((void)(0), use_spsp_fatsat) : 0;
        }
    }
    else
    {
        piuset = piuset & (~use4);
        cvmod( opuser4, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 4", 0, "" );
        cvoverride(opuser4, _opuser4.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        use_spsp_fatsat  = _use_spsp_fatsat.fixedflag ?  ((void)(0), use_spsp_fatsat) : 0;
    }

    /* HCSDM00082374 */
    {
        static int old_taratio_override;

        old_taratio_override = taratio_override;

        if ((PSD_XRMW_COIL == cfgcoiltype) && (PSD_OFF == touch_flag) && (PSD_ON == vrgfsamp) && (PSD_ON == rampopt))
        {
            piuset = piuset | use6;
            cvmod(opuser6, 0.0, 1.0, 0.0, "Max # Slices Optimization (1=on, 0=off)",0," ");
            opuser6  = _opuser6.fixedflag ?  ((void)(0), opuser6) : 0;

            if (existcv(opuser6) && ((exist(opuser6) > 1) || (exist(opuser6) < 0) || (exist(opuser6)!=(int)exist(opuser6))))
            {
                strcpy(estr, "%s must be set to either 0 or 1.");
                epic_error(use_ermes,estr,EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Max # Slices Optimization");
                return FAILURE;
            }

            taratio_override  = _taratio_override.fixedflag ?  ((void)(exist(opuser6)), taratio_override) : exist(opuser6);
        }
        else
        {
            piuset = piuset & (~use6);
            cvmod( opuser6, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 6", 0, "" );
            cvoverride(opuser6, _opuser6.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            taratio_override  = _taratio_override.fixedflag ?  ((void)(PSD_OFF), taratio_override) : PSD_OFF;
        }

        if (taratio_override != old_taratio_override)
        {
            set_cvs_changed_flag( TRUE );
        }
    }

    /* MRIhc55403 */
    if(PSD_ON == epira3_flag || PSD_ON == epiRTra3_flag)
    {
        if(cfgcoiltype == PSD_XRMB_COIL)
        {
            piuset = piuset | use7;
            cvmod(opuser7, 0.0, 1.0, 1.0, "Echo Spacing (Legacy=0, Minimized=1)",0," ");
            opuser7  = _opuser7.fixedflag ?  ((void)(1), opuser7) : 1;

            if( existcv(opuser7) && ((exist(opuser7) > 1) || (exist(opuser7) < 0) || (exist(opuser7)!=(int)exist(opuser7))))
            {
                strcpy(estr, "%s must be set to either 0 or 1.");
                epic_error(use_ermes,estr,EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Legacy or minimized echo-spacing");
                return FAILURE;
            }
            ra3_minesp_flag  = _ra3_minesp_flag.fixedflag ?  ((void)((int)exist(opuser7)), ra3_minesp_flag) : (int)exist(opuser7);
            if(PSD_ON == ra3_minesp_flag)
            {
                dbdt_model  = _dbdt_model.fixedflag ?  ((void)(DBDTMODELCONV), dbdt_model) : DBDTMODELCONV;
            }
            else
            {
                dbdt_model  = _dbdt_model.fixedflag ?  ((void)(DBDTMODELRECT), dbdt_model) : DBDTMODELRECT;
            }
        }
        else 
        {
            piuset = piuset & (~use7);
            cvmod( opuser7, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 7", 0, "" );
            cvoverride(opuser7, _opuser7.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            ra3_minesp_flag  = _ra3_minesp_flag.fixedflag ?  ((void)(0), ra3_minesp_flag) : 0;
        }

        piuset = piuset | use8;
        cvmod(opuser8, 0.0, 1.0, 0.0, "Phase Correction (Legacy=0, New=1)",0," ");
        opuser8  = _opuser8.fixedflag ?  ((void)(0), opuser8) : 0;

        if( existcv(opuser8) && ((exist(opuser8) > 1) || (exist(opuser8) < 0) || (exist(opuser8)!=(int)exist(opuser8))))
        {
            strcpy(estr, "%s must be set to either 0 or 1.");
            epic_error(use_ermes,estr,EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Legacy or new phase correction");
            return FAILURE;
        }
        ra3_sndpc_flag  = _ra3_sndpc_flag.fixedflag ?  ((void)((int)exist(opuser8)), ra3_sndpc_flag) : (int)exist(opuser8);
    }
    else
    {
        piuset = piuset & (~use7);
        cvmod( opuser7, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 7", 0, "" );
        cvoverride(opuser7, _opuser7.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        piuset = piuset & (~use8);
        cvmod( opuser8, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 8", 0, "" );
        cvoverride(opuser8, _opuser8.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
    }

    /*jwg bb opusercvs*/
    /*opuser20 will control external RF waveforms*/
    /* 1: 1H spsp, from macro; 
       2: sinc; 
       3: or_pass;
       4: complex spsp
       98: magnitude test spsp pulse
       99: complex test spsp pulse */
    cvmod(opuser20, 0, 99, 0, "External RF Waveform",0,"Invalid external waveform");    
    piuset |= use20;
    
    /*opuser21 controls # species to acquire*/
    cvmod(opuser21, 1, 5, 1, "Number of HP species to acquire",0,"Invalid # of metabolites");    
    _opuser21.defval = 1;
    piuset |= use21;
    num_mets  = _num_mets.fixedflag ?  ((void)((int)opuser21), num_mets) : (int)opuser21;
    
    /*opuser22 controls the number of dynamic timeframes to acquire*/
    cvmod(opuser22, 1, 100, 1, "Number of timeframes to acquire",0,"Invalid # of timeframes");    
    piuset |= use22; 
    num_frames  = _num_frames.fixedflag ?  ((void)((int)opuser22), num_frames) : (int)opuser22;
    
    /*opuser23 lets the user control the BW during a ramp sampled EPI*/
    cvmod(opuser23, 0, 1, 0, "User control of BW during ramp sampled EPI (1 = yes)",0,"User controlled BW opuser23");    
    piuset |= use23;     
    
    /*opuser24 Disable internal reference scan, DONT want this for C13 studies. Retained for 1H functionality*/
    cvmod(opuser24, 0, 1, 0, "Enable internal reference scan (1 = ENABLED)",0,"Enable iref_etl opuser24");    
    piuset |= use24;       
    enable_iref_etl  = _enable_iref_etl.fixedflag ?  ((void)((int)opuser24), enable_iref_etl) : (int)opuser24;
    
    /*jwg bb this cv should enable overlapped slices, see epic.h*/
    pioverlap  = _pioverlap.fixedflag ?  ((void)(1), pioverlap) : 1;
        
    /*opuser25 Enable VFA schemes*/
    cvmod(opuser25, 0, 99, 0, "Enable VFA Scheme (0 = Same flip for all freqs)",0,"vfa scheme opuser25");    
    piuset |= use25;       
    vfa_flag  = _vfa_flag.fixedflag ?  ((void)((int)opuser25), vfa_flag) : (int)opuser25;    
    
    /*opuser25 Enable VFA SAKE undersampling*/
    cvmod(opuser26, 0, 99, 0, "Enable SAKE undersampling (0 = off, 1-99 on)",0,"sake scheme opuser26");    
    piuset |= use26;       
    sake_flag  = _sake_flag.fixedflag ?  ((void)((int)opuser26), sake_flag) : (int)opuser26;      
    /*jwg bb sake force MINTE if and only if we're running SAKE*/
    if(sake_flag > 0) 
    {
    	cvoverride(opautote,PSD_MINTE, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
    	cvunlock(opautote);
    }
    
    /*jwg bb force opfphases to equal num_freqs X num_frames to leverage the built-in phase loop*/
    if (existcv(opuser21) && existcv(opuser22))
    {
    	cvoverride(opfphases,(opuser21 * opuser22), PSD_FIX_ON, PSD_EXIST_ON);
    }   	
    
    /*jwg end*/
    

    if(exist(opfmri) == PSD_ON) {

        /* Prevent users from selecting fMRI w/ EPI */
        /* Can only select fMRI with epiRT pulse sequence */
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "fMRI", STRING_ARG, "EPI (must use epiRT)" );
        return FAILURE;
    }

    /* MERGE EXT TRIGGER */

    if( !strncasecmp( "epi_trig", psd_name, 8 ) ) {
        cvdef(ext_trig, PSD_ON); 
        ext_trig  = _ext_trig.fixedflag ?  ((void)(PSD_ON), ext_trig) : PSD_ON;
    
        /* ext_trig range check */
        if(( existcv(ext_trig) && ((exist(ext_trig) > 1) || (exist(ext_trig) < 0)))) {
            strcpy(estr, " Invalid psd_trig entry - select again... ");
            epic_error(0,estr,EM_PSD_INVALID_RX, 0);
            return FAILURE;
        }
    } 
    /* END - MERGE EXT TRIGGER */



    if(exist(opfmri) == PSD_ON && exist(opirprep) == PSD_ON) {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "FMRI", STRING_ARG, "IR Prepared" );
        return FAILURE;
    }

    if(exist(opfmri) == PSD_ON && exist(opcgate) == PSD_ON) {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "FMRI", STRING_ARG, "Cardiac Gating/Triggering" );
        return FAILURE;
    }
    
    /* Check for Cal files */
    if(epiCalFileCVInit() != SUCCESS) return FAILURE;

    /* Set cvxfull, cvyfull, cvzfull for blipcorr() */
    cvxfull  = _cvxfull.fixedflag ?  ((void)(cfxfull), cvxfull) : cfxfull;
    cvyfull  = _cvyfull.fixedflag ?  ((void)(cfyfull), cvyfull) : cfyfull;
    cvzfull  = _cvzfull.fixedflag ?  ((void)(cfzfull), cvzfull) : cfzfull;
    
#if defined(RT) && defined(LIM_PROTOCOLS)
    if (lim_protocol() == FAILURE) {
        /* don't send ermes so that underlying ermes will be displayed */
        return FAILURE;
    }
#else
    if( (mph_flag == PSD_ON) && ((opfphases * opslquant) > 2048) ) 
    { 
        if(mph_protocol() == FAILURE) {
            /* don't send ermes so that underlying ermes will be displayed */
            return FAILURE;
        }
    }
#endif

    if( (PSD_OFF == pircbnub) && (PSD_OFF == exist(opautorbw)) )
    {
        opautorbw  = _opautorbw.fixedflag ?  ((void)(PSD_ON), opautorbw) : PSD_ON;
    }

    /* MRIhc44418 */
    reopt_flag = PSD_ON;
    total_gradopt_count = 0;

    if((cfgcoiltype == PSD_XRMB_COIL || cfgcoiltype == PSD_XRMW_COIL) && (epispec_flag == PSD_OFF))
    {
        ss_fa_scaling_flag  = _ss_fa_scaling_flag.fixedflag ?  ((void)(PSD_ON), ss_fa_scaling_flag) : PSD_ON;
    }
    else
    {
        ss_fa_scaling_flag  = _ss_fa_scaling_flag.fixedflag ?  ((void)(PSD_OFF), ss_fa_scaling_flag) : PSD_OFF;
    }

    return SUCCESS;
    
}  /* end CVINIT */


float sat_info[6][9];
float abswidth_sat, effwidth_sat; /* Abs width and Eff Width for Sat pulses */

/* Routine to initialize RF pulse structures */
void
sp_init_rf( INT *pw_ptr,
            FLOAT *amp_ptr,
            FLOAT *flip_ptr,
            INT type,
            RF_PULSE *rfstruct )
{
    switch (type)
    {
    case SINC_SAT:
        *amp_ptr = 1.0;
        rfstruct->pw = pw_ptr;
        rfstruct->amp = amp_ptr;
        rfstruct->abswidth = SAR_ABS_SINC1;
        rfstruct->effwidth = SAR_PSINC1;
        rfstruct->area     = SAR_ASINC1;
        rfstruct->dtycyc   = SAR_DTYCYC_SINC1;
        rfstruct->maxpw    = SAR_MAXPW_SINC1;
        rfstruct->num      = 0;
        rfstruct->max_b1 = 0.073;
        rfstruct->max_int_b1_sq = 0.00345;
        rfstruct->max_rms_b1 = 0.0328;
        rfstruct->nom_fa = 90.0;
        rfstruct->act_fa = flip_ptr;
        rfstruct->nom_pw = 3200 ;
        rfstruct->nom_bw = 1250.0;
        rfstruct->activity = PSD_PULSE_OFF;
        rfstruct->reference = TRUE;
        sat_pulse_type  = _sat_pulse_type.fixedflag ?  ((void)(REAL_RF), sat_pulse_type) : REAL_RF;
        break;
 
    case SLR_SAT:
        *amp_ptr = 1.0;
        rfstruct->pw = pw_ptr;
        rfstruct->amp = amp_ptr;
        rfstruct->abswidth = SAR_ABS_SLR;
        rfstruct->effwidth = SAR_PSLR;
        rfstruct->area     = SAR_ASLR;
        rfstruct->dtycyc   = SAR_DTYCYC_SLR;
        rfstruct->maxpw    = SAR_MAXPW_SLR;
        rfstruct->max_b1 = MAX_B1_DBLSATL0;
        rfstruct->max_int_b1_sq = MAX_INT_B1_SQ_DBLSATL0;
        rfstruct->max_rms_b1 = MAX_RMS_B1_DBLSATL0;
        rfstruct->nom_fa = 90.0;
        rfstruct->act_fa = flip_ptr;
        rfstruct->nom_pw = 4000 ;
        rfstruct->nom_bw = 1562.0;
        rfstruct->activity = PSD_PULSE_OFF;
        rfstruct->reference = TRUE;
        rfstruct->num      = 0;
        sat_pulse_type  = _sat_pulse_type.fixedflag ?  ((void)(REAL_RF), sat_pulse_type) : REAL_RF;
        break;

    case SLR_CSAT:
        *amp_ptr = 1.0;
        rfstruct->pw = pw_ptr;
        rfstruct->amp = amp_ptr;
        rfstruct->abswidth = 0.3472;
        rfstruct->effwidth = 0.2506;
        rfstruct->area     = 0.3472;
        rfstruct->dtycyc   = 0.9960;
        rfstruct->maxpw    = 0.9960;
        rfstruct->max_b1 = 0.105;
        rfstruct->max_int_b1_sq = 0.00179175;
        rfstruct->max_rms_b1 = 0.0211646;
        rfstruct->nom_fa = 90.0;
        rfstruct->act_fa = flip_ptr;
        rfstruct->nom_pw = 4000 ;
        rfstruct->nom_bw = 3000.0;
        rfstruct->activity = PSD_PULSE_OFF;
        rfstruct->reference = FALSE;
        rfstruct->num      = 0;
        sat_pulse_type  = _sat_pulse_type.fixedflag ?  ((void)(COMPLEX_RF), sat_pulse_type) : COMPLEX_RF;
        break;

    default:
        break;
    }
    
    abswidth_sat = rfstruct->abswidth; 
    effwidth_sat = rfstruct->effwidth;
    
    return;
}

STATUS
SpSatInit( INT sat_type )
{
#ifdef ERMES_DEBUG
    use_ermes  = _use_ermes.fixedflag ?  ((void)(0), use_ermes) : 0;
#else /* !ERMES_DEBUG */
    use_ermes  = _use_ermes.fixedflag ?  ((void)(1), use_ermes) : 1;
#endif /* ERMES_DEBUG */

    /* vmx 3/13/95 YI */
    if( cfpwrmontyp == PMTYP_VMX ) 
    {
        spsat_sys_type  = _spsat_sys_type.fixedflag ?  ((void)(1), spsat_sys_type) : 1;
        rfupa = spsat_rfupa;
    }
    /* end vmx */

    /* Note that pw_isisat & pw_rotdelay must be multiples of 4. Otherwise
       gradients do not occur on 4us boundaries that are required. */
    pw_isisat  = _pw_isisat.fixedflag ?    ((void)(RUP_GRD(200)), pw_isisat) : RUP_GRD(200); /*MRIge61221, SK */

    /* Calculate delay of rotation matrix relative to total SSP delay */
    isi_satdelay  = _isi_satdelay.fixedflag ?    ((void)(RDN_GRD(pw_isisat-psd_grd_wait)), isi_satdelay) : RDN_GRD(pw_isisat-psd_grd_wait);
    isi_extra  = _isi_extra.fixedflag ?    ((void)(32), isi_extra) : 32;     /* Make sure 32us after rot. update before
                             next gradient attack */

    rot_delay  = _rot_delay.fixedflag ?  ((void)(RUP_GRD(psd_grd_wait)), rot_delay) : RUP_GRD(psd_grd_wait); /* Make sure that rotation is done after
                                          gradient delay has been delayed in
                                          WARP */
    pw_rotupdate  = _pw_rotupdate.fixedflag ?    ((void)(RUP_GRD(12)), pw_rotupdate) : RUP_GRD(12); /* MRIge61221 , SK */

    /* MRIge77195 Changed default SAT thickness to 40mm */
    satthickx1  = _satthickx1.fixedflag ?  ((void)(40), satthickx1) : 40;  /* Default SAT thickness */
    satthickx2  = _satthickx2.fixedflag ?  ((void)(40), satthickx2) : 40;
    satthicky1  = _satthicky1.fixedflag ?  ((void)(40), satthicky1) : 40;
    satthicky2  = _satthicky2.fixedflag ?  ((void)(40), satthicky2) : 40;
    satthickz1  = _satthickz1.fixedflag ?  ((void)(40), satthickz1) : 40;
    satthickz2  = _satthickz2.fixedflag ?  ((void)(40), satthickz2) : 40;

    exsatthick1  = _exsatthick1.fixedflag ?  ((void)(80), exsatthick1) : 80; /* Explicit SAT thickness */
    exsatthick2  = _exsatthick2.fixedflag ?  ((void)(80), exsatthick2) : 80;
    exsatthick3  = _exsatthick3.fixedflag ?  ((void)(80), exsatthick3) : 80;
    exsatthick4  = _exsatthick4.fixedflag ?  ((void)(80), exsatthick4) : 80;
    exsatthick5  = _exsatthick5.fixedflag ?  ((void)(80), exsatthick5) : 80;
    exsatthick6  = _exsatthick6.fixedflag ?  ((void)(80), exsatthick6) : 80;
 
    gsat_scale  = _gsat_scale.fixedflag ?  ((void)(1), gsat_scale) : 1;

    flip_rfsx1  = _flip_rfsx1.fixedflag ?  ((void)(90.0), flip_rfsx1) : 90.0; /* Default SAT flip angles */
    flip_rfsx2  = _flip_rfsx2.fixedflag ?  ((void)(90.0), flip_rfsx2) : 90.0;
    flip_rfsy1  = _flip_rfsy1.fixedflag ?  ((void)(90.0), flip_rfsy1) : 90.0;
    flip_rfsy2  = _flip_rfsy2.fixedflag ?  ((void)(90.0), flip_rfsy2) : 90.0;
    flip_rfsz1  = _flip_rfsz1.fixedflag ?  ((void)(90.0), flip_rfsz1) : 90.0;
    flip_rfsz2  = _flip_rfsz2.fixedflag ?  ((void)(90.0), flip_rfsz2) : 90.0;

    flip_rfse1  = _flip_rfse1.fixedflag ?  ((void)(90.0), flip_rfse1) : 90.0; /* Explicit SAT slip angles */
    flip_rfse2  = _flip_rfse2.fixedflag ?  ((void)(90.0), flip_rfse2) : 90.0;
    flip_rfse3  = _flip_rfse3.fixedflag ?  ((void)(90.0), flip_rfse3) : 90.0;
    flip_rfse4  = _flip_rfse4.fixedflag ?  ((void)(90.0), flip_rfse4) : 90.0;
    flip_rfse5  = _flip_rfse5.fixedflag ?  ((void)(90.0), flip_rfse5) : 90.0;
    flip_rfse6  = _flip_rfse6.fixedflag ?  ((void)(90.0), flip_rfse6) : 90.0;
  
    if (opfluorotrigger)
    {
        flip_rfsx1  = _flip_rfsx1.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfsx1) : rtia3d_sat_flip; /* Default SAT flip angles */
        flip_rfsx2  = _flip_rfsx2.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfsx2) : rtia3d_sat_flip;
        flip_rfsy1  = _flip_rfsy1.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfsy1) : rtia3d_sat_flip;
        flip_rfsy2  = _flip_rfsy2.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfsy2) : rtia3d_sat_flip;
        flip_rfsz1  = _flip_rfsz1.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfsz1) : rtia3d_sat_flip;
        flip_rfsz2  = _flip_rfsz2.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfsz2) : rtia3d_sat_flip;

        flip_rfse1  = _flip_rfse1.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfse1) : rtia3d_sat_flip; /* Explicit SAT slip angles */
        flip_rfse2  = _flip_rfse2.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfse2) : rtia3d_sat_flip;
        flip_rfse3  = _flip_rfse3.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfse3) : rtia3d_sat_flip;
        flip_rfse4  = _flip_rfse4.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfse4) : rtia3d_sat_flip;
        flip_rfse5  = _flip_rfse5.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfse5) : rtia3d_sat_flip;
        flip_rfse6  = _flip_rfse6.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfse6) : rtia3d_sat_flip;
    }
 
    /* Initialize resolutions for rf pulse & 
       RF pulse structure in grad_rf_data.h */
    switch (sat_type)
    {
    case SINC_SAT:
        res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsx1) : RES_NVRGSAT;
        res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsx2) : RES_NVRGSAT;
        res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsy1) : RES_NVRGSAT;
        res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsy2) : RES_NVRGSAT;
        res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsz1) : RES_NVRGSAT;
        res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsz2) : RES_NVRGSAT;
        res_rfse1  = _res_rfse1.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse1) : RES_NVRGSAT;
        res_rfse2  = _res_rfse2.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse2) : RES_NVRGSAT;
        res_rfse3  = _res_rfse3.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse3) : RES_NVRGSAT;
        res_rfse4  = _res_rfse4.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse4) : RES_NVRGSAT;
        res_rfse5  = _res_rfse5.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse5) : RES_NVRGSAT;
        res_rfse6  = _res_rfse6.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse6) : RES_NVRGSAT;

        pw_rfs  = _pw_rfs.fixedflag ?   ((void)(3200), pw_rfs) : 3200;
        if(lp_mode ==1)
        {
            pw_rfs = _pw_rfs.fixedflag ? ((void)(lp_stretch*pw_rfs), pw_rfs) : lp_stretch*pw_rfs;
        }

        cyc_rfs  = _cyc_rfs.fixedflag ?  ((void)(1), cyc_rfs) : 1;

        sp_init_rf(_pw_rfsx1.fixedflag ? (_temp14_pw_rfsx1=pw_rfsx1,&_temp14_pw_rfsx1) : &pw_rfsx1, _a_rfsx1.fixedflag ? (_temp15_a_rfsx1=a_rfsx1,&_temp15_a_rfsx1) : &a_rfsx1, _flip_rfsx1.fixedflag ? (_temp16_flip_rfsx1=flip_rfsx1,&_temp16_flip_rfsx1) : &flip_rfsx1, SINC_SAT,
                   &rfpulse[RFSX1_SLOT]);
        sp_init_rf(_pw_rfsx2.fixedflag ? (_temp17_pw_rfsx2=pw_rfsx2,&_temp17_pw_rfsx2) : &pw_rfsx2, _a_rfsx2.fixedflag ? (_temp18_a_rfsx2=a_rfsx2,&_temp18_a_rfsx2) : &a_rfsx2, _flip_rfsx2.fixedflag ? (_temp19_flip_rfsx2=flip_rfsx2,&_temp19_flip_rfsx2) : &flip_rfsx2, SINC_SAT,
                   &rfpulse[RFSX2_SLOT]);
        sp_init_rf(_pw_rfsy1.fixedflag ? (_temp20_pw_rfsy1=pw_rfsy1,&_temp20_pw_rfsy1) : &pw_rfsy1, _a_rfsy1.fixedflag ? (_temp21_a_rfsy1=a_rfsy1,&_temp21_a_rfsy1) : &a_rfsy1, _flip_rfsy1.fixedflag ? (_temp22_flip_rfsy1=flip_rfsy1,&_temp22_flip_rfsy1) : &flip_rfsy1, SINC_SAT,
                   &rfpulse[RFSY1_SLOT]);
        sp_init_rf(_pw_rfsy2.fixedflag ? (_temp23_pw_rfsy2=pw_rfsy2,&_temp23_pw_rfsy2) : &pw_rfsy2, _a_rfsy2.fixedflag ? (_temp24_a_rfsy2=a_rfsy2,&_temp24_a_rfsy2) : &a_rfsy2, _flip_rfsy2.fixedflag ? (_temp25_flip_rfsy2=flip_rfsy2,&_temp25_flip_rfsy2) : &flip_rfsy2, SINC_SAT,
                   &rfpulse[RFSY2_SLOT]);
        sp_init_rf(_pw_rfsz1.fixedflag ? (_temp26_pw_rfsz1=pw_rfsz1,&_temp26_pw_rfsz1) : &pw_rfsz1, _a_rfsz1.fixedflag ? (_temp27_a_rfsz1=a_rfsz1,&_temp27_a_rfsz1) : &a_rfsz1, _flip_rfsz1.fixedflag ? (_temp28_flip_rfsz1=flip_rfsz1,&_temp28_flip_rfsz1) : &flip_rfsz1, SINC_SAT,
                   &rfpulse[RFSZ1_SLOT]);
        sp_init_rf(_pw_rfsz2.fixedflag ? (_temp29_pw_rfsz2=pw_rfsz2,&_temp29_pw_rfsz2) : &pw_rfsz2, _a_rfsz2.fixedflag ? (_temp30_a_rfsz2=a_rfsz2,&_temp30_a_rfsz2) : &a_rfsz2, _flip_rfsz2.fixedflag ? (_temp31_flip_rfsz2=flip_rfsz2,&_temp31_flip_rfsz2) : &flip_rfsz2, SINC_SAT,
                   &rfpulse[RFSZ2_SLOT]);
        sp_init_rf(_pw_rfse1.fixedflag ? (_temp32_pw_rfse1=pw_rfse1,&_temp32_pw_rfse1) : &pw_rfse1, _a_rfse1.fixedflag ? (_temp33_a_rfse1=a_rfse1,&_temp33_a_rfse1) : &a_rfse1, _flip_rfse1.fixedflag ? (_temp34_flip_rfse1=flip_rfse1,&_temp34_flip_rfse1) : &flip_rfse1, SINC_SAT,
                   &rfpulse[RFSE1_SLOT]);
        sp_init_rf(_pw_rfse2.fixedflag ? (_temp35_pw_rfse2=pw_rfse2,&_temp35_pw_rfse2) : &pw_rfse2, _a_rfse2.fixedflag ? (_temp36_a_rfse2=a_rfse2,&_temp36_a_rfse2) : &a_rfse2, _flip_rfse2.fixedflag ? (_temp37_flip_rfse2=flip_rfse2,&_temp37_flip_rfse2) : &flip_rfse2, SINC_SAT,
                   &rfpulse[RFSE2_SLOT]);
        sp_init_rf(_pw_rfse3.fixedflag ? (_temp38_pw_rfse3=pw_rfse3,&_temp38_pw_rfse3) : &pw_rfse3, _a_rfse3.fixedflag ? (_temp39_a_rfse3=a_rfse3,&_temp39_a_rfse3) : &a_rfse3, _flip_rfse3.fixedflag ? (_temp40_flip_rfse3=flip_rfse3,&_temp40_flip_rfse3) : &flip_rfse3, SINC_SAT,
                   &rfpulse[RFSE3_SLOT]);
        sp_init_rf(_pw_rfse4.fixedflag ? (_temp41_pw_rfse4=pw_rfse4,&_temp41_pw_rfse4) : &pw_rfse4, _a_rfse4.fixedflag ? (_temp42_a_rfse4=a_rfse4,&_temp42_a_rfse4) : &a_rfse4, _flip_rfse4.fixedflag ? (_temp43_flip_rfse4=flip_rfse4,&_temp43_flip_rfse4) : &flip_rfse4, SINC_SAT,
                   &rfpulse[RFSE4_SLOT]);
        sp_init_rf(_pw_rfse5.fixedflag ? (_temp44_pw_rfse5=pw_rfse5,&_temp44_pw_rfse5) : &pw_rfse5, _a_rfse5.fixedflag ? (_temp45_a_rfse5=a_rfse5,&_temp45_a_rfse5) : &a_rfse5, _flip_rfse5.fixedflag ? (_temp46_flip_rfse5=flip_rfse5,&_temp46_flip_rfse5) : &flip_rfse5, SINC_SAT,
                   &rfpulse[RFSE5_SLOT]);
        sp_init_rf(_pw_rfse6.fixedflag ? (_temp47_pw_rfse6=pw_rfse6,&_temp47_pw_rfse6) : &pw_rfse6, _a_rfse6.fixedflag ? (_temp48_a_rfse6=a_rfse6,&_temp48_a_rfse6) : &a_rfse6, _flip_rfse6.fixedflag ? (_temp49_flip_rfse6=flip_rfse6,&_temp49_flip_rfse6) : &flip_rfse6, SINC_SAT,
                   &rfpulse[RFSE6_SLOT]);
        break;

    case SLR_SAT:
        res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsx1) : RES_SLRSAT;
        res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsx2) : RES_SLRSAT;
        res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsy1) : RES_SLRSAT;
        res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsy2) : RES_SLRSAT;
        res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsz1) : RES_SLRSAT;
        res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsz2) : RES_SLRSAT;
        res_rfse1  = _res_rfse1.fixedflag ?  ((void)(RES_SLRSAT), res_rfse1) : RES_SLRSAT;
        res_rfse2  = _res_rfse2.fixedflag ?  ((void)(RES_SLRSAT), res_rfse2) : RES_SLRSAT;
        res_rfse3  = _res_rfse3.fixedflag ?  ((void)(RES_SLRSAT), res_rfse3) : RES_SLRSAT;
        res_rfse4  = _res_rfse4.fixedflag ?  ((void)(RES_SLRSAT), res_rfse4) : RES_SLRSAT;
        res_rfse5  = _res_rfse5.fixedflag ?  ((void)(RES_SLRSAT), res_rfse5) : RES_SLRSAT;
        res_rfse6  = _res_rfse6.fixedflag ?  ((void)(RES_SLRSAT), res_rfse6) : RES_SLRSAT;

        pw_rfs = _pw_rfs.fixedflag ?   ((void)(4000), pw_rfs) : 4000;
        if (opfluorotrigger) 
        {
            if (cffield > B0_15000)
            {
               pw_rfs  = _pw_rfs.fixedflag ?   ((void)(6400), pw_rfs) : 6400;
            }
            else
            {
               pw_rfs  = _pw_rfs.fixedflag ?   ((void)(1000), pw_rfs) : 1000;
            }
        }
        if(lp_mode ==1)
        {
            pw_rfs = _pw_rfs.fixedflag ? ((void)(lp_stretch*pw_rfs), pw_rfs) : lp_stretch*pw_rfs;
        }
        cyc_rfs  = _cyc_rfs.fixedflag ?  ((void)(1.21), cyc_rfs) : 1.21;

        sp_init_rf(_pw_rfsx1.fixedflag ? (_temp50_pw_rfsx1=pw_rfsx1,&_temp50_pw_rfsx1) : &pw_rfsx1, _a_rfsx1.fixedflag ? (_temp51_a_rfsx1=a_rfsx1,&_temp51_a_rfsx1) : &a_rfsx1, _flip_rfsx1.fixedflag ? (_temp52_flip_rfsx1=flip_rfsx1,&_temp52_flip_rfsx1) : &flip_rfsx1, SLR_SAT,
                   &rfpulse[RFSX1_SLOT]);
        sp_init_rf(_pw_rfsx2.fixedflag ? (_temp53_pw_rfsx2=pw_rfsx2,&_temp53_pw_rfsx2) : &pw_rfsx2, _a_rfsx2.fixedflag ? (_temp54_a_rfsx2=a_rfsx2,&_temp54_a_rfsx2) : &a_rfsx2, _flip_rfsx2.fixedflag ? (_temp55_flip_rfsx2=flip_rfsx2,&_temp55_flip_rfsx2) : &flip_rfsx2, SLR_SAT,
                   &rfpulse[RFSX2_SLOT]);
        sp_init_rf(_pw_rfsy1.fixedflag ? (_temp56_pw_rfsy1=pw_rfsy1,&_temp56_pw_rfsy1) : &pw_rfsy1, _a_rfsy1.fixedflag ? (_temp57_a_rfsy1=a_rfsy1,&_temp57_a_rfsy1) : &a_rfsy1, _flip_rfsy1.fixedflag ? (_temp58_flip_rfsy1=flip_rfsy1,&_temp58_flip_rfsy1) : &flip_rfsy1, SLR_SAT,
                   &rfpulse[RFSY1_SLOT]);
        sp_init_rf(_pw_rfsy2.fixedflag ? (_temp59_pw_rfsy2=pw_rfsy2,&_temp59_pw_rfsy2) : &pw_rfsy2, _a_rfsy2.fixedflag ? (_temp60_a_rfsy2=a_rfsy2,&_temp60_a_rfsy2) : &a_rfsy2, _flip_rfsy2.fixedflag ? (_temp61_flip_rfsy2=flip_rfsy2,&_temp61_flip_rfsy2) : &flip_rfsy2, SLR_SAT,
                   &rfpulse[RFSY2_SLOT]);
        sp_init_rf(_pw_rfsz1.fixedflag ? (_temp62_pw_rfsz1=pw_rfsz1,&_temp62_pw_rfsz1) : &pw_rfsz1, _a_rfsz1.fixedflag ? (_temp63_a_rfsz1=a_rfsz1,&_temp63_a_rfsz1) : &a_rfsz1, _flip_rfsz1.fixedflag ? (_temp64_flip_rfsz1=flip_rfsz1,&_temp64_flip_rfsz1) : &flip_rfsz1, SLR_SAT,
                   &rfpulse[RFSZ1_SLOT]);
        sp_init_rf(_pw_rfsz2.fixedflag ? (_temp65_pw_rfsz2=pw_rfsz2,&_temp65_pw_rfsz2) : &pw_rfsz2, _a_rfsz2.fixedflag ? (_temp66_a_rfsz2=a_rfsz2,&_temp66_a_rfsz2) : &a_rfsz2, _flip_rfsz2.fixedflag ? (_temp67_flip_rfsz2=flip_rfsz2,&_temp67_flip_rfsz2) : &flip_rfsz2, SLR_SAT,
                   &rfpulse[RFSZ2_SLOT]);
        sp_init_rf(_pw_rfse1.fixedflag ? (_temp68_pw_rfse1=pw_rfse1,&_temp68_pw_rfse1) : &pw_rfse1, _a_rfse1.fixedflag ? (_temp69_a_rfse1=a_rfse1,&_temp69_a_rfse1) : &a_rfse1, _flip_rfse1.fixedflag ? (_temp70_flip_rfse1=flip_rfse1,&_temp70_flip_rfse1) : &flip_rfse1, SLR_SAT,
                   &rfpulse[RFSE1_SLOT]);
        sp_init_rf(_pw_rfse2.fixedflag ? (_temp71_pw_rfse2=pw_rfse2,&_temp71_pw_rfse2) : &pw_rfse2, _a_rfse2.fixedflag ? (_temp72_a_rfse2=a_rfse2,&_temp72_a_rfse2) : &a_rfse2, _flip_rfse2.fixedflag ? (_temp73_flip_rfse2=flip_rfse2,&_temp73_flip_rfse2) : &flip_rfse2, SLR_SAT,
                   &rfpulse[RFSE2_SLOT]);
        sp_init_rf(_pw_rfse3.fixedflag ? (_temp74_pw_rfse3=pw_rfse3,&_temp74_pw_rfse3) : &pw_rfse3, _a_rfse3.fixedflag ? (_temp75_a_rfse3=a_rfse3,&_temp75_a_rfse3) : &a_rfse3, _flip_rfse3.fixedflag ? (_temp76_flip_rfse3=flip_rfse3,&_temp76_flip_rfse3) : &flip_rfse3, SLR_SAT,
                   &rfpulse[RFSE3_SLOT]);
        sp_init_rf(_pw_rfse4.fixedflag ? (_temp77_pw_rfse4=pw_rfse4,&_temp77_pw_rfse4) : &pw_rfse4, _a_rfse4.fixedflag ? (_temp78_a_rfse4=a_rfse4,&_temp78_a_rfse4) : &a_rfse4, _flip_rfse4.fixedflag ? (_temp79_flip_rfse4=flip_rfse4,&_temp79_flip_rfse4) : &flip_rfse4, SLR_SAT,
                   &rfpulse[RFSE4_SLOT]);
        sp_init_rf(_pw_rfse5.fixedflag ? (_temp80_pw_rfse5=pw_rfse5,&_temp80_pw_rfse5) : &pw_rfse5, _a_rfse5.fixedflag ? (_temp81_a_rfse5=a_rfse5,&_temp81_a_rfse5) : &a_rfse5, _flip_rfse5.fixedflag ? (_temp82_flip_rfse5=flip_rfse5,&_temp82_flip_rfse5) : &flip_rfse5, SLR_SAT,
                   &rfpulse[RFSE5_SLOT]);
        sp_init_rf(_pw_rfse6.fixedflag ? (_temp83_pw_rfse6=pw_rfse6,&_temp83_pw_rfse6) : &pw_rfse6, _a_rfse6.fixedflag ? (_temp84_a_rfse6=a_rfse6,&_temp84_a_rfse6) : &a_rfse6, _flip_rfse6.fixedflag ? (_temp85_flip_rfse6=flip_rfse6,&_temp85_flip_rfse6) : &flip_rfse6, SLR_SAT,
                   &rfpulse[RFSE6_SLOT]);
        break;

    case SLR_CSAT:
        res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsx1) : RES_SLRCSAT;
        res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsx2) : RES_SLRCSAT;
        res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsy1) : RES_SLRCSAT;
        res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsy2) : RES_SLRCSAT;
        res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsz1) : RES_SLRCSAT;
        res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsz2) : RES_SLRCSAT;
        res_rfse1  = _res_rfse1.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse1) : RES_SLRCSAT;
        res_rfse2  = _res_rfse2.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse2) : RES_SLRCSAT;
        res_rfse3  = _res_rfse3.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse3) : RES_SLRCSAT;
        res_rfse4  = _res_rfse4.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse4) : RES_SLRCSAT;
        res_rfse5  = _res_rfse5.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse5) : RES_SLRCSAT;
        res_rfse6  = _res_rfse6.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse6) : RES_SLRCSAT;

        pw_rfs = _pw_rfs.fixedflag ?   ((void)(4000), pw_rfs) : 4000;
        if (opfluorotrigger)
        {
            if (cffield > B0_15000)
            {
               pw_rfs  = _pw_rfs.fixedflag ?   ((void)(6400), pw_rfs) : 6400;
            }
            else
            {
               pw_rfs  = _pw_rfs.fixedflag ?   ((void)(1000), pw_rfs) : 1000;
            }
        }
        if(lp_mode ==1)
        {
            pw_rfs = _pw_rfs.fixedflag ? ((void)(lp_stretch*pw_rfs), pw_rfs) : lp_stretch*pw_rfs;
        }
        cyc_rfs  = _cyc_rfs.fixedflag ?  ((void)(3.0), cyc_rfs) : 3.0;

        sp_init_rf(_pw_rfsx1.fixedflag ? (_temp86_pw_rfsx1=pw_rfsx1,&_temp86_pw_rfsx1) : &pw_rfsx1, _a_rfsx1.fixedflag ? (_temp87_a_rfsx1=a_rfsx1,&_temp87_a_rfsx1) : &a_rfsx1, _flip_rfsx1.fixedflag ? (_temp88_flip_rfsx1=flip_rfsx1,&_temp88_flip_rfsx1) : &flip_rfsx1, SLR_CSAT,
                   &rfpulse[RFSX1_SLOT]);
        sp_init_rf(_pw_rfsx2.fixedflag ? (_temp89_pw_rfsx2=pw_rfsx2,&_temp89_pw_rfsx2) : &pw_rfsx2, _a_rfsx2.fixedflag ? (_temp90_a_rfsx2=a_rfsx2,&_temp90_a_rfsx2) : &a_rfsx2, _flip_rfsx2.fixedflag ? (_temp91_flip_rfsx2=flip_rfsx2,&_temp91_flip_rfsx2) : &flip_rfsx2, SLR_CSAT,
                   &rfpulse[RFSX2_SLOT]);
        sp_init_rf(_pw_rfsy1.fixedflag ? (_temp92_pw_rfsy1=pw_rfsy1,&_temp92_pw_rfsy1) : &pw_rfsy1, _a_rfsy1.fixedflag ? (_temp93_a_rfsy1=a_rfsy1,&_temp93_a_rfsy1) : &a_rfsy1, _flip_rfsy1.fixedflag ? (_temp94_flip_rfsy1=flip_rfsy1,&_temp94_flip_rfsy1) : &flip_rfsy1, SLR_CSAT,
                   &rfpulse[RFSY1_SLOT]);
        sp_init_rf(_pw_rfsy2.fixedflag ? (_temp95_pw_rfsy2=pw_rfsy2,&_temp95_pw_rfsy2) : &pw_rfsy2, _a_rfsy2.fixedflag ? (_temp96_a_rfsy2=a_rfsy2,&_temp96_a_rfsy2) : &a_rfsy2, _flip_rfsy2.fixedflag ? (_temp97_flip_rfsy2=flip_rfsy2,&_temp97_flip_rfsy2) : &flip_rfsy2, SLR_CSAT,
                   &rfpulse[RFSY2_SLOT]);
        sp_init_rf(_pw_rfsz1.fixedflag ? (_temp98_pw_rfsz1=pw_rfsz1,&_temp98_pw_rfsz1) : &pw_rfsz1, _a_rfsz1.fixedflag ? (_temp99_a_rfsz1=a_rfsz1,&_temp99_a_rfsz1) : &a_rfsz1, _flip_rfsz1.fixedflag ? (_temp100_flip_rfsz1=flip_rfsz1,&_temp100_flip_rfsz1) : &flip_rfsz1, SLR_CSAT,
                   &rfpulse[RFSZ1_SLOT]);
        sp_init_rf(_pw_rfsz2.fixedflag ? (_temp101_pw_rfsz2=pw_rfsz2,&_temp101_pw_rfsz2) : &pw_rfsz2, _a_rfsz2.fixedflag ? (_temp102_a_rfsz2=a_rfsz2,&_temp102_a_rfsz2) : &a_rfsz2, _flip_rfsz2.fixedflag ? (_temp103_flip_rfsz2=flip_rfsz2,&_temp103_flip_rfsz2) : &flip_rfsz2, SLR_CSAT,
                   &rfpulse[RFSZ2_SLOT]);
        sp_init_rf(_pw_rfse1.fixedflag ? (_temp104_pw_rfse1=pw_rfse1,&_temp104_pw_rfse1) : &pw_rfse1, _a_rfse1.fixedflag ? (_temp105_a_rfse1=a_rfse1,&_temp105_a_rfse1) : &a_rfse1, _flip_rfse1.fixedflag ? (_temp106_flip_rfse1=flip_rfse1,&_temp106_flip_rfse1) : &flip_rfse1, SLR_CSAT,
                   &rfpulse[RFSE1_SLOT]);
        sp_init_rf(_pw_rfse2.fixedflag ? (_temp107_pw_rfse2=pw_rfse2,&_temp107_pw_rfse2) : &pw_rfse2, _a_rfse2.fixedflag ? (_temp108_a_rfse2=a_rfse2,&_temp108_a_rfse2) : &a_rfse2, _flip_rfse2.fixedflag ? (_temp109_flip_rfse2=flip_rfse2,&_temp109_flip_rfse2) : &flip_rfse2, SLR_CSAT,
                   &rfpulse[RFSE2_SLOT]);
        sp_init_rf(_pw_rfse3.fixedflag ? (_temp110_pw_rfse3=pw_rfse3,&_temp110_pw_rfse3) : &pw_rfse3, _a_rfse3.fixedflag ? (_temp111_a_rfse3=a_rfse3,&_temp111_a_rfse3) : &a_rfse3, _flip_rfse3.fixedflag ? (_temp112_flip_rfse3=flip_rfse3,&_temp112_flip_rfse3) : &flip_rfse3, SLR_CSAT,
                   &rfpulse[RFSE3_SLOT]);
        sp_init_rf(_pw_rfse4.fixedflag ? (_temp113_pw_rfse4=pw_rfse4,&_temp113_pw_rfse4) : &pw_rfse4, _a_rfse4.fixedflag ? (_temp114_a_rfse4=a_rfse4,&_temp114_a_rfse4) : &a_rfse4, _flip_rfse4.fixedflag ? (_temp115_flip_rfse4=flip_rfse4,&_temp115_flip_rfse4) : &flip_rfse4, SLR_CSAT,
                   &rfpulse[RFSE4_SLOT]);
        sp_init_rf(_pw_rfse5.fixedflag ? (_temp116_pw_rfse5=pw_rfse5,&_temp116_pw_rfse5) : &pw_rfse5, _a_rfse5.fixedflag ? (_temp117_a_rfse5=a_rfse5,&_temp117_a_rfse5) : &a_rfse5, _flip_rfse5.fixedflag ? (_temp118_flip_rfse5=flip_rfse5,&_temp118_flip_rfse5) : &flip_rfse5, SLR_CSAT,
                   &rfpulse[RFSE5_SLOT]);
        sp_init_rf(_pw_rfse6.fixedflag ? (_temp119_pw_rfse6=pw_rfse6,&_temp119_pw_rfse6) : &pw_rfse6, _a_rfse6.fixedflag ? (_temp120_a_rfse6=a_rfse6,&_temp120_a_rfse6) : &a_rfse6, _flip_rfse6.fixedflag ? (_temp121_flip_rfse6=flip_rfse6,&_temp121_flip_rfse6) : &flip_rfse6, SLR_CSAT,
                   &rfpulse[RFSE6_SLOT]);
        break;

    default:
        break;
    }

    pw_rfsx1  = _pw_rfsx1.fixedflag ?  ((void)(pw_rfs), pw_rfsx1) : pw_rfs;  /* RF pulse width for default SAT */
    pw_rfsx2  = _pw_rfsx2.fixedflag ?  ((void)(pw_rfs), pw_rfsx2) : pw_rfs;
    pw_rfsy1  = _pw_rfsy1.fixedflag ?  ((void)(pw_rfs), pw_rfsy1) : pw_rfs;
    pw_rfsy2  = _pw_rfsy2.fixedflag ?  ((void)(pw_rfs), pw_rfsy2) : pw_rfs;
    pw_rfsz1  = _pw_rfsz1.fixedflag ?  ((void)(pw_rfs), pw_rfsz1) : pw_rfs;
    pw_rfsz2  = _pw_rfsz2.fixedflag ?  ((void)(pw_rfs), pw_rfsz2) : pw_rfs;

    pw_rfse1  = _pw_rfse1.fixedflag ?  ((void)(pw_rfs), pw_rfse1) : pw_rfs;  /* RF pulse width for explicit SAT */
    pw_rfse2  = _pw_rfse2.fixedflag ?  ((void)(pw_rfs), pw_rfse2) : pw_rfs;
    pw_rfse3  = _pw_rfse3.fixedflag ?  ((void)(pw_rfs), pw_rfse3) : pw_rfs;
    pw_rfse4  = _pw_rfse4.fixedflag ?  ((void)(pw_rfs), pw_rfse4) : pw_rfs;
    pw_rfse5  = _pw_rfse5.fixedflag ?  ((void)(pw_rfs), pw_rfse5) : pw_rfs;
    pw_rfse6  = _pw_rfse6.fixedflag ?  ((void)(pw_rfs), pw_rfse6) : pw_rfs;

    /* Init satloggrd structure.  Do it here to get ramp times */
    if( FAILURE == sp_init_satloggrd(&satloggrd) ) {
        return FAILURE;
    }
    pw_satrampx  = _pw_satrampx.fixedflag ?  ((void)(satloggrd.xrt), pw_satrampx) : satloggrd.xrt;
    pw_satrampy  = _pw_satrampy.fixedflag ?  ((void)(satloggrd.yrt), pw_satrampy) : satloggrd.yrt;
    pw_satrampz  = _pw_satrampz.fixedflag ?  ((void)(satloggrd.zrt), pw_satrampz) : satloggrd.zrt;

    pw_gxrfsx1  = _pw_gxrfsx1.fixedflag ?  ((void)(pw_rfsx1), pw_gxrfsx1) : pw_rfsx1;   /* Default SAT gradient width */
    pw_gxrfsx2  = _pw_gxrfsx2.fixedflag ?  ((void)(pw_rfsx2), pw_gxrfsx2) : pw_rfsx2;
    pw_gyrfsy1  = _pw_gyrfsy1.fixedflag ?  ((void)(pw_rfsy1), pw_gyrfsy1) : pw_rfsy1;
    pw_gyrfsy2  = _pw_gyrfsy2.fixedflag ?  ((void)(pw_rfsy2), pw_gyrfsy2) : pw_rfsy2;
    pw_gzrfsz1  = _pw_gzrfsz1.fixedflag ?  ((void)(pw_rfsz1), pw_gzrfsz1) : pw_rfsz1;
    pw_gzrfsz2  = _pw_gzrfsz2.fixedflag ?  ((void)(pw_rfsz2), pw_gzrfsz2) : pw_rfsz2;

    pw_gzrfse1a  = _pw_gzrfse1a.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse1a) : pw_satrampz;  /* Explicit SAt gradient ramp widths */
    pw_gzrfse2a  = _pw_gzrfse2a.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse2a) : pw_satrampz;
    pw_gzrfse3a  = _pw_gzrfse3a.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse3a) : pw_satrampz;
    pw_gzrfse4a  = _pw_gzrfse4a.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse4a) : pw_satrampz;
    pw_gzrfse5a  = _pw_gzrfse5a.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse5a) : pw_satrampz;
    pw_gzrfse6a  = _pw_gzrfse6a.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse6a) : pw_satrampz;
    pw_gzrfse1d  = _pw_gzrfse1d.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse1d) : pw_satrampz;
    pw_gzrfse2d  = _pw_gzrfse2d.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse2d) : pw_satrampz;
    pw_gzrfse3d  = _pw_gzrfse3d.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse3d) : pw_satrampz;
    pw_gzrfse4d  = _pw_gzrfse4d.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse4d) : pw_satrampz;
    pw_gzrfse5d  = _pw_gzrfse5d.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse5d) : pw_satrampz;
    pw_gzrfse6d  = _pw_gzrfse6d.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse6d) : pw_satrampz;

    pw_gzrfse1  = _pw_gzrfse1.fixedflag ?  ((void)(pw_rfse1), pw_gzrfse1) : pw_rfse1;    /* Explicit Sat gradient width */
    pw_gzrfse2  = _pw_gzrfse2.fixedflag ?  ((void)(pw_rfse2), pw_gzrfse2) : pw_rfse2;
    pw_gzrfse3  = _pw_gzrfse3.fixedflag ?  ((void)(pw_rfse3), pw_gzrfse3) : pw_rfse3;
    pw_gzrfse4  = _pw_gzrfse4.fixedflag ?  ((void)(pw_rfse4), pw_gzrfse4) : pw_rfse4;
    pw_gzrfse5  = _pw_gzrfse5.fixedflag ?  ((void)(pw_rfse5), pw_gzrfse5) : pw_rfse5;
    pw_gzrfse6  = _pw_gzrfse6.fixedflag ?  ((void)(pw_rfse6), pw_gzrfse6) : pw_rfse6;
  
#ifdef SPSATXKILLER
    gradx[GXKSE1_SLOT].attack = _pw_gxkse1a.fixedflag ? (_temp122_pw_gxkse1a=pw_gxkse1a,&_temp122_pw_gxkse1a) : &pw_gxkse1a;
    gradx[GXKSE2_SLOT].attack = _pw_gxkse2a.fixedflag ? (_temp123_pw_gxkse2a=pw_gxkse2a,&_temp123_pw_gxkse2a) : &pw_gxkse2a;
    gradx[GXKSE3_SLOT].attack = _pw_gxkse3a.fixedflag ? (_temp124_pw_gxkse3a=pw_gxkse3a,&_temp124_pw_gxkse3a) : &pw_gxkse3a;
    gradx[GXKSE4_SLOT].attack = _pw_gxkse4a.fixedflag ? (_temp125_pw_gxkse4a=pw_gxkse4a,&_temp125_pw_gxkse4a) : &pw_gxkse4a;
    gradx[GXKSE5_SLOT].attack = _pw_gxkse5a.fixedflag ? (_temp126_pw_gxkse5a=pw_gxkse5a,&_temp126_pw_gxkse5a) : &pw_gxkse5a;
    gradx[GXKSE6_SLOT].attack = _pw_gxkse6a.fixedflag ? (_temp127_pw_gxkse6a=pw_gxkse6a,&_temp127_pw_gxkse6a) : &pw_gxkse6a;
    gradx[GXKSX1_SLOT].attack = _pw_gxksx1a.fixedflag ? (_temp128_pw_gxksx1a=pw_gxksx1a,&_temp128_pw_gxksx1a) : &pw_gxksx1a;
    gradx[GXKSX2_SLOT].attack = _pw_gxksx2a.fixedflag ? (_temp129_pw_gxksx2a=pw_gxksx2a,&_temp129_pw_gxksx2a) : &pw_gxksx2a;
    gradx[GXKSY1_SLOT].attack = _pw_gxksy1a.fixedflag ? (_temp130_pw_gxksy1a=pw_gxksy1a,&_temp130_pw_gxksy1a) : &pw_gxksy1a;
    gradx[GXKSY2_SLOT].attack = _pw_gxksy2a.fixedflag ? (_temp131_pw_gxksy2a=pw_gxksy2a,&_temp131_pw_gxksy2a) : &pw_gxksy2a;
    gradx[GXKSZ1_SLOT].attack = _pw_gxksz1a.fixedflag ? (_temp132_pw_gxksz1a=pw_gxksz1a,&_temp132_pw_gxksz1a) : &pw_gxksz1a;
    gradx[GXKSZ2_SLOT].attack = _pw_gxksz2a.fixedflag ? (_temp133_pw_gxksz2a=pw_gxksz2a,&_temp133_pw_gxksz2a) : &pw_gxksz2a;

    gradx[GXKSE1_SLOT].decay = _pw_gxkse1d.fixedflag ? (_temp134_pw_gxkse1d=pw_gxkse1d,&_temp134_pw_gxkse1d) : &pw_gxkse1d;
    gradx[GXKSE2_SLOT].decay = _pw_gxkse2d.fixedflag ? (_temp135_pw_gxkse2d=pw_gxkse2d,&_temp135_pw_gxkse2d) : &pw_gxkse2d;
    gradx[GXKSE3_SLOT].decay = _pw_gxkse3d.fixedflag ? (_temp136_pw_gxkse3d=pw_gxkse3d,&_temp136_pw_gxkse3d) : &pw_gxkse3d;
    gradx[GXKSE4_SLOT].decay = _pw_gxkse4d.fixedflag ? (_temp137_pw_gxkse4d=pw_gxkse4d,&_temp137_pw_gxkse4d) : &pw_gxkse4d;
    gradx[GXKSE5_SLOT].decay = _pw_gxkse5d.fixedflag ? (_temp138_pw_gxkse5d=pw_gxkse5d,&_temp138_pw_gxkse5d) : &pw_gxkse5d;
    gradx[GXKSE6_SLOT].decay = _pw_gxkse6d.fixedflag ? (_temp139_pw_gxkse6d=pw_gxkse6d,&_temp139_pw_gxkse6d) : &pw_gxkse6d;
    gradx[GXKSX1_SLOT].decay = _pw_gxksx1d.fixedflag ? (_temp140_pw_gxksx1d=pw_gxksx1d,&_temp140_pw_gxksx1d) : &pw_gxksx1d;
    gradx[GXKSX2_SLOT].decay = _pw_gxksx2d.fixedflag ? (_temp141_pw_gxksx2d=pw_gxksx2d,&_temp141_pw_gxksx2d) : &pw_gxksx2d;
    gradx[GXKSY1_SLOT].decay = _pw_gxksy1d.fixedflag ? (_temp142_pw_gxksy1d=pw_gxksy1d,&_temp142_pw_gxksy1d) : &pw_gxksy1d;
    gradx[GXKSY2_SLOT].decay = _pw_gxksy2d.fixedflag ? (_temp143_pw_gxksy2d=pw_gxksy2d,&_temp143_pw_gxksy2d) : &pw_gxksy2d;
    gradx[GXKSZ1_SLOT].decay = _pw_gxksz1d.fixedflag ? (_temp144_pw_gxksz1d=pw_gxksz1d,&_temp144_pw_gxksz1d) : &pw_gxksz1d;
    gradx[GXKSZ2_SLOT].decay = _pw_gxksz2d.fixedflag ? (_temp145_pw_gxksz2d=pw_gxksz2d,&_temp145_pw_gxksz2d) : &pw_gxksz2d;

    gradx[GXKSE1_SLOT].pw = _pw_gxkse1.fixedflag ? (_temp146_pw_gxkse1=pw_gxkse1,&_temp146_pw_gxkse1) : &pw_gxkse1;
    gradx[GXKSE2_SLOT].pw = _pw_gxkse2.fixedflag ? (_temp147_pw_gxkse2=pw_gxkse2,&_temp147_pw_gxkse2) : &pw_gxkse2;
    gradx[GXKSE3_SLOT].pw = _pw_gxkse3.fixedflag ? (_temp148_pw_gxkse3=pw_gxkse3,&_temp148_pw_gxkse3) : &pw_gxkse3;
    gradx[GXKSE4_SLOT].pw = _pw_gxkse4.fixedflag ? (_temp149_pw_gxkse4=pw_gxkse4,&_temp149_pw_gxkse4) : &pw_gxkse4;
    gradx[GXKSE5_SLOT].pw = _pw_gxkse5.fixedflag ? (_temp150_pw_gxkse5=pw_gxkse5,&_temp150_pw_gxkse5) : &pw_gxkse5;
    gradx[GXKSE6_SLOT].pw = _pw_gxkse6.fixedflag ? (_temp151_pw_gxkse6=pw_gxkse6,&_temp151_pw_gxkse6) : &pw_gxkse6;
    gradx[GXKSX1_SLOT].pw = _pw_gxksx1.fixedflag ? (_temp152_pw_gxksx1=pw_gxksx1,&_temp152_pw_gxksx1) : &pw_gxksx1;
    gradx[GXKSX2_SLOT].pw = _pw_gxksx2.fixedflag ? (_temp153_pw_gxksx2=pw_gxksx2,&_temp153_pw_gxksx2) : &pw_gxksx2;
    gradx[GXKSY1_SLOT].pw = _pw_gxksy1.fixedflag ? (_temp154_pw_gxksy1=pw_gxksy1,&_temp154_pw_gxksy1) : &pw_gxksy1;
    gradx[GXKSY2_SLOT].pw = _pw_gxksy2.fixedflag ? (_temp155_pw_gxksy2=pw_gxksy2,&_temp155_pw_gxksy2) : &pw_gxksy2;
    gradx[GXKSZ1_SLOT].pw = _pw_gxksz1.fixedflag ? (_temp156_pw_gxksz1=pw_gxksz1,&_temp156_pw_gxksz1) : &pw_gxksz1;
    gradx[GXKSZ2_SLOT].pw = _pw_gxksz2.fixedflag ? (_temp157_pw_gxksz2=pw_gxksz2,&_temp157_pw_gxksz2) : &pw_gxksz2;

    gradx[GXKSE1_SLOT].amp = _a_gxkse1.fixedflag ? (_temp158_a_gxkse1=a_gxkse1,&_temp158_a_gxkse1) : &a_gxkse1;
    gradx[GXKSE2_SLOT].amp = _a_gxkse2.fixedflag ? (_temp159_a_gxkse2=a_gxkse2,&_temp159_a_gxkse2) : &a_gxkse2;
    gradx[GXKSE3_SLOT].amp = _a_gxkse3.fixedflag ? (_temp160_a_gxkse3=a_gxkse3,&_temp160_a_gxkse3) : &a_gxkse3;
    gradx[GXKSE4_SLOT].amp = _a_gxkse4.fixedflag ? (_temp161_a_gxkse4=a_gxkse4,&_temp161_a_gxkse4) : &a_gxkse4;
    gradx[GXKSE5_SLOT].amp = _a_gxkse5.fixedflag ? (_temp162_a_gxkse5=a_gxkse5,&_temp162_a_gxkse5) : &a_gxkse5;
    gradx[GXKSE6_SLOT].amp = _a_gxkse6.fixedflag ? (_temp163_a_gxkse6=a_gxkse6,&_temp163_a_gxkse6) : &a_gxkse6;
    gradx[GXKSX1_SLOT].amp = _a_gxksx1.fixedflag ? (_temp164_a_gxksx1=a_gxksx1,&_temp164_a_gxksx1) : &a_gxksx1;
    gradx[GXKSX2_SLOT].amp = _a_gxksx2.fixedflag ? (_temp165_a_gxksx2=a_gxksx2,&_temp165_a_gxksx2) : &a_gxksx2;
    gradx[GXKSY1_SLOT].amp = _a_gxksy1.fixedflag ? (_temp166_a_gxksy1=a_gxksy1,&_temp166_a_gxksy1) : &a_gxksy1;
    gradx[GXKSY2_SLOT].amp = _a_gxksy2.fixedflag ? (_temp167_a_gxksy2=a_gxksy2,&_temp167_a_gxksy2) : &a_gxksy2;
    gradx[GXKSZ1_SLOT].amp = _a_gxksz1.fixedflag ? (_temp168_a_gxksz1=a_gxksz1,&_temp168_a_gxksz1) : &a_gxksz1;
    gradx[GXKSZ2_SLOT].amp = _a_gxksz2.fixedflag ? (_temp169_a_gxksz2=a_gxksz2,&_temp169_a_gxksz2) : &a_gxksz2;
#endif

    return SUCCESS;
}

/***********************************************************************/


STATUS
SpSatCheck( void )
{

    if (exist(opccsat)==PSD_ON) 
    {
        if (exist(opileave) == PSD_ON) 
        {
            epic_error(use_ermes, "Can not perform Concat Sat with interleaving",
                       EM_PSD_CATSAT_INTLEAVE,0);
            return(FAILURE);
        }
    }
    return(SUCCESS);
}

/*************************************************************************/
STATUS ssInit(void) 
{
    INT ss_type = 0;
    off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;

    /* RF1 initialization */
    if (ss_rf1 == PSD_ON)  /* initialize spsp pulses for current field strength and SR17 */
    {
        /* Spatial-Spectral pulses use external gradient files. Do not scale pulse */
        switch ((int ) cffield) {
            case B0_40000:

            case B0_30000:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(268), pw_ss_rampz) : 268;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss3026838_RF1_PW), pw_rf1) : PSD_ss3026838_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss3026838_RF1_R), res_rf1) : PSD_ss3026838_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss3026838_RF1_LEFT;
                hrf1b = PSD_ss3026838_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss3026838_RF1_NUML), num_rf1lobe) : PSD_ss3026838_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss3026838_RF1_HlPW), pw_gzrf1lobe) : PSD_ss3026838_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp170_pw_rf1=pw_rf1,&_temp170_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp171_a_rf1=a_rf1,&_temp171_a_rf1) : &a_rf1, SAR_ABS_ss3026838,
                             SAR_Pss3026838, SAR_ARss3026838, SAR_DTCss3026838,
                             SAR_MAXPWss3026838, 1, MAX_B1_ss3026838, 
                             MAX_INT_B1_SQ_ss3026838, MAX_RMS_B1_ss3026838, 90.0, 
                             _flip_rf1.fixedflag ? (_temp172_flip_rf1=flip_rf1,&_temp172_flip_rf1) : &flip_rf1, (float)PSD_ss3026838_RF1_PW, NOM_BW_ss3026838,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp173_res_rf1=res_rf1,&_temp173_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp174_wg_rf1=wg_rf1,&_temp174_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "ss3026838.rho");
                sprintf(ssgzfile, "ss3026838.gz");
                whichss  = _whichss.fixedflag ?  ((void)(3026838), whichss) : 3026838;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss3026838), nbw_ssrf) : NOM_BW_ss3026838;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;     
                break;       /* end YH, YZ */

            case B0_7000:
                /* FEC (nMR) : Put same values as 0.5T, MUST FIX THIS !!!! */
                /*    MUST GENERATE EXTERNAL WAVEFORM FILE FOR 0.7T */
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(600), pw_ss_rampz) : 600;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss0560010_RF1_PW), pw_rf1) : PSD_ss0560010_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss0560010_RF1_R), res_rf1) : PSD_ss0560010_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss0560010_RF1_LEFT;
                hrf1b = PSD_ss0560010_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss0560010_RF1_NUML), num_rf1lobe) : PSD_ss0560010_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss0560010_RF1_HlPW), pw_gzrf1lobe) : PSD_ss0560010_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp175_pw_rf1=pw_rf1,&_temp175_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp176_a_rf1=a_rf1,&_temp176_a_rf1) : &a_rf1, SAR_ABS_ss0560010,
                             SAR_Pss0560010, SAR_ARss0560010, SAR_DTCss0560010,
                             SAR_MAXPWss0560010, 1, MAX_B1_ss0560010,
                             MAX_INT_B1_SQ_ss0560010, MAX_RMS_B1_ss0560010, 90.0,
                             _flip_rf1.fixedflag ? (_temp177_flip_rf1=flip_rf1,&_temp177_flip_rf1) : &flip_rf1, (float)PSD_ss0560010_RF1_PW, NOM_BW_ss0560010,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp178_res_rf1=res_rf1,&_temp178_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp179_wg_rf1=wg_rf1,&_temp179_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss0560010.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss0560010.gz");
                whichss  = _whichss.fixedflag ?  ((void)(560010), whichss) : 560010;
                break;

            case B0_5000:

            case B0_3500:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(600), pw_ss_rampz) : 600;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss0560010_RF1_PW), pw_rf1) : PSD_ss0560010_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss0560010_RF1_R), res_rf1) : PSD_ss0560010_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss0560010_RF1_LEFT;
                hrf1b = PSD_ss0560010_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss0560010_RF1_NUML), num_rf1lobe) : PSD_ss0560010_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss0560010_RF1_HlPW), pw_gzrf1lobe) : PSD_ss0560010_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp180_pw_rf1=pw_rf1,&_temp180_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp181_a_rf1=a_rf1,&_temp181_a_rf1) : &a_rf1, SAR_ABS_ss0560010,
                             SAR_Pss0560010, SAR_ARss0560010, SAR_DTCss0560010,
                             SAR_MAXPWss0560010, 1, MAX_B1_ss0560010, 
                             MAX_INT_B1_SQ_ss0560010, MAX_RMS_B1_ss0560010, 90.0, 
                             _flip_rf1.fixedflag ? (_temp182_flip_rf1=flip_rf1,&_temp182_flip_rf1) : &flip_rf1, (float)PSD_ss0560010_RF1_PW, NOM_BW_ss0560010,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp183_res_rf1=res_rf1,&_temp183_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp184_wg_rf1=wg_rf1,&_temp184_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss0560010.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss0560010.gz");
                whichss  = _whichss.fixedflag ?  ((void)(560010), whichss) : 560010;
                break;

            case B0_10000:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(600), pw_ss_rampz) : 600;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1060010_RF1_PW), pw_rf1) : PSD_ss1060010_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1060010_RF1_R), res_rf1) : PSD_ss1060010_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss1060010_RF1_LEFT;
                hrf1b = PSD_ss1060010_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1060010_RF1_NUML), num_rf1lobe) : PSD_ss1060010_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss1060010_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1060010_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp185_pw_rf1=pw_rf1,&_temp185_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp186_a_rf1=a_rf1,&_temp186_a_rf1) : &a_rf1, SAR_ABS_ss1060010,
                             SAR_Pss1060010, SAR_ARss1060010, SAR_DTCss1060010,
                             SAR_MAXPWss1060010, 1, MAX_B1_ss1060010,
                             MAX_INT_B1_SQ_ss1060010, MAX_RMS_B1_ss1060010, 90.0, 
                             _flip_rf1.fixedflag ? (_temp187_flip_rf1=flip_rf1,&_temp187_flip_rf1) : &flip_rf1, (float)PSD_ss1060010_RF1_PW, NOM_BW_ss1060010,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp188_res_rf1=res_rf1,&_temp188_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp189_wg_rf1=wg_rf1,&_temp189_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss1060010.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss1060010.gz");
                whichss  = _whichss.fixedflag ?  ((void)(1060010), whichss) : 1060010;
                break;

            case B0_15000:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(600), pw_ss_rampz) : 600;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1560010_RF1_PW), pw_rf1) : PSD_ss1560010_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1560010_RF1_R), res_rf1) : PSD_ss1560010_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss1560010_RF1_LEFT;
                hrf1b = PSD_ss1560010_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1560010_RF1_NUML), num_rf1lobe) : PSD_ss1560010_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss1560010_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1560010_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp190_pw_rf1=pw_rf1,&_temp190_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp191_a_rf1=a_rf1,&_temp191_a_rf1) : &a_rf1, SAR_ABS_ss1560010,
                             SAR_Pss1560010, SAR_ARss1560010, SAR_DTCss1560010,
                             SAR_MAXPWss1560010, 1, MAX_B1_ss1560010, 
                             MAX_INT_B1_SQ_ss1560010, MAX_RMS_B1_ss1560010, 90.0, 
                             _flip_rf1.fixedflag ? (_temp192_flip_rf1=flip_rf1,&_temp192_flip_rf1) : &flip_rf1, (float)PSD_ss1560010_RF1_PW, NOM_BW_ss1560010,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp193_res_rf1=res_rf1,&_temp193_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp194_wg_rf1=wg_rf1,&_temp194_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss1560010.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss1560010.gz");
                whichss  = _whichss.fixedflag ?  ((void)(1560010), whichss) : 1560010;
                break;

            default: /* not a defined field strength */
                SDL_PrintFStrengthWarning(SD_PSD_SUPPORT,cffield,__FILE__,__LINE__);
                break; 
                /* NOTREACHED */
        } /* end switch cffield */

        /* BJM: MRIge58917 - moved this out of ssEval1 */
        if (((ss_override!=560010)  && (ss_override!=1060010) && 
             (ss_override!=10110022) && (ss_override!=1028822) &&
             (ss_override!=1560010) && (ss_override!=15110022) &&
             (ss_override!=1528822) && (ss_override!=1544022) &&
             (ss_override!=1534433) && (ss_override!=3018027) && 
             (ss_override!=3026838) && (ss_override!=3026033) &&
             (ss_override!=30276221) && (ss_override!=30276222) && 
             (ss_override!=15048233) && (ss_override!=15048234) &&
             (ss_override!=15048235) && (ss_override!=30104233) &&
             (ss_override!=30104234) && (ss_override!=30104235) &&             
             (ss_override!=30248501) && (ss_override!=30248502) &&
             (ss_override!=30260334) && (ss_override!=3027633) &&
             (ss_override != 1) && (ss_override != 2))
             || (existcv(ss_override)==PSD_OFF) ) {
            /* choose pulse based on field strength and slew rate mode */
            switch ((int) cffield) {
                case B0_40000:

                case B0_30000:

                    /* HD new 30276221 Type I spsp pulse (default pulse for WHOLE mode) */
                    if((exist(opgradmode) == 1))
                        ss_type = 30276221;  

                    /* YH,YZ  Keep 3026033 spsp pulse for BRM/CRM and Zoom Modes */
                    else
                    {
                        switch(breast_spsp_flag)
                        {
                            case 0:
                            default:
                                ss_type = 30260334;  /* new ss pulse to replace 3026838 */
                                break;
                            case 1:
                                if(cfgcoiltype == PSD_XRMW_COIL)
                                    ss_type = 3027633;
                                else
                                    ss_type = 30248501;
                                break;
                            case 2:
                                ss_type = 30248502;
                                break;
                        }
                    }
                    
                    break;      

                case B0_7000:
                    /* FEC (nMR) : Put same values as 0.5T, MUST FIX THIS!! */
                    /*    MUST GENERATE EXTERNAL WAVEFORM FILE FOR 0.7T */
                    switch (cfsrmode) {
                        case PSD_SR17:
                            ss_type = 1060010;
                            break;
                        case PSD_SR20:
                        case PSD_SR25:
                            ss_type = 10110022;
                            break;
                        case PSD_SR77:
                        case PSD_SR100:
                        case PSD_SR120:
                        case PSD_SR150:
                        case PSD_SR200:
                        case PSD_SR230:
                            ss_type = 1028822;
                            break;
                        default:
                            epic_error(0, "Slew Rate %d not found", 0, EE_ARGS(1),
                                       INT_ARG, cfsrmode);
                            return FAILURE;
                            /* NOTREACHED */
                    }
                    break;
                case B0_5000:
                case B0_3500:
                    switch (cfsrmode) {
                        case PSD_SR17:
                        case PSD_SR25:  /* MFO 03/14/00 YI */
                            ss_type = 560010;
                            break;
                        default:
                            epic_error(0, "Slew Rate %d not found", 0, EE_ARGS(1),
                                       INT_ARG, cfsrmode);
                            return FAILURE;
                            /* NOTREACHED */
                    }
                    break;
                case B0_10000:
                    switch (cfsrmode) {
                        case PSD_SR17:
                            ss_type = 1060010;
                            break;
                        case PSD_SR20:
                        case PSD_SR50:
                            ss_type = 10110022;
                            break;
                        case PSD_SR77:
                        case PSD_SR100:
                        case PSD_SR120:
                        case PSD_SR150:
                        case PSD_SR200:
                        case PSD_SR230:
                            ss_type = 1028822;
                            break;
                        default:
                            epic_error(0, "Slew Rate %d not found", 0, EE_ARGS(1),
                                       INT_ARG, cfsrmode);
                            return FAILURE;
                            /* NOTREACHED */
                    }
                    break;
                case B0_15000:
                    switch (cfsrmode) {
                        case PSD_SR17:
                        case PSD_SR25:
                            ss_type = 1560010;
                            break;
                        case PSD_SR20:
                        case PSD_SR50:
                            if(VALUE_SYSTEM_HDE == value_system_flag){
                                ss_type = 1544022; 
                            } else {
                                ss_type = 15110022;
                            }
                            break;
                        case PSD_SR77:
                        case PSD_SR120:
                        case PSD_SR150:
                        case PSD_SR200:
                        case PSD_SR230:
                            ss_type = 1528822;
                            break;
                        case PSD_SR100:
                            ss_type = 1534433;
                            break;
                        default:
                            epic_error(0, "Slew Rate %d not found", 0, EE_ARGS(1),
                                       INT_ARG, cfsrmode);

                            return FAILURE;
                            /* NOTREACHED */
                    }
                    break;
                default:
                    SDL_PrintFStrengthWarning(SD_PSD_SUPPORT,cffield,
                                              __FILE__,__LINE__);
            } /* end switch cffield */

        } /* end if ss_override!=... */ 
        else {  /* use override the auto selection */
            ss_type = ss_override;
        } 
        /* set up pulses based on what pulse was chosen */
        switch (ss_type) {
            case 1:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(288), pw_ss_rampz) : 288;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1_RF1_PW), pw_rf1) : PSD_ss1_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1_RF1_R), res_rf1) : PSD_ss1_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss1_RF1_LEFT;
                hrf1b = PSD_ss1_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1_RF1_NUML), num_rf1lobe) : PSD_ss1_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ?  ((void)(PSD_ss1_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp195_pw_rf1=pw_rf1,&_temp195_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp196_a_rf1=a_rf1,&_temp196_a_rf1) : &a_rf1, SAR_ABS_ss1,
                             SAR_Pss1, SAR_ARss1, SAR_DTCss1,
                             SAR_MAXPWss1, 1, MAX_B1_ss1, 
                             MAX_INT_B1_SQ_ss1, MAX_RMS_B1_ss1, 45.0, 
                             _flip_rf1.fixedflag ? (_temp197_flip_rf1=flip_rf1,&_temp197_flip_rf1) : &flip_rf1, (float)PSD_ss1_RF1_PW, NOM_BW_ss1,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp198_res_rf1=res_rf1,&_temp198_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp199_wg_rf1=wg_rf1,&_temp199_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ssrfx3.rho");
                sprintf(ssgzfile, "/usr/g/bin/ssrfx3.gz");
                whichss  = _whichss.fixedflag ?  ((void)(1), whichss) : 1;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss1), nbw_ssrf) : NOM_BW_ss1;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 2:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(288), pw_ss_rampz) : 288;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss2_RF1_PW), pw_rf1) : PSD_ss2_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss2_RF1_R), res_rf1) : PSD_ss2_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss2_RF1_LEFT;
                hrf1b = PSD_ss2_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss2_RF1_NUML), num_rf1lobe) : PSD_ss2_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ?  ((void)(PSD_ss2_RF1_HlPW), pw_gzrf1lobe) : PSD_ss2_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp200_pw_rf1=pw_rf1,&_temp200_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp201_a_rf1=a_rf1,&_temp201_a_rf1) : &a_rf1, SAR_ABS_ss2,
                             SAR_Pss2, SAR_ARss2, SAR_DTCss2,
                             SAR_MAXPWss2, 1, MAX_B1_ss2, 
                             MAX_INT_B1_SQ_ss2, MAX_RMS_B1_ss2, 45.0, 
                             _flip_rf1.fixedflag ? (_temp202_flip_rf1=flip_rf1,&_temp202_flip_rf1) : &flip_rf1, (float)PSD_ss2_RF1_PW, NOM_BW_ss2,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp203_res_rf1=res_rf1,&_temp203_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp204_wg_rf1=wg_rf1,&_temp204_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ssrf6.rho");
                sprintf(ssgzfile, "/usr/g/bin/ssrf6.gz");
                whichss  = _whichss.fixedflag ?  ((void)(2), whichss) : 2;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss2), nbw_ssrf) : NOM_BW_ss2;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 30260334:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(252), pw_ss_rampz) : 252;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss30260334_RF1_PW), pw_rf1) : PSD_ss30260334_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss30260334_RF1_R), res_rf1) : PSD_ss30260334_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss30260334_RF1_LEFT;
                hrf1b = PSD_ss30260334_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss30260334_RF1_NUML), num_rf1lobe) : PSD_ss30260334_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ?  ((void)(PSD_ss30260334_RF1_HlPW), pw_gzrf1lobe) : PSD_ss30260334_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp205_pw_rf1=pw_rf1,&_temp205_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp206_a_rf1=a_rf1,&_temp206_a_rf1) : &a_rf1, SAR_ABS_ss30260334,
                             SAR_Pss30260334, SAR_ARss30260334, SAR_DTCss30260334,
                             SAR_MAXPWss30260334, 1, MAX_B1_ss30260334, 
                             MAX_INT_B1_SQ_ss30260334, MAX_RMS_B1_ss30260334, 90.0, 
                             _flip_rf1.fixedflag ? (_temp207_flip_rf1=flip_rf1,&_temp207_flip_rf1) : &flip_rf1, (float)PSD_ss30260334_RF1_PW, NOM_BW_ss30260334,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp208_res_rf1=res_rf1,&_temp208_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp209_wg_rf1=wg_rf1,&_temp209_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss30260334.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss30260334.gz");
                whichss  = _whichss.fixedflag ?  ((void)(30260334), whichss) : 30260334;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss30260334), nbw_ssrf) : NOM_BW_ss30260334;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 30248501:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(116), pw_ss_rampz) : 116;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss30248501_RF1_PW), pw_rf1) : PSD_ss30248501_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss30248501_RF1_R), res_rf1) : PSD_ss30248501_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss30248501_RF1_LEFT;
                hrf1b = PSD_ss30248501_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss30248501_RF1_NUML), num_rf1lobe) : PSD_ss30248501_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ?  ((void)(PSD_ss30248501_RF1_HlPW), pw_gzrf1lobe) : PSD_ss30248501_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp210_pw_rf1=pw_rf1,&_temp210_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp211_a_rf1=a_rf1,&_temp211_a_rf1) : &a_rf1, SAR_ABS_ss30248501,
                             SAR_Pss30248501, SAR_ARss30248501, SAR_DTCss30248501,
                             SAR_MAXPWss30248501, 1, MAX_B1_ss30248501,
                             MAX_INT_B1_SQ_ss30248501,
                             MAX_RMS_B1_ss30248501, 90.0,
                             _flip_rf1.fixedflag ? (_temp212_flip_rf1=flip_rf1,&_temp212_flip_rf1) : &flip_rf1, (float)PSD_ss30248501_RF1_PW, NOM_BW_ss30248501,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp213_res_rf1=res_rf1,&_temp213_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp214_wg_rf1=wg_rf1,&_temp214_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss30248501.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss30248501.gz");
                whichss  = _whichss.fixedflag ?  ((void)(30248501), whichss) : 30248501;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss30248501), nbw_ssrf) : NOM_BW_ss30248501;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 30248502:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(116), pw_ss_rampz) : 116;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss30248502_RF1_PW), pw_rf1) : PSD_ss30248502_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss30248502_RF1_R), res_rf1) : PSD_ss30248502_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss30248502_RF1_LEFT;
                hrf1b = PSD_ss30248502_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss30248502_RF1_NUML), num_rf1lobe) : PSD_ss30248502_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ?  ((void)(PSD_ss30248502_RF1_HlPW), pw_gzrf1lobe) : PSD_ss30248502_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp215_pw_rf1=pw_rf1,&_temp215_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp216_a_rf1=a_rf1,&_temp216_a_rf1) : &a_rf1, SAR_ABS_ss30248502,
                             SAR_Pss30248502, SAR_ARss30248502, SAR_DTCss30248502,
                             SAR_MAXPWss30248502, 1, MAX_B1_ss30248502, 
                             MAX_INT_B1_SQ_ss30248502, 
                             MAX_RMS_B1_ss30248502, 90.0, 
                             _flip_rf1.fixedflag ? (_temp217_flip_rf1=flip_rf1,&_temp217_flip_rf1) : &flip_rf1, (float)PSD_ss30248502_RF1_PW, NOM_BW_ss30248502,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp218_res_rf1=res_rf1,&_temp218_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp219_wg_rf1=wg_rf1,&_temp219_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss30248502.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss30248502.gz");
                whichss  = _whichss.fixedflag ?  ((void)(30248502), whichss) : 30248502;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss30248502), nbw_ssrf) : NOM_BW_ss30248502;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 3027633:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(188), pw_ss_rampz) : 188;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss3027633_RF1_PW), pw_rf1) : PSD_ss3027633_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss3027633_RF1_R), res_rf1) : PSD_ss3027633_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss3027633_RF1_LEFT;
                hrf1b = PSD_ss3027633_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss3027633_RF1_NUML), num_rf1lobe) : PSD_ss3027633_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ?  ((void)(PSD_ss3027633_RF1_HlPW), pw_gzrf1lobe) : PSD_ss3027633_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp220_pw_rf1=pw_rf1,&_temp220_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp221_a_rf1=a_rf1,&_temp221_a_rf1) : &a_rf1, SAR_ABS_ss3027633,
                             SAR_Pss3027633, SAR_ARss3027633, SAR_DTCss3027633,
                             SAR_MAXPWss3027633, 1, MAX_B1_ss3027633,
                             MAX_INT_B1_SQ_ss3027633,
                             MAX_RMS_B1_ss3027633, 90.0,
                             _flip_rf1.fixedflag ? (_temp222_flip_rf1=flip_rf1,&_temp222_flip_rf1) : &flip_rf1, (float)PSD_ss3027633_RF1_PW, NOM_BW_ss3027633,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp223_res_rf1=res_rf1,&_temp223_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp224_wg_rf1=wg_rf1,&_temp224_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss3027633.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss3027633.gz");
                whichss  = _whichss.fixedflag ?  ((void)(3027633), whichss) : 3027633;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss3027633), nbw_ssrf) : NOM_BW_ss3027633;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

                /* HD new spsp typeI 9nrf pulse (Default for WHOLE mode) */
            case 30276221:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(276), pw_ss_rampz) : 276;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss30276221_RF1_PW), pw_rf1) : PSD_ss30276221_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss30276221_RF1_R), res_rf1) : PSD_ss30276221_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss30276221_RF1_LEFT;
                hrf1b = PSD_ss30276221_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss30276221_RF1_NUML), num_rf1lobe) : PSD_ss30276221_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ?  ((void)(PSD_ss30276221_RF1_HlPW), pw_gzrf1lobe) : PSD_ss30276221_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp225_pw_rf1=pw_rf1,&_temp225_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp226_a_rf1=a_rf1,&_temp226_a_rf1) : &a_rf1, SAR_ABS_ss30276221,
                             SAR_Pss30276221,SAR_ARss30276221,SAR_DTCss30276221,
                             SAR_MAXPWss30276221, 1, MAX_B1_ss30276221, 
                             MAX_INT_B1_SQ_ss30276221, MAX_RMS_B1_ss30276221, 90.0, 
                             _flip_rf1.fixedflag ? (_temp227_flip_rf1=flip_rf1,&_temp227_flip_rf1) : &flip_rf1, (float)PSD_ss30276221_RF1_PW, NOM_BW_ss30276221,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp228_res_rf1=res_rf1,&_temp228_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp229_wg_rf1=wg_rf1,&_temp229_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/spsp_30276221.rho");
                sprintf(ssgzfile, "/usr/g/bin/spsp_30276221.gz");
                whichss  = _whichss.fixedflag ?  ((void)(30276221), whichss) : 30276221;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss30276221), nbw_ssrf) : NOM_BW_ss30276221;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

                /* HD new spsp typeII 7nrf pulse for WHOLE mode */
            case 30276222:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(276), pw_ss_rampz) : 276;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss30276222_RF1_PW), pw_rf1) : PSD_ss30276222_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss30276222_RF1_R), res_rf1) : PSD_ss30276222_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss30276222_RF1_LEFT;
                hrf1b = PSD_ss30276222_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss30276222_RF1_NUML), num_rf1lobe) : PSD_ss30276222_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ?  ((void)(PSD_ss30276222_RF1_HlPW), pw_gzrf1lobe) : PSD_ss30276222_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp230_pw_rf1=pw_rf1,&_temp230_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp231_a_rf1=a_rf1,&_temp231_a_rf1) : &a_rf1, SAR_ABS_ss30276222,
                             SAR_Pss30276222,SAR_ARss30276222,SAR_DTCss30276222,
                             SAR_MAXPWss30276222, 1, MAX_B1_ss30276222, 
                             MAX_INT_B1_SQ_ss30276222, MAX_RMS_B1_ss30276222, 90.0, 
                             _flip_rf1.fixedflag ? (_temp232_flip_rf1=flip_rf1,&_temp232_flip_rf1) : &flip_rf1, (float)PSD_ss30276222_RF1_PW, NOM_BW_ss30276222,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp233_res_rf1=res_rf1,&_temp233_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp234_wg_rf1=wg_rf1,&_temp234_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/spsp_30276222.rho");
                sprintf(ssgzfile, "/usr/g/bin/spsp_30276222.gz");
                whichss  = _whichss.fixedflag ?  ((void)(30276222), whichss) : 30276222;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss30276222), nbw_ssrf) : NOM_BW_ss30276222;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 560010:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(600), pw_ss_rampz) : 600;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss0560010_RF1_PW), pw_rf1) : PSD_ss0560010_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss0560010_RF1_R), res_rf1) : PSD_ss0560010_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss0560010_RF1_LEFT;
                hrf1b = PSD_ss0560010_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss0560010_RF1_NUML), num_rf1lobe) : PSD_ss0560010_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss0560010_RF1_HlPW), pw_gzrf1lobe) : PSD_ss0560010_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp235_pw_rf1=pw_rf1,&_temp235_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp236_a_rf1=a_rf1,&_temp236_a_rf1) : &a_rf1, SAR_ABS_ss0560010,
                             SAR_Pss0560010, SAR_ARss0560010, SAR_DTCss0560010,
                             SAR_MAXPWss0560010, 1, MAX_B1_ss0560010,
                             MAX_INT_B1_SQ_ss0560010, MAX_RMS_B1_ss0560010, 90.0,  
                             _flip_rf1.fixedflag ? (_temp237_flip_rf1=flip_rf1,&_temp237_flip_rf1) : &flip_rf1, (float)PSD_ss0560010_RF1_PW, NOM_BW_ss0560010,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp238_res_rf1=res_rf1,&_temp238_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp239_wg_rf1=wg_rf1,&_temp239_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss0560010.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss0560010.gz");
                whichss  = _whichss.fixedflag ?  ((void)(560010), whichss) : 560010;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss0560010), nbw_ssrf) : NOM_BW_ss0560010;
                break;

            case 1060010:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(600), pw_ss_rampz) : 600;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1060010_RF1_PW), pw_rf1) : PSD_ss1060010_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1060010_RF1_R), res_rf1) : PSD_ss1060010_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss1060010_RF1_LEFT;
                hrf1b = PSD_ss1060010_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1060010_RF1_NUML), num_rf1lobe) : PSD_ss1060010_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss1060010_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1060010_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp240_pw_rf1=pw_rf1,&_temp240_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp241_a_rf1=a_rf1,&_temp241_a_rf1) : &a_rf1, SAR_ABS_ss1060010,
                             SAR_Pss1060010, SAR_ARss1060010, SAR_DTCss1060010,
                             SAR_MAXPWss1060010, 1, MAX_B1_ss1060010,
                             MAX_INT_B1_SQ_ss1060010, MAX_RMS_B1_ss1060010, 90.0,  
                             _flip_rf1.fixedflag ? (_temp242_flip_rf1=flip_rf1,&_temp242_flip_rf1) : &flip_rf1, (float)PSD_ss1060010_RF1_PW, NOM_BW_ss1060010,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp243_res_rf1=res_rf1,&_temp243_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp244_wg_rf1=wg_rf1,&_temp244_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss1060010.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss1060010.gz");
                whichss  = _whichss.fixedflag ?  ((void)(1060010), whichss) : 1060010;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss1060010), nbw_ssrf) : NOM_BW_ss1060010;
                break;

            case 10110022:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(1100), pw_ss_rampz) : 1100;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss10110022_RF1_PW), pw_rf1) : PSD_ss10110022_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss10110022_RF1_R), res_rf1) : PSD_ss10110022_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss10110022_RF1_LEFT;
                hrf1b = PSD_ss10110022_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss10110022_RF1_NUML), num_rf1lobe) : PSD_ss10110022_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss10110022_RF1_HlPW), pw_gzrf1lobe) : PSD_ss10110022_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp245_pw_rf1=pw_rf1,&_temp245_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp246_a_rf1=a_rf1,&_temp246_a_rf1) : &a_rf1, SAR_ABS_ss10110022,
                             SAR_Pss10110022, SAR_ARss10110022, 
                             SAR_DTCss10110022, SAR_MAXPWss10110022, 1, 
                             MAX_B1_ss10110022, MAX_INT_B1_SQ_ss10110022, 
                             MAX_RMS_B1_ss10110022, 90.0, _flip_rf1.fixedflag ? (_temp247_flip_rf1=flip_rf1,&_temp247_flip_rf1) : &flip_rf1,
                             (float)PSD_ss10110022_RF1_PW, NOM_BW_ss10110022,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp248_res_rf1=res_rf1,&_temp248_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp249_wg_rf1=wg_rf1,&_temp249_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss10110022.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss10110022.gz");
                whichss  = _whichss.fixedflag ?  ((void)(10110022), whichss) : 10110022;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss10110022), nbw_ssrf) : NOM_BW_ss10110022;
                break;

            case 1028822:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(288), pw_ss_rampz) : 288;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1028822_RF1_PW), pw_rf1) : PSD_ss1028822_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1028822_RF1_R), res_rf1) : PSD_ss1028822_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss1028822_RF1_LEFT;
                hrf1b = PSD_ss1028822_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1028822_RF1_NUML), num_rf1lobe) : PSD_ss1028822_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss1028822_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1028822_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp250_pw_rf1=pw_rf1,&_temp250_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp251_a_rf1=a_rf1,&_temp251_a_rf1) : &a_rf1, SAR_ABS_ss1028822,
                             SAR_Pss1028822, SAR_ARss1028822, SAR_DTCss1028822,
                             SAR_MAXPWss1028822, 1, MAX_B1_ss1028822,
                             MAX_INT_B1_SQ_ss1028822, MAX_RMS_B1_ss1028822, 90.0,  
                             _flip_rf1.fixedflag ? (_temp252_flip_rf1=flip_rf1,&_temp252_flip_rf1) : &flip_rf1, (float)PSD_ss1028822_RF1_PW, NOM_BW_ss1028822,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp253_res_rf1=res_rf1,&_temp253_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp254_wg_rf1=wg_rf1,&_temp254_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss1028822.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss1028822.gz");
                whichss  = _whichss.fixedflag ?  ((void)(1028822), whichss) : 1028822;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss1028822), nbw_ssrf) : NOM_BW_ss1028822;
                off90minor  = _off90minor.fixedflag ?  ((void)(-25), off90minor) : -25;
                break;

            case 1534433: /* New designed pulse for SV EM and DM. wxc */
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(344), pw_ss_rampz) : 344;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1534433_RF1_PW), pw_rf1) : PSD_ss1534433_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1534433_RF1_R), res_rf1) : PSD_ss1534433_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss1534433_RF1_LEFT;
                hrf1b = PSD_ss1534433_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1534433_RF1_NUML), num_rf1lobe) : PSD_ss1534433_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss1534433_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1534433_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp255_pw_rf1=pw_rf1,&_temp255_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp256_a_rf1=a_rf1,&_temp256_a_rf1) : &a_rf1, SAR_ABS_ss1534433,
                             SAR_Pss1534433, SAR_ARss1534433, SAR_DTCss1534433,
                             SAR_MAXPWss1534433, 1, MAX_B1_ss1534433,
                             MAX_INT_B1_SQ_ss1534433, MAX_RMS_B1_ss1534433, 90.0,
                             _flip_rf1.fixedflag ? (_temp257_flip_rf1=flip_rf1,&_temp257_flip_rf1) : &flip_rf1, (float)PSD_ss1534433_RF1_PW, NOM_BW_ss1534433,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp258_res_rf1=res_rf1,&_temp258_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp259_wg_rf1=wg_rf1,&_temp259_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss1534433.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss1534433.gz");
                whichss  = _whichss.fixedflag ?  ((void)(1534433), whichss) : 1534433;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss1534433), nbw_ssrf) : NOM_BW_ss1534433;
                break; 

            case 1560010:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(600), pw_ss_rampz) : 600;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1560010_RF1_PW), pw_rf1) : PSD_ss1560010_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1560010_RF1_R), res_rf1) : PSD_ss1560010_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss1560010_RF1_LEFT;
                hrf1b = PSD_ss1560010_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1560010_RF1_NUML), num_rf1lobe) : PSD_ss1560010_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss1560010_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1560010_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp260_pw_rf1=pw_rf1,&_temp260_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp261_a_rf1=a_rf1,&_temp261_a_rf1) : &a_rf1, SAR_ABS_ss1560010,
                             SAR_Pss1560010, SAR_ARss1560010, SAR_DTCss1560010,
                             SAR_MAXPWss1560010, 1, MAX_B1_ss1560010,
                             MAX_INT_B1_SQ_ss1560010, MAX_RMS_B1_ss1560010, 90.0, 
                             _flip_rf1.fixedflag ? (_temp262_flip_rf1=flip_rf1,&_temp262_flip_rf1) : &flip_rf1, (float)PSD_ss1560010_RF1_PW, NOM_BW_ss1560010,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp263_res_rf1=res_rf1,&_temp263_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp264_wg_rf1=wg_rf1,&_temp264_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss1560010.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss1560010.gz");
                whichss  = _whichss.fixedflag ?  ((void)(1560010), whichss) : 1560010;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss1560010), nbw_ssrf) : NOM_BW_ss1560010;
                break;

            case 15110022:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(1100), pw_ss_rampz) : 1100;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss15110022_RF1_PW), pw_rf1) : PSD_ss15110022_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss15110022_RF1_R), res_rf1) : PSD_ss15110022_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss15110022_RF1_LEFT;
                hrf1b = PSD_ss15110022_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss15110022_RF1_NUML), num_rf1lobe) : PSD_ss15110022_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss15110022_RF1_HlPW), pw_gzrf1lobe) : PSD_ss15110022_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp265_pw_rf1=pw_rf1,&_temp265_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp266_a_rf1=a_rf1,&_temp266_a_rf1) : &a_rf1, SAR_ABS_ss15110022,
                             SAR_Pss15110022, SAR_ARss15110022, SAR_DTCss15110022,
                             SAR_MAXPWss15110022, 1, MAX_B1_ss15110022,
                             MAX_INT_B1_SQ_ss15110022, MAX_RMS_B1_ss15110022, 90.0,  
                             _flip_rf1.fixedflag ? (_temp267_flip_rf1=flip_rf1,&_temp267_flip_rf1) : &flip_rf1, (float)PSD_ss15110022_RF1_PW, NOM_BW_ss15110022,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp268_res_rf1=res_rf1,&_temp268_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp269_wg_rf1=wg_rf1,&_temp269_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss15110022.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss15110022.gz");
                whichss  = _whichss.fixedflag ?  ((void)(15110022), whichss) : 15110022;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss15110022), nbw_ssrf) : NOM_BW_ss15110022;
                break;

            case 1528822:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(288), pw_ss_rampz) : 288;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1528822_RF1_PW), pw_rf1) : PSD_ss1528822_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1528822_RF1_R), res_rf1) : PSD_ss1528822_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss1528822_RF1_LEFT;
                hrf1b = PSD_ss1528822_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1528822_RF1_NUML), num_rf1lobe) : PSD_ss1528822_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss1528822_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1528822_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp270_pw_rf1=pw_rf1,&_temp270_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp271_a_rf1=a_rf1,&_temp271_a_rf1) : &a_rf1, SAR_ABS_ss1528822,
                             SAR_Pss1528822, SAR_ARss1528822, SAR_DTCss1528822,
                             SAR_MAXPWss1528822, 1, MAX_B1_ss1528822, 
                             MAX_INT_B1_SQ_ss1528822, MAX_RMS_B1_ss1528822, 90.0, 
                             _flip_rf1.fixedflag ? (_temp272_flip_rf1=flip_rf1,&_temp272_flip_rf1) : &flip_rf1, (float)PSD_ss1528822_RF1_PW, NOM_BW_ss1528822,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp273_res_rf1=res_rf1,&_temp273_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp274_wg_rf1=wg_rf1,&_temp274_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss1528822.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss1528822.gz");
                sprintf(hgzssfn, "/usr/g/bin/hss1528822.grd");
                whichss  = _whichss.fixedflag ?  ((void)(1528822), whichss) : 1528822;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss1528822), nbw_ssrf) : NOM_BW_ss1528822;
                off90minor  = _off90minor.fixedflag ?  ((void)(-45), off90minor) : -45;
                break;

            case 1544022:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(440), pw_ss_rampz) : 440;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1544022_RF1_PW), pw_rf1) : PSD_ss1544022_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1544022_RF1_R), res_rf1) : PSD_ss1544022_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss1544022_RF1_LEFT;
                hrf1b = PSD_ss1544022_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1544022_RF1_NUML), num_rf1lobe) : PSD_ss1544022_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss1544022_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1544022_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp275_pw_rf1=pw_rf1,&_temp275_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp276_a_rf1=a_rf1,&_temp276_a_rf1) : &a_rf1, SAR_ABS_ss1544022,
                             SAR_Pss1544022, SAR_ARss1544022, SAR_DTCss1544022,
                             SAR_MAXPWss1544022, 1, MAX_B1_ss1544022,
                             MAX_INT_B1_SQ_ss1544022, MAX_RMS_B1_ss1544022, 90.0,
                             _flip_rf1.fixedflag ? (_temp277_flip_rf1=flip_rf1,&_temp277_flip_rf1) : &flip_rf1, (float)PSD_ss1544022_RF1_PW, NOM_BW_ss1544022,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp278_res_rf1=res_rf1,&_temp278_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp279_wg_rf1=wg_rf1,&_temp279_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss1544022.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss1544022.gz");
                whichss  = _whichss.fixedflag ?  ((void)(1544022), whichss) : 1544022;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss1544022), nbw_ssrf) : NOM_BW_ss1544022;
                break;

            case 3026838:  /*YH,YZ*/
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(268), pw_ss_rampz) : 268;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss3026838_RF1_PW), pw_rf1) : PSD_ss3026838_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss3026838_RF1_R), res_rf1) : PSD_ss3026838_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss3026838_RF1_LEFT;
                hrf1b = PSD_ss3026838_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss3026838_RF1_NUML), num_rf1lobe) : PSD_ss3026838_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss3026838_RF1_HlPW), pw_gzrf1lobe) : PSD_ss3026838_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp280_pw_rf1=pw_rf1,&_temp280_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp281_a_rf1=a_rf1,&_temp281_a_rf1) : &a_rf1, SAR_ABS_ss3026838,
                             SAR_Pss3026838, SAR_ARss3026838, SAR_DTCss3026838,
                             SAR_MAXPWss3026838, 1, MAX_B1_ss3026838, 
                             MAX_INT_B1_SQ_ss3026838, MAX_RMS_B1_ss3026838, 90.0, 
                             _flip_rf1.fixedflag ? (_temp282_flip_rf1=flip_rf1,&_temp282_flip_rf1) : &flip_rf1, (float)PSD_ss3026838_RF1_PW, NOM_BW_ss3026838,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp283_res_rf1=res_rf1,&_temp283_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp284_wg_rf1=wg_rf1,&_temp284_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss3026838.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss3026838.gz");
                whichss  = _whichss.fixedflag ?  ((void)(3026838), whichss) : 3026838;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss3026838), nbw_ssrf) : NOM_BW_ss3026838;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;  /*end YH,YZ*/

                /* cxl04 19991201 add 3018027 pulse */

            case 3026033:  /*YH,YZ*/
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(260), pw_ss_rampz) : 260;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss3026033_RF1_PW), pw_rf1) : PSD_ss3026033_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss3026033_RF1_R), res_rf1) : PSD_ss3026033_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                if(exist(opflip) > 60)
                { 
                    hrf1a = PSD_ss3026033_RF1_LEFT;
                    hrf1b = PSD_ss3026033_RF1_RIGHT;
                }
                else if ((30 < opflip) && (opflip <=60))
                {
                    hrf1a = 4820; 
                    hrf1b = 4900;
                }
                else
                {
                    hrf1a = 4910;
                    hrf1b = 4810;
                }
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss3026033_RF1_NUML), num_rf1lobe) : PSD_ss3026033_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss3026033_RF1_HlPW), pw_gzrf1lobe) : PSD_ss3026033_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp285_pw_rf1=pw_rf1,&_temp285_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp286_a_rf1=a_rf1,&_temp286_a_rf1) : &a_rf1, SAR_ABS_ss3026033,
                             SAR_Pss3026033, SAR_ARss3026033, SAR_DTCss3026033,
                             SAR_MAXPWss3026033, 1, MAX_B1_ss3026033, 
                             MAX_INT_B1_SQ_ss3026033, MAX_RMS_B1_ss3026033, 90.0, 
                             _flip_rf1.fixedflag ? (_temp287_flip_rf1=flip_rf1,&_temp287_flip_rf1) : &flip_rf1, (float)PSD_ss3026033_RF1_PW, NOM_BW_ss3026033,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp288_res_rf1=res_rf1,&_temp288_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp289_wg_rf1=wg_rf1,&_temp289_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "ss3026033.rho");
                sprintf(ssgzfile, "ss3026033.gz");
                whichss  = _whichss.fixedflag ?  ((void)(3026033), whichss) : 3026033;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss3026033), nbw_ssrf) : NOM_BW_ss3026033;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;  /*end YZ */

            case 3018027:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(180), pw_ss_rampz) : 180;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss3018027_RF1_PW), pw_rf1) : PSD_ss3018027_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss3018027_RF1_R), res_rf1) : PSD_ss3018027_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss3018027_RF1_LEFT;
                hrf1b = PSD_ss3018027_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss3018027_RF1_NUML), num_rf1lobe) : PSD_ss3018027_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss3018027_RF1_HlPW), pw_gzrf1lobe) : PSD_ss3018027_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp290_pw_rf1=pw_rf1,&_temp290_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp291_a_rf1=a_rf1,&_temp291_a_rf1) : &a_rf1, SAR_ABS_ss3018027,
                             SAR_Pss3018027, SAR_ARss3018027, SAR_DTCss3018027,
                             SAR_MAXPWss3018027, 1, MAX_B1_ss3018027, 
                             MAX_INT_B1_SQ_ss3018027, MAX_RMS_B1_ss3018027, 90.0, 
                             _flip_rf1.fixedflag ? (_temp292_flip_rf1=flip_rf1,&_temp292_flip_rf1) : &flip_rf1, (float)PSD_ss3018027_RF1_PW, NOM_BW_ss3018027,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp293_res_rf1=res_rf1,&_temp293_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp294_wg_rf1=wg_rf1,&_temp294_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss3018027.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss3018027.gz");
                whichss  = _whichss.fixedflag ?  ((void)(3018027), whichss) : 3018027;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss3018027), nbw_ssrf) : NOM_BW_ss3018027;
                off90minor  = _off90minor.fixedflag ?  ((void)(-45), off90minor) : -45;
                break;

            case 15048233:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(48), pw_ss_rampz) : 48;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss15048233_RF1_PW), pw_rf1) : PSD_ss15048233_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss15048233_RF1_R), res_rf1) : PSD_ss15048233_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss15048233_RF1_LEFT;
                hrf1b = PSD_ss15048233_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss15048233_RF1_NUML), num_rf1lobe) : PSD_ss15048233_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss15048233_RF1_HlPW), pw_gzrf1lobe) : PSD_ss15048233_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp295_pw_rf1=pw_rf1,&_temp295_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp296_a_rf1=a_rf1,&_temp296_a_rf1) : &a_rf1, SAR_ABS_ss15048233,
                             SAR_Pss15048233, SAR_ARss15048233, SAR_DTCss15048233,
                             SAR_MAXPWss15048233, 1, MAX_B1_ss15048233,
                             MAX_INT_B1_SQ_ss15048233, MAX_RMS_B1_ss15048233, 90.0,
                             _flip_rf1.fixedflag ? (_temp297_flip_rf1=flip_rf1,&_temp297_flip_rf1) : &flip_rf1, (float)PSD_ss15048233_RF1_PW, NOM_BW_ss15048233,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp298_res_rf1=res_rf1,&_temp298_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp299_wg_rf1=wg_rf1,&_temp299_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "spsp15048233.rho");
                sprintf(ssgzfile, "spsp15048233.gz");
                whichss  = _whichss.fixedflag ?  ((void)(15048233), whichss) : 15048233;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss15048233), nbw_ssrf) : NOM_BW_ss15048233;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 15048234:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(48), pw_ss_rampz) : 48;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss15048234_RF1_PW), pw_rf1) : PSD_ss15048234_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss15048234_RF1_R), res_rf1) : PSD_ss15048234_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss15048234_RF1_LEFT;
                hrf1b = PSD_ss15048234_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss15048234_RF1_NUML), num_rf1lobe) : PSD_ss15048234_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss15048234_RF1_HlPW), pw_gzrf1lobe) : PSD_ss15048234_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp300_pw_rf1=pw_rf1,&_temp300_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp301_a_rf1=a_rf1,&_temp301_a_rf1) : &a_rf1, SAR_ABS_ss15048234,
                             SAR_Pss15048234, SAR_ARss15048234, SAR_DTCss15048234,
                             SAR_MAXPWss15048234, 1, MAX_B1_ss15048234,
                             MAX_INT_B1_SQ_ss15048234, MAX_RMS_B1_ss15048234, 90.0,
                             _flip_rf1.fixedflag ? (_temp302_flip_rf1=flip_rf1,&_temp302_flip_rf1) : &flip_rf1, (float)PSD_ss15048234_RF1_PW, NOM_BW_ss15048234,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp303_res_rf1=res_rf1,&_temp303_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp304_wg_rf1=wg_rf1,&_temp304_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "spsp15048234.rho");
                sprintf(ssgzfile, "spsp15048234.gz");
                whichss  = _whichss.fixedflag ?  ((void)(15048234), whichss) : 15048234;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss15048234), nbw_ssrf) : NOM_BW_ss15048234;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 15048235:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(48), pw_ss_rampz) : 48;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss15048235_RF1_PW), pw_rf1) : PSD_ss15048235_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss15048235_RF1_R), res_rf1) : PSD_ss15048235_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss15048235_RF1_LEFT;
                hrf1b = PSD_ss15048235_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss15048235_RF1_NUML), num_rf1lobe) : PSD_ss15048235_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss15048235_RF1_HlPW), pw_gzrf1lobe) : PSD_ss15048235_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp305_pw_rf1=pw_rf1,&_temp305_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp306_a_rf1=a_rf1,&_temp306_a_rf1) : &a_rf1, SAR_ABS_ss15048235,
                             SAR_Pss15048235, SAR_ARss15048235, SAR_DTCss15048235,
                             SAR_MAXPWss15048235, 1, MAX_B1_ss15048235,
                             MAX_INT_B1_SQ_ss15048235, MAX_RMS_B1_ss15048235, 90.0,
                             _flip_rf1.fixedflag ? (_temp307_flip_rf1=flip_rf1,&_temp307_flip_rf1) : &flip_rf1, (float)PSD_ss15048235_RF1_PW, NOM_BW_ss15048235,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp308_res_rf1=res_rf1,&_temp308_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp309_wg_rf1=wg_rf1,&_temp309_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "spsp15048235.rho");
                sprintf(ssgzfile, "spsp15048235.gz");
                whichss  = _whichss.fixedflag ?  ((void)(15048235), whichss) : 15048235;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss15048235), nbw_ssrf) : NOM_BW_ss15048235;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 30104233:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(104), pw_ss_rampz) : 104;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss30104233_RF1_PW), pw_rf1) : PSD_ss30104233_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss30104233_RF1_R), res_rf1) : PSD_ss30104233_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss30104233_RF1_LEFT;
                hrf1b = PSD_ss30104233_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss30104233_RF1_NUML), num_rf1lobe) : PSD_ss30104233_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss30104233_RF1_HlPW), pw_gzrf1lobe) : PSD_ss30104233_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp310_pw_rf1=pw_rf1,&_temp310_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp311_a_rf1=a_rf1,&_temp311_a_rf1) : &a_rf1, SAR_ABS_ss30104233,
                             SAR_Pss30104233, SAR_ARss30104233, SAR_DTCss30104233,
                             SAR_MAXPWss30104233, 1, MAX_B1_ss30104233,
                             MAX_INT_B1_SQ_ss30104233, MAX_RMS_B1_ss30104233, 90.0,
                             _flip_rf1.fixedflag ? (_temp312_flip_rf1=flip_rf1,&_temp312_flip_rf1) : &flip_rf1, (float)PSD_ss30104233_RF1_PW, NOM_BW_ss30104233,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp313_res_rf1=res_rf1,&_temp313_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp314_wg_rf1=wg_rf1,&_temp314_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "spsp30104233.rho");
                sprintf(ssgzfile, "spsp30104233.gz");
                whichss  = _whichss.fixedflag ?  ((void)(30104233), whichss) : 30104233;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss30104233), nbw_ssrf) : NOM_BW_ss30104233;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 30104234:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(104), pw_ss_rampz) : 104;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss30104234_RF1_PW), pw_rf1) : PSD_ss30104234_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss30104234_RF1_R), res_rf1) : PSD_ss30104234_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss30104234_RF1_LEFT;
                hrf1b = PSD_ss30104234_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss30104234_RF1_NUML), num_rf1lobe) : PSD_ss30104234_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss30104234_RF1_HlPW), pw_gzrf1lobe) : PSD_ss30104234_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp315_pw_rf1=pw_rf1,&_temp315_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp316_a_rf1=a_rf1,&_temp316_a_rf1) : &a_rf1, SAR_ABS_ss30104234,
                             SAR_Pss30104234, SAR_ARss30104234, SAR_DTCss30104234,
                             SAR_MAXPWss30104234, 1, MAX_B1_ss30104234,
                             MAX_INT_B1_SQ_ss30104234, MAX_RMS_B1_ss30104234, 90.0,
                             _flip_rf1.fixedflag ? (_temp317_flip_rf1=flip_rf1,&_temp317_flip_rf1) : &flip_rf1, (float)PSD_ss30104234_RF1_PW, NOM_BW_ss30104234,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp318_res_rf1=res_rf1,&_temp318_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp319_wg_rf1=wg_rf1,&_temp319_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "spsp30104234.rho");
                sprintf(ssgzfile, "spsp30104234.gz");
                whichss  = _whichss.fixedflag ?  ((void)(30104234), whichss) : 30104234;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss30104234), nbw_ssrf) : NOM_BW_ss30104234;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 30104235:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(104), pw_ss_rampz) : 104;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss30104235_RF1_PW), pw_rf1) : PSD_ss30104235_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss30104235_RF1_R), res_rf1) : PSD_ss30104235_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a = PSD_ss30104235_RF1_LEFT;
                hrf1b = PSD_ss30104235_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss30104235_RF1_NUML), num_rf1lobe) : PSD_ss30104235_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss30104235_RF1_HlPW), pw_gzrf1lobe) : PSD_ss30104235_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp320_pw_rf1=pw_rf1,&_temp320_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp321_a_rf1=a_rf1,&_temp321_a_rf1) : &a_rf1, SAR_ABS_ss30104235,
                             SAR_Pss30104235, SAR_ARss30104235, SAR_DTCss30104235,
                             SAR_MAXPWss30104235, 1, MAX_B1_ss30104235,
                             MAX_INT_B1_SQ_ss30104235, MAX_RMS_B1_ss30104235, 90.0,
                             _flip_rf1.fixedflag ? (_temp322_flip_rf1=flip_rf1,&_temp322_flip_rf1) : &flip_rf1, (float)PSD_ss30104235_RF1_PW, NOM_BW_ss30104235,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp323_res_rf1=res_rf1,&_temp323_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp324_wg_rf1=wg_rf1,&_temp324_wg_rf1) : &wg_rf1, rfpulse);
                sprintf(ssrffile, "spsp30104235.rho");
                sprintf(ssgzfile, "spsp30104235.gz");
                whichss  = _whichss.fixedflag ?  ((void)(30104235), whichss) : 30104235;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss30104235), nbw_ssrf) : NOM_BW_ss30104235;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;                

            default:

                epic_error(0, "SS type %d not found", 0, EE_ARGS(1),
                           INT_ARG, ss_type);

                return FAILURE;
                /* NOTREACHED */
        } /* end switch ss_type */
    } /* end if ssrf1 */

    return(SUCCESS);
}

/******************************ssEval************************************/
/* 4/21/96 RJL: Init all new Advisory Cvs */

#include "InitAdvisories.h"

/*-------------------------------------------------------------------
 * PROCEDURE: InitAdvPnlCVs
 * INPUT: none
 * OUTPUT: none
 * RETURN: none
 * SYNOPSIS: This function sets the advisory panel minimum and maximum values
 *           for advisory panel cvs which are not set in cveval. This gives us
 *           the opportunity to start placing items into the 8.0 EPIC Advisory
 *           Panel popup as desired.
 *
 *           Example:
 *                 if (exist(opssfse)!=PSD_OFF && exist(opnex)!=0.5) {
 *                      avminnex = avmaxnex = 0.5;
 *                      return ADVISORY_FAILURE;
 *                 }
 *           The above will ensure that (Nex 0.5) appears in the popup as a valid choice.
 *
 *---------------------------------------------------------------------*/
void 
InitAdvPnlCVs( void )
{
 avmaxnecho = _opnecho.maxval;
 avmaxte = _opte.maxval;
 avmaxte2 = _opte2.maxval;
 avmaxti = _opti.maxval;
 avmaxtr = _optr.maxval;
 avmaxfov = _opfov.maxval;
 avmaxyres = _opyres.maxval;
 avmaxxres = _opxres.maxval;
 avmaxrbw = _oprbw.maxval; 
 avmaxrbw2 = _oprbw2.maxval;
 avmaxsldelay = _opsldelay.maxval;
 avmaxetl = _opetl.maxval;
 avmaxslicecnt = _opslicecnt.maxval;
 avmaxnshots = _opnshots.maxval;
 avmaxphasefov = _opphasefov.maxval;
 avmaxslthick = _opslthick.maxval;
 avmaxnex = _opnex.maxval;
 avmaxflip = _opflip.maxval;
 avminnecho = _opnecho.minval;
 avminte = _opte.minval;
 avminte2 = _opte2.minval;
 avminti = _opti.minval;
 avmintr = _optr.minval;
 avminfov = _opfov.minval;
 avmaxslquant = _opslquant.maxval;
 avminslquant = _opslquant.minval;
 avminrbw = _oprbw.minval; 
 avminrbw2 = _oprbw2.minval;
 avminsldelay  = _avminsldelay.fixedflag ?  ((void)(_opsldelay.minval), avminsldelay) : _opsldelay.minval;
 avminetl = _opetl.minval;
 avminyres = _opyres.minval;
 avminslicecnt = _opslicecnt.minval;
 avminxres = _opxres.minval;
 avminnshots = _opnshots.minval;
 avminphasefov = _opphasefov.minval;
 avminslthick = _opslthick.minval;
 avminnex = _opnex.minval;
 avminflip = _opflip.minval;
 avminslspace = _opslspace.minval;
 avmaxslspace = _opslspace.maxval;
 avminbspti = _opbspti.minval;
 avmaxbspti = _opbspti.maxval;

 return;
}


/**************************************************************************/
/* CVEVAL                                                                 */
/**************************************************************************/

/*jwg bb functions for reading external waveforms*/

/*this function reads dat files written by ss_save.m*/
STATUS read_spsp_datfile(char fname[100],
						 int *specspat,
						 int *res,
						 int *pw,
						 float *nom_flip,
						 float *abswidth,
						 float *effwidth,
						 float *area,
						 float *dtycyc,
						 float *maxpw,
						 float *max_b1,
						 float *max_int_b1_sqr,
						 float *max_rms_b1,
						 float *nom_bw,
						 int *isodelay,
						 float *a_gzs,
						 float *nom_thk)
{
  char junk[80];
  FILE *fid;
  fid = fopen(fname,"r");
  if (fid==NULL)
	{
	  fprintf (stderr, "Error opening rf pulse file:  %s!!\n",fname);
	  fflush (stderr);
	  return(FAILURE);
	}
  else
	{
	  fprintf (stderr, "reading dat file:  %s\n",fname);
	}
  
  fscanf(fid,"%d %s",specspat		,junk);
  fscanf(fid,"%d %s",res		,junk);    
  fscanf(fid,"%d %s",pw		,junk);
  fscanf(fid,"%f %s",nom_flip	,junk);
  fscanf(fid,"%f %s",abswidth	,junk);
  fscanf(fid,"%f %s",effwidth	,junk);
  fscanf(fid,"%f %s",area		,junk);
  fscanf(fid,"%f %s",dtycyc		,junk);
  fscanf(fid,"%f %s",maxpw		,junk);
  fscanf(fid,"%f %s",max_b1		,junk);
  fscanf(fid,"%f %s",max_int_b1_sqr	,junk);
  fscanf(fid,"%f %s",max_rms_b1	,junk);
  if (specspat == 0) {
	fscanf(fid,"%f %s",nom_bw	,junk);
    fscanf(fid,"%d %s",isodelay	,junk);
  } else {
	fscanf(fid,"%f %s",a_gzs	,junk);
	fscanf(fid,"%f %s",nom_thk	,junk);
  }
  fclose(fid);
  return SUCCESS;
}

/*this function reads dat files written by rf_write.m*/
STATUS read_rf_datfile(char fname[100],
					   float *abswidth,
					   float *effwidth,
					   float *area,
					   float *dtycyc,
					   float *maxpw,
					   float *max_b1,
					   float *max_int_b1_sqr,
					   float *max_rms_b1,
					   float *nom_flip,
					   int *pw,
					   float *nom_bw,
					   int *isodelay,
					   int *res,
					   int *extgradfile)
{
  char junk[80];
  FILE *fid;
  
  fid = fopen(fname,"r");
  if (fid==NULL)
	{
	  fprintf (stderr, "Error opening rf pulse file:  %s!!\n",fname);
	  fflush (stderr);
	  return(FAILURE);
	}
  else
	{
	  fprintf (stderr, "reading dat file:  %s\n",fname);
	}
  
  fscanf(fid,"%f %s",abswidth	,junk);
  fscanf(fid,"%f %s",effwidth	,junk);
  fscanf(fid,"%f %s",area		,junk);
  fscanf(fid,"%f %s",dtycyc		,junk);
  fscanf(fid,"%f %s",maxpw		,junk);
  fscanf(fid,"%f %s",max_b1		,junk);
  fscanf(fid,"%f %s",max_int_b1_sqr	,junk);
  fscanf(fid,"%f %s",max_rms_b1	,junk);
  fscanf(fid,"%f %s",nom_flip	,junk);
  fscanf(fid,"%d %s",pw		,junk);
  fscanf(fid,"%f %s",nom_bw	,junk);
  fscanf(fid,"%d %s",isodelay	,junk);
  fscanf(fid,"%d %s",res		,junk);    
  fscanf(fid,"%d %s",extgradfile		,junk);    
  fclose(fid);

  
  return SUCCESS;
}

STATUS read_flip_table( void )
{
    FILE * fp;
    int ii;
    int jj;
    char filedesc[1024];

    strcpy(fileloc_vfa,"vfa_sched_");        
    sprintf(vfa_loc_tmp,"%d", vfa_flag);
    strcat(fileloc_vfa, vfa_loc_tmp);        
    strcat(fileloc_vfa,".log");   
    fprintf(stderr,"Attempting to load %s\n",fileloc_vfa);
    
    if((fp=fopen(fileloc_vfa,"r"))==NULL)
    	{
	  fprintf (stderr, "Error opening vfa file!!\n");
	  fflush (stderr);
	  return(FAILURE);
	}        
	
    /*try and load in the descriptor/first line?*/	
    fgets(filedesc,1024,fp);
	
    vfa_ctr = 0;
    while(vfa_ctr < opfphases)
    {
    	fscanf(fp, "%f ", &vfa_flips[vfa_ctr]);
	vfa_ctr++;
    }
    
    /*close the file*/
    fclose(fp);    
    
vfa_ctr = 0;
/*fprintf(stderr,"VFA schedule is: \n");*/
fprintf(stderr,"%s\n",filedesc);
for (ii = 0; ii < num_frames; ii++)
{
	for (jj = 0; jj < num_mets; jj ++)
	{
		if(jj == 0) fprintf(stderr,"Timeframe %d: %-4.4f  ",ii+1,vfa_flips[vfa_ctr]);
		else if(jj == (num_mets-1)) fprintf(stderr,"%-4.4f  \n",vfa_flips[vfa_ctr]);
		else fprintf(stderr,"%-4.4f  ",vfa_flips[vfa_ctr]);
		vfa_ctr++;
	}
	fprintf(stderr,"\n");
}
    
    return SUCCESS;
}

STATUS write_flip_table( void )
{    
    FILE * fp;
    int jj;

    strcpy(fileloc_vfa,"vfa_sched_");        
    sprintf(vfa_loc_tmp,"%d", vfa_flag);
    strcat(fileloc_vfa, vfa_loc_tmp);        
    strcat(fileloc_vfa,".log");    
    fprintf(stderr,"Attempting to write %s\n",fileloc_vfa);    

    fp=fopen(fileloc_vfa,"w");
    
    /*calculate the VFA schedule in reverse order*/
    for (vfa_ctr = (num_frames - 1); vfa_ctr >= 0; vfa_ctr--)
    {
    	if(vfa_flag == 1) {
	/*Account solely for RF decay*/
    	if(vfa_ctr == (num_frames - 1))
	{
		vfa_flips[vfa_ctr] = PI/ 2;
	} else {
		vfa_flips[vfa_ctr] = atan(sin(vfa_flips[vfa_ctr + 1])); 
	}
	/*Account for RF and T1 decay, to be written*/
	} else {
		/*this is just filler*/
		vfa_flips[vfa_ctr] = vfa_ctr * PI/ 180;
    	}
    }

    /*Write file descriptor in the first line of the VFA schedule*/
    fprintf(fp,"RF compensated VFA for %i species and %i timeframes\n", num_mets, num_frames);

    /*Now write in in the correct order*/    
    for (vfa_ctr = 0; vfa_ctr < num_frames; vfa_ctr++) 
    {
    
    	/*convert from radians to degrees*/
    	vfa_flips[vfa_ctr] = vfa_flips[vfa_ctr] * 180/ PI;
	
	/*write each flip angle num_mets times*/
	for(jj = 0; jj < num_mets; jj++)
	{
	        fprintf(fp, "%f ",vfa_flips[vfa_ctr]);			
	}
	
	/*spit it out for diagnostics!*/	
        /*if(vfa_ctr == 0) fprintf(stderr,"VFA schedule is: ");
	if(vfa_ctr < (opfphases-1)) fprintf(stderr,"%f ",vfa_flips[vfa_ctr]);
	if(vfa_ctr == (opfphases-1)) fprintf(stderr,"%f \n",vfa_flips[vfa_ctr]);		*/
    }
    
    fclose(fp);

    /*spit it out for diagnostics*/
    read_flip_table();    
    return SUCCESS;    
}

/*jwg read in SAKE blip info*/
STATUS read_sake( void )
{
    FILE * fp;
    int ii;
    char filedesc[1024];
    char sake_loc_tmp[10];

    strcpy(fileloc_sake,"sake_blips_");        
    sprintf(sake_loc_tmp,"%d", sake_flag);
    strcat(fileloc_sake, sake_loc_tmp);        
    strcat(fileloc_sake,".log");   
    fprintf(stderr,"Attempting to load %s\n",fileloc_sake);
    
    if((fp=fopen(fileloc_sake,"r"))==NULL)
    	{
	  fprintf (stderr, "Error opening SAKE blip schedule!!\n");
	  fflush (stderr);
	  return(FAILURE);
	}        
	
    /*try and load in the descriptor/first line?*/	
    fgets(filedesc,1024,fp);
	
    sake_ctr = 0;
    while(sake_ctr < (opetl-1))
    {
    	fscanf(fp, "%f ", &sake_blips[sake_ctr]);
	if(sake_blips[sake_ctr] > sake_max_blip)
	{
		sake_max_blip  = _sake_max_blip.fixedflag ?  ((void)(sake_blips[sake_ctr]), sake_max_blip) : sake_blips[sake_ctr]; 
	}
	sake_ctr++;
    }
    
    /*close the file*/
    fclose(fp);    
    
sake_ctr = 0;
fprintf(stderr,"%s\n",filedesc);
for (ii = 0; ii < (opetl-1); ii++)
{
	fprintf(stderr,"%d ",(int)sake_blips[sake_ctr]);
	sake_ctr++;
}
fprintf(stderr,"\n");
    
    return SUCCESS;
}

STATUS
cveval( void )
{
    double ave_sar;
    double peak_sar; /* temp sar value locations */
    double cave_sar;
    double b1rms;

    float c1_scale;
    int crusher_type;

    int pack_ix;
    
    ctlend_last  = _ctlend_last.fixedflag ?  ((void)(0), ctlend_last) : 0; /* initialization */
    ctlend_fill  = _ctlend_fill.fixedflag ?  ((void)(0), ctlend_fill) : 0;
    ctlend_unfill  = _ctlend_unfill.fixedflag ?  ((void)(0), ctlend_unfill) : 0;
    
    if(specnuc > 1) cfbbmod = PSD_ON; /*jwg bb*/    
    if(specnuc > 1) autolock  = _autolock.fixedflag ?  ((void)(1), autolock) : 1; /*jwg bb*/   
    
    fprintf(stderr,"At top of cveval, pw_gyb and a_gyb are %d and %f \n",pw_gyb,a_gyb);    
    
    /*jwg bb do frequency calculations for metabolites based on B0 field*/
    df1  = _df1.fixedflag ?       ((void)(df1_ppm*GAM/1000000*cffield), df1) : df1_ppm*GAM/1000000*cffield; /* freq (hz) = chem shift (ppm) * hz/(G * ppm) * B0 (G) */
    df2  = _df2.fixedflag ?       ((void)(df2_ppm*GAM/1000000*cffield), df2) : df2_ppm*GAM/1000000*cffield; 
    df3  = _df3.fixedflag ?       ((void)(df3_ppm*GAM/1000000*cffield), df3) : df3_ppm*GAM/1000000*cffield;    
    df4  = _df4.fixedflag ?       ((void)(df4_ppm*GAM/1000000*cffield), df4) : df4_ppm*GAM/1000000*cffield;    
    df5  = _df5.fixedflag ?       ((void)(df5_ppm*GAM/1000000*cffield), df5) : df5_ppm*GAM/1000000*cffield;            
   
    /*jwg bb setup vfa scheme if required*/
    /*see RFsetup_bbepi.e for more details*/
    if(vfa_flag > 2) read_flip_table();
    if(vfa_flag == 1 || vfa_flag == 2) write_flip_table();
    if(vfa_flag == 0) fprintf(stderr,"No VFA schedule!\n");
    /*jwg read sake here*/
    if(sake_flag > 0) read_sake();

    user_bw  = _user_bw.fixedflag ?  ((void)(exist(opuser23)), user_bw) : exist(opuser23);

    epi_asset_override();

/* AssetEval inlined from Asset.e  */
{
    /* New flags, originally used in efgre3d , being expanded */
    assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_OFF), assetsl_flag) : PSD_OFF;
    assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_OFF), assetph_flag) : PSD_OFF;

    /* Pick up default step size computed from avmaxaccel_ph_stride
     * and avmaxaccel_sl_stride
     * */

    avmaxaccel_sl_stride = 1.0;
    avmaxaccel_ph_stride = 1.0;
    avminaccel_sl_stride = 1.0;
    avminaccel_ph_stride = 1.0;
    piaccel_sl_stride = 1.0;
    piaccel_ph_stride = 1.0;

    assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
    if( existcv(opasset) && (1 == exist(opassetscan)) &&
        (cfaccel_sl_maxstride > 1.0) && 
        (ASSET_SUPPORT_SLICE == asset_supported_direction) )
    {
        /* ASSET selected, App & Coil support slice ASSET */

        /* Enable slice ASSET (host no longer sets slices ASSET) */
        cvoverride(opasset, ASSET_SCAN_SLICE, PSD_FIX_ON, PSD_EXIST_ON);
        assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_ON), assetsl_flag) : PSD_ON;
        avmaxaccel_sl_stride = cfaccel_sl_maxstride;

        if( existcv(opaccel_sl_stride) )
        {
            /* If user specified value, display it */
            piaccel_sl_stride = opaccel_sl_stride;
        }
        else
        {
            /* Otherwise default to min of 2.0 or the coil capability */
            piaccel_sl_stride = FMin(2, accel_sl_defstride, avmaxaccel_sl_stride);
        }

        if (exist(opaccel_sl_stride) > 1.0) {
            assetsl_factor  = _assetsl_factor.fixedflag ?    ((void)(FMin(2,1.0,1.0/exist(opaccel_sl_stride))), assetsl_factor) : FMin(2,1.0,1.0/exist(opaccel_sl_stride));
        } else {
            assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
        }
    }

    asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
    if( existcv(opasset) && (1 == exist(opassetscan)) &&
        (cfaccel_ph_maxstride > 1.0) && 
        (ASSET_SUPPORT_PHASE == asset_supported_direction) )
    {
        /* ASSET selected, App & Coil support phase ASSET */

        /* Reset to phase ASSET (host no longer sets slice ASSET ) */
        cvoverride(opasset, ASSET_SCAN_PHASE, PSD_FIX_ON, PSD_EXIST_ON);

        assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_ON), assetph_flag) : PSD_ON;
        avmaxaccel_ph_stride = cfaccel_ph_maxstride;

        if( existcv(opaccel_ph_stride) )
        {
            /* If user specified value, display it */
            piaccel_ph_stride = opaccel_ph_stride;
        }
        else
        {
            /* Otherwise default to min of 2.0 and the coil capability */
            piaccel_ph_stride = FMin(2, accel_ph_defstride, avmaxaccel_ph_stride);
        }

        if (exist(opaccel_ph_stride) > 1.0) {
            asset_factor  = _asset_factor.fixedflag ?    ((void)(FMin(2,1.0,1.0/exist(opaccel_ph_stride))), asset_factor) : FMin(2,1.0,1.0/exist(opaccel_ph_stride));
        } else {
            asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
        }
    }

    /* Set asset_factor */
    /* MRIge92386 */
    if( existcv(opasset) &&  exist(opassetscan) == PSD_ON )
    {
        piaccelscrn = PSD_ON;

        /* Set up the PI pulldown */
        setAccelPulldown (avmaxaccel_ph_stride, avmaxaccel_sl_stride, 
                          &piaccel_phval2, &piaccel_phval3,
                          &piaccel_phval4, &piaccel_phval5,
                          &piaccel_phval6, &piaccel_phnub,
                          &piaccel_phedit, &piaccel_slval2,
                          &piaccel_slval3, &piaccel_slval4,
                          &piaccel_slval5, &piaccel_slval6,
                          &piaccel_slnub, &piaccel_sledit,
                          &piaccel_ph_step, &piaccel_sl_step);
    } 
    else
    {
        asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
        assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
        assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_OFF), assetph_flag) : PSD_OFF;
        assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_OFF), assetsl_flag) : PSD_OFF;
        if(PSD_OFF == exist(oparc))
        {
            piaccel_slnub = 0.0;
            piaccel_phnub = 0.0;
            piaccelscrn = PSD_OFF;
        }        
    }
} 

/* AssetEval inlined from Asset.e  */

    epi_asset_set_dropdown();

    /* update gradient config for DVw  */
    if(cfgcoiltype == PSD_XRMW_COIL && epigradspec_flag == PSD_ON)
    {
        dvw_grad_test  = _dvw_grad_test.fixedflag ?  ((void)(exist(opuser1)), dvw_grad_test) : exist(opuser1);
        if(dvw_grad_test != save_dvw_grad_test)
        {
            save_dvw_grad_test = dvw_grad_test;
            switch(dvw_grad_test)
            {
                case 1: 
                    config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_DVW_AMP20SR150), config_update_mode) : CONFIG_UPDATE_TYPE_DVW_AMP20SR150; 
                break;
                case 2: 
                    config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_DVW_AMP34SR120), config_update_mode) : CONFIG_UPDATE_TYPE_DVW_AMP34SR120; 
                break;
                default: 
                    config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_DVW_DEFAULT), config_update_mode) : CONFIG_UPDATE_TYPE_DVW_DEFAULT; 
                break;
            }
            inittargets(&loggrd, &phygrd);
            inittargets(&epiloggrd, &epiphygrd);
            epiphygrd.xrt = cfrmp2xfs;
            epiphygrd.yrt = cfrmp2yfs;
            epiphygrd.zrt = cfrmp2zfs;
            epiphygrd.xft = cffall2x0;
            epiphygrd.yft = cffall2y0;
            epiphygrd.zft = cffall2z0;
            epiloggrd.xrt = epiloggrd.yrt = epiloggrd.zrt =
                IMax(3,cfrmp2xfs,cfrmp2yfs,cfrmp2zfs);
            epiloggrd.xft = epiloggrd.yft = epiloggrd.zft =
                IMax(3,cffall2x0,cffall2y0,cffall2z0);
            opnewgeo = PSD_ON;
        }

    }

    /* Silent Mode  05/19/2005 YI */
    /* Get gradient spec for silent mode */
    getSilentSpec(exist(opsilent), _grad_spec_ctrl.fixedflag ? (_temp325_grad_spec_ctrl=grad_spec_ctrl,&_temp325_grad_spec_ctrl) : &grad_spec_ctrl, _glimit.fixedflag ? (_temp326_glimit=glimit,&_temp326_glimit) : &glimit, _srate.fixedflag ? (_temp327_srate=srate,&_temp327_srate) : &srate);

    /* MRIhc56520: for EPI with ART on 750w. */
    if (exist(opsilent) && (cffield == B0_30000) && (cfgcoiltype == PSD_XRMW_COIL))
    {
        srate  = _srate.fixedflag ?  ((void)(XRMW_3T_EPI_ART_SR), srate) : XRMW_3T_EPI_ART_SR;
    }

    /* Update configurable variables */
    if(set_grad_spec(grad_spec_ctrl,glimit,srate,PSD_ON,debug_grad_spec) == FAILURE)
    {
      epic_error(use_ermes,"Support routine set_grad_spec failed",
        EM_PSD_SUPPORT_FAILURE,1, STRING_ARG,"set_grad_spec");
        return FAILURE;
    }
    /* Skip setupConfig() if grad_spec_ctrl is turned on */
    if(grad_spec_change_flag) { 
        if(grad_spec_ctrl)config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_SKIP), config_update_mode) : CONFIG_UPDATE_TYPE_SKIP;
        else              config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_ACGD_PLUS), config_update_mode) : CONFIG_UPDATE_TYPE_ACGD_PLUS;
        inittargets(&loggrd, &phygrd);
        inittargets(&epiloggrd, &epiphygrd);
        epiphygrd.xrt = cfrmp2xfs;
        epiphygrd.yrt = cfrmp2yfs;
        epiphygrd.zrt = cfrmp2zfs;
        epiphygrd.xft = cffall2x0;
        epiphygrd.yft = cffall2y0;
        epiphygrd.zft = cffall2z0;
        epiloggrd.xrt = epiloggrd.yrt = epiloggrd.zrt =
            IMax(3,cfrmp2xfs,cfrmp2yfs,cfrmp2zfs);
        epiloggrd.xft = epiloggrd.yft = epiloggrd.zft =
            IMax(3,cffall2x0,cffall2y0,cffall2z0);
    }
    /* End Silent Mode */

    /* internref */  /* MRIhc06307 and MRIhc19932 */
    /* jwg bb added enable_iref_etl == 0 for C13 dynamic studies*/
    if( exist(opnshots) == 1 && acqs == 1 && enable_iref_etl == 1 &&(exist(opfmri) == PSD_ON || (mph_flag && (opfphases > 10) && (opacqo == PSD_OFF) && (PSD_OFF == touch_flag)) )){
 
        iref_etl  = _iref_etl.fixedflag ?  ((void)(DEFAULT_IREF_ETL), iref_etl) : DEFAULT_IREF_ETL;

    } else {

        iref_etl  = _iref_etl.fixedflag ?  ((void)(0), iref_etl) : 0;

    }

    rtb0_flag  = _rtb0_flag.fixedflag ?  ((void)(PSD_OFF), rtb0_flag) : PSD_OFF;
    rtb0_comp_flag  = _rtb0_comp_flag.fixedflag ?  ((void)(rtb0_flag), rtb0_comp_flag) : rtb0_flag;
    if(psd_board_type == PSDCERD || psd_board_type == PSDDVMR)
    {
        pack_ix = PSD_XCVR2;
    }
    else
    {
        pack_ix = 0;
    }
    rtb0_minintervalb4acq  = _rtb0_minintervalb4acq.fixedflag ?   
                                        
                                        ((void)(IMax(3,DABSETUP,XTRSETLNG+XTR_length[pack_ix]+DAB_length[pack_ix],XTRSETLNG+XTR_length[pack_ix]-rcvr_ub_off)), rtb0_minintervalb4acq) : IMax(3,DABSETUP,XTRSETLNG+XTR_length[pack_ix]+DAB_length[pack_ix],XTRSETLNG+XTR_length[pack_ix]-rcvr_ub_off);

    /* internref: following error checks are only for testing. 
     * should not be in error database */

    if( iref_etl < 0 ){
        epic_error(0,"Please set iref_etl not less than 0",0, 0);
        return FAILURE;
    }

    if((!rtb0_flag) && rtb0_comp_flag) {
        epic_error(0,"rtb0_comp_flag should not be ON when rtb0_flag is OFF",0, 0);
        return FAILURE;
    }

    if(iref_etl == 0 && rtb0_flag) {
        epic_error(0,"rtb0_flag should not be ON when iref_etl is 0",0, 0);
        return FAILURE;
    }

    if( ky_dir == PSD_CENTER_OUT && iref_etl != 0 ){
        epic_error(0,"Internal reference is incompatible with CENTER_OUT",0, 0);
        return FAILURE;
    }
    if( seq_data != 0 && iref_etl != 0 ){
        epic_error(0,"seq_data must be 0 when iref_etl > 0",0, 0);
        return FAILURE;
    }

    if( gy1pos != 1 && iref_etl != 0 ){
        epic_error(0,"gy1pos must be 1 when iref_etl > 0",0, 0);
        return FAILURE;
    }

    if( opacqo != 0 && iref_etl != 0 ){
        epic_error(0,"Sequential multi-phase is not compatible with iref_etl > 0",0, 0);
        return FAILURE;
    }

/* Start inline from touch.e TouchEval */
if( touch_flag )
{
    watchdogcount  = _watchdogcount.fixedflag ?  ((void)(15), watchdogcount) : 15; /* increase delay to allow for parameter download to active driver */
    /* Setup MR-Touch UI */
    pitouch = 1;

    pitouchaxnub = 7;
    pideftouchax = 4;
    pitouchaxval2 = 1;
    pitouchaxval3 = 2;
    pitouchaxval4 = 4;

    pideftouchtphases = 4;
    pideftouchfreq = 60;
    pideftouchcyc = 60;
    pideftouchamp = 70;
    pideftouchmegfreq = 60;

    pinecho  = _pinecho.fixedflag ?  ((void)(1), pinecho) : 1;

    pitrnub = 6;
    pitrval2 = 1000000;
    pitrval3 = 2000000;
    pitrval4 = 3000000;
    pitrval5 = 4000000;
    pitrval6 = 5000000;
                         
    /* ****************************** */
    /* set some multiphase parameters */
    /* ****************************** */
    cvoverride(opfphases,  exist(optouchtphases), PSD_FIX_ON, PSD_EXIST_ON);
    TR_PASS  = _TR_PASS.fixedflag ?  ((void)(20000), TR_PASS) : 20000;
    cvmin(opsldelay, TR_PASS);
    cvdef(opsldelay, TR_PASS);
    opsldelay  = _opsldelay.fixedflag ?  ((void)(TR_PASS), opsldelay) : TR_PASS;

    /* turn on multiphase screen */
    multiphase_flag  = _multiphase_flag.fixedflag ?  ((void)(PSD_ON), multiphase_flag) : PSD_ON;

    cvdef(opacqo, 0);
    opacqo  = _opacqo.fixedflag ?  ((void)(0), opacqo) : 0;

    if( PSD_ON == multiphase_flag )
    {
        multi_phases  = _multi_phases.fixedflag ?  ((void)(opfphases), multi_phases) : opfphases;
    }
    else
    {
        multi_phases  = _multi_phases.fixedflag ?  ((void)(1), multi_phases) : 1;
    }

    /* set frequency and phase encoding number pulldown menus */
    cvmax(opxres, 256);
    pixresval2 = 64;
    pixresval3 = 80;
    pixresval4 = 96;
    pixresval5 = 128;
    pixresval6 = 160;

    cvmax(opyres, 256);
    piyresval2 = 64;
    piyresval3 = 80;
    piyresval4 = 96;
    piyresval5 = 128;
    piyresval6 = 160;

    cvdef(optouchcyc, 60);
}
else{
    pitouch = 0;
    multiphase_flag  = _multiphase_flag.fixedflag ?  ((void)(PSD_OFF), multiphase_flag) : PSD_OFF;
    multi_phases  = _multi_phases.fixedflag ?  ((void)(1), multi_phases) : 1;
}
/* End inline from touch.e TouchEval */


    /* SXZ::MRIge76397: disable user cv page if no option inside */
    if( piuset == 0 ) pititle  = _pititle.fixedflag ?  ((void)(0), pititle) : 0;
    
    /* SXZ::MRIge80335 */
    if( exist(opuser0) == 1 )
    { 
        vrgfsamp  = _vrgfsamp.fixedflag ?  ((void)(1), vrgfsamp) : 1;
        /* MRIhc24685: The maximum xres allowed with ramp sampling ON  is 256 */
        cvmax(opxres, 256);

        if( (epispec_flag == PSD_ON) || (epiespopt_flag == PSD_ON) || (epiRTespopt_flag == PSD_ON) ||
            (epiminesp_flag == PSD_ON) || (epiRTminesp_flag == PSD_ON) || (dbdt_model == DBDTMODELCONV) ||
            ((cffield == B0_15000) && (PSD_XRMB_COIL == cfgcoiltype)))
        {
            rampopt  = _rampopt.fixedflag ?  ((void)(0), rampopt) : 0; 
        }
        else
        {
            rampopt  = _rampopt.fixedflag ?  ((void)(1), rampopt) : 1;
        } 
    }
    else
    {
        vrgfsamp  = _vrgfsamp.fixedflag ?  ((void)(0), vrgfsamp) : 0;
        /* MRIhc24685: The maximum xres allowed with ramp sampling OFF is 512 */ 
        cvmax(opxres, 512);
        rampopt  = _rampopt.fixedflag ?  ((void)(0), rampopt) : 0;
    }


    /* 4/21/96 RJL: Init all new Advisory Cvs from InitAdvisories.e */
    InitAdvPnlCVs();

    /* Initialize advisory panel values */
    avmaxtr = TR_MAX;
    avmaxslquant = 1;
    avminnecho = 1; 
    avmaxnecho = 1;
    
    avminphasefov = 0.5;
    avmaxphasefov = 1.0;
    if (touch_flag)
    {
        avminsldelay  = _avminsldelay.fixedflag ?  ((void)(TR_PASS), avminsldelay) : TR_PASS;
    }
    else
    {
        avminsldelay  = _avminsldelay.fixedflag ?    ((void)(0), avminsldelay) : 0;  /* minimum delay between passes */
    }
    avmaxsldelay = 20000000;

    avminxres = 16; /*jwg bb changed from 32 to 16 for c13*/
    avmaxxres = 512;
    
    /* Make sure Y res is within a valid range */
    if( opyres < avminyres ) {
        epic_error( use_ermes, "The phase encoding steps must be increased to %d for the current prescription.", EM_PSD_YRES_OUT_OF_RANGE2, EE_ARGS(1), INT_ARG, avminyres );
        return ADVISORY_FAILURE;
    }
    if( opyres > avmaxyres ) {
        epic_error( use_ermes, "The phase encoding steps must be decreased to %d for the current prescription.", EM_PSD_YRES_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, avmaxyres );
        return ADVISORY_FAILURE;
    }

    /* Setsysparms sets the psd_grd_wait and psd_rf_wait
       parameters for the particular system. */
    if (setsysparms() == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setsysparms");
        return FAILURE;
    }
    
    ir_on  = _ir_on.fixedflag ?  ((void)(exist(opirprep)), ir_on) : exist(opirprep);
    epi_ir_on  = _epi_ir_on.fixedflag ?  ((void)(ir_on), epi_ir_on) : ir_on;
    
    /* ***************************
       Multi-Phase parameters
       *************************** */
    mph_flag  = _mph_flag.fixedflag ?        ((void)(((exist(optouch)||exist(opmph))==PSD_ON?PSD_ON:PSD_OFF)), mph_flag) : ((exist(optouch)||exist(opmph))==PSD_ON?PSD_ON:PSD_OFF);
    
    if ( (mph_flag==PSD_ON) && (exist(opacqo)==0) && 
         (exist(opcgate)==PSD_ON) ) {   /* multi-rep cardiac gated */
        pass_reps  = _pass_reps.fixedflag ?  ((void)(exist(opfphases)), pass_reps) : exist(opfphases);
        reps  = _reps.fixedflag ?  ((void)(1), reps) : 1;
    } else { 
        if ( (mph_flag==PSD_ON) && (exist(opacqo)==0) ) {  /* interleaved multi-phase */
            pass_reps  = _pass_reps.fixedflag ?  ((void)(exist(opfphases)), pass_reps) : exist(opfphases);
            reps  = _reps.fixedflag ?  ((void)(1), reps) : 1;
        } else { 
            if ( (mph_flag==PSD_ON) && (exist(opacqo)==1) ) { /* sequential multi-phase */
                reps  = _reps.fixedflag ?  ((void)(exist(opfphases)), reps) : exist(opfphases);
                pass_reps  = _pass_reps.fixedflag ?  ((void)(1), pass_reps) : 1;
            } else {  /* default */
                reps  = _reps.fixedflag ?  ((void)(1), reps) : 1;
                pass_reps  = _pass_reps.fixedflag ?  ((void)(1), pass_reps) : 1;
            }
        }
    } /* end if(mph_flag.... */

    acqmode  = _acqmode.fixedflag ?   ((void)(exist(opacqo)), acqmode) : exist(opacqo); /* acq mode, 0=interleaved, 1=def=sequential */
    rhuser4  = _rhuser4.fixedflag ?  ((void)(acqmode), rhuser4) : acqmode; /* for recon fix MRIge36453 */

    /* MRIhc07356 */
    /* YMSmr06713  04/26/2005 YI */
    if (existcv(opsldelay) && (exist(opsldelay) == avminsldelay) && (avminsldelay <= 1  )) {

        /* set pass_delay to min. = 1 us which is effectively    */
        /* a delay = 0us between passes since the delay between */
        /* each null pass is also 1 us.                         */
        pass_delay  = _pass_delay.fixedflag ?    ((void)(1), pass_delay) : 1;
        num_passdelay  = _num_passdelay.fixedflag ?  ((void)(1), num_passdelay) : 1;
        
    } else {

        /* Else...set the delay to the prescribed value */
        pass_delay  = _pass_delay.fixedflag ?  ((void)(exist(opsldelay)), pass_delay) : exist(opsldelay);
        if (pass_delay > 15000000) {
            num_passdelay  = _num_passdelay.fixedflag ?  ((void)(pass_delay/15000000+((pass_delay%15000000==0)?0:1)), num_passdelay) : pass_delay/15000000+((pass_delay%15000000==0)?0:1);
        }
        else {
            num_passdelay  = _num_passdelay.fixedflag ?  ((void)(1), num_passdelay) : 1;
        }
        pass_delay  = _pass_delay.fixedflag ?  ((void)(pass_delay/num_passdelay+1), pass_delay) : pass_delay/num_passdelay+1;

    }

    piphases  = _piphases.fixedflag ?  ((void)(exist(opphases)), piphases) : exist(opphases);
    max_phases  = _max_phases.fixedflag ?  ((void)(piphases), max_phases) : piphases;
        
    if (cffield == B0_5000) 
    { /* at 0.5T, turn on fatsat, turn off spsp */
        cvoverride(opsat, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        cvoverride(opfat, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        ss_rf1  = _ss_rf1.fixedflag ?  ((void)(PSD_OFF), ss_rf1) : PSD_OFF;
    }
    
    /* MRIge48532 - turn on eosykiller if ss_rf1 = PSD_ON */
    if (exist(opfat) == PSD_ON) 
    {
        ss_rf1  = _ss_rf1.fixedflag ?  ((void)(PSD_OFF), ss_rf1) : PSD_OFF;
        eosykiller  = _eosykiller.fixedflag ?  ((void)(PSD_OFF), eosykiller) : PSD_OFF;
    } 
    else 
    {
        ss_rf1  = _ss_rf1.fixedflag ?  ((void)(PSD_ON), ss_rf1) : PSD_ON;
        eosykiller  = _eosykiller.fixedflag ?  ((void)(PSD_ON), eosykiller) : PSD_ON;
    }

    /* BJM: epi Specs */
    if(epispec_flag == PSD_ON) 
    {
        ss_rf1  = _ss_rf1.fixedflag ?  ((void)(PSD_OFF), ss_rf1) : PSD_OFF;        /* turn off spatial spectral flag */
    }

    opautotr  = _opautotr.fixedflag ?  ((void)(0), opautotr) : 0;
    fast_rec  = _fast_rec.fixedflag ?  ((void)(0), fast_rec) : 0;
    cvmin(intleaves, 1);
    cvmax(intleaves, avmaxyres);
    
    /* gxdelay and gydelay must lie on 4us bundaries */
    if (gxdelay % GRAD_UPDATE_TIME != 0) {
        cvoverride(gxdelay,RUP_GRD(gxdelay),_gxdelay.fixedflag, _gxdelay.existflag);
    }
    
    if (gydelay % GRAD_UPDATE_TIME != 0) {
        cvoverride(gydelay,RUP_GRD(gydelay),_gydelay.fixedflag, _gydelay.existflag);
    }
    
    intleaves  = _intleaves.fixedflag ?  ((void)(exist(opnshots)), intleaves) : exist(opnshots);
    
    piphasfovnub = 0;
    /* Variable FOV buttons on or off depending on square pixels */
    if ( (exist(opsquare) == PSD_ON) || (exist(opnopwrap) == PSD_ON) ) {
        piphasfovnub2 = 0;
    } else {
        piphasfovnub2 = 7;
        piphasfovval2 = 1.0;
        piphasfovval3 = 0.5;
    }
    
    /* Set default frequency encoding direction for head R/L  QT*/
    if (( TX_COIL_LOCAL == txCoilInfo[getTxIndex(coilInfo[0])].txCoilType 
          && ( exist(opplane) == PSD_AXIAL || exist(opplane)== PSD_COR) ) ||
        ( TX_COIL_LOCAL == txCoilInfo[getTxIndex(coilInfo[0])].txCoilType 
          && exist(opplane) == PSD_OBL && existcv(opplane) 
          && ( exist(opobplane) == PSD_AXIAL || exist(opobplane) == PSD_COR ))) 
        piswapfc = 1;
    else 
        piswapfc = 0;
    
    /****  Asymmetric Fov  ****/
    /* handling for phase (y) resolution and recon scale factor.*/
    if ( (exist(opphasefov) != 1.0) && existcv(opphasefov) 
         && ( (exist(opsquare) != PSD_ON) && existcv(opsquare) ) ) {
        rhphasescale  = _rhphasescale.fixedflag ?  ((void)(exist(opphasefov)), rhphasescale) : exist(opphasefov);
        eg_phaseres  = _eg_phaseres.fixedflag ?  ((void)(exist(opyres)), eg_phaseres) : exist(opyres);
    } else { 
        if (exist(opsquare) == PSD_ON) {
            rhphasescale  = _rhphasescale.fixedflag ?  ((void)((float)exist(opyres)/(float)exist(opxres)), rhphasescale) : (float)exist(opyres)/(float)exist(opxres);
            
            /* MRIge50536 - BJM: only set this if yres exists */
            /* MRIge61054 - BSA Menu chase correction,  error trapping moved to cvcheck */
            if( existcv(opyres) && existcv(opxres) && (rhphasescale<=1.0) && (0.5<=rhphasescale) ) {
                setexist(opphasefov,PSD_ON);
                _opphasefov.fixedflag = 0;
                opphasefov  = _opphasefov.fixedflag ?  ((void)(rhphasescale), opphasefov) : rhphasescale;
                _opphasefov.fixedflag = 1;
                eg_phaseres  = _eg_phaseres.fixedflag ?  ((void)(exist(opxres)), eg_phaseres) : exist(opxres);
            }
        } else {
            rhphasescale  = _rhphasescale.fixedflag ?  ((void)(1.0), rhphasescale) : 1.0;
            _opphasefov.fixedflag = 0;
            opphasefov  = _opphasefov.fixedflag ?  ((void)(1.0), opphasefov) : 1.0;
            _opphasefov.fixedflag = 1;
            eg_phaseres  = _eg_phaseres.fixedflag ?  ((void)(exist(opyres)), eg_phaseres) : exist(opyres);
        }
    }
    
    /* set up rhfreqscale */
    rhfreqscale  = _rhfreqscale.fixedflag ?  ((void)(1.0), rhfreqscale) : 1.0;
    dfg  = _dfg.fixedflag ?  ((void)(1), dfg) : 1;
    dfscale = 1.0;
    freq_scale  = _freq_scale.fixedflag ?  ((void)(rhfreqscale), freq_scale) : rhfreqscale;
       
    /**********************************************************************
     Initialize RF System Safety Information.  This must be re-initialized
     in eval section since CV changes may lead to scaling of rfpulse.
    *********************************************************************/
    for (pulse=0; pulse<RF_FREE; pulse++) {
        rfpulseInfo[pulse].change=PSD_OFF;
        rfpulseInfo[pulse].newres=0;
    }
    /* Reinitialize Prescan CV's for cveval. Done so rf system safety check
       can be performed with each OPIO change. */

    { /* Start of code inlined from vmx.e SysParmEval */
        if( cfpwrmontyp == PMTYP_VMX ) 
        {
            system_type  = _system_type.fixedflag ?  ((void)(1), system_type) : 1;
            rfupa = cv_rfupa;
        }
        if( (cfgradcoil == GCOIL_HGC)||(cfgradcoil == GCOIL_VECTRA) )
        {
            avmaxfov = FOV_MAX_VMX;
            _opweight.maxval = 150.0;
        }
        if(cffield == 2000)
        {
            avmaxfov = FOV_MAX_PROFILE;
            _opweight.maxval = 180.0;
        }
        if(cffield == 3500)
        {
            avmaxfov = FOV_MAX_PROFILE;
        }

        if( (exist(opimode) != PSD_3D) && (exist(opimode) != PSD_3DM)
           && (exist(oppseq) != PSD_TOF) && (exist(oppseq) != PSD_TOFSP)
           && (cffield <= B0_5000) ) 
        {
            if( exist(opslthick) < MINTHICK_VMX )
            { 
                epic_error(use_ermes, "Increase the slice thickness to %.1f",
                           EM_PSD_SLTHICK_OUT_OF_RANGE, EE_ARGS(1), FLOAT_ARG, MINTHICK_VMX);
                return FAILURE;
            }
        }

        /* Set pipure based on coil and application compatibility */
        pipure = coilInfo[0].pureCompatible;
        if ((PSD_SPECTRO == exist(opimode)) ||
            (PSD_3PLANE == exist(opplane)) ||
            (PSD_ON == exist(opassetcal)) || (PSD_ON == exist(oppurecal)) ||
            (PSD_ON == exist(oprealtime)))
        {
            pipure = 0;
        }

        if( psd_board_type == PSDCERD || psd_board_type == PSDDVMR )
        {
            
            if( cftpssize <= 0 )
            {
                if (VALUE_SYSTEM_HDE == value_system_flag) {
                    cftpssize = 133954560;
                }else {
                    cftpssize = 1670381568.0;
                }
            }
        }

        /* MRIhc41001 - maximum attenuation available for PSD
         * (xmtadd) usage is the hardware maximum minus 200 for
         * TG. (ampCal is unused and coil attenuation is included
         * in xmtadd.
         */
        cfdbmax = IMax(2, 0, cfrfMaxAttenuation - 200);

        /* Dynamic Plan */
        if( (exist(opdynaplan) == PSD_ON) && existcv(opdynaplan) ) {
            if(checkOptionKey( SOK_MPHVAR )){
                epic_error( use_ermes,
                            "%s is not available without the option key.",
                            EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1),
                            STRING_ARG, "Multi-Phase (variable delays)" );
                return FAILURE;
            }
            if( (exist(opfmri) == PSD_ON) && existcv(opfmri) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"fMRI");
                return FAILURE;
            }
            if( (exist(opectricks) == PSD_ON) && existcv(opectricks) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"ECTRICKS");
                return FAILURE;
            }
            if( (exist(opmph) == PSD_ON) && existcv(opmph) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Multi Phase");
                return FAILURE;
            }
            if( (exist(opcgate) == PSD_ON) && existcv(opcgate) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Cardiac Gating");
                return FAILURE;
            }
            if( (exist(oprtcgate) == PSD_ON) && existcv(oprtcgate) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Respiratory Triggering");
                return FAILURE;
            }
            if( (exist(oprealtime) == PSD_ON) && existcv(oprealtime) && (exist(opfluorotrigger) == PSD_OFF) && existcv(opfluorotrigger) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Realtime");
                return FAILURE;
            }
            /* MRIhc08845  08/03/2005 YI */
            if( (exist(opcosmic) == PSD_ON) && existcv(opcosmic) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"COSMIC");
                return FAILURE;
            }
            if( (exist(opswift) == PSD_ON) && existcv(opswift) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"SWIFT");
                return FAILURE;
            }
            if( (exist(opmerge) == PSD_ON) && existcv(opmerge) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"MERGE");
                return FAILURE;
            }
            /* MRIhc09973  09/07/2005 YI */
            if( (exist(opplane) == PSD_3PLANE) && existcv(opplane) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Localizer");
                return FAILURE;
            }
            if( (exist(optensor) > PSD_OFF) && existcv(optensor) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"TENSOR");
                return FAILURE;
            }
            if(NON_VALUE_SYSTEM == value_system_flag){
                if( (2 == exist(opnecho)) && (PSD_3D != exist(opimode)) && 
                    ((PSD_GE == exist(oppseq)) ||
                     (PSD_SPGR == exist(oppseq))) ) {
                    epic_error(use_ermes,"%s is incompatible with %s.",
                                EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                                STRING_ARG,"FGRE Dual Echo");
                    return FAILURE;
                }
                /* MRIhc09972  09/06/2005 YI */
                if( ((PSD_TOF == exist(oppseq)) || (PSD_TOFSP == exist(oppseq))) && (exist(opimode) == PSD_2D) ) {
                    epic_error(use_ermes,"%s is incompatible with %s.",
                                EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                                STRING_ARG,"Fast TOF");
                    return FAILURE;
                }
                if( (exist(opdiffuse) == PSD_ON) && existcv(opdiffuse) ) {
                    epic_error(use_ermes,"%s is incompatible with %s.",
                                EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                                STRING_ARG,"DWI");
                    return FAILURE;
                }
            }
        } /* End of Dynamic Plan */
        /* Update default values based on the system configuration */
        configSystem();
    } /* End of code inlined from vmx.e SysParmEval */

	fprintf(stderr,"before obloptim, pw_gyb and a_gyb are %d and %f \n\n\n\n",pw_gyb,a_gyb);    
    if (exist(opslquant) == 3 && b0calmode == 1) {
        setb0rotmats();
         
        save_newgeo = opnewgeo;
         
        if (obloptimize_epi(&loggrd, &phygrd, scan_info, exist(opslquant),
                            PSD_OBL, 0, 1, obl_debug, &opnewgeo, cfsrmode)==FAILURE) {
            psd_dump_scan_info();
            epic_error(use_ermes,"%s failed in %s", EM_PSD_FUNCTION_FAILURE,
                       EE_ARGS(2), STRING_ARG, "obloptimize_epi",
                       STRING_ARG, "cveval()");
            return FAILURE;
        }
         
        /* BJM: MRIge47073 derate non readout waveforms */
        dbdtderate(&loggrd, 0);  
         
        /* call for epiloggrd */
        opnewgeo = save_newgeo;
        if (obloptimize_epi(&epiloggrd, &epiphygrd, scan_info, exist(opslquant),
                            PSD_OBL, 0, 1, obl_debug, &opnewgeo, cfsrmode)==FAILURE) {
            psd_dump_scan_info();
            epic_error(use_ermes, "%s failed in %s", EM_PSD_FUNCTION_FAILURE,
                       EE_ARGS(2), STRING_ARG, "obloptimize_epi",
                       STRING_ARG, "cveval()");
            return FAILURE;
        }    
         
    } else {
        save_newgeo = opnewgeo;
        if (obloptimize_epi(&loggrd, &phygrd, scan_info, exist(opslquant),
                            exist(opplane), exist(opcoax), obl_method,
                            obl_debug, &opnewgeo, cfsrmode)==FAILURE) {
            psd_dump_scan_info();
            epic_error(use_ermes,"%s failed in %s", EM_PSD_FUNCTION_FAILURE,
                       EE_ARGS(2), STRING_ARG, "obloptimize_epi",
                       STRING_ARG, "cveval()");
            return FAILURE; 
        }
         
        /* BJM: MRIge47073 derate non readout waveforms */
        dbdtderate(&loggrd, 0);  
         
        opnewgeo = save_newgeo;
        if (obloptimize_epi(&epiloggrd, &epiphygrd, scan_info, exist(opslquant),
                            exist(opplane), exist(opcoax), obl_method,
                            obl_debug, &opnewgeo, cfsrmode)==FAILURE) {
            psd_dump_scan_info();
            epic_error(use_ermes, "%s failed in %s", EM_PSD_FUNCTION_FAILURE,
                       EE_ARGS(2), STRING_ARG, "obloptimize_epi",
                       STRING_ARG, "cveval()");
            return FAILURE; 
        }

    } /* end if (exist(opslquant) == 3 && b0calmode == 1) */
    	fprintf(stderr,"after obloptim, pw_gyb and a_gyb are %d and %f \n\n\n\n",pw_gyb,a_gyb);    
    /* reinitialize sat and prescan vars in case loggrd changed */
    
    if (SpSatInit(vrgsat) == FAILURE) return FAILURE;
 
    { /* Start of code inlined from ChemSat.e ChemSatInit */
        cyc_rfcssat  = _cyc_rfcssat.fixedflag ?  ((void)(1), cyc_rfcssat) : 1;
        alpha_rfcssat  = _alpha_rfcssat.fixedflag ?  ((void)(0.46), alpha_rfcssat) : 0.46;

        /* vmx 3/13/95 YI */
        if(cfpwrmontyp == PMTYP_VMX) 
        {
            csat_sys_type  = _csat_sys_type.fixedflag ?  ((void)(1), csat_sys_type) : 1;
            rfupa = csat_rfupa;
        }
        /* end vmx */
    } /* Start of code inlined from ChemSat.e ChemSatInit */

    {    /* Code inlined from BroadBand.e BBcvinit */
        
        if(cfbbmod == PSD_ON) {
            cvmax(acquire_type, SPECPSD_SLAVE_MNS);
        } else {
            cvmax(acquire_type, SPECPSD_MASTER_H1);
        }

    }    /* End of code inlined from BroadBand.e BBcvinit */

    { /* Start of code inlined from Prescan.e PScvinit */
        /*********************************************************************
         *                     PRESCAN.E HOST SECTION                        *
         *                           PScvinit                                *
         *                                                                   *
         * Write here the code unique to the Host PSD process. All code to   *
         * be executed in cvinit() must be written here.                     *
         *********************************************************************/
        
        cvdef(mpsfov, cfsystemmaxfov);
        cvdef(FTGfov, cfsystemmaxfov);
        
        FTGfov  = _FTGfov.fixedflag ?  ((void)(cfsystemmaxfov), FTGfov) : cfsystemmaxfov;

        PScvinit();
        FTGcvinit();
        XTGcvinit();
        AScvinit();
        RGcvinit();
     } /* End of code inlined from Prescan.e PScvinit */

    { /* Start of code inlined from Inversion.e InversionInit */
        /* vmx 3/13/95 YI */
        if(cfpwrmontyp == PMTYP_VMX) 
        {
            ir_sys_type  = _ir_sys_type.fixedflag ?  ((void)(1), ir_sys_type) : 1;
            rfupa = ir_rfupa;
        }
        /* end vmx */

        ir_on     = _ir_on.fixedflag ?  ((void)(0), ir_on) : 0;

        /* TI Buttons */
        pitinub = 0;
        pitival2 = 70000;
        pitival3 = 100000;
        pitival4 = 150000;
        pitival5 = 200000;
        pitival6 = 300000;

        cvmin(opti, TI_MIN);
        cvmax(opti, TI_MAX);

        avminti = TI_MIN;
        avmaxti = TI_MAX;

        piadvmin &= ~(1<<PSD_ADVTI);
        piadvmax &= ~(1<<PSD_ADVTI);

        non_tetitime  = _non_tetitime.fixedflag ?  ((void)(0), non_tetitime) : 0;

        /* vmx 3/13/95 YI */
        if(cfpwrmontyp == PMTYP_VMX) 
        {
            ir_sys_type  = _ir_sys_type.fixedflag ?  ((void)(1), ir_sys_type) : 1;
            rfupa = ir_rfupa;
        }
        /* end vmx */

        /* set flag for IR */  
        if ( (oppseq == PSD_IR) || (opirprep == PSD_ON) ) {
            ir_on  = _ir_on.fixedflag ?  ((void)(PSD_ON), ir_on) : PSD_ON;
        } else {
            ir_on  = _ir_on.fixedflag ?  ((void)(PSD_OFF), ir_on) : PSD_OFF;
        }


        /* Initialize rf structure */
        if (silver_hoult == PSD_ON) /* adiabatic pulse */
        { 

/* MRIhc13638 - Substituting sh3t2 for shNvrg5b when 3T field & ir3t_flag is selected.
   Add an if loop for cffield here  */

            if(  (cffield <= B0_15000)  || (ir3t_flag == 0) )
            {
                pw_rf0   = _pw_rf0.fixedflag ?  ((void)(PSD_INV_RF0_SH_PW), pw_rf0) : PSD_INV_RF0_SH_PW;
                cyc_rf0  = _cyc_rf0.fixedflag ?  ((void)(2.0), cyc_rf0) : 2.0;
                a_rf0    = _a_rf0.fixedflag ?  ((void)(0.8253), a_rf0) : 0.8253;
                res_rf0  = _res_rf0.fixedflag ?  ((void)(RES_SILVER), res_rf0) : RES_SILVER;

                /*
                 AF 011300 MRIge57466 - GSCALE_RFO is tuned to fix
                 FSEIR and FLAIR  image quality problems.
                 The 0.9 value is the original GSCALE_RF1
                 that the present GSCALE_RF0 value of 0.87
                 is matched with.
                */
                if ( t1flair_flag == PSD_ON ) 
                {
                    if( (PSD_ON == invThickOpt) && (PSD_ON == enht2flairflag))
                    {
                        gscale_rf0  = _gscale_rf0.fixedflag ?  ((void)(1.0), gscale_rf0) : 1.0;/* for accurate calculation of inversion slab thickness*/
                    }
                    else
                    {
                        gscale_rf0  = _gscale_rf0.fixedflag ?    ((void)(0.87*csf_fact), gscale_rf0) : 0.87*csf_fact;
                    }
                } 
                else if ( flair_on == PSD_ON )
                {
                    if(PSD_ON == invThickOpt)
                    {
                        gscale_rf0  = _gscale_rf0.fixedflag ?  ((void)(1.0), gscale_rf0) : 1.0;/* for accurate calculation of inversion slab thickness*/
                    }
                    else
                    {
                        gscale_rf0  = _gscale_rf0.fixedflag ?       ((void)(0.87*csf_fact*gscale_rf1/0.9), gscale_rf0) : 0.87*csf_fact*gscale_rf1/0.9;
                    }
                }
                else if ( ((oppseq == PSD_IR) || (opirprep == PSD_ON)) &&
                          (opfast == PSD_ON) ) 
                {
                    gscale_rf0  = _gscale_rf0.fixedflag ?     ((void)(0.87*gscale_rf1/0.9), gscale_rf0) : 0.87*gscale_rf1/0.9;
                } 
                else 
                {
                    gscale_rf0  = _gscale_rf0.fixedflag ?  ((void)(0.87), gscale_rf0) : 0.87;
                }

            	/* **************************************************************
               		RF0 Pulse Initialization
               		************************************************************* */
            	rfpulse[RF0_SLOT].abswidth = SAR_ABS_ADIABATIC;
            	rfpulse[RF0_SLOT].area = SAR_A_ADIABATIC;
            	rfpulse[RF0_SLOT].effwidth = SAR_ADIABATIC_EFF_WIDTH;
            	rfpulse[RF0_SLOT].dtycyc = SAR_DTYCYC_ADIABATIC;
            	rfpulse[RF0_SLOT].maxpw = SAR_MAXPW_ADIABATIC;
            	rfpulse[RF0_SLOT].max_b1 = MAX_B1_ADIABATIC;
            	rfpulse[RF0_SLOT].nom_fa = NOM_FA_ADIABATIC; /* flip angle to make a_rf0/a_rf2=0.825*/
            	rfpulse[RF0_SLOT].nom_pw = PSD_INV_RF0_SH_PW;
            	rfpulse[RF0_SLOT].nom_bw = 5.12*cyc_rf0/((FLOAT)PSD_INV_RF0_SH_PW/(FLOAT)1000000);
            	rfpulse[RF0_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_ADIABATIC;
            	rfpulse[RF0_SLOT].max_rms_b1 = MAX_RMS_B1_ADIABATIC;
            }
            else                          /* 3T and above  & ir3t_flag == 1 - Parameters for sh3t2.rho and sh3t2.pha */
            {

            /*
              AF 011300 MRIge57466 - GSCALE_RFO is tuned to fix 
              FSEIR and FLAIR  image quality problems.
              The 0.9 value is the original GSCALE_RF1
              that the present GSCALE_RF0 value of 0.87
              is matched with.
             */ 
                if ( t1flair_flag == PSD_ON ) 
                {
                    if( (PSD_ON == invThickOpt) && (PSD_ON == enht2flairflag) )
                    {
                        gscale_rf0  = _gscale_rf0.fixedflag ?  ((void)(1.0), gscale_rf0) : 1.0;/* for accurate calculation of inversion slab thickness*/
                    }
                    else
                    {
                        gscale_rf0  = _gscale_rf0.fixedflag ?    ((void)(0.87*csf_fact), gscale_rf0) : 0.87*csf_fact;
                    }
                } 
                else if ( flair_on == PSD_ON )
                {
                    if(PSD_ON == invThickOpt)
                    {
                        gscale_rf0  = _gscale_rf0.fixedflag ?  ((void)(1.0), gscale_rf0) : 1.0;/* for accurate calculation of inversion slab thickness*/
                    }
                    else
                    {
                        gscale_rf0  = _gscale_rf0.fixedflag ?       ((void)(0.87*csf_fact*gscale_rf1/0.9), gscale_rf0) : 0.87*csf_fact*gscale_rf1/0.9;
                    }
                } 
                else if ( ((oppseq == PSD_IR) || (opirprep == PSD_ON)) &&
                          (opfast == PSD_ON) ) 
                {
                    gscale_rf0  = _gscale_rf0.fixedflag ?     ((void)(0.87*gscale_rf1/0.9), gscale_rf0) : 0.87*gscale_rf1/0.9;
                } 
                else 
                {
                    gscale_rf0  = _gscale_rf0.fixedflag ?  ((void)(0.87), gscale_rf0) : 0.87;
                }

            	rfpulse[RF0_SLOT].abswidth = 0.5390;
            	rfpulse[RF0_SLOT].area = 0.5390;
            	rfpulse[RF0_SLOT].effwidth = 0.3732;
            	rfpulse[RF0_SLOT].dtycyc = 1.0;
            	rfpulse[RF0_SLOT].maxpw = 1.0;
            	rfpulse[RF0_SLOT].max_b1 = 0.125;
            	rfpulse[RF0_SLOT].nom_fa = 250;         /* MATLAB simulation for inversion needs 0.125 gauss. flip_rf0=250 */
            	rfpulse[RF0_SLOT].act_fa = _flip_rf0.fixedflag ? (_temp328_flip_rf0=flip_rf0,&_temp328_flip_rf0) : &flip_rf0;
            	rfpulse[RF0_SLOT].nom_pw = 16000;
            	rfpulse[RF0_SLOT].nom_bw = 1500;
            	rfpulse[RF0_SLOT].max_int_b1_sq = 0.00110705;
            	rfpulse[RF0_SLOT].max_rms_b1 = 0.0130766;

            	pw_rf0   = _pw_rf0.fixedflag ?  ((void)(16000), pw_rf0) : 16000;
            	a_rf0    = _a_rf0.fixedflag ?  ((void)(1.0), a_rf0) : 1.0;
            	res_rf0  = _res_rf0.fixedflag ?  ((void)(400), res_rf0) : 400;
            	bw_rf0  = _bw_rf0.fixedflag ?  ((void)((rfpulse[RF0_SLOT].nom_bw*rfpulse[RF0_SLOT].nom_pw)/(pw_rf0)), bw_rf0) : (rfpulse[RF0_SLOT].nom_bw*rfpulse[RF0_SLOT].nom_pw)/(pw_rf0);

			}          /* cffield > 1.5T */
        }
        else 
        {
            /* Stretch the rf0 for SLR pulse */
            pw_rf0      = _pw_rf0.fixedflag ?      ((void)((int)rint((double)rfscale*(double)PSD_INV_RF0_PW)), pw_rf0) : (int)rint((double)rfscale*(double)PSD_INV_RF0_PW);
            cyc_rf0     = _cyc_rf0.fixedflag ?  ((void)(1.0), cyc_rf0) : 1.0;
            a_rf0       = _a_rf0.fixedflag ?  ((void)(0.1312), a_rf0) : 0.1312;
            gscale_rf0  = _gscale_rf0.fixedflag ?  ((void)(0.90), gscale_rf0) : 0.90;	
            res_rf0     = _res_rf0.fixedflag ?  ((void)(PSD_INV_RF0_R), res_rf0) : PSD_INV_RF0_R;
        
            /* **************************************************************
               RF0 Pulse Initialization
               ************************************************************* */
            rfpulse[RF0_SLOT].abswidth = SAR_ABS_INVI0;
            rfpulse[RF0_SLOT].area = SAR_AINVI0;
            rfpulse[RF0_SLOT].effwidth = SAR_PINVI0;
            rfpulse[RF0_SLOT].dtycyc = SAR_DTYCYC_INVI0;
            rfpulse[RF0_SLOT].maxpw = SAR_MAXPW_INVI0;
            rfpulse[RF0_SLOT].max_b1 = MAX_B1_INVI0_180;
            rfpulse[RF0_SLOT].nom_fa = 178.0;
            rfpulse[RF0_SLOT].nom_pw = 5000.0;
            rfpulse[RF0_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_INVI0_180;
            rfpulse[RF0_SLOT].max_rms_b1 = MAX_RMS_B1_INVI0_180;
        }
        rfpulse[RF0_SLOT].act_fa = _flip_rf0.fixedflag ? (_temp329_flip_rf0=flip_rf0,&_temp329_flip_rf0) : &flip_rf0;
        if( flair_on )
        {
            /* Round to RF update time and pulse resolution boundary */
            pw_rf0  = _pw_rf0.fixedflag ?      ((void)(RUP_RF((int)rint((double)pw_rf0/(double)res_rf0))*res_rf0), pw_rf0) : RUP_RF((int)rint((double)pw_rf0/(double)res_rf0))*res_rf0;
        }

        pw_gzrf0   = _pw_gzrf0.fixedflag ?  ((void)(pw_rf0), pw_gzrf0) : pw_rf0;
        pw_gzrf0a  = _pw_gzrf0a.fixedflag ?  ((void)(loggrd.zrt), pw_gzrf0a) : loggrd.zrt;   /* MRIge54948 - need it. */
        pw_gzrf0d  = _pw_gzrf0d.fixedflag ?  ((void)(pw_gzrf0a), pw_gzrf0d) : pw_gzrf0a;

        flip_rf0   = _flip_rf0.fixedflag ?  ((void)(180.0), flip_rf0) : 180.0;

        /*adding case for 3T head (GE)*/
        if (cffield == B0_30000) 
        {
            /* MRIhc12447 & MRIhc19616 */
            if(PSD_ON == flair_on || ((opbsp == PSD_OFF) && (opimode == PSD_2D)
                                      && (oppseq == PSD_IR) && (opfast == PSD_ON)
                                      && (opirmode == PSD_ON) && (t1flair_flag == PSD_OFF)) ) 
            {
                /*
                 * MRIhc24506 - To avoid minseqrfamp failures on 3T TRM/CRM
                 * for patient weight greater than 125kg for Body Coil
                 * and 143kg for Surfact Coils flip_rf0 is set to 200
                 */
                flip_rf0  = _flip_rf0.fixedflag ?  ((void)(FA_RF0_3T), flip_rf0) : FA_RF0_3T;
                if( TX_COIL_BODY == getTxCoilType() && (opimode == PSD_3D)
                    && ( (RX_COIL_BODY == getRxCoilType()
                          && (exist(opweight) > 125))
                         || exist(opweight) > 143 ) && (cfgcoiltype != PSD_XRMB_COIL) ) /* Fix not required for DVMR */
                {
                    flip_rf0  = _flip_rf0.fixedflag ?  ((void)(FA_RF0_3T_BODY_LARGE_WEIGHT), flip_rf0) : FA_RF0_3T_BODY_LARGE_WEIGHT;
                }
            }
        }

        /* set TI buttons, and advisory for TI, based on IR flag */
        if (ir_on == PSD_ON)
        {
            pitinub = 6;
            pititype = PSD_LABEL_TI_IR;
            piadvmin |= (1<<PSD_ADVTI);
            piadvmax |= (1<<PSD_ADVTI);
            piautoti = PSD_OFF;
            pitival2 = 50000;
        }
        else if ((PSD_ON==exist(opspecir)) && existcv(opspecir))
        {
            pitinub = 2;
            pititype = PSD_LABEL_TE_PREP;
            piadvmin |= (1<<PSD_ADVTI);
            piadvmax |= (1<<PSD_ADVTI);
            piautoti = PSD_ON;
        }
        else
        {
            pitinub = 0;
            pititype = PSD_LABEL_TI_IR;
            piadvmin &= ~(1<<PSD_ADVTI);
            piadvmax &= ~(1<<PSD_ADVTI);
            piautoti = PSD_OFF; 
            pitival2 = 50000;
        }

        /* set num fields and activity for RF0 based on IR flag */
        if (ir_on == PSD_ON)
        {
            rfpulse[RF0_SLOT].num = 1;
            rfpulse[RF0_SLOT].activity = PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON;
            /* rfpulse[RF0_CFH_SLOT].activity = PSD_CFH_ON; */
            /*MRIge92242 - enabled for CFH all the time */
        }
        else
        {
            rfpulse[RF0_SLOT].num = 0;
            rfpulse[RF0_SLOT].activity = PSD_PULSE_OFF;
            /* rfpulse[RF0_CFH_SLOT].activity = PSD_PULSE_OFF; */ 
        }

        if (ir_on == PSD_ON)
        {
            gradz[GZRF0_SLOT].num = 1;   
            grady[GYK0_SLOT].num = 1;   
        }
        else 
        {
            gradz[GZRF0_SLOT].num = 0;   
            grady[GYK0_SLOT].num = 0;   
        }
    } /* End of code inlined from Inversion.e InversionInit */

	
    /*jwg bb opuser20 for external waveforms*/
    if ((opuser20 == 0)) /*play default fat/water spsp*/
    {	
    if ( (exist(oppseq) == PSD_SE) || (exist(opflip)>30) ) {
        pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_SE_RF1_PW), pw_rf1) : PSD_SE_RF1_PW;
        res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_SE_RF1_R), res_rf1) : PSD_SE_RF1_R;
        gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(.90), gscale_rf1) : .90;
        flip_rf1  = _flip_rf1.fixedflag ?  ((void)(90.0), flip_rf1) : 90.0;
        hrf1a = PSD_SE_RF1_LEFT;
        hrf1b = PSD_SE_RF1_RIGHT;
        a_rf1  = _a_rf1.fixedflag ?  ((void)(0.5), a_rf1) : 0.5;
        rftype  = _rftype.fixedflag ?  ((void)(PLAY_RFFILE), rftype) : PLAY_RFFILE;
	thetaflag  = _thetaflag.fixedflag ?  ((void)(0), thetaflag) : 0;		
        sprintf(ssrffile, "/usr/g/bin/rffl901mc.rho");
        sprintf(ssgzfile, "/usr/g/bin/rfempty1.gz");
	a_phaserf1  = _a_phaserf1.fixedflag ?  ((void)(0), a_phaserf1) : 0;
	sw_freq  = _sw_freq.fixedflag ?  ((void)(0), sw_freq) : 0;			
    } else {
        pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_GR_RF1_PW), pw_rf1) : PSD_GR_RF1_PW;
        res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_GR_RF1_R), res_rf1) : PSD_GR_RF1_R;
        gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(.90), gscale_rf1) : .90;
        flip_rf1  = _flip_rf1.fixedflag ?  ((void)(30.0), flip_rf1) : 30.0;
        hrf1a = PSD_GR_RF1_LEFT;
        hrf1b = PSD_GR_RF1_RIGHT;
        a_rf1  = _a_rf1.fixedflag ?  ((void)(0.5), a_rf1) : 0.5;
        rftype  = _rftype.fixedflag ?  ((void)(PLAY_RFFILE), rftype) : PLAY_RFFILE;
	thetaflag  = _thetaflag.fixedflag ?  ((void)(0), thetaflag) : 0;		
        sprintf(ssrffile, "/usr/g/bin/rfgr30l.rho");
        sprintf(ssgzfile, "/usr/g/bin/rfempty1.gz");
	a_phaserf1  = _a_phaserf1.fixedflag ?  ((void)(0), a_phaserf1) : 0;
	sw_freq  = _sw_freq.fixedflag ?  ((void)(0), sw_freq) : 0;			
    }
    } else {
    /*jwg bb this is where external rf info goes*/
    /*the system default calls thetatype for the OMEGA pulse, I added thetaflag for the THETA board for complex RF*/
    /*dont ask*/
    switch ((int)opuser20)
    {
    case 1: /*sinc excitation*/
        pw_rf1  = _pw_rf1.fixedflag ?  ((void)(3200), pw_rf1) : 3200;
        res_rf1  = _res_rf1.fixedflag ?  ((void)(320), res_rf1) : 320;
        gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1), gscale_rf1) : 1;
        flip_rf1  = _flip_rf1.fixedflag ?  ((void)(opflip), flip_rf1) : opflip;
        hrf1a = pw_rf1/ 2;
        hrf1b = pw_rf1/ 2;
        a_rf1  = _a_rf1.fixedflag ?   ((void)((float)flip_rf1/180), a_rf1) : (float)flip_rf1/180;
        sprintf(ssrffile, "/usr/g/bin/hard.rho");
        sprintf(ssgzfile, "/usr/g/bin/rfempty1.gz");
	ss_rf1  = _ss_rf1.fixedflag ?  ((void)(0), ss_rf1) : 0; /*no spsp*/
	rftype  = _rftype.fixedflag ?  ((void)(0), rftype) : 0;
	gztype  = _gztype.fixedflag ?  ((void)(0), gztype) : 0;
	thetatype  = _thetatype.fixedflag ?  ((void)(0), thetatype) : 0;
	thetaflag  = _thetaflag.fixedflag ?  ((void)(0), thetaflag) : 0;	
	a_phaserf1  = _a_phaserf1.fixedflag ?  ((void)(0), a_phaserf1) : 0;
	sw_freq  = _sw_freq.fixedflag ?  ((void)(0), sw_freq) : 0;				
    break;
    case 2: /*or_pass spsp*/
        /*RF pulses stored in /usr/g/mrsc/jwgordon/ */
	strcpy(rf1froot,"jwgordon/or_pass");    
	strcpy(rf1_datfile,rf1froot);  strcat(rf1_datfile,".dat");
	read_spsp_datfile(rf1_datfile,_specspat_temp.fixedflag ? (_temp330_specspat_temp=specspat_temp,&_temp330_specspat_temp) : &specspat_temp,_res_temp.fixedflag ? (_temp331_res_temp=res_temp,&_temp331_res_temp) : &res_temp,_nom_pw_temp.fixedflag ? (_temp332_nom_pw_temp=nom_pw_temp,&_temp332_nom_pw_temp) : &nom_pw_temp,_nom_flip_temp.fixedflag ? (_temp333_nom_flip_temp=nom_flip_temp,&_temp333_nom_flip_temp) : &nom_flip_temp,
				   _abswidth_temp.fixedflag ? (_temp334_abswidth_temp=abswidth_temp,&_temp334_abswidth_temp) : &abswidth_temp,_effwidth_temp.fixedflag ? (_temp335_effwidth_temp=effwidth_temp,&_temp335_effwidth_temp) : &effwidth_temp,_area_temp.fixedflag ? (_temp336_area_temp=area_temp,&_temp336_area_temp) : &area_temp,_dtycyc_temp.fixedflag ? (_temp337_dtycyc_temp=dtycyc_temp,&_temp337_dtycyc_temp) : &dtycyc_temp,
				   _maxpw_temp.fixedflag ? (_temp338_maxpw_temp=maxpw_temp,&_temp338_maxpw_temp) : &maxpw_temp,_max_b1_temp.fixedflag ? (_temp339_max_b1_temp=max_b1_temp,&_temp339_max_b1_temp) : &max_b1_temp,_max_int_b1_sqr_temp.fixedflag ? (_temp340_max_int_b1_sqr_temp=max_int_b1_sqr_temp,&_temp340_max_int_b1_sqr_temp) : &max_int_b1_sqr_temp,
				   _max_rms_b1_temp.fixedflag ? (_temp341_max_rms_b1_temp=max_rms_b1_temp,&_temp341_max_rms_b1_temp) : &max_rms_b1_temp,_nom_bw_temp.fixedflag ? (_temp342_nom_bw_temp=nom_bw_temp,&_temp342_nom_bw_temp) : &nom_bw_temp,_isodelay_temp.fixedflag ? (_temp343_isodelay_temp=isodelay_temp,&_temp343_isodelay_temp) : &isodelay_temp,
				   _a_gzs_temp.fixedflag ? (_temp344_a_gzs_temp=a_gzs_temp,&_temp344_a_gzs_temp) : &a_gzs_temp,_nom_thk_temp.fixedflag ? (_temp345_nom_thk_temp=nom_thk_temp,&_temp345_nom_thk_temp) : &nom_thk_temp);
				   
	nom_thk_rf1  = _nom_thk_rf1.fixedflag ?  ((void)(nom_thk_temp), nom_thk_rf1) : nom_thk_temp;
	pw_rf1  = _pw_rf1.fixedflag ?  ((void)(nom_pw_temp), pw_rf1) : nom_pw_temp;
	nom_bw_temp  = _nom_bw_temp.fixedflag ?      ((void)(GAM*a_gzs_temp*nom_thk_rf1/10), nom_bw_temp) : GAM*a_gzs_temp*nom_thk_rf1/10; /*calc this to make rest of psd happy, we set amp manually below*/
	res_rf1  = _res_rf1.fixedflag ?  ((void)(res_temp), res_rf1) : res_temp; 
	bw_rf1  = _bw_rf1.fixedflag ?  ((void)(nom_bw_temp), bw_rf1) : nom_bw_temp;
	/*double check the below values!!!*/
	gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1), gscale_rf1) : 1;
	flip_rf1  = _flip_rf1.fixedflag ?  ((void)(opflip), flip_rf1) : opflip;
	hrf1a = pw_rf1/ 2;
	hrf1b = pw_rf1/ 2;
	a_rf1  = _a_rf1.fixedflag ?   ((void)(opflip/180), a_rf1) : opflip/180;
	ss_rf1  = _ss_rf1.fixedflag ?  ((void)(1), ss_rf1) : 1;
	rftype  = _rftype.fixedflag ?  ((void)(1), rftype) : 1;
	gztype  = _gztype.fixedflag ?  ((void)(1), gztype) : 1;
	thetatype  = _thetatype.fixedflag ?  ((void)(0), thetatype) : 0; /*no external theta file*/
	thetaflag  = _thetaflag.fixedflag ?  ((void)(0), thetaflag) : 0;	
        sprintf(ssrffile, "jwgordon/or_pass.rho");
        sprintf(ssgzfile, "jwgordon/or_pass.grd");
	a_phaserf1  = _a_phaserf1.fixedflag ?  ((void)(0), a_phaserf1) : 0;
	sw_freq  = _sw_freq.fixedflag ?  ((void)(0), sw_freq) : 0;		
    break;
    case 3: /*complex spsp, non-symmetric frequency response*/
        /*RF pulses stored in  */
	strcpy(rf1froot,"jwgordon/comp_sb");    
	strcpy(rf1_datfile,rf1froot);  strcat(rf1_datfile,".dat");
	read_spsp_datfile(rf1_datfile,_specspat_temp.fixedflag ? (_temp346_specspat_temp=specspat_temp,&_temp346_specspat_temp) : &specspat_temp,_res_temp.fixedflag ? (_temp347_res_temp=res_temp,&_temp347_res_temp) : &res_temp,_nom_pw_temp.fixedflag ? (_temp348_nom_pw_temp=nom_pw_temp,&_temp348_nom_pw_temp) : &nom_pw_temp,_nom_flip_temp.fixedflag ? (_temp349_nom_flip_temp=nom_flip_temp,&_temp349_nom_flip_temp) : &nom_flip_temp,
				   _abswidth_temp.fixedflag ? (_temp350_abswidth_temp=abswidth_temp,&_temp350_abswidth_temp) : &abswidth_temp,_effwidth_temp.fixedflag ? (_temp351_effwidth_temp=effwidth_temp,&_temp351_effwidth_temp) : &effwidth_temp,_area_temp.fixedflag ? (_temp352_area_temp=area_temp,&_temp352_area_temp) : &area_temp,_dtycyc_temp.fixedflag ? (_temp353_dtycyc_temp=dtycyc_temp,&_temp353_dtycyc_temp) : &dtycyc_temp,
				   _maxpw_temp.fixedflag ? (_temp354_maxpw_temp=maxpw_temp,&_temp354_maxpw_temp) : &maxpw_temp,_max_b1_temp.fixedflag ? (_temp355_max_b1_temp=max_b1_temp,&_temp355_max_b1_temp) : &max_b1_temp,_max_int_b1_sqr_temp.fixedflag ? (_temp356_max_int_b1_sqr_temp=max_int_b1_sqr_temp,&_temp356_max_int_b1_sqr_temp) : &max_int_b1_sqr_temp,
				   _max_rms_b1_temp.fixedflag ? (_temp357_max_rms_b1_temp=max_rms_b1_temp,&_temp357_max_rms_b1_temp) : &max_rms_b1_temp,_nom_bw_temp.fixedflag ? (_temp358_nom_bw_temp=nom_bw_temp,&_temp358_nom_bw_temp) : &nom_bw_temp,_isodelay_temp.fixedflag ? (_temp359_isodelay_temp=isodelay_temp,&_temp359_isodelay_temp) : &isodelay_temp,
				   _a_gzs_temp.fixedflag ? (_temp360_a_gzs_temp=a_gzs_temp,&_temp360_a_gzs_temp) : &a_gzs_temp,_nom_thk_temp.fixedflag ? (_temp361_nom_thk_temp=nom_thk_temp,&_temp361_nom_thk_temp) : &nom_thk_temp);
				   
	nom_thk_rf1  = _nom_thk_rf1.fixedflag ?  ((void)(nom_thk_temp), nom_thk_rf1) : nom_thk_temp;
	pw_rf1  = _pw_rf1.fixedflag ?  ((void)(nom_pw_temp), pw_rf1) : nom_pw_temp;
	nom_bw_temp  = _nom_bw_temp.fixedflag ?      ((void)(GAM*a_gzs_temp*nom_thk_rf1/10), nom_bw_temp) : GAM*a_gzs_temp*nom_thk_rf1/10; /*calc this to make rest of psd happy, we set amp manually below*/
	res_rf1  = _res_rf1.fixedflag ?  ((void)(res_temp), res_rf1) : res_temp; 
	bw_rf1  = _bw_rf1.fixedflag ?  ((void)(nom_bw_temp), bw_rf1) : nom_bw_temp;
	/*double check the below values!!!*/
	gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1), gscale_rf1) : 1;
	flip_rf1  = _flip_rf1.fixedflag ?  ((void)(opflip), flip_rf1) : opflip;
	hrf1a = pw_rf1/ 2;
	hrf1b = pw_rf1/ 2;
	a_rf1  = _a_rf1.fixedflag ?   ((void)(opflip/180), a_rf1) : opflip/180;
	ss_rf1  = _ss_rf1.fixedflag ?  ((void)(1), ss_rf1) : 1;
	rftype  = _rftype.fixedflag ?  ((void)(1), rftype) : 1;
	gztype  = _gztype.fixedflag ?  ((void)(1), gztype) : 1;
	thetatype  = _thetatype.fixedflag ?  ((void)(0), thetatype) : 0; /*no external theta file*/
	thetaflag  = _thetaflag.fixedflag ?  ((void)(1), thetaflag) : 1;	
        sprintf(ssrffile, "jwgordon/comp_sb.rho");
        sprintf(ssgzfile, "jwgordon/comp_sb.grd");
	sprintf(ssthetafile,"jwgordon/comp_sb.pha");	
	pw_phaserf1  = _pw_phaserf1.fixedflag ?  ((void)(pw_rf1), pw_phaserf1) : pw_rf1; /*these two are here to make the EXTWAVE macro happy, now don't need to download twice*/
	res_phaserf1  = _res_phaserf1.fixedflag ?  ((void)(res_rf1), res_phaserf1) : res_rf1;
	a_phaserf1  = _a_phaserf1.fixedflag ?  ((void)(1), a_phaserf1) : 1;
	sw_freq  = _sw_freq.fixedflag ?  ((void)(598), sw_freq) : 598;	
    break; 
    case 98: /*magnitude spsp*/
        /*RF pulses stored in  */
	strcpy(rf1froot,"jwgordon/spsp98");    
	strcpy(rf1_datfile,rf1froot);  strcat(rf1_datfile,".dat");
	read_spsp_datfile(rf1_datfile,_specspat_temp.fixedflag ? (_temp362_specspat_temp=specspat_temp,&_temp362_specspat_temp) : &specspat_temp,_res_temp.fixedflag ? (_temp363_res_temp=res_temp,&_temp363_res_temp) : &res_temp,_nom_pw_temp.fixedflag ? (_temp364_nom_pw_temp=nom_pw_temp,&_temp364_nom_pw_temp) : &nom_pw_temp,_nom_flip_temp.fixedflag ? (_temp365_nom_flip_temp=nom_flip_temp,&_temp365_nom_flip_temp) : &nom_flip_temp,
				   _abswidth_temp.fixedflag ? (_temp366_abswidth_temp=abswidth_temp,&_temp366_abswidth_temp) : &abswidth_temp,_effwidth_temp.fixedflag ? (_temp367_effwidth_temp=effwidth_temp,&_temp367_effwidth_temp) : &effwidth_temp,_area_temp.fixedflag ? (_temp368_area_temp=area_temp,&_temp368_area_temp) : &area_temp,_dtycyc_temp.fixedflag ? (_temp369_dtycyc_temp=dtycyc_temp,&_temp369_dtycyc_temp) : &dtycyc_temp,
				   _maxpw_temp.fixedflag ? (_temp370_maxpw_temp=maxpw_temp,&_temp370_maxpw_temp) : &maxpw_temp,_max_b1_temp.fixedflag ? (_temp371_max_b1_temp=max_b1_temp,&_temp371_max_b1_temp) : &max_b1_temp,_max_int_b1_sqr_temp.fixedflag ? (_temp372_max_int_b1_sqr_temp=max_int_b1_sqr_temp,&_temp372_max_int_b1_sqr_temp) : &max_int_b1_sqr_temp,
				   _max_rms_b1_temp.fixedflag ? (_temp373_max_rms_b1_temp=max_rms_b1_temp,&_temp373_max_rms_b1_temp) : &max_rms_b1_temp,_nom_bw_temp.fixedflag ? (_temp374_nom_bw_temp=nom_bw_temp,&_temp374_nom_bw_temp) : &nom_bw_temp,_isodelay_temp.fixedflag ? (_temp375_isodelay_temp=isodelay_temp,&_temp375_isodelay_temp) : &isodelay_temp,
				   _a_gzs_temp.fixedflag ? (_temp376_a_gzs_temp=a_gzs_temp,&_temp376_a_gzs_temp) : &a_gzs_temp,_nom_thk_temp.fixedflag ? (_temp377_nom_thk_temp=nom_thk_temp,&_temp377_nom_thk_temp) : &nom_thk_temp);
				   
	nom_thk_rf1  = _nom_thk_rf1.fixedflag ?  ((void)(nom_thk_temp), nom_thk_rf1) : nom_thk_temp;
	pw_rf1  = _pw_rf1.fixedflag ?  ((void)(nom_pw_temp), pw_rf1) : nom_pw_temp;
	nom_bw_temp  = _nom_bw_temp.fixedflag ?      ((void)(GAM*a_gzs_temp*nom_thk_rf1/10), nom_bw_temp) : GAM*a_gzs_temp*nom_thk_rf1/10; /*calc this to make rest of psd happy, we set amp manually below*/
	res_rf1  = _res_rf1.fixedflag ?  ((void)(res_temp), res_rf1) : res_temp; 
	bw_rf1  = _bw_rf1.fixedflag ?  ((void)(nom_bw_temp), bw_rf1) : nom_bw_temp;
	/*double check the below values!!!*/
	gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1), gscale_rf1) : 1;
	flip_rf1  = _flip_rf1.fixedflag ?  ((void)(opflip), flip_rf1) : opflip;
	hrf1a = pw_rf1/ 2;
	hrf1b = pw_rf1/ 2;
	a_rf1  = _a_rf1.fixedflag ?   ((void)(opflip/180), a_rf1) : opflip/180;
	ss_rf1  = _ss_rf1.fixedflag ?  ((void)(1), ss_rf1) : 1;
	rftype  = _rftype.fixedflag ?  ((void)(1), rftype) : 1;
	gztype  = _gztype.fixedflag ?  ((void)(1), gztype) : 1;
	thetatype  = _thetatype.fixedflag ?  ((void)(0), thetatype) : 0; /*no external theta file*/
	thetaflag  = _thetaflag.fixedflag ?  ((void)(0), thetaflag) : 0;	
        sprintf(ssrffile, "jwgordon/spsp98.rho");
        sprintf(ssgzfile, "jwgordon/spsp98.grd");
	a_phaserf1  = _a_phaserf1.fixedflag ?  ((void)(0), a_phaserf1) : 0;
	sw_freq  = _sw_freq.fixedflag ?  ((void)(0), sw_freq) : 0;		
    break;       
    case 99: /*test SPSP, complex RF*/
    	/*If want to do frequency shifting of passbands, need to input sw_freq manually for this pulse*/
        /*RF pulses stored in  */
	strcpy(rf1froot,"jwgordon/spsp99");    
	strcpy(rf1_datfile,rf1froot);  strcat(rf1_datfile,".dat");
	read_spsp_datfile(rf1_datfile,_specspat_temp.fixedflag ? (_temp378_specspat_temp=specspat_temp,&_temp378_specspat_temp) : &specspat_temp,_res_temp.fixedflag ? (_temp379_res_temp=res_temp,&_temp379_res_temp) : &res_temp,_nom_pw_temp.fixedflag ? (_temp380_nom_pw_temp=nom_pw_temp,&_temp380_nom_pw_temp) : &nom_pw_temp,_nom_flip_temp.fixedflag ? (_temp381_nom_flip_temp=nom_flip_temp,&_temp381_nom_flip_temp) : &nom_flip_temp,
				   _abswidth_temp.fixedflag ? (_temp382_abswidth_temp=abswidth_temp,&_temp382_abswidth_temp) : &abswidth_temp,_effwidth_temp.fixedflag ? (_temp383_effwidth_temp=effwidth_temp,&_temp383_effwidth_temp) : &effwidth_temp,_area_temp.fixedflag ? (_temp384_area_temp=area_temp,&_temp384_area_temp) : &area_temp,_dtycyc_temp.fixedflag ? (_temp385_dtycyc_temp=dtycyc_temp,&_temp385_dtycyc_temp) : &dtycyc_temp,
				   _maxpw_temp.fixedflag ? (_temp386_maxpw_temp=maxpw_temp,&_temp386_maxpw_temp) : &maxpw_temp,_max_b1_temp.fixedflag ? (_temp387_max_b1_temp=max_b1_temp,&_temp387_max_b1_temp) : &max_b1_temp,_max_int_b1_sqr_temp.fixedflag ? (_temp388_max_int_b1_sqr_temp=max_int_b1_sqr_temp,&_temp388_max_int_b1_sqr_temp) : &max_int_b1_sqr_temp,
				   _max_rms_b1_temp.fixedflag ? (_temp389_max_rms_b1_temp=max_rms_b1_temp,&_temp389_max_rms_b1_temp) : &max_rms_b1_temp,_nom_bw_temp.fixedflag ? (_temp390_nom_bw_temp=nom_bw_temp,&_temp390_nom_bw_temp) : &nom_bw_temp,_isodelay_temp.fixedflag ? (_temp391_isodelay_temp=isodelay_temp,&_temp391_isodelay_temp) : &isodelay_temp,
				   _a_gzs_temp.fixedflag ? (_temp392_a_gzs_temp=a_gzs_temp,&_temp392_a_gzs_temp) : &a_gzs_temp,_nom_thk_temp.fixedflag ? (_temp393_nom_thk_temp=nom_thk_temp,&_temp393_nom_thk_temp) : &nom_thk_temp);
				   
	nom_thk_rf1  = _nom_thk_rf1.fixedflag ?  ((void)(nom_thk_temp), nom_thk_rf1) : nom_thk_temp;
	pw_rf1  = _pw_rf1.fixedflag ?  ((void)(nom_pw_temp), pw_rf1) : nom_pw_temp;
	nom_bw_temp  = _nom_bw_temp.fixedflag ?      ((void)(GAM*a_gzs_temp*nom_thk_rf1/10), nom_bw_temp) : GAM*a_gzs_temp*nom_thk_rf1/10; /*calc this to make rest of psd happy, we set amp manually below*/
	res_rf1  = _res_rf1.fixedflag ?  ((void)(res_temp), res_rf1) : res_temp; 
	bw_rf1  = _bw_rf1.fixedflag ?  ((void)(nom_bw_temp), bw_rf1) : nom_bw_temp;
	/*double check the below values!!!*/
	gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1), gscale_rf1) : 1;
	flip_rf1  = _flip_rf1.fixedflag ?  ((void)(opflip), flip_rf1) : opflip;
	hrf1a = pw_rf1/ 2;
	hrf1b = pw_rf1/ 2;
	a_rf1  = _a_rf1.fixedflag ?   ((void)(opflip/180), a_rf1) : opflip/180;
	ss_rf1  = _ss_rf1.fixedflag ?  ((void)(1), ss_rf1) : 1;
	rftype  = _rftype.fixedflag ?  ((void)(1), rftype) : 1;
	gztype  = _gztype.fixedflag ?  ((void)(1), gztype) : 1;
	thetatype  = _thetatype.fixedflag ?  ((void)(0), thetatype) : 0; /*no external theta file*/
	thetaflag  = _thetaflag.fixedflag ?  ((void)(1), thetaflag) : 1;
        sprintf(ssrffile, "jwgordon/spsp99.rho");
        sprintf(ssgzfile, "jwgordon/spsp99.grd");
	sprintf(ssthetafile,"jwgordon/spsp99.pha");
	pw_phaserf1  = _pw_phaserf1.fixedflag ?  ((void)(pw_rf1), pw_phaserf1) : pw_rf1; /*these two are here to make the EXTWAVE macro happy, now don't need to download twice*/
	res_phaserf1  = _res_phaserf1.fixedflag ?  ((void)(res_rf1), res_phaserf1) : res_rf1;
	a_phaserf1  = _a_phaserf1.fixedflag ?  ((void)(1), a_phaserf1) : 1;
    break;    
    } /*end switch*/
    } /*end opuser if/else*/
    /*jwg end*/    
    
    /*jwg bb for center frequency shifting. If desired, can manually set sw_freq to the stopband BW*/
    sw  = _sw.fixedflag ?   ((void)(sw_freq/TARDIS_FREQ_RES), sw) : sw_freq/TARDIS_FREQ_RES;	
    
    /*gztype = PLAY_TRAP;*/
    /*thetatype = NO_THETA;*/
    pw_rf2  = _pw_rf2.fixedflag ?   ((void)(3200), pw_rf2) : 3200; 
    res_rf2  = _res_rf2.fixedflag ?  ((void)(RES_SE1B4_RF2), res_rf2) : RES_SE1B4_RF2;
    gscale_rf2  = _gscale_rf2.fixedflag ?  ((void)(.90), gscale_rf2) : .90;
    flip_rf2  = _flip_rf2.fixedflag ?  ((void)(180.0), flip_rf2) : 180.0;
    hrf2a = pw_rf2/2;
    hrf2b = pw_rf2/2;
    a_rf2  = _a_rf2.fixedflag ?  ((void)(1.0), a_rf2) : 1.0;
    alpha_rf2  = _alpha_rf2.fixedflag ?  ((void)(0.46), alpha_rf2) : 0.46;
    
    /*jwg for testing passband shifting and complex RF, will clean up later*/
    /*if(opuser20 == 99) { sw = sw_freq / TARDIS_FREQ_RES; a_phaserf1 = 1; } else { sw = 0; a_phaserf1 = 0;}*/

    fprintf(stderr,"before SETUP \n");
    /*jwg bb only change setup based on PSD, not flip angle*/
    if (exist(oppseq) == PSD_SE /*|| (exist(opflip)>30)*/ ) {
        setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp394_pw_rf1=pw_rf1,&_temp394_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp395_a_rf1=a_rf1,&_temp395_a_rf1) : &a_rf1, SAR_ABS_FL901MC, SAR_PFL901MC,
                     SAR_AFL901MC, SAR_DTYCYC_FL901MC, SAR_MAXPW_FL901MC, 1,
                     MAX_B1_FL901MC_90, MAX_INT_B1_SQ_FL901MC_90,
                     MAX_RMS_B1_FL901MC_90, 90.0, _flip_rf1.fixedflag ? (_temp396_flip_rf1=flip_rf1,&_temp396_flip_rf1) : &flip_rf1, 4000.0,
                     NOM_BW_FL901MC_RF1, PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON,
                     0, hrf1b, 1.0, _res_rf1.fixedflag ? (_temp397_res_rf1=res_rf1,&_temp397_res_rf1) : &res_rf1, 0, _wg_rf1.fixedflag ? (_temp398_wg_rf1=wg_rf1,&_temp398_wg_rf1) : &wg_rf1, rfpulse);
        
        setuprfpulse(RF2_SLOT, _pw_rf2.fixedflag ? (_temp399_pw_rf2=pw_rf2,&_temp399_pw_rf2) : &pw_rf2, _a_rf2.fixedflag ? (_temp400_a_rf2=a_rf2,&_temp400_a_rf2) : &a_rf2, SAR_ABS_SE1B4, SAR_PSE1B4,
                     SAR_ASE1B4, SAR_DTYCYC_SE1B4, SAR_MAXPW_SE1B4, 1,
                     MAX_B1_SE1B4_180, MAX_INT_B1_SQ_SE1B4_180,
                     MAX_RMS_B1_SE1B4_180, 180.0, _flip_rf2.fixedflag ? (_temp401_flip_rf2=flip_rf2,&_temp401_flip_rf2) : &flip_rf2, 3200.0,
                     NOM_BW_SE1B4, PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                     hrf2b, 1.0, _res_rf2.fixedflag ? (_temp402_res_rf2=res_rf2,&_temp402_res_rf2) : &res_rf2, 0, _wg_rf2.fixedflag ? (_temp403_wg_rf2=wg_rf2,&_temp403_wg_rf2) : &wg_rf2, rfpulse);
    } else { /*jwg: GRE mode, where we'll initially be for c13 imaging*/
    if(opuser20 < 2) /*run default code if want 1H spsp (=0)or sinc (=1)*/
    {
        fprintf(stderr,"default setuprfpulse \n");
        setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp404_pw_rf1=pw_rf1,&_temp404_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp405_a_rf1=a_rf1,&_temp405_a_rf1) : &a_rf1, SAR_ABS_GR30L, SAR_PGR30L,
                     SAR_AGR30L, SAR_DTYCYC_GR30L, SAR_MAXPW_GR30L, 1,
                     MAX_B1_GR30L, MAX_INT_B1_SQ_GR30L, MAX_RMS_B1_GR30L,
                     30.0, _flip_rf1.fixedflag ? (_temp406_flip_rf1=flip_rf1,&_temp406_flip_rf1) : &flip_rf1, 3200.0, NOM_BW_GR30L,
                     PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                     hrf1b, 1.0, _res_rf1.fixedflag ? (_temp407_res_rf1=res_rf1,&_temp407_res_rf1) : &res_rf1, 0, _wg_rf1.fixedflag ? (_temp408_wg_rf1=wg_rf1,&_temp408_wg_rf1) : &wg_rf1, rfpulse);
    } else { /*run setuprfpulse given the parameters from the dat file*/
	setuprfpulse (RF1_SLOT, _pw_rf1.fixedflag ? (_temp409_pw_rf1=pw_rf1,&_temp409_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp410_a_rf1=a_rf1,&_temp410_a_rf1) : &a_rf1, abswidth_temp, effwidth_temp,
		 area_temp,dtycyc_temp, maxpw_temp, 1, max_b1_temp,
		 max_int_b1_sqr_temp, max_rms_b1_temp,
		 nom_flip_temp, _flip_rf1.fixedflag ? (_temp411_flip_rf1=flip_rf1,&_temp411_flip_rf1) : &flip_rf1, nom_pw_temp, nom_bw_temp,
		 PSD_MPS2_ON+PSD_APS2_ON+PSD_SCAN_ON, (char ) 0, 0, 0.0,
		 (int *) &res_rf1, 1,(int*)&wg_rf1 ,rfpulse);
		 
	/*calculate amp from .dat file, won't use ampslice functions below*/	
	nom_thk_rf1  = _nom_thk_rf1.fixedflag ?     ((void)(nom_thk_rf1*4257.6/(GAM)), nom_thk_rf1) : nom_thk_rf1*4257.6/(GAM);
	pw_gzrf1  = _pw_gzrf1.fixedflag ?  ((void)(pw_rf1), pw_gzrf1) : pw_rf1;
	a_gzrf1  = _a_gzrf1.fixedflag ?   ((void)(a_gzs_temp*(nom_thk_rf1/thk_rf1)*(rfpulse[RF1_SLOT].nom_pw/pw_rf1)), a_gzrf1) : a_gzs_temp*(nom_thk_rf1/thk_rf1)*(rfpulse[RF1_SLOT].nom_pw/pw_rf1);
	gettarget(_target.fixedflag ? (_temp412_target=target,&_temp412_target) : &target, ZGRAD, &loggrd);
	ia_gzrf1  = _ia_gzrf1.fixedflag ?    ((void)((a_gzrf1/target)*MAX_PG_IAMP), ia_gzrf1) : (a_gzrf1/target)*MAX_PG_IAMP;
//nom_bw_temp  = _nom_bw_temp.fixedflag ?      ((void)(GAM*a_gzs_temp*nom_thk_rf1/10), nom_bw_temp) : GAM*a_gzs_temp*nom_thk_rf1/10; /*calc this to make rest of psd happy, we set amp manually below*/
	nom_bw_temp  = _nom_bw_temp.fixedflag ?      ((void)(4257.6*a_gzs_temp*nom_thk_temp/10), nom_bw_temp) : 4257.6*a_gzs_temp*nom_thk_temp/10;
	res_rf1  = _res_rf1.fixedflag ?  ((void)(res_temp), res_rf1) : res_temp; 
	bw_rf1  = _bw_rf1.fixedflag ?  ((void)(nom_bw_temp), bw_rf1) : nom_bw_temp;
	rfpulse[RF1_SLOT].nom_bw = bw_rf1; /*jwg bb need to set this to bw_rf1, as it will be used in sseval1 for calculations!*/
        fprintf(stderr,"bw is %d\n", bw_rf1);
	fprintf(stderr,"a_gzs_temp = %f, nom_thk_rf1 = %f, thk_rf1 = %f, nom PW = %f, pw_rf1 = %d\n",a_gzs_temp,nom_thk_rf1,thk_rf1,rfpulse[RF1_SLOT].nom_pw,pw_rf1);		 
	fprintf(stderr,"right after calc, amp and iamp are %f and %d \n",a_gzrf1,ia_gzrf1);
    }		     
        /*see prototype in include/support_func.host.h*/
        setuprfpulse(RF2_SLOT, _pw_rf2.fixedflag ? (_temp413_pw_rf2=pw_rf2,&_temp413_pw_rf2) : &pw_rf2, _a_rf2.fixedflag ? (_temp414_a_rf2=a_rf2,&_temp414_a_rf2) : &a_rf2, SAR_ABS_SE1B4, SAR_PSE1B4,
                     SAR_ASE1B4, SAR_DTYCYC_SE1B4, SAR_MAXPW_SE1B4, 1,
                     MAX_B1_SE1B4_180, MAX_INT_B1_SQ_SE1B4_180,
                     MAX_RMS_B1_SE1B4_180, 180.0, _flip_rf2.fixedflag ? (_temp415_flip_rf2=flip_rf2,&_temp415_flip_rf2) : &flip_rf2, 3200.0,
                     NOM_BW_SE1B4, PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                     hrf2b, 1.0, _res_rf2.fixedflag ? (_temp416_res_rf2=res_rf2,&_temp416_res_rf2) : &res_rf2, 0, _wg_rf2.fixedflag ? (_temp417_wg_rf2=wg_rf2,&_temp417_wg_rf2) : &wg_rf2, rfpulse);
    }
    fprintf(stderr,"after SETUP \n");    
    
    /* BJM epispec stuff */
    if(epispec_flag == PSD_ON) {
        pw_rf1  = _pw_rf1.fixedflag ?  ((void)(NOM_PW_RTIA), pw_rf1) : NOM_PW_RTIA;                  /* width of RF1 */
        res_rf1  = _res_rf1.fixedflag ?  ((void)(RES_RTIA), res_rf1) : RES_RTIA;                    /* resolution of RF1 */
        hrf1a = NOM_PW_RTIA-ISO_RTIA;
        hrf1b = ISO_RTIA;
        setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp418_pw_rf1=pw_rf1,&_temp418_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp419_a_rf1=a_rf1,&_temp419_a_rf1) : &a_rf1, SAR_ABS_RTIA, SAR_PRTIA,
                     SAR_ARTIA, SAR_DTYCYC_RTIA, SAR_MAXPW_RTIA, 1,
                     MAX_B1_RTIA_08_30, 0.000858061, 0.0327502,
                     NOM_FA_RTIA, _flip_rf1.fixedflag ? (_temp420_flip_rf1=flip_rf1,&_temp420_flip_rf1) : &flip_rf1, NOM_PW_RTIA, NOM_BW_RTIA,
                     PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                     ISO_RTIA, 1.0, _res_rf1.fixedflag ? (_temp421_res_rf1=res_rf1,&_temp421_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp422_wg_rf1=wg_rf1,&_temp422_wg_rf1) : &wg_rf1, rfpulse);
        sprintf(ssrffile, "/usr/g/bin/rf_bw4_800us.rho");
      
        sprintf(ssgzfile, "/usr/g/bin/rfempty1.gz");
    }

    /* BJM: change pulse if possible */
    if( (cfsrmode >= PSD_SR100) ) {
 
        /* turn on 1.5T delay insensitive RF pulse */
        if (cffield ==  B0_15000) {
            ss_override  = _ss_override.fixedflag ?  ((void)(1), ss_override) : 1;
        } else {
            ss_override  = _ss_override.fixedflag ?  ((void)(0), ss_override) : 0;   /* 3T is already delay insensitive */
        }

    } else {

        ss_override  = _ss_override.fixedflag ?  ((void)(0), ss_override) : 0;

    }

    /*jwg bb this is where things are being changed behind our back!*/
    /*it looks like the psd is setting up the pulse above, but then it's */
    /*overwriting it based on the ss_rf1 flag. */
    /*Let's change that! Only call for 1H SPSP or sinc*/    
    if (opuser20 < 2 ) 
    {
	    if (ssInit() == FAILURE) return FAILURE;
    }
    
    
    
    /* Check to see if rf pw's need scaling for large patients */
    for (entry=0; entry<MAX_ENTRY_POINTS; entry ++)
        scalerfpulses(opweight,cfgcoiltype,RF_FREE,rfpulse,entry,rfpulseInfo);
    
    /* If pulse width of 90 scaled, then scale off90 accordingly */
    if (rfpulseInfo[RF1_SLOT].change==PSD_ON)
        off90  = _off90.fixedflag ?    ((void)((int)rint(pw_rf1/rfpulse[RF1_SLOT].nom_pw)), off90) : off90*(int)rint(pw_rf1/rfpulse[RF1_SLOT].nom_pw);
    
    /*	iso_delay = pw_rf1/2 + off90; */
    
    /* Inner volume selective pulse */
    pw_gyrf2iv  = _pw_gyrf2iv.fixedflag ?  ((void)(pw_rf2), pw_gyrf2iv) : pw_rf2;
    off90  = _off90.fixedflag ?  ((void)(0), off90) : 0;
    
    pw_gzrf1  = _pw_gzrf1.fixedflag ?  ((void)(pw_rf1), pw_gzrf1) : pw_rf1;
    pw_gzrf2  = _pw_gzrf2.fixedflag ?  ((void)(pw_rf2), pw_gzrf2) : pw_rf2;
    flip_rf1  = _flip_rf1.fixedflag ?  ((void)(exist(opflip)), flip_rf1) : exist(opflip);

    fprintf(stderr,"before sseval1, amp and iamp are %f and %d \n",a_gzrf1,ia_gzrf1);
    fprintf(stderr,"bw is %d\n", bw_rf1);
    /*jwg this is resetting a_gzrf1 and ia_gzrf1 for user-defined c13 pulses.*/
    /*jwg need to run it to make the psd happy, so just reset the CVs after it*/
    if (ssEval1() == FAILURE) return FAILURE;  /* Redefine area_gz1, bw_rf1, 
                                                  hrf1a, hrf1b and other parameters for spectral-spatial pulse. */
    if(opuser20 > 1 )
    {
    	a_gzrf1  = _a_gzrf1.fixedflag ?   ((void)(a_gzs_temp*(nom_thk_rf1/thk_rf1)*(rfpulse[RF1_SLOT].nom_pw/pw_rf1)), a_gzrf1) : a_gzs_temp*(nom_thk_rf1/thk_rf1)*(rfpulse[RF1_SLOT].nom_pw/pw_rf1);
	gettarget(_target.fixedflag ? (_temp423_target=target,&_temp423_target) : &target, ZGRAD, &loggrd);
	ia_gzrf1  = _ia_gzrf1.fixedflag ?    ((void)((a_gzrf1/target)*MAX_PG_IAMP), ia_gzrf1) : (a_gzrf1/target)*MAX_PG_IAMP;
	fprintf(stderr,"after sseval1 amp and iamp are %f and %d \n",a_gzrf1,ia_gzrf1);
    fprintf(stderr,"bw is %d\n", bw_rf1);
    }
    
    if (ss_fa_scaling_flag && (cfgcoiltype == PSD_XRMB_COIL || cfgcoiltype == PSD_XRMW_COIL) &&
        (ss_rf1 == PSD_ON) && (exist(oppseq) == PSD_GE) && max_ss_fa < avmaxflip)
    {
        avmaxflip = max_ss_fa;
    }

    /* Make sure the true bandwidths are up to date. */
    bw_rf1  = _bw_rf1.fixedflag ?  ((void)(rfpulse[RF1_SLOT].nom_bw*rfpulse[RF1_SLOT].nom_pw/pw_rf1), bw_rf1) : rfpulse[RF1_SLOT].nom_bw*rfpulse[RF1_SLOT].nom_pw/pw_rf1;
    bw_rf2  = _bw_rf2.fixedflag ?  ((void)(rfpulse[RF2_SLOT].nom_bw*rfpulse[RF2_SLOT].nom_pw/pw_rf2), bw_rf2) : rfpulse[RF2_SLOT].nom_bw*rfpulse[RF2_SLOT].nom_pw/pw_rf2;
    fprintf(stderr,"bw is %d\n", bw_rf1);
    
    /* time from the start of the excitation pulse to the magnetic isocenter */
    t_exa  = _t_exa.fixedflag ?    ((void)(hrf1a-off90), t_exa) : hrf1a-off90;
    
    rfExIso  = _rfExIso.fixedflag ?    ((void)(hrf1b+off90), rfExIso) : hrf1b+off90;
    
    /* auto min te and tr */
    if ( exist(opautote) == PSD_MINTE || exist(opautote) == PSD_MINTEFULL ) 
        setexist(opte,PSD_OFF);
    
    if (exist(opfcomp) == PSD_ON && existcv(opfcomp)) {
        zgmn_type  = _zgmn_type.fixedflag ?  ((void)(CALC_GMN1), zgmn_type) : CALC_GMN1;
        ygmn_type  = _ygmn_type.fixedflag ?  ((void)(CALC_GMN1), ygmn_type) : CALC_GMN1;
    } else {
        zgmn_type  = _zgmn_type.fixedflag ?  ((void)(NO_GMN), zgmn_type) : NO_GMN;
        ygmn_type  = _ygmn_type.fixedflag ?  ((void)(NO_GMN), ygmn_type) : NO_GMN;
    }
    
    pw_gzrf2a  = _pw_gzrf2a.fixedflag ?  ((void)(RUP_GRD(loggrd.zrt)), pw_gzrf2a) : RUP_GRD(loggrd.zrt);
    pw_gzrf2d  = _pw_gzrf2d.fixedflag ?  ((void)(RUP_GRD(loggrd.zrt)), pw_gzrf2d) : RUP_GRD(loggrd.zrt);
    pw_gzrf2r1a  = _pw_gzrf2r1a.fixedflag ?  ((void)(RUP_GRD(loggrd.zrt)), pw_gzrf2r1a) : RUP_GRD(loggrd.zrt); 
    pw_gzrf2r1d  = _pw_gzrf2r1d.fixedflag ?  ((void)(RUP_GRD(loggrd.zrt)), pw_gzrf2r1d) : RUP_GRD(loggrd.zrt);
    
    /* Seqtype(MPMP, XRR, NCAT,CAT  needed for several routines */
    if (seqtype(_seq_type.fixedflag ? (_temp424_seq_type=seq_type,&_temp424_seq_type) : &seq_type) == FAILURE) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "seqtype");
        return FAILURE;
    }
    
    /* Set the fract_ CVs */
    fract_ky  = _fract_ky.fixedflag ?  ((void)(PSD_FULL_KY), fract_ky) : PSD_FULL_KY;
    ky_dir  = _ky_dir.fixedflag ?  ((void)(PSD_TOP_DOWN), ky_dir) : PSD_TOP_DOWN;
    
    if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FULL_KY)
        ep_alt  = _ep_alt.fixedflag ?  ((void)(2), ep_alt) : 2;   /*1st half +, second half - */
    else
        ep_alt  = _ep_alt.fixedflag ?  ((void)(0), ep_alt) : 0;
    
    nexcalc();
    
    /* X readout train */
    
    /* Some hardware restrictions apply:  When operating with the standard
       receiver, the data acquisition window spacings must be a multiple of
       the 187.5 kHz demodulation frequency offset.  This corresponds to a
       5.33 us period. The nearest integral multiple is then 16 us. */
    
    if (vrgfsamp == 0) {
        /* epigradopt() will set this properly for vrg */
        rhfrsize  = _rhfrsize.fixedflag ?  ((void)(exist(opxres)), rhfrsize) : exist(opxres);
    }
    
    if (vrgfsamp == 1 && user_bw == 0) {
        /* Turn off bandwidth buttons & rbw advisory */
        pircbnub = 0;
        piadvmax = (piadvmax & ~(1<<PSD_ADVRCVBW)); 
        piadvmin = (piadvmin & ~(1<<PSD_ADVRCVBW)); 
        
        /* MRIge50913 - BJM: force user to select rbw if vrgf turned off */
        _oprbw.existflag = 0;
    } else {
        piadvmax = (piadvmax | (1<<PSD_ADVRCVBW));
        piadvmin = (piadvmin | (1<<PSD_ADVRCVBW));
    }
    
    /* Fill in the epigradopt input structure */
    if (autogap == 1) {
        xtarg  = _xtarg.fixedflag ?  ((void)(epiloggrd.tx), xtarg) : epiloggrd.tx;
        ytarg  = _ytarg.fixedflag ?  ((void)(epiloggrd.ty), ytarg) : epiloggrd.ty;
    } else {
        xtarg  = _xtarg.fixedflag ?  ((void)(epiloggrd.tx_xy), xtarg) : epiloggrd.tx_xy;
        ytarg  = _ytarg.fixedflag ?  ((void)(epiloggrd.ty_xy), ytarg) : epiloggrd.ty_xy;
    }
    
    /* Local block for calcualting tsp */
    {
        /* HALF_KHZ_USEC is from filter.h - need to change from cfcerdbw1 when */
        /* config name changes */
        float tsp_min = (HALF_KHZ_USEC/RBW_MAX);
        float act_rbw;
        float decimation;
        float max_rbw;
 
        if (vrgfsamp == PSD_ON  && user_bw == 0) {
            
            rbw  = _rbw.fixedflag ?  ((void)(0.0), rbw) : 0.0;  /* calculate this for the vrgf case */
            
            /* Do this so rhfrsize remains low enough for current recon limitations */
            if (exist(opxres) <= 128) {
                vrgf_targ  = _vrgf_targ.fixedflag ?  ((void)(2.0), vrgf_targ) : 2.0;
            } else {
                vrgf_targ  = _vrgf_targ.fixedflag ?  ((void)(1.6), vrgf_targ) : 1.6;
            }
            
            /* 4x oversampling ratio desired */
            tsp  = _tsp.fixedflag ?          ((void)(1.0/(GAM*xtarg*exist(opfov)/10.0)/(vrgf_targ/1.0e6)), tsp) : 1.0/(GAM*xtarg*exist(opfov)/10.0)/(vrgf_targ/1.0e6); 
                                  
            /* Cant go lower than hardware sample period */
            if (tsp < tsp_min) {
                tsp  = _tsp.fixedflag ?  ((void)(tsp_min), tsp) : tsp_min;
            }  

            /* Calculate desited RBW in kHz. */
            /* Note: this might not be valid if the */
            /* decimation required is not supported by */
            /* MGD.  Thus, we will check this calculation */
            /* below with calcvalidrbw() */
            /* Hz to kHz */
            rbw  = _rbw.fixedflag ?      ((void)((1.0/(2.0*(tsp/1000000)))/1000.0), rbw) : (1.0/(2.0*(tsp/1000000)))/1000.0;

            /* Check for a valid RBW */
            /* Calculate the rbw, decimation based on the */
            /* the supported MGD configuration */
            /* This function will return act_rbw with the nearest */
            /* valid value and also overwrite the value of oprbw  */
            if (SUCCESS != calcvalidrbw(rbw, &act_rbw, &max_rbw, &decimation, 
                                        OVERWRITE_OPRBW, vrgfsamp)) {
                return FAILURE;
            }
            
            /* Recalculate tsp now that we have a valid RBW */
            tsp  = _tsp.fixedflag ?  ((void)(1000000*(1.0/(2.0*(1000.0*act_rbw)))), tsp) : 1000000*(1.0/(2.0*(1000.0*act_rbw)));

            /* Reset rbw to updated value */
            rbw  = _rbw.fixedflag ?  ((void)(act_rbw), rbw) : act_rbw;
            
        }  else {
            
            /* first, check for a valid RBW */
            /* calculate the rbw, decimation based on the */
            if (SUCCESS != calcvalidrbw(exist(oprbw), &act_rbw, &max_rbw, 
                                        &decimation, OVERWRITE_OPRBW, vrgfsamp)) {
                return FAILURE;
            }

            /* tsp = echo1_filt.tsp;*/
            rbw  = _rbw.fixedflag ?  ((void)(exist(oprbw)), rbw) : exist(oprbw); 

            /* Need to calculate tsp for epigradopt */
            tsp  = _tsp.fixedflag ?  ((void)(1000000*(1.0/(2.0*(1000.0*rbw)))), tsp) : 1000000*(1.0/(2.0*(1000.0*rbw)));
            
        } /* end if(vrgfsamp == PSD_ON) */
    
        /* Round tsp (removes any small RO error) */
        tsp  = _tsp.fixedflag ?     ((void)((float)((floor)((tsp*10.0)+0.5)/10.0)), tsp) : (float)((floor)((tsp*10.0)+0.5)/10.0);

    } /* end local block */
    
    /* Fill in the gradient structure for epigradopt() call */
    gradin.xfs = xtarg;
    gradin.yfs = ytarg;
    gradin.xrt = epiloggrd.xrt;
    gradin.yrt = epiloggrd.yrt;
    gradin.xbeta = epiloggrd.xbeta;
    gradin.ybeta = epiloggrd.ybeta;
    gradin.xfov = rhfreqscale*exist(opfov)/10.0;   /* convert to cm */
    /* MRIge92386 */
    gradin.yfov = exist(opphasefov)*exist(opfov)*asset_factor/10.0; /* convert to cm */

    if (vrgfsamp == PSD_OFF)
        gradin.xres = rhfrsize;
    else
        gradin.xres = exist(opxres);
    
    /* MRIge92386 */
    gradin.yres = (int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor);

    if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FULL_KY)
        gradin.ileaves = intleaves/2;
    else
        gradin.ileaves = intleaves;
    gradin.xdis = cfdbdtdx;
    gradin.ydis = cfdbdtdy;
    gradin.tsp  = _tsp.fixedflag ?  ((void)(tsp), tsp) : tsp;
    gradin.osamps = osamp;
    gradin.fbhw  = _fbhw.fixedflag ?  ((void)(fbhw), fbhw) : fbhw;
    gradin.vvp = hrdwr_period;    
    pw_gxgap  = _pw_gxgap.fixedflag ?  ((void)(0), pw_gxgap) : 0;  

    /* SXZ::MRIge72411: find taratio value for the current prescription */
    /* max k value */
    totarea  = _totarea.fixedflag ?       ((void)(1.0e6*gradin.xres/(gradin.xfov*(FLOAT)GAM)), totarea) : 1.0e6*gradin.xres/(gradin.xfov*(FLOAT)GAM);
    if( vrgfsamp == PSD_ON && rampopt == 1 ){
        int indx;
        for(indx = 0; indx < NODESIZE; indx++){
            if(totarea <= totarea_arr[indx]){
                if( indx == 0 ){
                    taratio  = _taratio.fixedflag ?  ((void)(taratio_arr[indx]), taratio) : taratio_arr[indx];
                }else{ 
                    taratio  = _taratio.fixedflag ?   
                         

                        ((void)(taratio_arr[indx-1]+(totarea-totarea_arr[indx-1])/(totarea_arr[indx]-totarea_arr[indx-1])*(taratio_arr[indx]-taratio_arr[indx-1])), taratio) : taratio_arr[indx-1]+(totarea-totarea_arr[indx-1])/(totarea_arr[indx]-totarea_arr[indx-1])*(taratio_arr[indx]-taratio_arr[indx-1]);
                }
                break;
            }else if(indx==NODESIZE-1){
                taratio  = _taratio.fixedflag ?  ((void)(taratio_arr[indx]), taratio) : taratio_arr[indx];
            }
        }

/* MRIhc05886 and MRIhc14486 */

        if( (cfgcoiltype == PSD_TRM_COIL) && (epispec_flag == 0) && (mph_flag == PSD_ON) && ((opfphases * opslquant) > 2048) ) {
            if( !checkOptionKey( SOK_IPCM ) ) {
                if( taratio < 0.85 ) {
                    taratio  = _taratio.fixedflag ?  ((void)(0.85), taratio) : 0.85;
                }
            } else {
                if( taratio < 0.9 ) {
                    taratio  = _taratio.fixedflag ?  ((void)(0.9), taratio) : 0.9;
                }
            }
            if( taratio < 0.9 && exist(opasset) == ASSET_SCAN && opxres < 128 ) {
                taratio  = _taratio.fixedflag ?  ((void)(0.9), taratio) : 0.9;
            }
        }

        if ((PSD_ON == taratio_override) && (PSD_XRMW_COIL == cfgcoiltype))
        {
            taratio  = _taratio.fixedflag ?  ((void)(TARATIO_XRMW), taratio) : TARATIO_XRMW;
        }

    }else{
        taratio  = _taratio.fixedflag ?  ((void)(0), taratio) : 0;
    }

    gradin.taratio  = _taratio.fixedflag ?  ((void)(taratio), taratio) : taratio;

    /* MRIhc44418 activate ESP range check*/

    each_gradopt_count = 0;

    if(iref_etl > 0 && cffield >= B0_30000 && PSD_XRMB_COIL == cfgcoiltype && 
       ((epira3_flag == PSD_ON || epiRTra3_flag == PSD_ON) && (ra3_sndpc_flag == PSD_OFF)))
    {
        esprange_check  = _esprange_check.fixedflag ?  ((void)(1), esprange_check) : 1;
    }
    else if(cffield >= B0_30000 && PSD_XRMW_COIL == cfgcoiltype)
    {
        esprange_check  = _esprange_check.fixedflag ?  ((void)(1), esprange_check) : 1;
    }
    else
    {
        esprange_check  = _esprange_check.fixedflag ?  ((void)(0), esprange_check) : 0;
    }

    if(esprange_check == 1) readEspRange();

    if(dbdt_model == DBDTMODELCONV && (cfdbdtts == 0.0 && cfdbdtper > 0.0))
    {
        if(optGradAndEsp_conv() == FAILURE) 
        {
            reopt_flag = PSD_ON;
            return FAILURE;
        }
        if(iref_etl > 0 && dbdtper_new > cfdbdtper) no_gy1_ol_gxw  = _no_gy1_ol_gxw.fixedflag ?  ((void)(1), no_gy1_ol_gxw) : 1;
        else no_gy1_ol_gxw  = _no_gy1_ol_gxw.fixedflag ?  ((void)(0), no_gy1_ol_gxw) : 0;
    }
    else if(esprange_check && (cfdbdtts == 0.0 && cfdbdtper > 0.0))
    {
        if(optGradAndEsp_rect() == FAILURE) 
        {
            reopt_flag = PSD_ON;
            return FAILURE;
        }
        no_gy1_ol_gxw  = _no_gy1_ol_gxw.fixedflag ?  ((void)(0), no_gy1_ol_gxw) : 0;
    }
    else
    {
        pw_gxgap  = _pw_gxgap.fixedflag ?  ((void)(0), pw_gxgap) : 0;
        dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(cfdbdtper), dbdtper_new) : cfdbdtper;
        if(epigradopt_rect(dbdtper_new, 0) == FAILURE) 
        {
            reopt_flag = PSD_ON;
            return FAILURE;
        }
        if(epigradopt_debug) printEpigradoptLog();
        no_gy1_ol_gxw  = _no_gy1_ol_gxw.fixedflag ?  ((void)(0), no_gy1_ol_gxw) : 0;
    }
    
    /* echo shifting for fractional echo and tuning */
    msamp  = _msamp.fixedflag ?  ((void)(0.0), msamp) : 0.0;
    dsamp  = _dsamp.fixedflag ?  ((void)(0.0), dsamp) : 0.0;       /* Delta echo shift (tuning) */
    
    /* PW_GXW delta for GW1 calc */ 
    delpw  = _delpw.fixedflag ?  ((void)((msamp+dsamp)*tsp), delpw) : (msamp+dsamp)*tsp;
    
    /* Position of dephaser pulses: pre- or post- 180 */
    /* For GRE - the positions are post-180 to get the proper sign */  
    if (exist(oppseq) != PSD_SE) {              
        /* set the gx1 and gy1 position flags */
        cvoverride(gx1pos, PSD_POST_180,_gx1pos.fixedflag,_gx1pos.existflag);
        cvoverride(gy1pos, PSD_POST_180,_gy1pos.fixedflag,_gy1pos.existflag);
    }
    
    /* X dephaser pulse */
    gx1_area  = _gx1_area.fixedflag ?       
                          ((void)(a_gxw*((float)pw_gxwad/2.0+(float)pw_gxwl+(float)pw_gxw/2.0+delpw)), gx1_area) : a_gxw*((float)pw_gxwad/2.0+(float)pw_gxwl+(float)pw_gxw/2.0+delpw);
    
    /* The GRAM circuit may require shaped attack and decay ramps to
       facilitate a smooth transition between the ramp transition and
       adjacent pulse seqments.  A mechanism is provided in 5.5 to shape
       the waveform such that it begins as a parabola, transitions smoothly
       into a linear segment covering the center portion of the transition,
       and transitions smoothly into a parabolic segment (a mirror of the
       first parabolic component) to terminate the transition.  This
       composite waveform and its first deriviative are continuous from
       start to end.   A parameter called "beta," ranging form 0 to 1,
       specifies the portion of the ramp that is linear.  If beta is 1,
       the ramp is completely linear; if zero, the ramp is completely
       parabolic.  As a greater portion of the waveform becomes parabolic,
       the slope of the linear segment increases.  The absolute area under
       the "ramp" transition remains constant for any value of beta over
       its range [0..1].
       PSD_ss1528822_RF1_LEFT
       Please refer to the 5.5 General PSD Enhancements SRS.
       
       The wave shaping is performed at the low level ramp generation
       routine (w_ramp funciton in wg_linear.c, PGEN_WAVE project).
       
       In the readout echo planar pulse train, the first attack and last
       decay ramp will have different shapes than the other ramps.
       For VRG sampling, this results in an assymmetry in the first and
       last view of the train.  To circumvent this, the dephaser pulse
       can be moved up against the readout train, and the dephaser's
       decay and be combined with the first readout attack ramp.
       
       The following code make this determination.  */
    
    /* If epiloggrd.xrt == loggrd.xrt then dB/dt is not an issue and
       a single ramp is legal. */
    if (( gx1_area >= a_gxw*(float)pw_gxwad) && gx1pos == PSD_POST_180 &&
        epiloggrd.xrt == loggrd.xrt)
        single_ramp_gx1d  = _single_ramp_gx1d.fixedflag ?  ((void)(1), single_ramp_gx1d) : 1;
    else
        single_ramp_gx1d  = _single_ramp_gx1d.fixedflag ?  ((void)(0), single_ramp_gx1d) : 0;
    
    if (single_ramp_gx1d == PSD_ON) {
        pw_gx1a  = _pw_gx1a.fixedflag ?  ((void)(pw_gxwad), pw_gx1a) : pw_gxwad;
        pw_gx1d  = _pw_gx1d.fixedflag ?  ((void)(pw_gxwad), pw_gx1d) : pw_gxwad;
        /* pw_gx1 must >= MIN_PLATEAU_TIME */
        pw_gx1  = _pw_gx1.fixedflag ?      ((void)(IMax(2,RUP_GRD((int)(gx1_area/a_gxw-(float)pw_gx1a)),MIN_PLATEAU_TIME)), pw_gx1) : IMax(2,RUP_GRD((int)(gx1_area/a_gxw-(float)pw_gx1a)),MIN_PLATEAU_TIME); 
        a_gx1  = _a_gx1.fixedflag ?    ((void)(-gx1_area/(float)(pw_gx1a+pw_gx1)), a_gx1) : -gx1_area/(float)(pw_gx1a+pw_gx1);
    } else {
        if (gx1pos == PSD_POST_180)
            gx1_area  = _gx1_area.fixedflag ?  ((void)(-1), gx1_area) : gx1_area*-1;
        start_amp  = _start_amp.fixedflag ?  ((void)(0.0), start_amp) : 0.0;
        end_amp  = _end_amp.fixedflag ?  ((void)(0.0), end_amp) : 0.0;
        if (amppwgradmethod(&gradx[GX1_SLOT], gx1_area, loggrd.tx_xyz, start_amp,
                            end_amp, loggrd.xrt, MIN_PLATEAU_TIME) == FAILURE) {
            epic_error(use_ermes,"%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "amppwgradmethod:gx1");
            return FAILURE;
        }
    }
    
    pw_gx1_tot  = _pw_gx1_tot.fixedflag ?      ((void)(pw_gx1a+pw_gx1+pw_gx1d), pw_gx1_tot) : pw_gx1a+pw_gx1+pw_gx1d;
    
    /* At this point, we know the timing for the basic parameters for
       the echo planar gradient train: amplitudes and pulse widths of
       readout and phase encoding trapezoids, excluding the y axis
       dephaser.
       
       To compute the advisory panel minimum TE, first calculate the
       other timing elements, such as slice select axis timing, killer
       pulses, etc.  Then proceed with advisory calculations,
       finishing up with calculation of the phase encoding dephaser,
       ky_offset, rhhnover, etc. */
    
    
    /***** Slice select timing ****************************************/
    /*jwg bb the external spsp rf files already have nominal thickness calculated,
    so we don't need to go through this process for them!*/
    if (opuser20 < 2)
    {
    fprintf(stderr,"running ampslice and optramp \n");
    if (ampslice(_a_gzrf1.fixedflag ? (_temp425_a_gzrf1=a_gzrf1,&_temp425_a_gzrf1) : &a_gzrf1, bw_rf1, exist(opslthick), gscale_rf1, TYPDEF)
        == FAILURE) {
        epic_error(use_ermes, "%s failed for gzrf1", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice");
        return FAILURE;
    }
    
    /* optimize attack and decay ramps */
    if (optramp(_pw_gzrf1d.fixedflag ? (_temp426_pw_gzrf1d=pw_gzrf1d,&_temp426_pw_gzrf1d) : &pw_gzrf1d, a_gzrf1, loggrd.tz_xyz, loggrd.zrt, TYPDEF) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp:pw_gzrf1d");
        return FAILURE;
    }
    pw_gzrf1a  = _pw_gzrf1a.fixedflag ?  ((void)(pw_gzrf1d), pw_gzrf1a) : pw_gzrf1d;
    }

    if (ampslice(_a_gzrf2.fixedflag ? (_temp427_a_gzrf2=a_gzrf2,&_temp427_a_gzrf2) : &a_gzrf2, bw_rf2, exist(opslthick), gscale_rf2,TYPDEF)== FAILURE) {
        epic_error(use_ermes,"%s failed for gzrf2", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice");
        return FAILURE;
    }
    
    ivslthick  = _ivslthick.fixedflag ?  ((void)(exist(opfov)), ivslthick) : exist(opfov);
    if (ampslice(_a_gyrf2iv.fixedflag ? (_temp428_a_gyrf2iv=a_gyrf2iv,&_temp428_a_gyrf2iv) : &a_gyrf2iv, bw_rf2, ivslthick, gscale_rf2, TYPDEF) == FAILURE) {
        epic_error(use_ermes, "%s failed for gyrf2iv", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice");
        return FAILURE;
    }
    
    gradz[GZRF1_SLOT].num = 1;
    gradz[GZK_SLOT].num = 1;
    
    if (exist(oppseq) == PSD_SE) {

        if (innerVol == PSD_ON) {  /* refocus pulse on logical Y */
            gradz[GZRF2_SLOT].num = 0;
            grady[GYRF2IV_SLOT].num = 1;

            if (optramp(_pw_gyrf2iva.fixedflag ? (_temp429_pw_gyrf2iva=pw_gyrf2iva,&_temp429_pw_gyrf2iva) : &pw_gyrf2iva, loggrd.ty_xyz, loggrd.ty, loggrd.yrt, TYPDEF)
                == FAILURE) {
                epic_error(use_ermes,"%s failed", EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "optramp:pw_gyrf2iva");
                return FAILURE;
	    }
            pw_gyrf2ivd  = _pw_gyrf2ivd.fixedflag ?  ((void)(pw_gyrf2iva), pw_gyrf2ivd) : pw_gyrf2iva;

	} else {  /* refocus pulse on logical Z */
            gradz[GZRF2_SLOT].num = 1;
            grady[GYRF2IV_SLOT].num = 0;
	}

        gradz[GZRF2L1_SLOT].num = 1;
        gradz[GZRF2R1_SLOT].num = 1;
        gradz[GZRF2_SLOT].num = 1;
        rfpulse[RF2_SLOT].num = 1;
        rfpulse[RF2_SLOT].activity = PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON;

    } else {
        gradz[GZRF2_SLOT].num = 0;
        grady[GYRF2IV_SLOT].num = 0;
        gradz[GZRF2L1_SLOT].num = 0;
        gradz[GZRF2R1_SLOT].num = 0;
        gradz[GZRF2_SLOT].num = 0;
        rfpulse[RF2_SLOT].num = 0;
        rfpulse[RF2_SLOT].activity = PSD_PULSE_OFF;
    }
    
    rfpulse[RF1_SLOT].num = 1;
    
    if (optramp(_pw_gzrf2l1a.fixedflag ? (_temp430_pw_gzrf2l1a=pw_gzrf2l1a,&_temp430_pw_gzrf2l1a) : &pw_gzrf2l1a, loggrd.tz_xyz, loggrd.tz, loggrd.zrt, TYPDEF) == FAILURE) {
        epic_error(use_ermes,"%s failure", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp:pw_gzrf2l1a");
        return FAILURE;
    }
  
    if (optramp(_pw_gzrf2l1d.fixedflag ? (_temp431_pw_gzrf2l1d=pw_gzrf2l1d,&_temp431_pw_gzrf2l1d) : &pw_gzrf2l1d, fabs(a_gzrf2l1-a_gzrf2), loggrd.tz_xyz,
                loggrd.zrt, TYPDEF) == FAILURE)
        return FAILURE;
    
    crusher_type = PSD_TYPCMEMP;
    if (crusherutil(crusher_scale, crusher_type) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "crusherutil");
        return FAILURE;
    }
	
    /* The CVs c1_scale, c2_scale, ... are maintained for bay testing. */
    c1_scale = crusher_scale[0];
    area_std  = _area_std.fixedflag ?  ((void)(pw_gzrf2*a_gzrf2/2), area_std) : pw_gzrf2*a_gzrf2/2;
    
    /*  The following part is not needed for GRE-EPI. MRIge33618.  ypd */
    if (exist(oppseq) == PSD_SE || se_ref == 1) {
        if ((amppwcrush(&gradz[GZRF2R1_SLOT], &gradz[GZRF2L1_SLOT],
                        (int)1, c1_scale, loggrd.tz_xyz, a_gzrf2, area_std,
                        MIN_PLATEAU_TIME, loggrd.zrt) == FAILURE)) {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "amppwcrush");
            return FAILURE;
        }
    } 
    
    /* Include gz1 and gzmn in gradient duty cycle calc. MRIge33619 YP Du */
    gradz[GZ1_SLOT].num = 1;
    
    if ( existcv(opfcomp) && exist(opfcomp) == PSD_ON)
        gradz[GZMN_SLOT].num = 1;
	
    /* *******************************************************
       Left Crusher for 1st 180 (handles 90 pulse rephasing)
       Calc area needed for z rephaser for amppwlcrsh routine.
    *******************************************************/
	
    /* spsp area needed for rephaser */
    
    avail_pwgz1  = _avail_pwgz1.fixedflag ?  ((void)(TR_MAX), avail_pwgz1) : TR_MAX;
    area_gz1  = _area_gz1.fixedflag ?    ((void)(((float)rfExIso+(float)pw_gzrf1d/2.0)*a_gzrf1), area_gz1) : ((float)rfExIso+(float)pw_gzrf1d/2.0)*a_gzrf1; 
    
    if (ssEval1() == FAILURE) return FAILURE;  /* redefine area_gz1 for
                                                  spectral-spatial pulse */

    if(opuser20 > 1 )
    {
    	a_gzrf1  = _a_gzrf1.fixedflag ?   ((void)(a_gzs_temp*(nom_thk_rf1/thk_rf1)*(rfpulse[RF1_SLOT].nom_pw/pw_rf1)), a_gzrf1) : a_gzs_temp*(nom_thk_rf1/thk_rf1)*(rfpulse[RF1_SLOT].nom_pw/pw_rf1);
	gettarget(_target.fixedflag ? (_temp432_target=target,&_temp432_target) : &target, ZGRAD, &loggrd);
	ia_gzrf1  = _ia_gzrf1.fixedflag ?    ((void)((a_gzrf1/target)*MAX_PG_IAMP), ia_gzrf1) : (a_gzrf1/target)*MAX_PG_IAMP;
	fprintf(stderr,"after sseval1 AGAIN amp and iamp are %f and %d \n",a_gzrf1,ia_gzrf1);
    }
    
    if(ss_rf1 == PSD_OFF) 
        area_gz1  = _area_gz1.fixedflag ?    ((void)(((float)rfExIso+(float)pw_gzrf1d/2.0)*a_gzrf1), area_gz1) : ((float)rfExIso+(float)pw_gzrf1d/2.0)*a_gzrf1;

    if (zgmn_type == CALC_GMN1) {
        /* Set time origin for moment calculation at end of gzrf1d decay ramp.
           Therefore the gzrf1 pulse is time reversed. */
        pulsepos  = _pulsepos.fixedflag ?  ((void)(0), pulsepos) : 0;
        zeromomentsum  = _zeromomentsum.fixedflag ?  ((void)(0.0), zeromomentsum) : 0.0;
        firstmomentsum  = _firstmomentsum.fixedflag ?  ((void)(0.0), firstmomentsum) : 0.0;
        invertphase  = _invertphase.fixedflag ?  ((void)(0), invertphase) : 0;
        
        if (ss_rf1 == PSD_ON) {
            zeromomentsum  = _zeromomentsum.fixedflag ?  ((void)(gz1_zero_moment), zeromomentsum) : gz1_zero_moment;
            firstmomentsum  = _firstmomentsum.fixedflag ?  ((void)(gz1_first_moment), firstmomentsum) : gz1_first_moment;
	} else {
            rampmoments(0.0, a_gzrf1, pw_gzrf1d, invertphase, _pulsepos.fixedflag ? (_temp433_pulsepos=pulsepos,&_temp433_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp434_zeromoment=zeromoment,&_temp434_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp435_firstmoment=firstmoment,&_temp435_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp436_zeromomentsum=zeromomentsum,&_temp436_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp437_firstmomentsum=firstmomentsum,&_temp437_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gzrf1, a_gzrf1, rfExIso, invertphase, _pulsepos.fixedflag ? (_temp438_pulsepos=pulsepos,&_temp438_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp439_zeromoment=zeromoment,&_temp439_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp440_firstmoment=firstmoment,&_temp440_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp441_zeromomentsum=zeromomentsum,&_temp441_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp442_firstmomentsum=firstmomentsum,&_temp442_firstmomentsum) : &firstmomentsum);
	}

        if (exist(oppseq) == PSD_SE) {
            /* Make left and right crushers mirror images of each other */
            a_gzrf2l1  = _a_gzrf2l1.fixedflag ?  ((void)(a_gzrf2r1), a_gzrf2l1) : a_gzrf2r1;
            pw_gzrf2l1d  = _pw_gzrf2l1d.fixedflag ?  ((void)(pw_gzrf2r1a), pw_gzrf2l1d) : pw_gzrf2r1a;
            pw_gzrf2l1  = _pw_gzrf2l1.fixedflag ?  ((void)(pw_gzrf2r1), pw_gzrf2l1) : pw_gzrf2r1;
            pw_gzrf2l1a  = _pw_gzrf2l1a.fixedflag ?  ((void)(pw_gzrf2r1d), pw_gzrf2l1a) : pw_gzrf2r1d;
            pulsepos  = _pulsepos.fixedflag ?       
                      ((void)(-(rfExIso+pw_gzrf1d)+exist(opte)-(pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d+pw_gzrf2/2)), pulsepos) : -(rfExIso+pw_gzrf1d)+exist(opte)-(pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d+pw_gzrf2/2);
            rampmoments(0.0, a_gzrf2l1, pw_gzrf2l1a, invertphase, _pulsepos.fixedflag ? (_temp443_pulsepos=pulsepos,&_temp443_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp444_zeromoment=zeromoment,&_temp444_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp445_firstmoment=firstmoment,&_temp445_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp446_zeromomentsum=zeromomentsum,&_temp446_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp447_firstmomentsum=firstmomentsum,&_temp447_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gzrf2l1, a_gzrf2l1, pw_gzrf2l1, invertphase, _pulsepos.fixedflag ? (_temp448_pulsepos=pulsepos,&_temp448_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp449_zeromoment=zeromoment,&_temp449_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp450_firstmoment=firstmoment,&_temp450_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp451_zeromomentsum=zeromomentsum,&_temp451_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp452_firstmomentsum=firstmomentsum,&_temp452_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gzrf2l1, a_gzrf2, pw_gzrf2l1d, invertphase, _pulsepos.fixedflag ? (_temp453_pulsepos=pulsepos,&_temp453_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp454_zeromoment=zeromoment,&_temp454_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp455_firstmoment=firstmoment,&_temp455_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp456_zeromomentsum=zeromomentsum,&_temp456_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp457_firstmomentsum=firstmomentsum,&_temp457_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gzrf2, a_gzrf2, pw_gzrf2/2, invertphase, _pulsepos.fixedflag ? (_temp458_pulsepos=pulsepos,&_temp458_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp459_zeromoment=zeromoment,&_temp459_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp460_firstmoment=firstmoment,&_temp460_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp461_zeromomentsum=zeromomentsum,&_temp461_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp462_firstmomentsum=firstmomentsum,&_temp462_firstmomentsum) : &firstmomentsum);
            invertphase  = _invertphase.fixedflag ?  ((void)(1), invertphase) : 1;
            rampmoments(a_gzrf2, a_gzrf2, pw_gzrf2/2, invertphase, _pulsepos.fixedflag ? (_temp463_pulsepos=pulsepos,&_temp463_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp464_zeromoment=zeromoment,&_temp464_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp465_firstmoment=firstmoment,&_temp465_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp466_zeromomentsum=zeromomentsum,&_temp466_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp467_firstmomentsum=firstmomentsum,&_temp467_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gzrf2, a_gzrf2r1, pw_gzrf2r1a, invertphase, _pulsepos.fixedflag ? (_temp468_pulsepos=pulsepos,&_temp468_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp469_zeromoment=zeromoment,&_temp469_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp470_firstmoment=firstmoment,&_temp470_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp471_zeromomentsum=zeromomentsum,&_temp471_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp472_firstmomentsum=firstmomentsum,&_temp472_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gzrf2r1, a_gzrf2r1, pw_gzrf2r1, invertphase, _pulsepos.fixedflag ? (_temp473_pulsepos=pulsepos,&_temp473_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp474_zeromoment=zeromoment,&_temp474_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp475_firstmoment=firstmoment,&_temp475_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp476_zeromomentsum=zeromomentsum,&_temp476_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp477_firstmomentsum=firstmomentsum,&_temp477_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gzrf2r1, 0.0, pw_gzrf2r1d, invertphase, _pulsepos.fixedflag ? (_temp478_pulsepos=pulsepos,&_temp478_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp479_zeromoment=zeromoment,&_temp479_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp480_firstmoment=firstmoment,&_temp480_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp481_zeromomentsum=zeromomentsum,&_temp481_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp482_firstmomentsum=firstmomentsum,&_temp482_firstmomentsum) : &firstmomentsum);
            avail_zflow_time  = _avail_zflow_time.fixedflag ?         
                                                 
                                              ((void)(exist(opte)-(rfExIso+pw_gzrf1d+pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d+pw_gzrf2/2)), avail_zflow_time) : exist(opte)-(rfExIso+pw_gzrf1d+pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d+pw_gzrf2/2);
            firstmomentsum  = _firstmomentsum.fixedflag ?  ((void)(-1.0), firstmomentsum) : firstmomentsum*-1.0;
	} else {  /* gradient recalled echo */
            avail_zflow_time  = _avail_zflow_time.fixedflag ?      ((void)(exist(opte)-(rfExIso+pw_gzrf1d)), avail_zflow_time) : exist(opte)-(rfExIso+pw_gzrf1d);
	}
        
        /* Calculate the z moment nulling pulses: gz1, gzmn */
        if (amppwgmn(zeromomentsum, firstmomentsum, 0.0, 0.0, avail_zflow_time,
                     loggrd.zbeta, loggrd.tz_xyz, loggrd.zrt, MIN_PLATEAU_TIME,
                     _a_gz1.fixedflag ? (_temp483_a_gz1=a_gz1,&_temp483_a_gz1) : &a_gz1, _pw_gz1a.fixedflag ? (_temp484_pw_gz1a=pw_gz1a,&_temp484_pw_gz1a) : &pw_gz1a, _pw_gz1.fixedflag ? (_temp485_pw_gz1=pw_gz1,&_temp485_pw_gz1) : &pw_gz1, _pw_gz1d.fixedflag ? (_temp486_pw_gz1d=pw_gz1d,&_temp486_pw_gz1d) : &pw_gz1d, _a_gzmn.fixedflag ? (_temp487_a_gzmn=a_gzmn,&_temp487_a_gzmn) : &a_gzmn, _pw_gzmna.fixedflag ? (_temp488_pw_gzmna=pw_gzmna,&_temp488_pw_gzmna) : &pw_gzmna,
                     _pw_gzmn.fixedflag ? (_temp489_pw_gzmn=pw_gzmn,&_temp489_pw_gzmn) : &pw_gzmn, _pw_gzmnd.fixedflag ? (_temp490_pw_gzmnd=pw_gzmnd,&_temp490_pw_gzmnd) : &pw_gzmnd) == FAILURE) {
            /* don't trap the failure here; this will drive minimum te */
        }
        a_gz1  = _a_gz1.fixedflag ?  ((void)(-1.0), a_gz1) : a_gz1*-1.0;  /* Invert gz1 pulse */

    } else {        /* zgmn_type != CALC_GMN1 */

        pw_gzmna  = _pw_gzmna.fixedflag ?  ((void)(0), pw_gzmna) : 0;
        pw_gzmn  = _pw_gzmn.fixedflag ?  ((void)(0), pw_gzmn) : 0;
        pw_gzmnd  = _pw_gzmnd.fixedflag ?  ((void)(0), pw_gzmnd) : 0;
        
        if (exist(oppseq) != PSD_SE) {
	    if(opuser20 < 2 )  /*for 1H spsp or sinc*/
	    	{
	            if (amppwgz1(_a_gz1.fixedflag ? (_temp491_a_gz1=a_gz1,&_temp491_a_gz1) : &a_gz1, _pw_gz1.fixedflag ? (_temp492_pw_gz1=pw_gz1,&_temp492_pw_gz1) : &pw_gz1, _pw_gz1a.fixedflag ? (_temp493_pw_gz1a=pw_gz1a,&_temp493_pw_gz1a) : &pw_gz1a, _pw_gz1d.fixedflag ? (_temp494_pw_gz1d=pw_gz1d,&_temp494_pw_gz1d) : &pw_gz1d, area_gz1,
        	                 avail_pwgz1, MIN_PLATEAU_TIME, loggrd.zrt,
                	         loggrd.tz_xyz) == FAILURE) {
	                epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
        	                   EE_ARGS(1), STRING_ARG, "amppwgz1");
                	return FAILURE;
			}
	
		    } else { /*jwg c13 spsp pulses are self-refocusing (i.e. built-in)*/
		     	area_gz1  = _area_gz1.fixedflag ?  ((void)(0), area_gz1) : 0; 
			a_gz1  = _a_gz1.fixedflag ?  ((void)(0), a_gz1) : 0;
			/*have to give these some time to make the system happy!*/
			pw_gz1a  = _pw_gz1a.fixedflag ?  ((void)(12), pw_gz1a) : 12; 
			pw_gz1  = _pw_gz1.fixedflag ?  ((void)(12), pw_gz1) : 12;
			pw_gz1d  = _pw_gz1d.fixedflag ?  ((void)(12), pw_gz1d) : 12;
		
	    }
            
	} else {
            a_gz1  = _a_gz1.fixedflag ?  ((void)(0.0), a_gz1) : 0.0;
            pw_gz1a  = _pw_gz1a.fixedflag ?  ((void)(0), pw_gz1a) : 0;
            pw_gz1  = _pw_gz1.fixedflag ?  ((void)(0), pw_gz1) : 0;
            pw_gz1d  = _pw_gz1d.fixedflag ?  ((void)(0), pw_gz1d) : 0;
            if (amppwlcrsh(&gradz[GZRF2L1_SLOT], &gradz[GZRF2R1_SLOT],
                           area_gz1, a_gzrf2, loggrd.tz_xyz, MIN_PLATEAU_TIME,
                           loggrd.zrt, _pw_gzrf2a.fixedflag ? (_temp495_pw_gzrf2a=pw_gzrf2a,&_temp495_pw_gzrf2a) : &pw_gzrf2a) == FAILURE) {
                epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "amppwlcrush");
                return FAILURE;
	    }
	}
    }  /* 	if (zgmn_type == CALC_GMN1) */

    pw_gz1_tot  = _pw_gz1_tot.fixedflag ?            ((void)(pw_gz1a+pw_gz1+pw_gz1d+pw_gzmna+pw_gzmn+pw_gzmnd), pw_gz1_tot) : pw_gz1a+pw_gz1+pw_gz1d+pw_gzmna+pw_gzmn+pw_gzmnd;
    
    if (ssEval2() != SUCCESS) return FAILURE;
    
    pw_gzrf2a  = _pw_gzrf2a.fixedflag ?  ((void)(pw_gzrf2l1d), pw_gzrf2a) : pw_gzrf2l1d;
    pw_gzrf2d  = _pw_gzrf2d.fixedflag ?  ((void)(pw_gzrf2r1a), pw_gzrf2d) : pw_gzrf2r1a;
    pw_gzrf2l1_tot  = _pw_gzrf2l1_tot.fixedflag ?      ((void)(pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d), pw_gzrf2l1_tot) : pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d;
    pw_gzrf2r1_tot  = _pw_gzrf2r1_tot.fixedflag ?      ((void)(pw_gzrf2r1a+pw_gzrf2r1+pw_gzrf2r1d), pw_gzrf2r1_tot) : pw_gzrf2r1a+pw_gzrf2r1+pw_gzrf2r1d;
    
    /***** End of sequences (eos) killer pulses *******************************/
    
    if (eoskillers == PSD_ON) {

        target_area  = _target_area.fixedflag ?    ((void)(a_gxw*(float)(pw_gxwad+pw_gxw/2)), target_area) : a_gxw*(float)(pw_gxwad+pw_gxw/2);

        if (eosxkiller == PSD_ON) {   /* X killer pulse */
            if (amppwgradmethod(&gradx[GXK_SLOT], target_area, loggrd.tx_xyz,
                                start_amp, end_amp,
                                loggrd.xrt, MIN_PLATEAU_TIME)==FAILURE) {
                epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "amppwgradmethod:gxk");
                return FAILURE;
            }
        }

        if (eosykiller == PSD_ON) {   /* Y killer pulse */
            if (amppwgradmethod(&grady[GYK_SLOT], target_area, loggrd.ty_xyz,
                                start_amp, end_amp,
                                loggrd.yrt, MIN_PLATEAU_TIME)==FAILURE) {
                epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "amppwgradmethod:gyk");
                return FAILURE;
            }
        }
        if (eoszkiller == PSD_ON) {   /* Z killer pulse */
            if (amppwgradmethod(&gradz[GZK_SLOT], target_area, loggrd.tz_xyz,
                                start_amp, end_amp,
                                loggrd.zrt, MIN_PLATEAU_TIME)==FAILURE) {
                epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "amppwgradmethod:gzk");
                return FAILURE;
            }
        }

        gxktime  = _gxktime.fixedflag ?      ((void)(pw_gxk+pw_gxka+pw_gxkd), gxktime) : pw_gxk+pw_gxka+pw_gxkd;
        gyktime  = _gyktime.fixedflag ?      ((void)(pw_gyk+pw_gyka+pw_gykd), gyktime) : pw_gyk+pw_gyka+pw_gykd;
        gzktime  = _gzktime.fixedflag ?      ((void)(pw_gzk+pw_gzka+pw_gzkd), gzktime) : pw_gzk+pw_gzka+pw_gzkd;

    } else {

        gxktime  = _gxktime.fixedflag ?  ((void)(0), gxktime) : 0;
        gyktime  = _gyktime.fixedflag ?  ((void)(0), gyktime) : 0;
        gzktime  = _gzktime.fixedflag ?  ((void)(0), gzktime) : 0;

    }
	  
    gktime   = _gktime.fixedflag ?    ((void)(IMax(3,gxktime,gyktime,gzktime)), gktime) : IMax(3,gxktime,gyktime,gzktime);

    /**** End of killer pulse calcs */
   
    
    /***** Cardiac and advisory panel control *********************************/
    
    if (ChemSatEval(_cs_sattime.fixedflag ? (_temp496_cs_sattime=cs_sattime,&_temp496_cs_sattime) : &cs_sattime) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_ROUTINE_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ChemSat Eval");
        return FAILURE;
    }
    
    if (SpSatEval(_sp_sattime.fixedflag ? (_temp497_sp_sattime=sp_sattime,&_temp497_sp_sattime) : &sp_sattime) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_ROUTINE_FAILURE,
                   EE_ARGS(1), STRING_ARG, "Spatial Sat Eval");
        return FAILURE;
    }

    /* The sat time is not calculated correctly in SpSat.e */
    /* Adding 200 us will compensate for the incorrect sat time */
    /* for the time being... */
    if( sp_sattime > 0) {
        sp_sattime  = _sp_sattime.fixedflag ?       ((void)(sp_sattime+200), sp_sattime) : sp_sattime+200;
    }

    /*
     * Set the gradient calc mode here for selecting the right gradsafety
     * calc technique.
     * NOTE: The gradHeatMethod CV is used in minseq() to decide whether to call
     *       minseqseg() (gradHeatMethod = TRUE -> Linear Segment Method) or
     *       minseqgrad() (gradHeatMethod = FALSE -> Traditional Method).
     */
    gradHeatMethod  = _gradHeatMethod.fixedflag ?  ((void)(PSD_ON), gradHeatMethod) : PSD_ON;
    
    /* YMSmr07133 */
    if( value_system_flag == VALUE_SYSTEM_HDE ){ 
        gradDriverMethod  = _gradDriverMethod.fixedflag ?  ((void)(PSD_ON), gradDriverMethod) : PSD_ON;
    }
    
    if( exist(opnshots) == 1 && (mph_flag && (opfphases > 10) && (opacqo == PSD_OFF)) &&
        _iref_etl.fixedflag == PSD_OFF && iref_etl == 0){
        if(get_cvs_changed_flag() == TRUE)
        {
            iref_etl  = _iref_etl.fixedflag ?  ((void)(DEFAULT_IREF_ETL), iref_etl) : DEFAULT_IREF_ETL;
            if(dbdt_model == DBDTMODELCONV && (cfdbdtts == 0.0 && cfdbdtper > 0.0) && dbdtper_new > cfdbdtper)
                no_gy1_ol_gxw  = _no_gy1_ol_gxw.fixedflag ?  ((void)(1), no_gy1_ol_gxw) : 1;
            saved_tmin_total  = _saved_tmin_total.fixedflag ?  ((void)(0), saved_tmin_total) : 0;

            if (cveval1() == FAILURE) {        
                /* don't send ermes so that underlying ermes will be displayed */
                return FAILURE;
            }

            iref_etl  = _iref_etl.fixedflag ?  ((void)(0), iref_etl) : 0;
            no_gy1_ol_gxw  = _no_gy1_ol_gxw.fixedflag ?  ((void)(0), no_gy1_ol_gxw) : 0;
            saved_tmin_total  = _saved_tmin_total.fixedflag ?  ((void)(tmin_total), saved_tmin_total) : tmin_total;
        }
    }
    else
    {
        saved_tmin_total  = _saved_tmin_total.fixedflag ?  ((void)(0), saved_tmin_total) : 0;
    }
    if (cveval1() == FAILURE) {        
        /* don't send ermes so that underlying ermes will be displayed */
        return FAILURE;
    }

    /* MRIge75651*/
    if( peakAveSars( &ave_sar, &cave_sar, &peak_sar, &b1rms, (int)RF_FREE,
                     rfpulse, L_SCAN, (int)(act_tr/slquant1) )  == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_ROUTINE_FAILURE,
                   EE_ARGS(1), STRING_ARG, "peakAveSars");
        return FAILURE;
    }

    piasar = (float)ave_sar; /* Report to plasma */
    picasar = (float)cave_sar; /* Coil SAR to plasma */
    pipsar = (float)peak_sar; /* Report to plasma */
    pib1rms = (float)b1rms; /* Report predicted b1rms value on the UI */

    /* Set fecho_factor based on value for fract_ky */
    if (fract_ky == PSD_FRACT_KY) {
        /* jwg this has been changed in ESE24*/
	/*fecho_factor =((float)rhdayres/2 + num_overscan)/rhdayres;*/
	fecho_factor  = _fecho_factor.fixedflag ?    ((void)((float)(rhnframes+rhhnover)/fullk_nframes), fecho_factor) : (float)(rhnframes+rhhnover)/fullk_nframes;
    } else {
        fecho_factor  = _fecho_factor.fixedflag ?  ((void)(1.0), fecho_factor) : 1.0;
    }
    
    /* SNR monitor */
    _pifractecho.fixedflag = 0;
    pifractecho  = _pifractecho.fixedflag ?  ((void)(fecho_factor), pifractecho) : fecho_factor;
    setexist(pifractecho,_opte.existflag);
    _pifractecho.fixedflag = _opte.fixedflag;
    
    /* MRIge56926 - Calculation of avminslthick - TAA */
    ampslice(&av_temp_float, bw_rf1, loggrd.tz, gscale_rf1,TYPDEF);
    av_temp_float = ceil(av_temp_float*10.0)/10.0;
    avminslthick = av_temp_float;
    
    ampslice(&av_temp_float, bw_rf2, loggrd.tz, gscale_rf2,TYPDEF);
    av_temp_float = ceil(av_temp_float*10.0)/10.0;
    
    /*jwg bb only concerned w/ this calc if using standard spsp pulses (ie opuser20 = 0) */
    if (opuser20 < 2) 
    {
	avminslthick = FMax(3,avminslthick,av_temp_float, ss_rf1*ss_min_slthk);
    }
    
    /* MRIge56898 - To perform calculation of avminnshots outside of error
       conditions  - TAA */
    if (existcv(opnex) != PSD_OFF) {
        avmaxnshots = exist(opyres);
    }
        
    /*MRIge61054 - BSA*/
    if (nshots_locks == PSD_ON) {

        if ( (cfsrmode==PSD_SR20) || (cfsrmode==PSD_SR25) ) {

            min_nshots  = _min_nshots.fixedflag ?  ((void)(8), min_nshots) : 8;
            pishotnub = 49;

        } else { if ( cfsrmode <= PSD_SR77 ) { 

            if (exist(opxres) <= 256){
                min_nshots  = _min_nshots.fixedflag ?  ((void)(1), min_nshots) : 1;
                pishotnub = 63;
                    
            } else {
                    
                min_nshots  = _min_nshots.fixedflag ?  ((void)(4), min_nshots) : 4;
                pishotnub = 57;
                    
            } 

        } else if ( (cfsrmode==PSD_SR100) || (cfsrmode==PSD_SR120) || (cfsrmode==PSD_SR150) || (cfsrmode==PSD_SR200) )  {

            if (exist(opxres)==512) {
                min_nshots  = _min_nshots.fixedflag ?  ((void)(2), min_nshots) : 2;
                pishotnub = 61;
            } else {
                min_nshots  = _min_nshots.fixedflag ?  ((void)(1), min_nshots) : 1;
            }

        } else {
            min_nshots  = _min_nshots.fixedflag ?  ((void)(1), min_nshots) : 1;
        }   
        }

    } /* nshots_locks */
    
    avminnshots = min_nshots;
    
    if (existcv(opnshots)== PSD_OFF && exist(opnshots) < avminnshots) 
        cvdef(opnshots, avminnshots); 

#if defined(RT) && defined(LIM_PROTOCOLS)
    if (lim_protocol() == FAILURE) {
        /* don't send ermes so that underlying ermes will be displayed */
        return FAILURE;
    }
#else
    if( (mph_flag == PSD_ON) && ((opfphases * opslquant) > 2048) )
    {
        if(mph_protocol() == FAILURE) {
            /* don't send ermes so that underlying ermes will be displayed */
            return FAILURE;
        }
    } 
#endif

    if( (PSD_OFF == pircbnub) && (PSD_OFF == exist(opautorbw)) )
    {
        opautorbw  = _opautorbw.fixedflag ?  ((void)(PSD_ON), opautorbw) : PSD_ON;
    }

    /* MRIhc48581 -- 3dgradwarp UI */
    /* disable 3D gradwarp for sequential MPh mode */ 
    if( (PSD_OFF == opdynaplan) && (PSD_ON == mph_flag) && (opacqo == 1) )
    {
        pi3dgradwarpnub  = _pi3dgradwarpnub.fixedflag ?  ((void)(0), pi3dgradwarpnub) : 0;
    }
    else
    {
        pi3dgradwarpnub  = _pi3dgradwarpnub.fixedflag ?  ((void)(_pi3dgradwarpnub.defval), pi3dgradwarpnub) : _pi3dgradwarpnub.defval;;
    }

    /* ZZ, activate ASPIR through SPECIAL fat sat option */
    if( PSD_ON == exist(optouch) ) {
        pichemsatopt = 2;
    }
    else {
        pichemsatopt = 0;
    }

    if( PSD_ON == exist(opspecir)) {
        /* Activate advisory panel checks for TI */
        piadvmin = (piadvmin | (1<<PSD_ADVTI));
        piadvmax = (piadvmax | (1<<PSD_ADVTI));

        /* Set TI annotation */
        pititype = PSD_LABEL_TE_PREP;
        /* Only show Auto TI */
        pitinub = 2;
	piautoti = PSD_ON;

        if(cffield == B0_15000)
        {
            avmaxti = ASPIR_DWI_MAX_15T_TI;
            cvmax(opti,ASPIR_DWI_MAX_15T_TI);
            avminti = IMax(2, ASPIR_DWI_MIN_15T_TI, aspir_minti);
            cvmin(opti,avminti);
            cvdef(opti, ASPIR_DWI_15T_TI);
            pitidefval = ASPIR_DWI_15T_TI;
	    pitival2 = ASPIR_DWI_15T_TI;
            if(existcv(opautoti) && exist(opautoti))
            {
                cvoverride(opti, ASPIR_DWI_15T_TI, PSD_FIX_OFF, PSD_EXIST_ON);
            }
        }
        else if (cffield == B0_30000)
        {
            avmaxti = ASPIR_DWI_MAX_3T_TI;
            cvmax(opti,ASPIR_DWI_MAX_3T_TI);
            avminti = IMax(2, ASPIR_DWI_MIN_3T_TI, aspir_minti);
            cvmin(opti,avminti);
            cvdef(opti, ASPIR_DWI_3T_TI);
            pitidefval = ASPIR_DWI_3T_TI;
	    pitival2 = ASPIR_DWI_3T_TI;
            if(existcv(opautoti) && exist(opautoti))
            {
                cvoverride(opti, ASPIR_DWI_3T_TI, PSD_FIX_OFF, PSD_EXIST_ON);
            }
        }
    }
    else {
        /* turn off TI field */
        pitinub=0;
	piautoti = PSD_OFF;
        cvoverride(opautoti, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_OFF);
    }
fprintf(stderr,"At bottom of cveval, pw_gyb and a_gyb are %d and %f \n\n\n\n",pw_gyb,a_gyb);    
    return SUCCESS;

} /* End of cveval */


/* optimize gradient and esp based on rectangular dbdt model */
STATUS optGradAndEsp_rect(void)
{
    int readout_phyaxis;

    if(isGradAndEspReoptNeeded() == PSD_OFF) return SUCCESS;

    pw_gxgap  = _pw_gxgap.fixedflag ?  ((void)(0), pw_gxgap) : 0;
    dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(cfdbdtper), dbdtper_new) : cfdbdtper;
    if(epigradopt_rect(dbdtper_new, 0) == FAILURE) return FAILURE;
    if(epigradopt_debug) printEpigradoptLog();

    if(!esprange_check) return SUCCESS;
   
    readout_phyaxis = getReadoutPhyAxis();    
    if(isEspOutOfUnwantedRange(esp, readout_phyaxis) == PSD_OFF)
    {
        if(searchEspLonger_rect(esp, readout_phyaxis) == FAILURE) return FAILURE;
        if(epigradopt_debug) printEpigradoptLog();
    } 
    return SUCCESS;
}


/* optimize gradient and esp based on convolution dbdt model */
STATUS optGradAndEsp_conv(void)
{
    int dbdtper_inc;

    int esp_value[DBDT_MAXNUMSTEPS];
    int dbdtper_value[DBDT_MAXNUMSTEPS];
    int prev_esp;
    int esp_notchanged;

    int hit_esp_index;
    int i;
    int readout_phyaxis;

    int esp_first;



    if(isGradAndEspReoptNeeded() == PSD_OFF) return SUCCESS;
    
    pw_gxgap  = _pw_gxgap.fixedflag ?  ((void)(0), pw_gxgap) : 0;
    readout_phyaxis = getReadoutPhyAxis();
    if((!espopt) && (!esprange_check))
    {
        dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(cfdbdtper), dbdtper_new) : cfdbdtper;
        if(epigradopt_rect(dbdtper_new, 0) == FAILURE) return FAILURE;
        pidbdtper = calcdbdtper_conv();
        if(epigradopt_debug) printEpigradoptLog();
        return SUCCESS;
    }

    /* Search for shortest esp with pidbdtper smaller than cfdbdtper */
    dbdtper_count = 0;
    dbdtper_inc = DBDT_STEPSIZE;
    dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(cfdbdtper), dbdtper_new) : cfdbdtper;
    esp_notchanged = 0;
    prev_esp = -1;
    esp_first = -1;
    do
    {
        if(epigradopt_rect(dbdtper_new, 0) == FAILURE) return FAILURE;
        if(esp_first == -1) esp_first = esp;
        pidbdtper = calcdbdtper_conv();
        if(epigradopt_debug) printEpigradoptLog();

        if(pidbdtper > cfdbdtper) break; /* break when pidbdtper reaches cfdbdtper */
        esp_value[dbdtper_count] = esp;
        dbdtper_value[dbdtper_count] = dbdtper_new;
        dbdtper_count++;
        if(dbdtper_count >= DBDT_MAXNUMSTEPS) break; /* break if too many steps */

        if(esp == prev_esp) 
        {
            esp_notchanged++;
            if(esp_notchanged >= 3) break; /* break if esp not changed in 3 continous steps */
        }
        else
        {
            prev_esp = esp;
            esp_notchanged = 0;
        }
        
        if(!espopt) 
        {
            if(isEspOutOfUnwantedRange(esp, readout_phyaxis) == PSD_ON) 
            {
                return SUCCESS;
            }
        }

        dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(dbdtper_inc), dbdtper_new) : dbdtper_new+dbdtper_inc;

    } while(1);
    
    if(!espopt) /* increase esp until out of unwanted range */
    {
        if(searchEspLonger_rect(esp_first, readout_phyaxis) == FAILURE) return FAILURE;
        pidbdtper = calcdbdtper_conv(); 
        if(epigradopt_debug) printEpigradoptLog();
        return SUCCESS;
    }

    if(!esprange_check) /* no need to check esp range */
    {
        if(pidbdtper > cfdbdtper) /* one step back */
        {
            dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(dbdtper_inc), dbdtper_new) : dbdtper_new-dbdtper_inc;
            if(epigradopt_rect(dbdtper_new, 0) == FAILURE) return FAILURE;
            pidbdtper = calcdbdtper_conv();
            if(epigradopt_debug) printEpigradoptLog();
        }
        return SUCCESS;
    }

    /* search for shortest esp out of unwanted range */
    hit_esp_index = -1;
    for(i=dbdtper_count-1; i>=0; i--)
    {
        if(isEspOutOfUnwantedRange(esp_value[i], readout_phyaxis) == PSD_ON)
        {
            hit_esp_index = i;
            break;
        }
    }
    if(hit_esp_index < 0) /* search esp in terms of out of unwanted range */
    {
        if(searchEspLonger_rect(esp_first, readout_phyaxis) == FAILURE) return FAILURE;
        pidbdtper = calcdbdtper_conv();
        if(epigradopt_debug) printEpigradoptLog();
    }
    else
    {
        dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(dbdtper_value[hit_esp_index]), dbdtper_new) : dbdtper_value[hit_esp_index];
        if(epigradopt_rect(dbdtper_new, 0) == FAILURE) return FAILURE;
        pidbdtper = calcdbdtper_conv();
        if(epigradopt_debug) printEpigradoptLog();
    }
    
    return SUCCESS;
}

/* get esp out of unwanted range */
/* if get esp longer than esp_start, longer_shorter = 1;
   else longer_shorter = -1 */
int getEspOutOfUnwantedRange(int esp_start, int longer_shorter, int readout_phyaxis) 
{
    if(longer_shorter < 0) longer_shorter = -1;
    else longer_shorter = 1;

    while(isEspOutOfUnwantedRange(esp_start, readout_phyaxis) == PSD_OFF)
    {
        esp_start += GRAD_UPDATE_TIME*longer_shorter;   
    }

    return esp_start;
}

/* search esp out of unwanted range by increasing esp */
STATUS searchEspLonger_rect(int esp_start, int readout_phyaxis)
{

    if(espincway == 0)
    {
        int dbdtper_inc;
        dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(cfdbdtper), dbdtper_new) : cfdbdtper;
        dbdtper_inc = DBDT_STEPSIZE;
        do /* search for optimal esp in terms of shortest out of the unwanted range */
        {
            dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(dbdtper_inc), dbdtper_new) : dbdtper_new-dbdtper_inc;
            if(dbdtper_new <= 0)
            {
                epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "optGradAndEsp");
                return FAILURE;
            }
            epigradopt_rect(dbdtper_new, 0);
            if(epigradopt_debug) printEpigradoptLog();
        } while(isEspOutOfUnwantedRange(esp, readout_phyaxis) == PSD_OFF);
    }
    else
    {
        int esp_new;
        dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(cfdbdtper), dbdtper_new) : cfdbdtper;

        epigradopt_rect(dbdtper_new, 0);
        if(epigradopt_debug) printEpigradoptLog();
        esp_new =  getEspOutOfUnwantedRange(esp, 1, readout_phyaxis); 
        pw_gxgap  = _pw_gxgap.fixedflag ?      ((void)(pw_gxgap+(esp_new-esp)), pw_gxgap) : pw_gxgap+(esp_new-esp);
        if ((pw_gxgap - (pw_gxgap/pwmin_gap)*pwmin_gap) != 0.0)
            pw_gxgap  = _pw_gxgap.fixedflag ?     ((void)((int)ceil((double)pw_gxgap/(double)pwmin_gap)*pwmin_gap), pw_gxgap) : (int)ceil((double)pw_gxgap/(double)pwmin_gap)*pwmin_gap;
        if( FAILURE == setEpiEsp() ) 
        {
            epic_error(use_ermes, "setEpiEsp_failed", EM_PSD_SUPPORT_FAILURE,1,
                   STRING_ARG, "setEpiEsp()");
            return FAILURE;
        } 
    }

    return SUCCESS;
}


/* Get physical axis of readout gradient */
int getReadoutPhyAxis(void)
{
    int readout_phyaxis, i; 
    readout_phyaxis = 0;
    for(i=0; i<exist(opslquant); i++)
    {
        if(rsprot[i][0] != 0) readout_phyaxis |= XAXIS;
        if(rsprot[i][3] != 0) readout_phyaxis |= YAXIS;
        if(rsprot[i][6] != 0) readout_phyaxis |= ZAXIS;
    }
    return readout_phyaxis;
}

/* check if esp is out of unwanted range or not */                        
int isEspOutOfUnwantedRange(int esp_v, int readout_phyaxis)
{
    int i;

    if(readout_phyaxis & XAXIS)
    {
        for(i=0; i<numesprange_x; i++)
        {
            if(esp_v >= esprange_x[i][0] && esp_v <= esprange_x[i][1]) return PSD_OFF;
        }
    }
    if(readout_phyaxis & YAXIS)
    {
        for(i=0; i<numesprange_y; i++)
        {
            if(esp_v >= esprange_y[i][0] && esp_v <= esprange_y[i][1]) return PSD_OFF;
        }
    }
    if(readout_phyaxis & ZAXIS)
    {
        for(i=0; i<numesprange_z; i++)
        {
            if(esp_v >= esprange_z[i][0] && esp_v <= esprange_z[i][1]) return PSD_OFF;
        }
    }

    return PSD_ON;
}

/* generate epi readout gradient waveform and set esp */
STATUS epigradopt_rect(float cfdbdtper_new, int reqesp_new)
{
    epigradopt( &gradin, &gradout, &pidbdtts, &pidbdtper, cfdbdtts, cfdbdtper_new,
           cfdbdtdx, cfdbdtdy, reqesp_new, autogap, (int)vrgfsamp,
           (int)vrgfsamp, (int)debug );
    
    rhfrsize  = _rhfrsize.fixedflag ?  ((void)(temprhfrsize), rhfrsize) : temprhfrsize;
    /* SXZ::MRIge72411: calc actual ratio */
    if(vrgfsamp == PSD_ON && rampopt == 1){
        int tempvar;
        /* ramp area */
        tempvar = ((float)a_gxw*pw_gxwad-a_gxw*(pw_gyba+pw_gyb/2)*(pw_gyba+pw_gyb/2)/pw_gxwad);
        /* top area */
        tempvar = totarea - tempvar;
        actratio  = _actratio.fixedflag ?  ((void)(tempvar/totarea), actratio) : tempvar/totarea;
    } else {
        actratio  = _actratio.fixedflag ?  ((void)(1), actratio) : 1;
    }
    
    /* MGD: call calcfilter() */
    /* MRIge66608: need rhfrsize input pts and no exist(oprbw) for VRGF */
    if( FAILURE == (calcfilter(&echo1_filt, oprbw, rhfrsize, OVERWRITE_OPRBW)) ) {
        epic_error(use_ermes, "calfilter_failed", EM_PSD_SUPPORT_FAILURE,1, 
                   STRING_ARG, "calcfilter");
        return FAILURE;
    } 
    
    getminesp(echo1_filt, xtr_offset, intleaves, hrdwr_period, vrgfsamp, _minesp.fixedflag ? (_temp498_minesp=minesp,&_temp498_minesp) : &minesp);
    
    /* There is a bug in epigradopt for non-vrg.  Bump up pw_gxwad */
    pw_gxwad  = _pw_gxwad.fixedflag ?  ((void)(RUP_GRD(pw_gxwad)), pw_gxwad) : RUP_GRD(pw_gxwad);
    
    /* Also, epigradopt does not make pw_gxgap a mult. of 2*GRAD_UPDATE_TIME,
       so do it here (MRIge23911) */
    if ((pw_gxgap - (pw_gxgap/pwmin_gap)*pwmin_gap) != 0.0)
        pw_gxgap  = _pw_gxgap.fixedflag ?     ((void)((int)ceil((double)pw_gxgap/(double)pwmin_gap)*pwmin_gap), pw_gxgap) : (int)ceil((double)pw_gxgap/(double)pwmin_gap)*pwmin_gap;
    
    /* need to set the decay of the blip to = the attack found in epgradopt() */
    pw_gybd  = _pw_gybd.fixedflag ?  ((void)(pw_gyba), pw_gybd) : pw_gyba;
    
    /* Call to calculate the echo-sapcing (esp) */
    if( FAILURE == setEpiEsp() ) {
        epic_error(use_ermes, "setEpiEsp_failed", EM_PSD_SUPPORT_FAILURE,1, 
                   STRING_ARG, "setEpiEsp()");
        return FAILURE;
    } 
    return SUCCESS;
}
    
/* check if EPI readout gradient waveforms need to be regenerated  */
int isGradAndEspReoptNeeded(void)    
{
    if((reopt_flag == PSD_ON) ||
       memcmp(&gradin, &gradin_old, sizeof(OPT_GRAD_INPUT)) || memcmp(rsprot[0], rsprot_old, 9*sizeof(long)) ||
       (cfdbdtper != cfdbdtper_old) || (dbdt_model != dbdt_model_old) ||
       (esprange_check != esprange_check_old) || (mph_flag != opmph_old) ||
       (rampopt != rampopt_old) || (espopt != espopt_old) || (espincway != espincway_old))
    {
        reopt_flag = PSD_OFF;
        memcpy(&gradin_old, &gradin, sizeof(OPT_GRAD_INPUT));
        memcpy(rsprot_old, rsprot[0], 9*sizeof(long));
        cfdbdtper_old = cfdbdtper;
        dbdt_model_old = dbdt_model;
        esprange_check_old = esprange_check;
        opmph_old = mph_flag;
        rampopt_old = rampopt;
        espopt_old = espopt;
        espincway_old = espincway;
        epigradopt_debug_old = epigradopt_debug;
        return PSD_ON;
    }
    if(epigradopt_debug && epigradopt_debug != epigradopt_debug_old)
    {
        epigradopt_debug_old = epigradopt_debug;
        return PSD_ON;
    }
    epigradopt_debug_old = epigradopt_debug;

    return PSD_OFF;
}

/* calculate dbdtper of EPI readout gradient waveforms using convolution dbdt model */
float calcdbdtper_conv(void)
{
/*
    The epi readout gradient waveforms could be considered three parts:
       1. The first ramp. There is no epi blip here. 3 corner points for this part. 
       2. Parity switching period. There is epi bilp within this period. This period is repeated, and 10 
          corner points needed for each repetation.
       3. The last ramp: There is no epi blip here. 3 corner points for this part.
*/

    int i, j;
    float max_dbdtper;

    int tcon1[3], tcon2[10], tcon3[3];
    float aconx1[3], aconx2[10], aconx3[3];
    float acony1[3], acony2[10], acony3[3];

    /* generate corner points */
    tcon1[0]=0; tcon1[1]=pw_gxwad; tcon1[2]=pw_gxwl;
    aconx1[0]=0; aconx1[1]=a_gxw; aconx1[2]=a_gxw;
    acony1[0]=0; acony1[1]=0; acony1[2]=0;

    tcon3[0]=pw_gxw; tcon3[1]=pw_gxwr; tcon3[2]=pw_gxwad;
    aconx3[0]=a_gxw; aconx3[1]=a_gxw; aconx3[2]=0;
    acony3[0]=0; acony3[1]=0; acony3[2]=0;
     
    tcon2[0]=pw_gxw; aconx2[0]=a_gxw;  acony2[0]=0;
    if(pw_gyba+pw_gyb/2 > pw_gxwad+pw_gxgap/2) 
    {
        tcon2[1]=pw_gxwr+(pw_gxwad+pw_gxgap/2)-(pw_gyba+pw_gyb/2); aconx2[1]=a_gxw;  acony2[1]=0; 
        if(pw_gyb/2 > pw_gxwad+pw_gxgap/2)
        {
            tcon2[2]=pw_gyba; aconx2[2]=a_gxw;  acony2[2]=a_gyb; 
            tcon2[3]=(pw_gyb/2)-(pw_gxwad+pw_gxgap/2); aconx2[3]=a_gxw; acony2[3]=a_gyb;
            tcon2[4]=pw_gxwad; aconx2[4]=0; acony2[4]=a_gyb;
        }
        else
        {
            tcon2[2]=(pw_gyba+pw_gyb/2)-(pw_gxwad+pw_gxgap/2); aconx2[2]=a_gxw;  acony2[2]=0; 
            if(pw_gyb/2 > pw_gxgap/2)
            {
                tcon2[3]=(pw_gxwad+pw_gxgap/2)-(pw_gyb/2); 
                aconx2[3]=intercept(a_gxw, 0, pw_gxwad,tcon2[3]); 
                acony2[3]=a_gyb;
                tcon2[4]=pw_gxwr+pw_gxwad; aconx2[4]=0; acony2[4]=a_gyb;
            }
            else
            {
                tcon2[3]=pw_gxwad; 
                aconx2[3]=0; 
                acony2[3]=intercept(0, a_gyb, pw_gyba,tcon2[2]+tcon2[3]);
                tcon2[4]=(pw_gxgap/2)-(pw_gyb/2); aconx2[4]=0; acony2[4]=a_gyb;
            }
              
        }
    }
    else
    {
        tcon2[1]=pw_gxwr; aconx2[1]=a_gxw;  acony2[1]=0; 
        if(pw_gyba+pw_gyb/2 > pw_gxgap/2)
        {
            tcon2[2]=(pw_gxwad+pw_gxgap/2)-(pw_gyba+pw_gyb/2); 
            aconx2[2]=intercept(a_gxw, 0, pw_gxwad, tcon2[2]);  
            acony2[2]=0; 
            if(pw_gyb/2 > pw_gxgap/2)
            {
                tcon2[3]=pw_gyba; 
                aconx2[3]=intercept(a_gxw, 0, pw_gxwad,pw_gxwad+pw_gxgap/2-pw_gyb/2); 
                acony2[3]=a_gyb;
                tcon2[4]=pw_gyb/2-pw_gxgap/2; aconx2[4]=0; acony2[4]=a_gyb;
            }
            else
            {
                tcon2[3]=(pw_gyba+pw_gyb/2)-(pw_gxgap/2); 
                aconx2[3]=0; 
                acony2[3]=intercept(0, a_gyb, pw_gyba, tcon2[3]);
                tcon2[4]=pw_gxgap/2-pw_gyb/2; aconx2[4]=0; acony2[4]=a_gyb;
            }
        }
        else
        {
            tcon2[2]=pw_gxwad; aconx2[2]=0;  acony2[2]=0; 
            tcon2[3]=(pw_gxgap/2)-(pw_gyba+pw_gyb/2); aconx2[3]=0; acony2[3]=0;
            tcon2[4]=pw_gyba; aconx2[4]=0; acony2[4]=a_gyb;
        }
           
    }

    tcon2[5]=2*((pw_gxwr+pw_gxwad+pw_gxgap/2)-tcon2[1]-tcon2[2]-tcon2[3]-tcon2[4]);
    for(i=6;i<10;i++)
    {
        tcon2[i]=tcon2[10-i];
    }
    for(i=5;i<10;i++)
    {
        aconx2[i]=-aconx2[9-i];
        acony2[i]=acony2[9-i];
    }


    /* calculate dbdtper with convolution dbdt model*/
    {
        int etl_1, num_cornerpoints;
        int * tcon;
        float * aconx, * acony;
        float * dbdtper_x_data, * dbdtper_y_data, * dbdtper_data;

        float us2s = 1.0e-6;
        float gcm2Tm = 1.0e-2;
        float cm2m = 1.0e-2;

        int sign = 1;
        float dbdtdxyz;

        etl_1 = DBDT_ETL;
        num_cornerpoints = 3+10*(etl_1-1)+3;

	tcon = (int *)malloc(num_cornerpoints*sizeof(int));
        aconx = (float *)malloc(num_cornerpoints*sizeof(float));
        acony = (float *)malloc(num_cornerpoints*sizeof(float));
        dbdtper_x_data = (float *)malloc(num_cornerpoints*sizeof(float));
        dbdtper_y_data = (float *)malloc(num_cornerpoints*sizeof(float));
        dbdtper_data = (float *)malloc(num_cornerpoints*sizeof(float));

        tcon[0]=0;
        aconx[0]=0;
        acony[0]=0;
        for(i=1; i<num_cornerpoints; i++)
        {
            if(i<3)
            {
                tcon[i] = tcon[i-1]+tcon1[i];
                aconx[i] = aconx1[i];
                acony[i] = acony1[i];
            }
            else if(i>=num_cornerpoints-3) 
            {
                tcon[i] = tcon[i-1]+tcon3[i-(num_cornerpoints-3)];
                aconx[i] = aconx3[i-(num_cornerpoints-3)]*sign;
                acony[i] = acony3[i-(num_cornerpoints-3)];
            }
            else 
            {
                tcon[i] = tcon[i-1]+tcon2[(i-3)%10];
                aconx[i] = aconx2[(i-3)%10]*sign;
                acony[i] = acony2[(i-3)%10];
                if(((i-3)%10)==9) sign *= -1;
            }
        }

        if(epigradopt_debug) printCornerPoint(num_cornerpoints, tcon, aconx, acony);

        dbdtdxyz = FMax(3, cfdbdtdx, cfdbdtdy, cfdbdtdz);
        for(i=0;i<num_cornerpoints; i++)
        {
            aconx[i] *= dbdtdxyz*cm2m*gcm2Tm;
            acony[i] *= dbdtdxyz*cm2m*gcm2Tm;
        }
        
        max_dbdtper=0.0;
        dbdtper_x_data[0] = dbdtper_y_data[0] = dbdtper_data[0] = 0.0;
        for(i=1; i<num_cornerpoints; i++)
        {
            float the_dbdtper_x=0.0;
            float the_dbdtper_y=0.0;
            float the_dbdtper;
        
            for(j=0;j<i;j++)
            {
                float dbdt_x, dbdt_y;
                if(tcon[j+1]==tcon[j]) continue;

                dbdt_x=(aconx[j+1]-aconx[j])/(tcon[j+1]-tcon[j])/us2s;
                dbdt_y=(acony[j+1]-acony[j])/(tcon[j+1]-tcon[j])/us2s;
                the_dbdtper_x=the_dbdtper_x+dbdt_x*cfrfact/cfrinf*
                              (1.0/(cfrfact+tcon[i]-tcon[j+1]) - 1.0/(cfrfact+tcon[i]-tcon[j]));
                the_dbdtper_y=the_dbdtper_y+dbdt_y*cfrfact/cfrinf*
                              (1.0/(cfrfact+tcon[i]-tcon[j+1]) - 1.0/(cfrfact+tcon[i]-tcon[j]));
            }
            the_dbdtper = sqrt(the_dbdtper_x*the_dbdtper_x+the_dbdtper_y*the_dbdtper_y);
            if(the_dbdtper>max_dbdtper) max_dbdtper=the_dbdtper;

            dbdtper_x_data[i] = the_dbdtper_x;
            dbdtper_y_data[i] = the_dbdtper_y;
            dbdtper_data[i] = the_dbdtper;
        }

        if(epigradopt_debug) printDbdtper(max_dbdtper*100.0, num_cornerpoints, tcon, dbdtper_x_data, dbdtper_y_data, dbdtper_data);

        free(tcon);
        free(aconx);
        free(acony);
        free(dbdtper_x_data);
        free(dbdtper_y_data);
        free(dbdtper_data);
    }

    /* return the minimum dbdtper value of rect and conv models */
    return (pidbdtper > 0.0 ? FMin(2, pidbdtper, max_dbdtper*100.0) : max_dbdtper*100.0);
}

float intercept(float y1, float y2, int xl, int x)
{
    return (y2-y1)/xl*x+y1;
}

/* read unwanted ESP range from a host file epiesp.dat
   File format:
   1  <--- number of ranges of X axisi, could be 0-5
   420 460   <--- first range of X axis
   1  <--- number of ranges of Y axis, could be 0-5
   420 460   <--- first range of Y axis
   1  <--- number of ranges of Z axis, could be 0-5
   360 400   <--- first range of Z axis

   comments could be inserted with # as the first character of the line
*/
void readEspRange(void)
{
    FILE * fp;
    char tempstring[MAXCHAR];
    int i;

    if(epigradopt_debug && no_esprangefile == 1) printEspRange();
    if(no_esprangefile == 1) return;
#ifndef SIM
    if(PSD_XRMW_COIL == cfgcoiltype)
    {
        if((fp=fopen("/usr/g/bin/epiespW.dat", "rt")) == NULL) {procNoEspRangeFile(fp); return;}
    }
    else
    {
        if((fp=fopen("/usr/g/bin/epiesp.dat", "rt")) == NULL) {procNoEspRangeFile(fp); return;}
    }
#else
    if(PSD_XRMW_COIL == cfgcoiltype)
    {
        if((fp=fopen("epiespW.dat", "rt")) == NULL) {procNoEspRangeFile(fp); return;}
    }
    else
    {
        if((fp=fopen("epiesp.dat", "rt")) == NULL) {procNoEspRangeFile(fp); return;}
    }
#endif
    /* reading esp range on X axis */
    do
    {
        if(fgets( tempstring, MAXCHAR, fp ) == NULL) {procNoEspRangeFile(fp); return;}
    } while(isCommentOrBlankLine(tempstring));
    if(sscanf(tempstring, "%d", &numesprange_x) != 1) {procNoEspRangeFile(fp); return;}
    if(numesprange_x < 0 || numesprange_x > MAXNUMESPRANGE) {procNoEspRangeFile(fp); return;}
    for(i=0; i<numesprange_x; i++)
    {
        do
        {
            if(fgets( tempstring, MAXCHAR, fp ) == NULL) {procNoEspRangeFile(fp); return;}
        } while(isCommentOrBlankLine(tempstring));
        if(sscanf(tempstring, "%d %d", &esprange_x[i][0], &esprange_x[i][1]) != 2) {procNoEspRangeFile(fp); return;}
        if(esprange_x[i][0] <= 0 || esprange_x[i][1] <= 0) {procNoEspRangeFile(fp); return;}
        if(esprange_x[i][1] < esprange_x[i][0]) {procNoEspRangeFile(fp); return;}
    }

    /* reading esp range on Y axis */
    do
    {
        if(fgets( tempstring, MAXCHAR, fp ) == NULL) {procNoEspRangeFile(fp); return;}
    } while(isCommentOrBlankLine(tempstring));
    if(sscanf(tempstring, "%d", &numesprange_y) != 1) {procNoEspRangeFile(fp); return;}
    if(numesprange_y < 0 || numesprange_y > MAXNUMESPRANGE) {procNoEspRangeFile(fp); return;}
    for(i=0; i<numesprange_y; i++)
    {
        do
        {
            if(fgets( tempstring, MAXCHAR, fp ) == NULL) {procNoEspRangeFile(fp); return;}
        } while(isCommentOrBlankLine(tempstring));
        if(sscanf(tempstring, "%d %d", &esprange_y[i][0], &esprange_y[i][1]) != 2) {procNoEspRangeFile(fp); return;}
        if(esprange_y[i][0] <= 0 || esprange_y[i][1] <= 0) {procNoEspRangeFile(fp); return;}
        if(esprange_y[i][1] < esprange_y[i][0]) {procNoEspRangeFile(fp); return;}
    }

    /* reading esp range on Z axis */
    do
    {
        if(fgets( tempstring, MAXCHAR, fp ) == NULL) {procNoEspRangeFile(fp); return;}
    } while(isCommentOrBlankLine(tempstring));
    if(sscanf(tempstring, "%d", &numesprange_z) != 1) {procNoEspRangeFile(fp); return;}
    if(numesprange_z < 0 || numesprange_z > MAXNUMESPRANGE) {procNoEspRangeFile(fp); return;}
    for(i=0; i<numesprange_z; i++)
    {
        do
        {
            if(fgets( tempstring, MAXCHAR, fp ) == NULL) {procNoEspRangeFile(fp); return;}
        } while(isCommentOrBlankLine(tempstring));
        if(sscanf(tempstring, "%d %d", &esprange_z[i][0], &esprange_z[i][1]) != 2) {procNoEspRangeFile(fp); return;}
        if(esprange_z[i][0] <= 0 || esprange_z[i][1] <= 0) {procNoEspRangeFile(fp); return;}
        if(esprange_z[i][1] < esprange_z[i][0]) {procNoEspRangeFile(fp); return;}
    }
    no_esprangefile = 1;
    fclose(fp);
}

int isCommentOrBlankLine(char * str)
{
    int i;
    
    i = -1;
    while(isspace(str[++i]));
    if((i == strlen(str)) || (str[i] == '#')) return 1;
    return 0;
} 

void procNoEspRangeFile(FILE * fp)
{
    if(fp != NULL) fclose(fp);
#ifndef SIM
    epic_warning( "epiesp.dat was corrupted or not found. Using default values.");
#endif
    numesprange_x = 0;
    numesprange_y = 0;
    numesprange_z = 0;
    no_esprangefile = 1;
}

void printEpigradoptLog(void)
{
    FILE * fp;

    total_gradopt_count++;
    each_gradopt_count++;

    if((fp=fopen("epigradopt.log","a"))==NULL) return;
    fprintf(fp, "dbdtper and esp:\n");
    fprintf(fp, "%d %d %d %f %f %f %d\n",dbdt_model, total_gradopt_count, each_gradopt_count,
        cfdbdtper, dbdtper_new, pidbdtper, esp);
    fclose(fp);
}

void printEspRange(void)
{
    FILE * fp;
    int i;

    if((fp=fopen("epigradopt.log","a"))==NULL) return;
    fprintf(fp, "X esp range:\n");
    for(i=0; i<numesprange_x; i++)
    {
        fprintf(fp, "%d %d %d\n", i+1, esprange_x[i][0], esprange_x[i][1]);
    }
    fprintf(fp, "Y esp range:\n");
    for(i=0; i<numesprange_y; i++)
    {
        fprintf(fp, "%d %d %d\n", i+1, esprange_y[i][0], esprange_y[i][1]);
    }
    fprintf(fp, "Z esp range:\n");
    for(i=0; i<numesprange_z; i++)
    {
        fprintf(fp, "%d %d %d\n", i+1, esprange_z[i][0], esprange_z[i][1]);
    }
    fclose(fp);
}

void printCornerPoint(int nump, int * tcon, float * aconx, float * acony)
{
    FILE * fp;
    int i;

    if((fp=fopen("epigradopt.log","a"))==NULL) return;
    fprintf(fp, "readout and phase waveform:\n");
    fprintf(fp, "%d %d %d\n",dbdt_model, total_gradopt_count+1, each_gradopt_count+1);
    fprintf(fp, "dbdtinf %f dbdtfactor %d efflength %f\n", cfrinf, cfrfact, FMax(3, cfdbdtdx, cfdbdtdy, cfdbdtdz));
    fprintf(fp, "all %d\n", nump);
    for(i=0; i<nump; i++)
    {
        fprintf(fp, "%d %f %f 0.0\n", tcon[i], aconx[i], acony[i]);
    }
    fclose(fp);
}

void printDbdtper(float the_dbdtper, int nump, int * tcon, float * dbdtper_x, float * dbdtper_y, float * dbdtper_t)
{
    FILE * fp;
    int i;

    if((fp=fopen("epigradopt.log","a"))==NULL) return;
    fprintf(fp, "convolution model dbdtper waveform:\n");
    fprintf(fp, "%d %d %d %f\n",dbdt_model, total_gradopt_count+1, each_gradopt_count+1, the_dbdtper);
    for(i=0; i<nump; i++)
    {
        fprintf(fp, "%d %f %f %f\n", tcon[i], dbdtper_x[i], dbdtper_y[i], dbdtper_t[i]);
    }
    fclose(fp);
}

void printEpigradoptResult(void)
{
    FILE * fp;
    float ta;

    if((fp=fopen("epigradopt_result.log","a"))==NULL) return;
    if(vrgfsamp == PSD_OFF) ta = 1.0;
    else ta = ((float)pw_gxw)/(pw_gxw+(float)pw_gxwad-(pw_gyba+pw_gyb/2.0)*(pw_gyba+pw_gyb/2.0)/pw_gxwad);
    fprintf(fp, "%d %d %d %d %f %d %d %f %f %f %d %f %d %d %d %d\n", dbdt_model, rampopt, 
        esprange_check, espopt, opfov, opxres, opyres, cfdbdtper, dbdtper_new, 
        pidbdtper, esp, ta, min_seqgrad, tmin, tmin_total, avmaxslquant);
    fclose(fp);
}

STATUS 
#ifdef __STDC__
setEpiEsp( void )
#else
    setEpiEsp()
#endif
{
    /* Minimum time between the endof one frame and beginning */
    /* of next is 50us in MGD DRF. */

    /* modify pw_gxwl,r1 to satisfy esp constraints */
    pw_gxwl1  = _pw_gxwl1.fixedflag ?  ((void)(0), pw_gxwl1) : 0;
    pw_gxwr1  = _pw_gxwr1.fixedflag ?  ((void)(0), pw_gxwr1) : 0;
    pw_gxwl2  = _pw_gxwl2.fixedflag ?  ((void)(0), pw_gxwl2) : 0;
    pw_gxwr2  = _pw_gxwr2.fixedflag ?  ((void)(0), pw_gxwr2) : 0;
    pw_gxwl  = _pw_gxwl.fixedflag ?  ((void)(pw_gxwl1), pw_gxwl) : pw_gxwl1;
    pw_gxwr  = _pw_gxwr.fixedflag ?  ((void)(pw_gxwr1), pw_gxwr) : pw_gxwr1;
    
    esp   = _esp.fixedflag ?          ((void)(pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap), esp) : pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap;
    
    if (esp < minesp) {  /* is esp long enough? - if not, adjust pw_gxwl1,r2 */
        pw_gxwl1  = _pw_gxwl1.fixedflag ?    ((void)((minesp-esp)/2), pw_gxwl1) : (minesp-esp)/2;
        pw_gxwr1  = _pw_gxwr1.fixedflag ?  ((void)(pw_gxwl1), pw_gxwr1) : pw_gxwl1;
        pw_gxwl  = _pw_gxwl.fixedflag ?  ((void)(pw_gxwl1), pw_gxwl) : pw_gxwl1;
        pw_gxwr  = _pw_gxwr.fixedflag ?  ((void)(pw_gxwr1), pw_gxwr) : pw_gxwr1;
        esp   = _esp.fixedflag ?          ((void)(pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap), esp) : pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap;
    }
    
    if (vrgfsamp != PSD_ON)  {

        if ( (2*pw_gxwad + pw_gxwl1 + pw_gxwr1) < (pw_gyba + pw_gyb + pw_gybd) ) {
            pw_gxwl1  = _pw_gxwl1.fixedflag ?        ((void)(pw_gxwl1+RUP_GRD(pw_gyb/2+pw_gyba-pw_gxwad)), pw_gxwl1) : pw_gxwl1+RUP_GRD(pw_gyb/2+pw_gyba-pw_gxwad);
            pw_gxwr1  = _pw_gxwr1.fixedflag ?        ((void)(pw_gxwr1+RUP_GRD(pw_gyb/2+pw_gyba-pw_gxwad)), pw_gxwr1) : pw_gxwr1+RUP_GRD(pw_gyb/2+pw_gyba-pw_gxwad);
            pw_gxwl  = _pw_gxwl.fixedflag ?  ((void)(pw_gxwl1), pw_gxwl) : pw_gxwl1;
            pw_gxwr  = _pw_gxwr.fixedflag ?  ((void)(pw_gxwr1), pw_gxwr) : pw_gxwr1;
            esp   = _esp.fixedflag ?          ((void)(pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap), esp) : pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap;
	}

        /* local scope { } */
        {  
            /* make sure esp/intleaves is a multiple of (hardware period)*intleaves by adjusting pw_gxwl1,r1 */
            int tmp, esp_new;
            
            esp_new = esp;
            tmp = intleaves * hrdwr_period;
            if( (esp % tmp) != 0) esp_new = (esp/tmp + 1) * tmp;
            esp_new = IMax(2, esp_new, minesp);
            
            if( esp_new > esp ) {
                pw_gxwl1  = _pw_gxwl1.fixedflag ?      ((void)(pw_gxwl1+(esp_new-esp)/2), pw_gxwl1) : pw_gxwl1+(esp_new-esp)/2;
                pw_gxwr1  = _pw_gxwr1.fixedflag ?  ((void)(pw_gxwl1), pw_gxwr1) : pw_gxwl1;
                pw_gxwl  = _pw_gxwl.fixedflag ?  ((void)(pw_gxwl1), pw_gxwl) : pw_gxwl1;
                pw_gxwr  = _pw_gxwr.fixedflag ?  ((void)(pw_gxwr1), pw_gxwr) : pw_gxwr1;
                esp   = _esp.fixedflag ?          ((void)(pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap), esp) : pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap;
            }   

        } /* end local {} scope */


    } /* end if vrgfsamp != PSD_ON */

    /* Last check: Make sure the echo-spacing */
    /* does not violate the minimum time from the end */
    /* of one data frame to the beginning of the next */
    if( (esp - rhfrsize*tsp) <  MinFram2FramTime) {      
        pw_gxgap   = _pw_gxgap.fixedflag ?    ((void)(RUP_GRD((int)(MinFram2FramTime-(esp-rhfrsize*tsp)))), pw_gxgap) : RUP_GRD((int)(MinFram2FramTime-(esp-rhfrsize*tsp)));

        /* Make sure added pw_gxgap/2 is on 4 us boundary */
        if ((pw_gxgap - (pw_gxgap/pwmin_gap)*pwmin_gap) != 0.0)
            pw_gxgap  = _pw_gxgap.fixedflag ?     ((void)((int)ceil((double)pw_gxgap/(double)pwmin_gap)*pwmin_gap), pw_gxgap) : (int)ceil((double)pw_gxgap/(double)pwmin_gap)*pwmin_gap;    
    } 
    
    /* Do the following in case pw_gxwl2 was modified by modify cvs */
    pw_gxwr2  = _pw_gxwr2.fixedflag ?  ((void)(pw_gxwl2), pw_gxwr2) : pw_gxwl2;
    pw_gxwl  = _pw_gxwl.fixedflag ?    ((void)(pw_gxwl1+pw_gxwl2), pw_gxwl) : pw_gxwl1+pw_gxwl2;
    pw_gxwr  = _pw_gxwr.fixedflag ?    ((void)(pw_gxwr1+pw_gxwr2), pw_gxwr) : pw_gxwr1+pw_gxwr2;
    esp   = _esp.fixedflag ?          ((void)(pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap), esp) : pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap;
    
    /* total readout flat-top */
    pw_gxw_total  = _pw_gxw_total.fixedflag ?      ((void)(pw_gxwl+pw_gxw+pw_gxwr), pw_gxw_total) : pw_gxwl+pw_gxw+pw_gxwr;  
    
    return SUCCESS;
}

STATUS
mph_protocol( void )
{
    INT noFpsLimitFlag = FALSE;
    FILE *fp = NULL;

    int rtperftest = FALSE;

    /* If file exists enable performance test mode */
    fp = fopen("/usr/g/bin/.epiRTPerfTest", "r");
    if( NULL != fp )
    {
        rtperftest = TRUE;
        fclose(fp);
    }

    /* With DVMR receive chain hardware, there is no frames per second
     * restriction. Remove restrictions if performance testing. */
    if( (PSDDVMR == psd_board_type)
        || rtperftest )
    {
        noFpsLimitFlag = TRUE;
    } 
    else
    {
        noFpsLimitFlag = FALSE;
    }

    if (noFpsLimitFlag == FALSE) {

        INT numcoils =  ((cfrecvend - cfrecvst)+1);
        FLOAT fps_limit = 256.0;  /* limit on fps */
        INT maxDimension;

        maxDimension = IMax(2,exist(opxres), exist(opyres));

        if  ( maxDimension <= 64 ) {
            fps_limit = (numcoils > 4) ? 20.0 : 25.0;
            if(((float)avmaxslquant/(float)((float)exist(optr)/1.0e6) > fps_limit)) {
                avmaxslquant = floor(fps_limit*(float)exist(optr)/1.0e6);
                avmintr = (INT)(ceil(1.0e6 * (float)((float)exist(opslquant)/(float)fps_limit)));
                avmintr = (INT)(ceil((float)avmintr/ 1000.0) * 1000.0);
            }
        } else if ( maxDimension <= 128 )  {
            fps_limit = (numcoils > 4) ? 13.0 : 18.0;
            if(((float)avmaxslquant/(float)((float)exist(optr)/1.0e6) > fps_limit)) {
                avmaxslquant = floor(fps_limit*(float)exist(optr)/1.0e6);
                avmintr = (INT)(ceil(1.0e6 * (float)((float)exist(opslquant)/(float)fps_limit)));
                avmintr = (INT)(ceil((float)avmintr/ 1000.0) * 1000.0);
            }
        } else {
            fps_limit = (numcoils > 4) ? 5.0 : 10.0;
            if(((float)avmaxslquant/(float)((float)exist(optr)/1.0e6) > fps_limit)) {
                avmaxslquant = floor(fps_limit*(float)exist(optr)/1.0e6);
                avmintr = (INT)(ceil(1.0e6 * (float)((float)exist(opslquant)/(float)fps_limit)));
                avmintr = (INT)(ceil((float)avmintr/ 1000.0) * 1000.0);
            }
        }
    } /* end noFpsLimitFlag Check */

    if( exist(opileave) == PSD_ON) {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "fMRI", STRING_ARG, "Interleaved Slice Spacing" );
        return FAILURE;
    }
    if ( existcv(optr) && exist(optr)<avmintr )
    {
        epic_error(use_ermes,
                   "The selected TR must be increased to %3.1f ms for the current prescription.",EM_PSD_FLOAT_MINTR_OUT_OF_RANGE, EE_ARGS(1), FLOAT_ARG, (FLOAT) ((INT)(avmintr*1.0e-3)) );
        return ADVISORY_FAILURE;
    }

    if ( existcv(optr) && exist(optr)>avmaxtr )
    {
        epic_error(use_ermes,
                   "The selected TR must be decreased to %3.1f ms for the current prescription.",EM_PSD_FLOAT_MAXTR_OUT_OF_RANGE, EE_ARGS(1), FLOAT_ARG, (FLOAT)((INT)(avmaxtr*1.0e-3)) );
        return FAILURE;
    }
    if ((avmaxslquant > 0) && (exist(opslquant) > avmaxslquant)) {
        strcpy(estr, "Too many slices per TR, please reduce slice number or increase TR");
        epic_error(use_ermes, estr, EM_PSD_FMRI_MULTIACQS, EE_ARGS(0));
        return ADVISORY_FAILURE;
    }

    return SUCCESS;
}


STATUS
#ifdef __STDC__ 
cveval1( void )
#else /* !__STDC__ */
    cveval1() 
#endif /* __STDC__ */
{
    int icount, pulsecnt;
    const CHAR funcName[] = "cveval1";
    int temp_slquant = 1; /* MRIhc27295 */
    int temp_maxslquant;

    tlead  = _tlead.fixedflag ?    ((void)(24), tlead) : 24;
    tleadssp  = _tleadssp.fixedflag ?  ((void)(tlead), tleadssp) : tlead;
    tlead  = _tlead.fixedflag ?  ((void)(RUP_GRD(tlead)), tlead) : RUP_GRD(tlead);
    tleadssp  = _tleadssp.fixedflag ?  ((void)(RUP_GRD(tleadssp)), tleadssp) : RUP_GRD(tleadssp);

    psd_card_hdwr_delay  = _psd_card_hdwr_delay.fixedflag ?  ((void)(10000), psd_card_hdwr_delay) : 10000;  
    if ((exist(opcgate) == PSD_ON) && existcv(opcgate)) 
    {
        avmintdel1 = psd_card_hdwr_delay + tlead + t_exa + GRAD_UPDATE_TIME;
        avmintdel1 = avmintdel1 + ir_time_total;
        if (ir_on == PSD_ON)
        {
            pitdel1 = avmintdel1;
        }
        else
        {
            pitdel1 = avmintdel1 + sp_sattime + cs_sattime;
            pitdel1 = pitdel1 + satdelay;
        }
        advroundup(&avmintdel1); /* round up to ms */
        advroundup(&pitdel1); /* round up to ms */
        
        /* Override Trigger Delay value if user prescribes Minimum or Recommended */
        if( existcv(opautotdel1) ) 
        { 
            if( PSD_TDEL1_MINIMUM == exist(opautotdel1) ) 
            { 
                cvdef(optdel1, avmintdel1); 
                cvoverride(optdel1, _optdel1.defval, PSD_FIX_ON, PSD_EXIST_ON); 
            } 
            else if( PSD_TDEL1_RECOMMENDED == exist(opautotdel1) ) 
            { 
                cvdef(optdel1, pitdel1); 
                cvoverride(optdel1, _optdel1.defval, PSD_FIX_ON, PSD_EXIST_ON); 
            } 
        }

        if (optdel1 < pitdel1)
            td0  = _td0.fixedflag ?     
                                                     ((void)(RUP_GRD((int)(exist(optdel1)-(psd_card_hdwr_delay+tlead+t_exa)))), td0) : RUP_GRD((int)(exist(optdel1)-(psd_card_hdwr_delay+tlead+t_exa)));
        else
            td0  = _td0.fixedflag ?       
                                                           ((void)(RUP_GRD((int)(exist(optdel1)-(psd_card_hdwr_delay+tlead+t_exa+sp_sattime+cs_sattime+ir_time+satdelay)))), td0) : RUP_GRD((int)(exist(optdel1)-(psd_card_hdwr_delay+tlead+t_exa+sp_sattime+cs_sattime+ir_time+satdelay)));
      
        gating  = _gating.fixedflag ?  ((void)(TRIG_ECG), gating) : TRIG_ECG;
        piadvmin = (piadvmin & ~(1<<PSD_ADVTR));
        piadvmax = (piadvmax & ~(1<<PSD_ADVTR));
        pitrnub = 0;
    } 
    else 
    {
        _opphases.fixedflag = 0;
        opphases  = _opphases.fixedflag ?  ((void)(1), opphases) : 1;
        avmintdel1 = 0;
        td0  = _td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), td0) : GRAD_UPDATE_TIME;
        piadvmin = (piadvmin | (1<<PSD_ADVTR));
        piadvmax = (piadvmax | (1<<PSD_ADVTR));
        pitrnub = 6;
        gating  = _gating.fixedflag ?  ((void)(TRIG_INTERN), gating) : TRIG_INTERN;
    }
			   
    /* Find the avail time for freq dephaser */

    /* Need fix here for trapezoidal phase encoding */
    if (exist(oppseq) == PSD_SE)
    {
        avail_pwgx1  = _avail_pwgx1.fixedflag ?         
                            ((void)((int)(exist(opte)/2-rfExIso-pw_rf2/2-RUP_GRD(rfupd))), avail_pwgx1) : (int)(exist(opte)/2-rfExIso-pw_rf2/2-RUP_GRD(rfupd));
    }
    else
    {
        avail_pwgx1  = _avail_pwgx1.fixedflag ?          
                            ((void)((int)(exist(opte)-rfExIso-(pw_gxwad+pw_gxw/2)-RUP_GRD(rfupd))), avail_pwgx1) : (int)(exist(opte)-rfExIso-(pw_gxwad+pw_gxw/2)-RUP_GRD(rfupd));
    }

    /*
     * MRIge55604 - Calculate minimun and maximum FOV
     */
    avminfovx  = _avminfovx.fixedflag ?         ((void)(1.0/(GAM*xtarg*tsp*1.0e-6)), avminfovx) : 1.0/(GAM*xtarg*tsp*1.0e-6);
    avminfovy  = _avminfovy.fixedflag ?  ((void)(0.0), avminfovy) : 0.0;
    avminfov = (avminfovx > avminfovy) ? avminfovx : avminfovy; 
    avminfov = ceil(avminfov) * 10.0;
    if (vrgfsamp == PSD_ON  && user_bw == 0)
    {
        /* Always use the minimum FOV for Ramp Sampling */
        avminfov = _opfov.minval;
    }
    else
    {
        /* Make sure min FOV is within the valid range */
        avminfov = (avminfov < _opfov.minval) ? _opfov.minval : avminfov;
    }
    /* This is the best Scan can do on the advisory panel.  The PSD supports
       a larger fov than 99cm, but the advisory panel won't reflect it. */
    avmaxfov = _opfov.maxval;
  
    /*
     * MRIge55604 - Calculate minimun and maximum RBW
     */
    if( exist(opnshots) > 1) {
        avminrbw = 31.25;
    } else {
        avminrbw = 62.5;
    }
    avmaxrbw = RBW_MAX;
    avminrbw = 15.625; /*jwg enable very low RBW for testing*/
  
    {
        float tsptmp;   /* min possible sampling period in micro seconds. */
      
        /* Calculate maximum RBW when ramp samp is not ON */
        /* MRIge51408 - Set max RBW based on max FOV */
        tsptmp = 10.0/ (GAM * xtarg * avmaxfov * 1.0e-6);
        /* round up to nearest 50 nanoseconds */
        tsptmp = (int)(5+100*tsptmp)/100.0;
        tsptmp -= ((int)(100*tsptmp)%5)/100.0;
        avmaxrbw = (1.0/ (2.0 * (tsptmp/ 1000.0)));
        avmaxrbw = (avmaxrbw > RBW_MAX) ? RBW_MAX : avmaxrbw;
    }

    /* avmaxrbw2 is not used in EPI, but this value
       will be displayed in the insensitive field of
       bandwidth2 */
    avmaxrbw2 = avmaxrbw;

    /* Calculate or adjust some timing variables based on MRE information */
/* Start inline from touch.e TouchEvalTimings */
/* Set up CVs other parameters */
if( touch_flag )
{
    /* Set some parameters for controlling sliding waveforms during multishot EPI acquisitions */
    pw_touch_wssp  = _pw_touch_wssp.fixedflag ?      ((void)(esp+8), pw_touch_wssp) : esp+8;

    if( PSD_ON == multiphase_flag )
    { /* when multiphase is on for MRE, opfphases is the number of phase offsets */
        multi_phases  = _multi_phases.fixedflag ?  ((void)(opfphases), multi_phases) : opfphases;
    }
    else
    { /* Set default values */
        multi_phases  = _multi_phases.fixedflag ?  ((void)(1), multi_phases) : 1;
    }

    touch_ndir  = _touch_ndir.fixedflag ?  ((void)(2), touch_ndir) : 2;

    meg_mode  = _meg_mode.fixedflag ?  ((void)(3), meg_mode) : 3; /* set variable that controls if MEGs will be both before and after the refocusing pulse or not */

    /* determine how the motion encoding is going to be done, including the number of encoding directions and which axes are invovled */
    /* grad_axis is a bit flag indicating which gradients will have MEGs on them */
    grad_axis  = _grad_axis.fixedflag ?  ((void)((int)exist(optouchax)), grad_axis) : (int)exist(optouchax);
    touch_xdir  = _touch_xdir.fixedflag ?      ((void)(((((int)grad_axis)&1)!=0)), touch_xdir) : ((((int)grad_axis)&1)!=0); /* flag indicating if there will be a MEG in the frequency-encoding direction */
    touch_ydir  = _touch_ydir.fixedflag ?      ((void)(((((int)grad_axis)&2)!=0)), touch_ydir) : ((((int)grad_axis)&2)!=0); /* flag indicating if there will be a MEG in the phase-encoding direction */
    touch_zdir  = _touch_zdir.fixedflag ?      ((void)(((((int)grad_axis)&4)!=0)), touch_zdir) : ((((int)grad_axis)&4)!=0); /* flag indicating if there will be a MEG in the slice-select direction */

    /* derate to lowest gradient parameters so all gradients have same response for the target gradient amplitude and minimum rise time */
    touch_target  = _touch_target.fixedflag ?     ((void)(FMin(3,loggrd.tx,loggrd.ty,loggrd.tz)), touch_target) : FMin(3,loggrd.tx,loggrd.ty,loggrd.tz);
    touch_rt  = _touch_rt.fixedflag ?     ((void)(IMax(3,loggrd.xrt,loggrd.yrt,loggrd.zrt)), touch_rt) : IMax(3,loggrd.xrt,loggrd.yrt,loggrd.zrt);

    touch_fcomp  = _touch_fcomp.fixedflag ?  ((void)(2), touch_fcomp) : 2; /* flow comp. style for MEG (0=not flow comp'ed, 1=long MEG 1-2-1, 2=short MEG 1-2-1). This could be linked to opfcomp, but currently it is not for max flexibility. */
    /* set the number of motion-encoding gradients to be put before the refocusing pulse */
    if( touch_fcomp > 0 )
    { 
        touch_gnum  = _touch_gnum.fixedflag ?  ((void)(1), touch_gnum) : 1;
    }
    touch_gdrate  = _touch_gdrate.fixedflag ?  ((void)(0.8), touch_gdrate) : 0.8; /* derating scale factor to be multiplied times the hardware maximum gradient amplitude to get the MEG amplitude */
    touch_gamp  = _touch_gamp.fixedflag ?    ((void)(touch_gdrate*touch_target), touch_gamp) : touch_gdrate*touch_target; /* scale the target maximum gradient amplitude to get the desired MEG amplitude */
    touch_pwramp  = _touch_pwramp.fixedflag ?      ((void)(IMax(2,GRAD_UPDATE_TIME,RUP_GRD((int)(touch_rt*touch_gdrate)))), touch_pwramp) : IMax(2,GRAD_UPDATE_TIME,RUP_GRD((int)(touch_rt*touch_gdrate))); /* calculate the attack/decay ramp times for the MEG accounting for derated amplitude of the MEG */
    if( touch_fcomp == 2 )
    {
        touch_pwramp  = _touch_pwramp.fixedflag ?    ((void)(2*touch_pwramp), touch_pwramp) : 2*touch_pwramp; /* for this style of MEG, the flow comp. lobes have half the ramp and plateau times of the main MEG lobe we are defining, so make sure the small lobe doesn't violate slewing limits */
    }

    touch_period_meg  = _touch_period_meg.fixedflag ?   ((void)(RUP_GRD((int)(1000000/((float)exist(optouchmegfreq))))), touch_period_meg) : RUP_GRD((int)(1000000/((float)exist(optouchmegfreq)))); /* calculate the desired period of one MEG */
    if( touch_fcomp == 2 )
    {
        touch_period_meg  = _touch_period_meg.fixedflag ?         ((void)(4*GRAD_UPDATE_TIME*(touch_period_meg/(4*GRAD_UPDATE_TIME))), touch_period_meg) : 4*GRAD_UPDATE_TIME*(touch_period_meg/(4*GRAD_UPDATE_TIME)); /* for this flow compensated MEG, make the main lobe size divisible by 4 UPDATE_TIME's . . . */
    }
    else
    {
        touch_period_meg  = _touch_period_meg.fixedflag ?         ((void)(2*GRAD_UPDATE_TIME*(touch_period_meg/(2*GRAD_UPDATE_TIME))), touch_period_meg) : 2*GRAD_UPDATE_TIME*(touch_period_meg/(2*GRAD_UPDATE_TIME)); /* . . . otherwise, just make it divisible by 2 */
    }
    touch_pwcon  = _touch_pwcon.fixedflag ?       ((void)((touch_period_meg/2)-2*touch_pwramp), touch_pwcon) : (touch_period_meg/2)-2*touch_pwramp; /* calculate the plateau width for the main MEG lobe (i.e., half the period minus the attack and decay ramps) */
    /* if the MEG frequency is too high, we can't ramp up to the desired MEG amplitude, so we must artificially lower the MEG amplitude and recalculate everything */
    if( (touch_pwcon < GRAD_UPDATE_TIME) || ((touch_fcomp == 2) && (touch_pwcon < 2 * GRAD_UPDATE_TIME)) )
    {
        if( touch_fcomp == 2 )
        {
            touch_pwcon  = _touch_pwcon.fixedflag ?    ((void)(2*GRAD_UPDATE_TIME), touch_pwcon) : 2*GRAD_UPDATE_TIME;
            touch_pwramp  = _touch_pwramp.fixedflag ?       ((void)(RDN_GRD((touch_period_meg-2*touch_pwcon)/8)*2), touch_pwramp) : RDN_GRD((touch_period_meg-2*touch_pwcon)/8)*2;
            touch_gdrate  = _touch_gdrate.fixedflag ?       ((void)(touch_pwramp*1./(2*touch_rt)), touch_gdrate) : touch_pwramp*1./(2*touch_rt);
            touch_gamp  = _touch_gamp.fixedflag ?    ((void)(touch_gdrate*touch_target), touch_gamp) : touch_gdrate*touch_target;
        }
        else
        {
            touch_pwcon  = _touch_pwcon.fixedflag ?    ((void)(1*GRAD_UPDATE_TIME), touch_pwcon) : 1*GRAD_UPDATE_TIME;
            touch_pwramp  = _touch_pwramp.fixedflag ?       ((void)(RDN_GRD((touch_period_meg-2*touch_pwcon)/4)), touch_pwramp) : RDN_GRD((touch_period_meg-2*touch_pwcon)/4);
            touch_gdrate  = _touch_gdrate.fixedflag ?     ((void)(touch_pwramp*1./touch_rt), touch_gdrate) : touch_pwramp*1./touch_rt;
            touch_gamp  = _touch_gamp.fixedflag ?    ((void)(touch_gdrate*touch_target), touch_gamp) : touch_gdrate*touch_target;
        }
    }
    touch_period_meg  = _touch_period_meg.fixedflag ?        ((void)(2*(touch_pwcon+2*touch_pwramp)), touch_period_meg) : 2*(touch_pwcon+2*touch_pwramp); /* calculate the final period of the MEG */
    touch_period_motion  = _touch_period_motion.fixedflag ?       ((void)(2*RUP_GRD((int)(1000000/(2.0*exist(optouchfreq))))), touch_period_motion) : 2*RUP_GRD((int)(1000000/(2.0*exist(optouchfreq))));
    touch_delta  = _touch_delta.fixedflag ?   ((void)(RUP_GRD(touch_period_motion/multi_phases)), touch_delta) : RUP_GRD(touch_period_motion/multi_phases); /* calculate the amount of time between trigger pulses */
    touch_act_freq_motion  = _touch_act_freq_motion.fixedflag ?   ((void)(1000000/((float)touch_period_motion)), touch_act_freq_motion) : 1000000/((float)touch_period_motion); /* report the actual motion frequency after the above rounding of the period of motion . . . */
    touch_lobe_motion  = _touch_lobe_motion.fixedflag ?   ((void)(touch_period_motion/2), touch_lobe_motion) : touch_period_motion/2; /* . . . and a half period of motion */
    touch_act_freq_meg  = _touch_act_freq_meg.fixedflag ?   ((void)(1000000/((float)touch_period_meg)), touch_act_freq_meg) : 1000000/((float)touch_period_meg); /* report the actual MEG frequency after the above adjustments to the gradient waveforms . . . */
    touch_lobe_meg  = _touch_lobe_meg.fixedflag ?   ((void)(touch_period_meg/2), touch_lobe_meg) : touch_period_meg/2; /* and a half period of the MEG */

    touch_driver_amp  = _touch_driver_amp.fixedflag ?  ((void)((int)exist(optouchamp)), touch_driver_amp) : (int)exist(optouchamp);
    touch_burst_count  = _touch_burst_count.fixedflag ?  ((void)((int)exist(optouchcyc)), touch_burst_count) : (int)exist(optouchcyc);
    
    calc_menc(_touch_menc.fixedflag ? (_temp499_touch_menc=touch_menc,&_temp499_touch_menc) : &touch_menc); /* calculate the motion sensitivity (MENC) for this acquisition and update pitouchmenc to reflect that information while prescribing other parameters */
    pitouchmenc = touch_menc;

    /* Calculate the amount of time the MEG's will take based on the above gradient waveform durations.  This time will be needed to update the minimum echo time correctly */
    touch_time  = _touch_time.fixedflag ?      ((void)(2*touch_gnum*touch_lobe_meg), touch_time) : 2*touch_gnum*touch_lobe_meg;
    if( touch_fcomp == 1 )
    {
        touch_time  = _touch_time.fixedflag ?  ((void)(touch_lobe_meg), touch_time) : touch_time+touch_lobe_meg;
    }

    /* set touch CVs */
    optouchtphases  = _optouchtphases.fixedflag ?  ((void)(opfphases), optouchtphases) : opfphases;
    touch_act_freq  = _touch_act_freq.fixedflag ?  ((void)(touch_act_freq_motion), touch_act_freq) : touch_act_freq_motion;

    /* Report the number of various MEG waveforms in the various grad structures acounting for things like flow comp, half gradient pairs, and motion-encoding on various axes */
    if( touch_fcomp )
    {
        gradx[TOUCH_GXU_SLOT].num = touch_xdir * (touch_gnum - 1);
        gradx[TOUCH_GXD_SLOT].num = touch_xdir * touch_gnum;
        grady[TOUCH_GYU_SLOT].num = touch_ydir * (touch_gnum - 1);
        grady[TOUCH_GYD_SLOT].num = touch_ydir * touch_gnum;
        gradz[TOUCH_GZU_SLOT].num = touch_zdir * (touch_gnum - 1);
        gradz[TOUCH_GZD_SLOT].num = touch_zdir * touch_gnum;
        gradx[TOUCH_GXF_SLOT].num = touch_xdir * 2;
        grady[TOUCH_GYF_SLOT].num = touch_ydir * 2;
        gradz[TOUCH_GZF_SLOT].num = touch_zdir * 2;
    }
    else
    {
        gradx[TOUCH_GXU_SLOT].num = touch_xdir * ((int)ceil(touch_gnum));
        gradx[TOUCH_GXD_SLOT].num = touch_xdir * ((int)touch_gnum);
        grady[TOUCH_GYU_SLOT].num = touch_ydir * ((int)ceil(touch_gnum));
        grady[TOUCH_GYD_SLOT].num = touch_ydir * ((int)touch_gnum);
        gradz[TOUCH_GZU_SLOT].num = touch_zdir * ((int)ceil(touch_gnum));
        gradz[TOUCH_GZD_SLOT].num = touch_zdir * ((int)touch_gnum);
        gradx[TOUCH_GXF_SLOT].num = 0;
        grady[TOUCH_GYF_SLOT].num = 0;
        gradz[TOUCH_GZF_SLOT].num = 0;
    }

    /* Now do the same thing for the MEG's that are after the refocusing pulse (which are not always present). */
    {
        int blip2_tmp;

        if( meg_mode >= 1 )
        {
            blip2_tmp = 1; /* if meg_mode >= 1, then these gradients are present, so set this scale factor to 1 so the number of MEGs is used . . . */
        }
        else
        {
            blip2_tmp = 0; /* . . . otherwise, set this scale factor to 0 */
        }

        if( touch_fcomp )
        {
            gradx[TOUCH_GXU2_SLOT].num = blip2_tmp * touch_xdir * (touch_gnum - 1);
            gradx[TOUCH_GXD2_SLOT].num = blip2_tmp * touch_xdir * touch_gnum;
            grady[TOUCH_GYU2_SLOT].num = blip2_tmp * touch_ydir * (touch_gnum - 1);
            grady[TOUCH_GYD2_SLOT].num = blip2_tmp * touch_ydir * touch_gnum;
            gradz[TOUCH_GZU2_SLOT].num = blip2_tmp * touch_zdir * (touch_gnum - 1);
            gradz[TOUCH_GZD2_SLOT].num = blip2_tmp * touch_zdir * touch_gnum;
            gradx[TOUCH_GXF2_SLOT].num = blip2_tmp * touch_xdir * 2;
            grady[TOUCH_GYF2_SLOT].num = blip2_tmp * touch_ydir * 2;
            gradz[TOUCH_GZF2_SLOT].num = blip2_tmp * touch_zdir * 2;
        }
        else
        {
            gradx[TOUCH_GXU2_SLOT].num = blip2_tmp * touch_xdir * ((int)ceil(touch_gnum));
            gradx[TOUCH_GXD2_SLOT].num = blip2_tmp * touch_xdir * ((int)touch_gnum);
            grady[TOUCH_GYU2_SLOT].num = blip2_tmp * touch_ydir * ((int)ceil(touch_gnum));
            grady[TOUCH_GYD2_SLOT].num = blip2_tmp * touch_ydir * ((int)touch_gnum);
            gradz[TOUCH_GZU2_SLOT].num = blip2_tmp * touch_zdir * ((int)ceil(touch_gnum));
            gradz[TOUCH_GZD2_SLOT].num = blip2_tmp * touch_zdir * ((int)touch_gnum);
            gradx[TOUCH_GXF2_SLOT].num = 0;
            grady[TOUCH_GYF2_SLOT].num = 0;
            gradz[TOUCH_GZF2_SLOT].num = 0;
        }
    }
}
else
{
    pw_touch_wssp  = _pw_touch_wssp.fixedflag ?  ((void)(0), pw_touch_wssp) : 0;
    multi_phases  = _multi_phases.fixedflag ?  ((void)(1), multi_phases) : 1;
}
/* End inline from touch.e TouchEvalTimings */


    fullk_nframes  = _fullk_nframes.fixedflag ?  ((void)((int)(ceilf(opyres*asset_factor/rup_factor)*rup_factor)), fullk_nframes) : (int)(ceilf(opyres*asset_factor/rup_factor)*rup_factor);

    /* Begin Minimum TE *****************************************************/
    area_gyb  = _area_gyb.fixedflag ?    ((void)((float)(pw_gyba+pw_gyb)*a_gyb), area_gyb) : (float)(pw_gyba+pw_gyb)*a_gyb;  /* G usec / cm */
    /*jwg bb run amppwgrad so that we can generate 'worst-case scenario' blip scheme*/
    if(sake_flag > 0)
    {
        gettarget(_target.fixedflag ? (_temp500_target=target,&_temp500_target) : &target, YGRAD, &loggrd);
	getramptime(_rtime.fixedflag ? (_temp501_rtime=rtime,&_temp501_rtime) : &rtime, _ftime.fixedflag ? (_temp502_ftime=ftime,&_temp502_ftime) : &ftime, YGRAD, &loggrd);
	rtime = _rtime.fixedflag ?  ((void)(4), rtime) : rtime/4;
    	amppwgrad(area_gyb, target, 0.0, 0.0, rtime * (int)sake_max_blip, MIN_PLATEAU_TIME, _a_gyb.fixedflag ? (_temp503_a_gyb=a_gyb,&_temp503_a_gyb) : &a_gyb, _pw_gyba.fixedflag ? (_temp504_pw_gyba=pw_gyba,&_temp504_pw_gyba) : &pw_gyba, _pw_gyb.fixedflag ? (_temp505_pw_gyb=pw_gyb,&_temp505_pw_gyb) : &pw_gyb, _pw_gybd.fixedflag ? (_temp506_pw_gybd=pw_gybd,&_temp506_pw_gybd) : &pw_gybd);
	fprintf(stderr,"Target is %f, rtime is %d, Rise time is %d \n",target,rtime,loggrd.yrt);    
    } else {
    	sake_max_blip  = _sake_max_blip.fixedflag ?  ((void)(1), sake_max_blip) : 1;
    }
        
  
    /* Compute minimum te with full ky coverage first *************************/

    /* MRIge92386 */
    etl  = _etl.fixedflag ?  ((void)((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves), etl) : (int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves;
    num_overscan  = _num_overscan.fixedflag ?  ((void)(0), num_overscan) : 0;
  
    /* Set the fract_ CVs */
    fract_ky  = _fract_ky.fixedflag ?  ((void)(PSD_FULL_KY), fract_ky) : PSD_FULL_KY;
    if(exist(opview_order) == PSD_OFF) {
        ky_dir  = _ky_dir.fixedflag ?  ((void)(PSD_TOP_DOWN), ky_dir) : PSD_TOP_DOWN;
    } else {
        ky_dir  = _ky_dir.fixedflag ?  ((void)(PSD_BOTTOM_UP), ky_dir) : PSD_BOTTOM_UP;
    }
   
    /* BJM: setup ky_offset, dont allow mods below if single etl */
    /* MRIge92386 */
    if ((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor) == exist(opnshots)) {
        cvoverride(ky_offset, 0, PSD_FIX_ON, PSD_EXIST_ON);
        cvoverride(delt, 0, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        cvoverride(ky_offset, 0, PSD_FIX_OFF, PSD_EXIST_ON);
        cvoverride(delt, 0, PSD_FIX_OFF, PSD_EXIST_ON);
    }

    if (intleaves == 1) 
    {
        delt  = _delt.fixedflag ?  ((void)(0), delt) : 0;
        ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;
        pw_wgx  = _pw_wgx.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_wgx) : GRAD_UPDATE_TIME;
    } 
    else 
        if ( ky_dir==PSD_BOTTOM_UP ) 
        {
            delt  = _delt.fixedflag ?  ((void)(RUP_HRD((int)((float)esp/(float)(intleaves)))), delt) : RUP_HRD((int)((float)esp/(float)(intleaves)));
            if (etl % 2 == 0) 
            {
                /* BJM: MRIge60610 */
                if ((etl/2) % 2 == 0)
                    ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil(-(double)intleaves/2.0))), ky_offset) : (float)(ceil(-(double)intleaves/2.0));
                else
                    ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)intleaves/2.0))), ky_offset) : (float)(ceil((double)intleaves/2.0));
            } 
            else 
            {
                ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)-intleaves))), ky_offset) : (float)(ceil((double)-intleaves));
            }
            pw_wgx  = _pw_wgx.fixedflag ?    ((void)((intleaves-1)*delt/2+GRAD_UPDATE_TIME), pw_wgx) : (intleaves-1)*delt/2+GRAD_UPDATE_TIME;
        } 
        else 	
        {    /* full ky CENTER-OUT */
            delt  = _delt.fixedflag ?  ((void)(RUP_HRD((int)((float)esp/(float)(intleaves*2)))), delt) : RUP_HRD((int)((float)esp/(float)(intleaves*2)));
            ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;
            pw_wgx  = _pw_wgx.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_wgx) : GRAD_UPDATE_TIME;
        }

    blips2cent  = _blips2cent.fixedflag ?    ((void)(etl/2+ky_offset/intleaves), blips2cent) : etl/2+ky_offset/intleaves;

    pw_wgx  = _pw_wgx.fixedflag ?  ((void)(RUP_GRD(pw_wgx)), pw_wgx) : RUP_GRD(pw_wgx);
    pw_wgy  = _pw_wgy.fixedflag ?  ((void)(pw_wgx), pw_wgy) : pw_wgx;
    pw_wgz  = _pw_wgz.fixedflag ?  ((void)(pw_wgx), pw_wgz) : pw_wgx;
    pw_wssp  = _pw_wssp.fixedflag ?  ((void)(pw_wgx), pw_wssp) : pw_wgx;
    pw_womega  = _pw_womega.fixedflag ?  ((void)(pw_wgx), pw_womega) : pw_wgx;
	
    tdaqhxa  = _tdaqhxa.fixedflag ?        ((void)(((float)etl/2.0+ky_offset/(float)intleaves+iref_etl)*(float)esp+delt/2), tdaqhxa) : ((float)etl/2.0+ky_offset/(float)intleaves+iref_etl)*(float)esp+delt/2;
    /* MRIge92386 */
    area_gy1  = _area_gy1.fixedflag ?      ((void)(area_gyb*(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor/2.0-0.5)/(float)intleaves), area_gy1) : area_gyb*(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor/2.0-0.5)/(float)intleaves;

    avmintecalc();

    avmintefull  = _avmintefull.fixedflag ?  ((void)((int)(100.0*ceil((double)avmintetemp/100.0))), avmintefull) : (int)(100.0*ceil((double)avmintetemp/100.0));	/* round up to 0.1 ms, YP Du */
 
    /* BJM - SE Ref Scan */
    /* Determine min TE for Full Ky Spin Echo Ref Case */
    minTeFull_ref  = _minTeFull_ref.fixedflag ?  ((void)(avmintecalc_ref()), minTeFull_ref) : avmintecalc_ref();

    /* Compute minimum te with fractional ky coverage or full ky with center/out
       coverage next ******************/

    /* Set the fract_ CVs */
    fract_ky  = _fract_ky.fixedflag ?  ((void)(PSD_FRACT_KY), fract_ky) : PSD_FRACT_KY;

    if(exist(opview_order) == PSD_OFF) {
        ky_dir  = _ky_dir.fixedflag ?  ((void)(PSD_TOP_DOWN), ky_dir) : PSD_TOP_DOWN;
    } else {
        ky_dir  = _ky_dir.fixedflag ?  ((void)(PSD_BOTTOM_UP), ky_dir) : PSD_BOTTOM_UP;
    }

    /* New rhhnover calculation - use minimum number of overscans (based
       on opnshots and fract_ky).  Leave old algorithm in, but use it to
       calc. rhhnover_max, which is not currently used, but may be in the
       future to maximize s/n. */
    if ( exist(oppseq) == PSD_GE )
    	/*jwg bb change from MIN_HNOVER_GRE to opyres/4, i.e. 0.75PE*/
	if (sake_flag == 0)
	{
        	rhhnover_min  = _rhhnover_min.fixedflag ?   ((void)((int)ceilf(opyres/4)), rhhnover_min) : (int)ceilf(opyres/4);
	} else {
		rhhnover_min  = _rhhnover_min.fixedflag ?  ((void)(0), rhhnover_min) : 0; /*jwg trick system into acquiring only half k-space lines*/
		rhhnover  = _rhhnover.fixedflag ?  ((void)(0), rhhnover) : 0;
	}
    else
        rhhnover_min  = _rhhnover_min.fixedflag ?  ((void)(MIN_HNOVER_DEF), rhhnover_min) : MIN_HNOVER_DEF;

    /* MRIge92386 */
    if( intleaves < (int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor) ) {
        for (icount=0; icount<=rhhnover_min; icount++) {
            if (icount*intleaves>=rhhnover_min) {
                num_overscan  = _num_overscan.fixedflag ?  ((void)((icount*intleaves)), num_overscan) : (icount*intleaves);
                break;
            }
        }
      
    } else {
        num_overscan  = _num_overscan.fixedflag ?  ((void)(rhhnover_min), num_overscan) : rhhnover_min;
    } 

    /* MRIge92386; Change it to ASSET_SCAN */
    /* asset = 2 for scans, 1 for calibration */
    if((exist(opasset) == ASSET_SCAN) &&
       ((exist(oppseq) == PSD_SE) || (intleaves == 1))) { /* YMSmr08010 */

        /* Use 8  overscans for Asset */
        num_overscan  = _num_overscan.fixedflag ?  ((void)(8), num_overscan) : 8;


        if(num_overscan >= (int)(ceilf(asset_factor*exist(opyres)/rup_factor)*rup_factor/2.0)) {
            num_overscan  = _num_overscan.fixedflag ?  ((void)((int)(ceilf(asset_factor*exist(opyres)/rup_factor)*rup_factor/2.0)), num_overscan) : (int)(ceilf(asset_factor*exist(opyres)/rup_factor)*rup_factor/2.0);
        }

    }

    /* MRIge92386 */
    etl  = _etl.fixedflag ?    ((void)(((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/2+num_overscan)/intleaves), etl) : ((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/2+num_overscan)/intleaves;

    /* Determine ky offsets */
    if (intleaves == 1) 
    {
        delt  = _delt.fixedflag ?  ((void)(0), delt) : 0;
        ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;

        if(ky_dir == PSD_BOTTOM_UP) {
            tdaqhxa  = _tdaqhxa.fixedflag ?  ((void)((float)num_overscan*(float)esp), tdaqhxa) : (float)num_overscan*(float)esp;
        } else {
            tdaqhxa  = _tdaqhxa.fixedflag ?  ((void)((float)((fullk_nframes/2)*(float)esp)), tdaqhxa) : (float)((fullk_nframes/2)*(float)esp);
        }
        tdaqhxa  = _tdaqhxa.fixedflag ?  ((void)((float)iref_etl*esp), tdaqhxa) : tdaqhxa+(float)iref_etl*esp;

        pw_wgx  = _pw_wgx.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_wgx) : GRAD_UPDATE_TIME;
    } 
    else 
    {
        delt  = _delt.fixedflag ?  ((void)(RUP_HRD((int)((float)esp/(float)(intleaves)))), delt) : RUP_HRD((int)((float)esp/(float)(intleaves)));

        if ((num_overscan/intleaves) % 2 == 0)
            ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)-intleaves/2.0))), ky_offset) : (float)(ceil((double)-intleaves/2.0));
        else
            ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)intleaves/2.0))), ky_offset) : (float)(ceil((double)intleaves/2.0));

        if (fullk_nframes == exist(opnshots))
            ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;

        /* BJM: MRIge60610 */ 
        if(num_overscan > 0) {
            /* BJM: the true number of overscans */
            rhhnover  = _rhhnover.fixedflag ?    ((void)(num_overscan+ky_offset), rhhnover) : num_overscan+ky_offset;

            /* MRIhc57297 06/15/2011 YI */
            ky_offset_save  = _ky_offset_save.fixedflag ?  ((void)(ky_offset), ky_offset_save) : ky_offset;
            rhhnover_save  = _rhhnover_save.fixedflag ?  ((void)(rhhnover), rhhnover_save) : rhhnover;
            rhnframes_tmp  = _rhnframes_tmp.fixedflag ?  ((void)((short)(ceilf((float)exist(opyres)*asset_factor/rup_factor)*rup_factor*fn*nop)), rhnframes_tmp) : (short)(ceilf((float)exist(opyres)*asset_factor/rup_factor)*rup_factor*fn*nop);
          
            /* MRIge61204 & MRIge61702 */
            /* Here's da deal: we are trying to put the echo peak */
            /* at the center of the group of flow comped echoes.   */
            /* It's desirable to place the peak early instead of late */
            /* to minimize TE.  However, if we can't, then place the */
            /* echo peak "late" instead for min TE */
            if(fabs(ky_offset) > 0) {
                if (exist(oppseq) == PSD_GE && rhhnover < MIN_HNOVER_GRE) {
                    ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil(3.0*(double)intleaves/2.0))), ky_offset) : (float)(ceil(3.0*(double)intleaves/2.0));
                    rhhnover  = _rhhnover.fixedflag ?    ((void)(MIN_HNOVER_GRE+ky_offset), rhhnover) : MIN_HNOVER_GRE+ky_offset;
                } else if (rhhnover < MIN_HNOVER_DEF) {
                    ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil(3.0*(double)intleaves/2.0))), ky_offset) : (float)(ceil(3.0*(double)intleaves/2.0));
                    rhhnover  = _rhhnover.fixedflag ?    ((void)(MIN_HNOVER_DEF+ky_offset), rhhnover) : MIN_HNOVER_DEF+ky_offset;
                }

                /* MRIhc57297 06/15/2011 YI */
                if(rhhnover > rhnframes_tmp - ky_offset) {
                    ky_offset  = _ky_offset.fixedflag ?  ((void)(ky_offset_save), ky_offset) : ky_offset_save;
                    rhhnover  = _rhhnover.fixedflag ?  ((void)(rhhnover_save), rhhnover) : rhhnover_save;
                }

            } /* end fabs(ky_offset) > 0 */          
        }

        tdaqhxa  = _tdaqhxa.fixedflag ?     
              ((void)(((float)num_overscan+ky_offset)*(float)esp/(float)intleaves+delt*(intleaves-1)/2+(float)iref_etl*esp), tdaqhxa) : ((float)num_overscan+ky_offset)*(float)esp/(float)intleaves+delt*(intleaves-1)/2+(float)iref_etl*esp;

	/* MRIge92386 */
        etl  = _etl.fixedflag ?      ((void)(((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves)/2+IMax(2,num_overscan/intleaves,1)), etl) : ((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves)/2+IMax(2,num_overscan/intleaves,1);


        pw_wgx  = _pw_wgx.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_wgx) : GRAD_UPDATE_TIME;

    }

    pw_wgx  = _pw_wgx.fixedflag ?  ((void)(RUP_GRD(pw_wgx)), pw_wgx) : RUP_GRD(pw_wgx);
    pw_wgy  = _pw_wgy.fixedflag ?  ((void)(pw_wgx), pw_wgy) : pw_wgx;
    pw_wgz  = _pw_wgz.fixedflag ?  ((void)(pw_wgx), pw_wgz) : pw_wgx;
    pw_wssp  = _pw_wssp.fixedflag ?  ((void)(pw_wgx), pw_wssp) : pw_wgx;
    pw_womega  = _pw_womega.fixedflag ?  ((void)(pw_wgx), pw_womega) : pw_wgx;

    area_gy1  = _area_gy1.fixedflag ?       ((void)(area_gyb*((float)num_overscan-0.5)/(float)intleaves), area_gy1) : area_gyb*((float)num_overscan-0.5)/(float)intleaves;

    avmintecalc();
    fprintf(stderr,"avminx is %d, avminy is %d, avminz is %d \n",avminx, avminy, avminz);    
  
    /* BJM - SE Ref Scan */
    /* Determine min TE for Fract Ky Spin Echo Case */
    minTeFrac_ref  = _minTeFrac_ref.fixedflag ?  ((void)(avmintecalc_ref()), minTeFrac_ref) : avmintecalc_ref();

    if ((exist(opautote) == PSD_MINTEFULL) || (exist(opnshots) == fullk_nframes) ||
        (num_overscan == fullk_nframes/2 ) || (ky_dir == PSD_TOP_DOWN))
        avminte = avmintefull;
    else
        avminte = (int)(100.0*ceil((double)avmintetemp/100.0));   /* round up to 0.1ms */
   
    if (exist(opautote) == PSD_MINTE || exist(opautote) == PSD_MINTEFULL) 
    {
        /* Round up min te to nears 0.1 ms */    
        cvoverride(opte,ceil((float)avminte/100.0)*100, PSD_FIX_ON, PSD_EXIST_ON);   
    }
    else if ((existcv(opte) == PSD_ON) && smart_numoverscan)
    {
        if ((exist(opte) > avminte) && (exist(opte) < avmintefull))
        {
            int extra_os_time;
            if (oppseq == PSD_GE)
            {
                extra_os_time = exist(opte) - avminte;
            }
            else
            {
                extra_os_time = (exist(opte) - avminte)/2;
            }
            num_overscan  = _num_overscan.fixedflag ?  ((void)((extra_os_time/esp/2)*2), num_overscan) : num_overscan+(extra_os_time/esp/2)*2;
            etl  = _etl.fixedflag ?    ((void)((num_overscan+(int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/2)/intleaves), etl) : (num_overscan+(int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/2)/intleaves;
        }
    }
  
    /* End Minimum TE *******************************************************/

    /* Now recompute everything based on operator selected parameters *******/

    if (exist(opte) >= avmintefull) 
    {
        fract_ky  = _fract_ky.fixedflag ?  ((void)(PSD_FULL_KY), fract_ky) : PSD_FULL_KY;
      
        /* BJM - SE Ref Scan */
        refScanTe  = _refScanTe.fixedflag ?  ((void)((int)(100.0*ceil((double)minTeFull_ref/100.0))), refScanTe) : (int)(100.0*ceil((double)minTeFull_ref/100.0)); 
    } 
    else 
    {
        fract_ky  = _fract_ky.fixedflag ?  ((void)(PSD_FRACT_KY), fract_ky) : PSD_FRACT_KY;

        /* BJM - SE Ref Scan */
        refScanTe  = _refScanTe.fixedflag ?  ((void)((int)(100.0*ceil((double)minTeFrac_ref/100.0))), refScanTe) : (int)(100.0*ceil((double)minTeFrac_ref/100.0)); 

    }
  
    if((ky_dir == PSD_TOP_DOWN) && (exist(opautote) != PSD_MINTEFULL) && 
       (fract_ky_topdown == PSD_FRACT_KY) && (fullk_nframes/2.0 > num_overscan))
    {
        fract_ky  = _fract_ky.fixedflag ?  ((void)(PSD_FRACT_KY), fract_ky) : PSD_FRACT_KY;
    }

    nexcalc();
  
    if (intleaves == 1) 
    {
        delt  = _delt.fixedflag ?  ((void)(0), delt) : 0;
    } 
    else 
        if ( ky_dir==PSD_BOTTOM_UP ) 
        {
            delt  = _delt.fixedflag ?  ((void)(RUP_HRD((int)((float)esp/(float)(intleaves)))), delt) : RUP_HRD((int)((float)esp/(float)(intleaves)));
        } 
        else 	
        {
            delt  = _delt.fixedflag ?  ((void)(RUP_HRD((int)((float)esp/(float)(intleaves*2)))), delt) : RUP_HRD((int)((float)esp/(float)(intleaves*2)));
        }
  
    /* Wait pulses */
    if (intleaves == 1)
        pw_wgx  = _pw_wgx.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_wgx) : GRAD_UPDATE_TIME;
    else 
        if ( ky_dir==PSD_BOTTOM_UP ) 
            pw_wgx  = _pw_wgx.fixedflag ?    ((void)((intleaves-1)*delt/2+GRAD_UPDATE_TIME), pw_wgx) : (intleaves-1)*delt/2+GRAD_UPDATE_TIME;
        else    /* full ky CENTER-OUT */
            pw_wgx  = _pw_wgx.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_wgx) : GRAD_UPDATE_TIME;

    pw_wgx  = _pw_wgx.fixedflag ?  ((void)(RUP_GRD(pw_wgx)), pw_wgx) : RUP_GRD(pw_wgx);
    pw_wgy  = _pw_wgy.fixedflag ?  ((void)(pw_wgx), pw_wgy) : pw_wgx;
    pw_wgz  = _pw_wgz.fixedflag ?  ((void)(pw_wgx), pw_wgz) : pw_wgx;
    pw_wssp  = _pw_wssp.fixedflag ?  ((void)(pw_wgx), pw_wssp) : pw_wgx;
    pw_womega  = _pw_womega.fixedflag ?  ((void)(pw_wgx), pw_womega) : pw_wgx;

    if (intleaves > 1) 
    {
        if ( ky_dir == PSD_BOTTOM_UP && fract_ky == PSD_FRACT_KY ) 
	{
            if (etl % 2 == 0)
                ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)-intleaves/2.0))), ky_offset) : (float)(ceil((double)-intleaves/2.0));
            else
                ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)intleaves/2.0))), ky_offset) : (float)(ceil((double)intleaves/2.0));
	} 
        else 
            if ( (ky_dir == PSD_BOTTOM_UP && fract_ky == PSD_FULL_KY) ||
                 ky_dir == PSD_TOP_DOWN ) 
            {
		/* MRIge92386 */
                etl  = _etl.fixedflag ?  ((void)((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves), etl) : (int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves;
                if (etl % 2 == 0) 
                {
                    if ((etl/2) % 2 == 0)
                        ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)-intleaves/2.0))), ky_offset) : (float)(ceil((double)-intleaves/2.0));
                    else
                        ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)intleaves/2.0))), ky_offset) : (float)(ceil((double)intleaves/2.0));
                } 
                else 
                {
                    ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)-intleaves/2.0))), ky_offset) : (float)(ceil((double)-intleaves/2.0));
                }
            } 
            else 
                if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FULL_KY)
                    ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;
    } 
    else 
    {             /* single interleave */
        ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;
    }

    /* MRIge75283 */
    if (fullk_nframes == exist(opnshots)) {
        ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;
    }
  
    if (fract_ky == PSD_FULL_KY) 
    {
        rhhnover  = _rhhnover.fixedflag ?  ((void)(0), rhhnover) : 0;
        num_overscan  = _num_overscan.fixedflag ?  ((void)(0), num_overscan) : 0;
	/* MRIge92386 */
        etl  = _etl.fixedflag ?  ((void)((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves), etl) : (int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves;
    } 
    else
    {
        if (intleaves > 1) 
        {
            if ((num_overscan/intleaves) % 2 == 0)
                ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)-intleaves/2.0))), ky_offset) : (float)(ceil((double)-intleaves/2.0));
            else
                ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)intleaves/2.0))), ky_offset) : (float)(ceil((double)intleaves/2.0));
        } 
        else 
        {
            ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;
        }
	
	/* MRIge92386 */
        etl  = _etl.fixedflag ?    ((void)((num_overscan+(int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/2)/intleaves), etl) : (num_overscan+(int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/2)/intleaves;

	/* MRIge92386 */
        if (num_overscan >= fullk_nframes/2) 
	{
            rhhnover  = _rhhnover.fixedflag ?  ((void)(0), rhhnover) : 0;
            num_overscan  = _num_overscan.fixedflag ?  ((void)(0), num_overscan) : 0;
            fract_ky  = _fract_ky.fixedflag ?  ((void)(PSD_FULL_KY), fract_ky) : PSD_FULL_KY;
            ky_dir  = _ky_dir.fixedflag ?  ((void)(PSD_BOTTOM_UP), ky_dir) : PSD_BOTTOM_UP;
	    /* MRIge92386 */
            etl  = _etl.fixedflag ?  ((void)((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves), etl) : (int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves;
            /* MRIge41484 BJM: modify ky_offset and set fn = 1.0 to prevent */
            /*                 download failure of Min TE, multi-shot, */
            /*                 spin-echo epi */
            ky_offset  = _ky_offset.fixedflag ?  ((void)(-1), ky_offset) : ky_offset*-1;
            fn  = _fn.fixedflag ?  ((void)(1.0), fn) : 1.0;         /* reset fractional nex value */

	}

    } /* partial ky */

    /* since opetl gets stored in the header */
    opetl  = _opetl.fixedflag ?  ((void)(etl), opetl) : etl;

    /* BJM: MRIge60610 */ 
    if(num_overscan > 0) {
        /* BJM: the true number of overscans */
        rhhnover  = _rhhnover.fixedflag ?    ((void)(num_overscan+ky_offset), rhhnover) : num_overscan+ky_offset;

        /* MRIhc57297 06/15/2011 YI */
        ky_offset_save  = _ky_offset_save.fixedflag ?  ((void)(ky_offset), ky_offset_save) : ky_offset;
        rhhnover_save  = _rhhnover_save.fixedflag ?  ((void)(rhhnover), rhhnover_save) : rhhnover;
        rhnframes_tmp  = _rhnframes_tmp.fixedflag ?  ((void)((short)(ceilf((float)exist(opyres)*asset_factor/rup_factor)*rup_factor*fn*nop)), rhnframes_tmp) : (short)(ceilf((float)exist(opyres)*asset_factor/rup_factor)*rup_factor*fn*nop);

        /* MRIge61204 & MRIge61702 */
        if(fabs(ky_offset) > 0) {
            if (exist(oppseq) == PSD_GE && rhhnover < MIN_HNOVER_GRE) {
                ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil(3.0*(double)intleaves/2.0))), ky_offset) : (float)(ceil(3.0*(double)intleaves/2.0));
                rhhnover  = _rhhnover.fixedflag ?    ((void)(MIN_HNOVER_GRE+ky_offset), rhhnover) : MIN_HNOVER_GRE+ky_offset;
            } else if (rhhnover < MIN_HNOVER_DEF) {
                ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil(3.0*(double)intleaves/2.0))), ky_offset) : (float)(ceil(3.0*(double)intleaves/2.0));
                rhhnover  = _rhhnover.fixedflag ?    ((void)(MIN_HNOVER_DEF+ky_offset), rhhnover) : MIN_HNOVER_DEF+ky_offset;
            }

            /* MRIhc57297 06/15/2011 YI */
            if(rhhnover > rhnframes_tmp - ky_offset) {
                ky_offset  = _ky_offset.fixedflag ?  ((void)(ky_offset_save), ky_offset) : ky_offset_save;
                rhhnover  = _rhhnover.fixedflag ?  ((void)(rhhnover_save), rhhnover) : rhhnover_save;
            }

        } /* end fabs(ky_offset) > 0 */
    }

    nblips  = _nblips.fixedflag ?    ((void)(etl-1), nblips) : etl-1;
	
    /* Y phase encode prephaser */
  
    if (etl == 1) {
        area_gy1  = _area_gy1.fixedflag ?  ((void)(area_gyb/2.0), area_gy1) : area_gyb/2.0;
        blips2cent  = _blips2cent.fixedflag ?  ((void)(0), blips2cent) : 0;
    } else {
        if (ky_dir == PSD_BOTTOM_UP && fract_ky == PSD_FRACT_KY) {

            area_gy1  = _area_gy1.fixedflag ?       ((void)(area_gyb*((float)num_overscan-0.5)/(float)intleaves), area_gy1) : area_gyb*((float)num_overscan-0.5)/(float)intleaves;
            blips2cent  = _blips2cent.fixedflag ?     ((void)((num_overscan+ky_offset)/intleaves), blips2cent) : (num_overscan+ky_offset)/intleaves;

        } else if (ky_dir == PSD_TOP_DOWN && fract_ky == PSD_FRACT_KY) {

	    /* MRIge92386 */
            area_gy1  = _area_gy1.fixedflag ?      
                ((void)(area_gyb*(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor/2.0-0.5)/(float)intleaves), area_gy1) : area_gyb*(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor/2.0-0.5)/(float)intleaves;
            blips2cent  = _blips2cent.fixedflag ?    ((void)(etl/2+ky_offset/intleaves), blips2cent) : etl/2+ky_offset/intleaves;

        }  else if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FULL_KY) {

            area_gy1  = _area_gy1.fixedflag ?      ((void)(area_gyb*((float)intleaves/2.0-0.5)), area_gy1) : area_gyb*((float)intleaves/2.0-0.5);
            blips2cent  = _blips2cent.fixedflag ?  ((void)(0), blips2cent) : 0;

        } else if ( (ky_dir == PSD_BOTTOM_UP && fract_ky == PSD_FULL_KY) ||
                    (ky_dir == PSD_TOP_DOWN && fract_ky == PSD_FULL_KY) ) {
        /*MRIhc00996*/
            area_gy1  = _area_gy1.fixedflag ?      
                ((void)(area_gyb*(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor/2.0-0.5)/(float)intleaves), area_gy1) : area_gyb*(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor/2.0-0.5)/(float)intleaves;
            blips2cent  = _blips2cent.fixedflag ?    ((void)(etl/2+ky_offset/intleaves), blips2cent) : etl/2+ky_offset/intleaves;

        }
    }
  
    gy1_offset  = _gy1_offset.fixedflag ?  ((void)(ky_offset*fabs(area_gyb)/intleaves), gy1_offset) : ky_offset*fabs(area_gyb)/intleaves;
  
    /* Shift ky=0 point to center of x flow comp'd echoes */
    if (etl > 1)
        area_gy1  = _area_gy1.fixedflag ?  ((void)(gy1_offset), area_gy1) : area_gy1+gy1_offset;
  
    /* Scale the waveform amps for the phase encodes 
     * so each phase instruction jump is an integer step */
  
    if (ky_dir == PSD_BOTTOM_UP && fract_ky == PSD_FRACT_KY) {
        if (intleaves <= 1)
            endview_iamp  = _endview_iamp.fixedflag ?  ((void)(max_pg_wamp), endview_iamp) : max_pg_wamp;
        else {
            if (num_overscan >= 2)
                endview_iamp  = _endview_iamp.fixedflag ?   
                                               
                    ((void)((int)((int)(2*max_pg_wamp/(num_overscan-1+2*ky_offset))/2)*2*(num_overscan-1+2*ky_offset)/2), endview_iamp) : (int)((int)(2*max_pg_wamp/(num_overscan-1+2*ky_offset))/2)*2*(num_overscan-1+2*ky_offset)/2;
            else
                endview_iamp  = _endview_iamp.fixedflag ?  ((void)(max_pg_wamp), endview_iamp) : max_pg_wamp;
        }
    } else if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FULL_KY) {
        if (intleaves <= 2)
            endview_iamp  = _endview_iamp.fixedflag ?  ((void)(max_pg_wamp), endview_iamp) : max_pg_wamp;
        else
	    /* MRIge92386 */
            endview_iamp  = _endview_iamp.fixedflag ?  
                                         
                  ((void)((int)((int)(2*max_pg_wamp/((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)-1+2*ky_offset))/2)*2*((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)-1+2*ky_offset)/2), endview_iamp) : (int)((int)(2*max_pg_wamp/((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)-1+2*ky_offset))/2)*2*((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)-1+2*ky_offset)/2;
    } else if ((ky_dir == PSD_TOP_DOWN || ky_dir == PSD_BOTTOM_UP) &&
               fract_ky == PSD_FULL_KY) {
        if (intleaves <= 1)
            endview_iamp  = _endview_iamp.fixedflag ?  ((void)(max_pg_wamp), endview_iamp) : max_pg_wamp;
        else
	    /* MRIge92386 */
            endview_iamp  = _endview_iamp.fixedflag ?  
                                         
                  ((void)((int)((int)(2*max_pg_wamp/((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)-1+2*ky_offset))/2)*2*((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)-1+2*ky_offset)/2), endview_iamp) : (int)((int)(2*max_pg_wamp/((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)-1+2*ky_offset))/2)*2*((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)-1+2*ky_offset)/2;
    }
  
    endview_scale  = _endview_scale.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iamp), endview_scale) : (float)max_pg_iamp/(float)endview_iamp;
  
    /* Find the amplitudes and pulse widths of the trapezoidal
       phase encoding pulse. */
  if(opuser26 == 0)
  {
    if (amppwtpe(_a_gy1a.fixedflag ? (_temp507_a_gy1a=a_gy1a,&_temp507_a_gy1a) : &a_gy1a,_a_gy1b.fixedflag ? (_temp508_a_gy1b=a_gy1b,&_temp508_a_gy1b) : &a_gy1b,_pw_gy1.fixedflag ? (_temp509_pw_gy1=pw_gy1,&_temp509_pw_gy1) : &pw_gy1,_pw_gy1a.fixedflag ? (_temp510_pw_gy1a=pw_gy1a,&_temp510_pw_gy1a) : &pw_gy1a,_pw_gy1d.fixedflag ? (_temp511_pw_gy1d=pw_gy1d,&_temp511_pw_gy1d) : &pw_gy1d,
                 loggrd.ty_xyz/endview_scale,loggrd.yrt,
                 area_gy1) == FAILURE)
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe");
        return FAILURE;
    } 
    } else {
    /*jwg with sake want to ensure we got out to edge of k-space, even though we trick it w/ rhhnover_min = 0*/
	    if (amppwtpe(_a_gy1a.fixedflag ? (_temp512_a_gy1a=a_gy1a,&_temp512_a_gy1a) : &a_gy1a,_a_gy1b.fixedflag ? (_temp513_a_gy1b=a_gy1b,&_temp513_a_gy1b) : &a_gy1b,_pw_gy1.fixedflag ? (_temp514_pw_gy1=pw_gy1,&_temp514_pw_gy1) : &pw_gy1,_pw_gy1a.fixedflag ? (_temp515_pw_gy1a=pw_gy1a,&_temp515_pw_gy1a) : &pw_gy1a,_pw_gy1d.fixedflag ? (_temp516_pw_gy1d=pw_gy1d,&_temp516_pw_gy1d) : &pw_gy1d,
                 loggrd.ty_xyz/endview_scale,loggrd.yrt,
                 (area_gyb * ((float)(opyres/2) - 0.5)/ (float)intleaves)) == FAILURE)
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe");
        return FAILURE;
    } 
    }
  
    pw_gy1_tot  = _pw_gy1_tot.fixedflag ?      ((void)(pw_gy1a+pw_gy1+pw_gy1d), pw_gy1_tot) : pw_gy1a+pw_gy1+pw_gy1d;
  
    a_gy1a  = _a_gy1a.fixedflag ?         
                ((void)(((exist(oppseq)==PSD_SE&&gy1pos==PSD_PRE_180)?a_gy1a:-a_gy1a)), a_gy1a) : ((exist(oppseq)==PSD_SE&&gy1pos==PSD_PRE_180)?a_gy1a:-a_gy1a);
    a_gy1b  = _a_gy1b.fixedflag ?         
                ((void)(((exist(oppseq)==PSD_SE&&gy1pos==PSD_PRE_180)?a_gy1b:-a_gy1b)), a_gy1b) : ((exist(oppseq)==PSD_SE&&gy1pos==PSD_PRE_180)?a_gy1b:-a_gy1b);
  
    if (ygmn_type == CALC_GMN1) {
    
        /* set time origin at end of bipolar flow comp lobe/beginning of 
           gy1f phase encoding pulse */
        invertphase  = _invertphase.fixedflag ?  ((void)(0), invertphase) : 0;
        zeromomentsum  = _zeromomentsum.fixedflag ?  ((void)(0.0), zeromomentsum) : 0.0;
        firstmomentsum  = _firstmomentsum.fixedflag ?  ((void)(0.0), firstmomentsum) : 0.0;
        pulsepos  = _pulsepos.fixedflag ?  ((void)(0), pulsepos) : 0;
    
        /* compute moments for blips */
        pulsepos  = _pulsepos.fixedflag ?            ((void)(pw_gy1_tot+pw_gxwad+esp-pw_gxwad/2-pw_gyb/2-pw_gybd), pulsepos) : pw_gy1_tot+pw_gxwad+esp-pw_gxwad/2-pw_gyb/2-pw_gybd;
        if(no_gy1_ol_gxw && iref_etl > 0) pulsepos  = _pulsepos.fixedflag ?  ((void)(esp), pulsepos) : pulsepos+esp;
        for (pulsecnt=0;pulsecnt<blips2cent;pulsecnt++) {
            rampmoments(0.0, a_gyb, pw_gyba, invertphase, _pulsepos.fixedflag ? (_temp517_pulsepos=pulsepos,&_temp517_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp518_zeromoment=zeromoment,&_temp518_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp519_firstmoment=firstmoment,&_temp519_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp520_zeromomentsum=zeromomentsum,&_temp520_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp521_firstmomentsum=firstmomentsum,&_temp521_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gyb, a_gyb, pw_gyb, invertphase, _pulsepos.fixedflag ? (_temp522_pulsepos=pulsepos,&_temp522_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp523_zeromoment=zeromoment,&_temp523_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp524_firstmoment=firstmoment,&_temp524_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp525_zeromomentsum=zeromomentsum,&_temp525_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp526_firstmomentsum=firstmomentsum,&_temp526_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gyb, 0.0, pw_gybd, invertphase, _pulsepos.fixedflag ? (_temp527_pulsepos=pulsepos,&_temp527_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp528_zeromoment=zeromoment,&_temp528_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp529_firstmoment=firstmoment,&_temp529_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp530_zeromomentsum=zeromomentsum,&_temp530_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp531_firstmomentsum=firstmomentsum,&_temp531_firstmomentsum) : &firstmomentsum);
            pulsepos  = _pulsepos.fixedflag ?      ((void)((esp-pw_gyba-pw_gyb/2)), pulsepos) : pulsepos+(esp-pw_gyba-pw_gyb/2);
        }		
        gyb_tot_0thmoment  = _gyb_tot_0thmoment.fixedflag ?  ((void)(zeromomentsum), gyb_tot_0thmoment) : zeromomentsum;
        gyb_tot_1stmoment  = _gyb_tot_1stmoment.fixedflag ?  ((void)(firstmomentsum), gyb_tot_1stmoment) : firstmomentsum;
    
        /* Here we compute the gradient moment nulling pulse parameters
           for a worst case condition: when the gy1f pulse has zero
           amplitude.  Since the gy1f never really steps to zero amplitude,
           this is hardly an optimal solution.  A future option is to
           compute the minimum amplitude of gy1f across all intleaves
           in this calculation. */
    
        amppwygmn(gyb_tot_0thmoment, gyb_tot_1stmoment, pw_gy1a, pw_gy1,
                  pw_gy1d, 0.0, 0.0, loggrd.ty_xyz, (float)loggrd.yrt,
                  0, _pw_gymn2a.fixedflag ? (_temp532_pw_gymn2a=pw_gymn2a,&_temp532_pw_gymn2a) : &pw_gymn2a, _pw_gymn2.fixedflag ? (_temp533_pw_gymn2=pw_gymn2,&_temp533_pw_gymn2) : &pw_gymn2, _pw_gymn2d.fixedflag ? (_temp534_pw_gymn2d=pw_gymn2d,&_temp534_pw_gymn2d) : &pw_gymn2d, _a_gymn2.fixedflag ? (_temp535_a_gymn2=a_gymn2,&_temp535_a_gymn2) : &a_gymn2);
    
        a_gymn2  = _a_gymn2.fixedflag ?  ((void)(-a_gymn2), a_gymn2) : -a_gymn2;
        a_gymn1  = _a_gymn1.fixedflag ?  ((void)(-a_gymn2), a_gymn1) : -a_gymn2;
        pw_gymn1a  = _pw_gymn1a.fixedflag ?  ((void)(pw_gymn2a), pw_gymn1a) : pw_gymn2a;
        pw_gymn1  = _pw_gymn1.fixedflag ?  ((void)(pw_gymn2), pw_gymn1) : pw_gymn2;
        pw_gymn1d  = _pw_gymn1d.fixedflag ?  ((void)(pw_gymn2d), pw_gymn1d) : pw_gymn2d;
    
        pw_gymn1_tot  = _pw_gymn1_tot.fixedflag ?      ((void)(pw_gymn1a+pw_gymn1+pw_gymn1d), pw_gymn1_tot) : pw_gymn1a+pw_gymn1+pw_gymn1d;
        pw_gymn2_tot  = _pw_gymn2_tot.fixedflag ?      ((void)(pw_gymn2a+pw_gymn2+pw_gymn2d), pw_gymn2_tot) : pw_gymn2a+pw_gymn2+pw_gymn2d;
    
    } else {    /* if (ygmn_type != CALC_GMN1) */
        pw_gymn1_tot  = _pw_gymn1_tot.fixedflag ?  ((void)(0), pw_gymn1_tot) : 0;
        pw_gymn2_tot  = _pw_gymn2_tot.fixedflag ?  ((void)(0), pw_gymn2_tot) : 0;
    }

    /* internref: pw_iref_gxwait is defined in EP_TRAIN() */
    if( iref_etl != 0 && pw_gy1_tot + pw_gymn1_tot + pw_gymn2_tot > esp ){
        pw_iref_gxwait  = _pw_iref_gxwait.fixedflag ?        ((void)(RUP_GRD(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot-esp)), pw_iref_gxwait) : RUP_GRD(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot-esp);
    }else{
        pw_iref_gxwait  = _pw_iref_gxwait.fixedflag ?  ((void)(0), pw_iref_gxwait) : 0;
    }
    if(no_gy1_ol_gxw && iref_etl > 0)
        pw_iref_gxwait  = _pw_iref_gxwait.fixedflag ?      ((void)(RUP_GRD(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot)), pw_iref_gxwait) : RUP_GRD(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot);

    /* Actual inter echo time */
    if (etl == 1)
        esp  = _esp.fixedflag ?  ((void)(0), esp) : 0;  /* can't define an echo spacing with an etl of 1! */
  
    if (esp % GRAD_UPDATE_TIME != 0) {
        sprintf(estr,
                " esp not an integral multiple of grad hardware period. ");
        epic_error(use_ermes, estr, EM_PSD_SUPPORT_FAILURE, 1, STRING_ARG,
                   " esp not an integral multiple of grad hardware period. ");
        return FAILURE;
    }
 
    if (etl == 1) {
        tdaqhxa  = _tdaqhxa.fixedflag ?        ((void)((pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr)/2), tdaqhxa) : (pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr)/2;
        tdaqhxb  = _tdaqhxb.fixedflag ?  ((void)(tdaqhxa), tdaqhxb) : tdaqhxa;
        pw_gxgap  = _pw_gxgap.fixedflag ?  ((void)(0), pw_gxgap) : 0;
    } else {
        if ((ky_dir==PSD_TOP_DOWN || ky_dir==PSD_BOTTOM_UP) &&
            fract_ky == PSD_FULL_KY) {
            tdaqhxa  = _tdaqhxa.fixedflag ?      ((void)(((float)etl/2.0+ky_offset/(float)intleaves+iref_etl)*(float)esp), tdaqhxa) : ((float)etl/2.0+ky_offset/(float)intleaves+iref_etl)*(float)esp;
            tdaqhxb  = _tdaqhxb.fixedflag ?    ((void)(((float)etl/2.0-ky_offset/(float)intleaves)*(float)esp), tdaqhxb) : ((float)etl/2.0-ky_offset/(float)intleaves)*(float)esp;
        } else if (ky_dir == PSD_BOTTOM_UP && fract_ky == PSD_FRACT_KY) {
            /* Do overscans first */
            tdaqhxa  = _tdaqhxa.fixedflag ?      ((void)(((float)num_overscan-ky_offset)*(float)esp/(float)intleaves+(float)iref_etl*esp), tdaqhxa) : ((float)num_overscan-ky_offset)*(float)esp/(float)intleaves+(float)iref_etl*esp;
            tdaqhxb  = _tdaqhxb.fixedflag ?  
                ((void)(((float)etl-(((float)num_overscan+ky_offset)/(float)intleaves))*(float)esp), tdaqhxb) : ((float)etl-(((float)num_overscan+ky_offset)/(float)intleaves))*(float)esp;
        }  else if (ky_dir == PSD_TOP_DOWN && fract_ky == PSD_FRACT_KY) {
            /* Do overscans LAST */
            tdaqhxb  = _tdaqhxb.fixedflag ?    ((void)(((float)num_overscan-ky_offset)*(float)esp/(float)intleaves), tdaqhxb) : ((float)num_overscan-ky_offset)*(float)esp/(float)intleaves;
            tdaqhxa  = _tdaqhxa.fixedflag ?  
                  ((void)(((float)etl-(((float)num_overscan+ky_offset)/(float)intleaves))*(float)esp+(float)iref_etl*esp), tdaqhxa) : ((float)etl-(((float)num_overscan+ky_offset)/(float)intleaves))*(float)esp+(float)iref_etl*esp;
        } else if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FULL_KY) {
            /* Put the middle of the first echo at the nominal TE */
            tdaqhxa  = _tdaqhxa.fixedflag ?      ((void)(pw_gxwad+pw_gxwl+(pw_gxw/2)), tdaqhxa) : pw_gxwad+pw_gxwl+(pw_gxw/2);
            tdaqhxb  = _tdaqhxb.fixedflag ?          ((void)(etl*esp+pw_gxgap+pw_gxwad+pw_gxwl+(pw_gxw/2)), tdaqhxb) : etl*esp+pw_gxgap+pw_gxwad+pw_gxwl+(pw_gxw/2);
        }
    }

    tdaqhxa  = _tdaqhxa.fixedflag ?  ((void)(pw_iref_gxwait), tdaqhxa) : tdaqhxa+pw_iref_gxwait;

    if (etl % 2 == 0)       /* odd number of views, so negate killer ampl. */
        a_gxk  = _a_gxk.fixedflag ?  ((void)(-a_gxk), a_gxk) : -a_gxk;
 
    if (etl+iref_etl >= 256) {
        if  (PSDDVMR == psd_board_type){
            time_ssi  = _time_ssi.fixedflag ?  ((void)(4000), time_ssi) : 4000;
        }
        else{
            time_ssi  = _time_ssi.fixedflag ?  ((void)(2000), time_ssi) : 2000;
        }
    }
    else {
        if (PSDDVMR == psd_board_type){
            if (PSD_OFF == epispec_flag) {
                if(etl+iref_etl <= 192) {
                    time_ssi  = _time_ssi.fixedflag ?  ((void)(1200), time_ssi) : 1200;
                }
                else {
                    time_ssi  = _time_ssi.fixedflag ?  ((void)(2000), time_ssi) : 2000;
                }
            }
            else {
                time_ssi  = _time_ssi.fixedflag ?  ((void)(1000), time_ssi) : 1000;
            }
        }
        else{
            time_ssi  = _time_ssi.fixedflag ?  ((void)(1000), time_ssi) : 1000;
        }
    }
       
    te_time  = _te_time.fixedflag ?  ((void)(exist(opte)), te_time) : exist(opte);
    gkdelay  = _gkdelay.fixedflag ?  ((void)(RUP_GRD(gkdelay)), gkdelay) : RUP_GRD(gkdelay);

    pos_start  = _pos_start.fixedflag ?    ((void)(RUP_GRD((int)tlead+GRAD_UPDATE_TIME)), pos_start) : RUP_GRD((int)tlead+GRAD_UPDATE_TIME);


    if ((pos_start + pw_gzrf1a) < -rfupa) {
        pos_start  = _pos_start.fixedflag ?      ((void)(RUP_GRD((int)(-rfupa-pw_gzrf1a+GRAD_UPDATE_TIME))), pos_start) : RUP_GRD((int)(-rfupa-pw_gzrf1a+GRAD_UPDATE_TIME));
    }

    /* MRIge57894 - added pw_sspshift to non_tetime *//* YMSmr08284 */
    non_tetime  = _non_tetime.fixedflag ?             
                 
          ((void)(pos_start+cs_sattime+sp_sattime+pw_gzrf1a+t_exa+tdaqhxb+gktime+gkdelay+time_ssi+GRAD_UPDATE_TIME+delt*(intleaves-1)+psd_rf_wait+pw_sspshift), non_tetime) : pos_start+cs_sattime+sp_sattime+pw_gzrf1a+t_exa+tdaqhxb+gktime+gkdelay+time_ssi+GRAD_UPDATE_TIME+delt*(intleaves-1)+psd_rf_wait+pw_sspshift;
    { /* Start of code inlined from Inversion.e InversionEval */
        hrf0  = _hrf0.fixedflag ?  ((void)((pw_rf0)/2), hrf0) : (pw_rf0)/2;  
        pw_gzrf0  = _pw_gzrf0.fixedflag ?  ((void)(pw_rf0), pw_gzrf0) : pw_rf0;

        /* determine the bandwidth of IR pulse */
/* MRIhc13638 - Substituting sh3t2 for shNvrg5b when 3T field is selected. */
/* No need to differentiate between silver-hoult and slr for bw_rf0 calculation */

        bw_rf0  = _bw_rf0.fixedflag ?  ((void)((rfpulse[RF0_SLOT].nom_bw*rfpulse[RF0_SLOT].nom_pw)/(pw_rf0)), bw_rf0) : (rfpulse[RF0_SLOT].nom_bw*rfpulse[RF0_SLOT].nom_pw)/(pw_rf0);

        if (ir_on == PSD_ON) 
        {
            /* determine the amplitude of IR pulse */
            float tmpInvThick;
            if((PSD_ON == invThickOpt) && (PSD_ON == enht2flairflag))
            {
                double timeAdjSlCenDelta, adjInvPulseDeltaTime;

                timeAdjSlCenDelta = acqs * 2 * (exist(opslthick)+exist(opslspace));
                adjInvPulseDeltaTime = invThickOpt_seqtime;
                invthick  = _invthick.fixedflag ?  ((void)(timeAdjSlCenDelta/(1+adjInvPulseDeltaTime/(2*opti))), invthick) : timeAdjSlCenDelta/(1+adjInvPulseDeltaTime/(2*opti));
                tmpInvThick = invthick;
            }
            else
            {
                tmpInvThick = exist(opslthick);
            }

            if (ampslice(_a_gzrf0.fixedflag ? (_temp536_a_gzrf0=a_gzrf0,&_temp536_a_gzrf0) : &a_gzrf0, bw_rf0, 
                         ((exist(opimode) == PSD_3D) ? exist(opvthick) : tmpInvThick),
                         gscale_rf0,TYPDEF)
                == FAILURE)
            {
                epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1),STRING_ARG,"ampslice");
                return FAILURE;
            }

            /* Optimize Ramps - RJF */
            if ( optramp ( _pw_gzrf0a.fixedflag ? (_temp537_pw_gzrf0a=pw_gzrf0a,&_temp537_pw_gzrf0a) : &pw_gzrf0a, a_gzrf0, loggrd.tz_yz, loggrd.zrt, (INT) TYPDEF) == FAILURE ) { 
                epic_error (use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, 
                            EE_ARGS(1), STRING_ARG, "optramp");
                return FAILURE;
            }

            pw_gzrf0d  = _pw_gzrf0d.fixedflag ?  ((void)(pw_gzrf0a), pw_gzrf0d) : pw_gzrf0a;


            /* Y Killer CVs */
            if (amppwgrad(yk0_killer_area, loggrd.ty_yz, 0.0, 0.0, loggrd.yrt,
                          MIN_PLATEAU_TIME, _a_gyk0.fixedflag ? (_temp538_a_gyk0=a_gyk0,&_temp538_a_gyk0) : &a_gyk0, _pw_gyk0a.fixedflag ? (_temp539_pw_gyk0a=pw_gyk0a,&_temp539_pw_gyk0a) : &pw_gyk0a,
                          _pw_gyk0.fixedflag ? (_temp540_pw_gyk0=pw_gyk0,&_temp540_pw_gyk0) : &pw_gyk0, _pw_gyk0d.fixedflag ? (_temp541_pw_gyk0d=pw_gyk0d,&_temp541_pw_gyk0d) : &pw_gyk0d) == FAILURE) {
                epic_error(use_ermes, "%s failed in InversionEval.",
                           EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"amppwgrad:gyk0"); 
                return FAILURE;
            }
        }

        a_gyk0  = _a_gyk0.fixedflag ?    ((void)(a_gyk0*ir_on), a_gyk0) : a_gyk0*ir_on;

        ir_grad_time   = _ir_grad_time.fixedflag ?       
                                            
                                             ((void)(RUP_GRD((ir_on)*(pw_gzrf0a+pw_rf0+IMax(2,pw_gzrf0d,pw_gyk0a)+pw_gyk0+pw_gyk0d))), ir_grad_time) : RUP_GRD((ir_on)*(pw_gzrf0a+pw_rf0+IMax(2,pw_gzrf0d,pw_gyk0a)+pw_gyk0+pw_gyk0d));

        /* consider rffrequency bits, unblank power amp and rf wait when 
           estimating start of the IR pulse.  Make sure there's at least 48us 
           before the start of the attack ramp to avoid Gradient over ranges due 
           to SSI Matrix Update - RJF, 12/July/99 */

        ir_start  = _ir_start.fixedflag ?      
                                      ((void)(RUP_GRD(GRAD_UPDATE_TIME+tlead+IMax(2,(48+pw_gzrf0a),rffrequency_length[bd_index]-rfupa-psd_rf_wait))), ir_start) : RUP_GRD(GRAD_UPDATE_TIME+tlead+IMax(2,(48+pw_gzrf0a),rffrequency_length[bd_index]-rfupa-psd_rf_wait)); 

        irk_start  = _irk_start.fixedflag ?      ((void)(RUP_GRD(ir_start+pw_rf0+pw_gyk0a)), irk_start) : RUP_GRD(ir_start+pw_rf0+pw_gyk0a);

        if (t1flair_flag == PSD_ON)
        {
            /* t1flair, pack the IR and the gradient killer as close as possible */
            ir_time  = _ir_time.fixedflag ?          
                                             ((void)(RUP_GRD((ir_on)*(GRAD_UPDATE_TIME+(int)tlead+pw_gzrf0a+pw_rf0+IMax(2,pw_gzrf0d,pw_gyk0a)+pw_gyk0+pw_gyk0d))), ir_time) : RUP_GRD((ir_on)*(GRAD_UPDATE_TIME+(int)tlead+pw_gzrf0a+pw_rf0+IMax(2,pw_gzrf0d,pw_gyk0a)+pw_gyk0+pw_gyk0d));
        }
        else
        {
            ir_time   = _ir_time.fixedflag ?       
                                                
                                           
                                                       ((void)(RUP_GRD((ir_on)*(opti+pw_gzrf0a+hrf0-cs_sattime-sp_sattime-satdelay-(hrf1a+IMax(2,pw_gzrf1a,DAB_length[bd_index]+rffrequency_length[bd_index]-rfupa))))), ir_time) : RUP_GRD((ir_on)*(opti+pw_gzrf0a+hrf0-cs_sattime-sp_sattime-satdelay-(hrf1a+IMax(2,pw_gzrf1a,DAB_length[bd_index]+rffrequency_length[bd_index]-rfupa)))); /* vmx 3/13/95 YI */
        }

        ir_time_total  = _ir_time_total.fixedflag ?          ((void)(RUP_GRD((ir_on)*(opti+pw_gzrf0a+hrf0-t_exa))), ir_time_total) : RUP_GRD((ir_on)*(opti+pw_gzrf0a+hrf0-t_exa));

        /* The interval between two pulses in the inversion pulse chain.  
           The default value is tmin in all cases.  If the value needs to change
           for certain specific application, change the value in the psd code.
           The change must happen posterior to InversionEval in order to make
           the change in the psd take effect - HS, 30/Aug/2012. */
        irinterval  = _irinterval.fixedflag ?  ((void)(tmin), irinterval) : tmin;
    } /* End of code inlined from Inversion.e InversionEval */

 
    non_tetime  = _non_tetime.fixedflag ?      ((void)(non_tetime+ir_time+satdelay), non_tetime) : non_tetime+ir_time+satdelay;
  

    tmin  = _tmin.fixedflag ?    ((void)(te_time+non_tetime), tmin) : te_time+non_tetime;
  
    /* Imgtimutil calculates actual tr for 
       normal scans, available portion of R-R
       interval for imaging for cardiac scans.
       First parameter is only used if the scan
       is cardiac gated. */
  
    premid_rf90  = _premid_rf90.fixedflag ?       ((void)(optdel1-psd_card_hdwr_delay-td0), premid_rf90) : optdel1-psd_card_hdwr_delay-td0;
    if (imgtimutil(premid_rf90, seq_type, gating, 
                   _avail_image_time.fixedflag ? (_temp542_avail_image_time=avail_image_time,&_temp542_avail_image_time) : &avail_image_time)==FAILURE)
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "imgtimutil");
    else 
        act_tr  = _act_tr.fixedflag ?   ((void)(avail_image_time), act_tr) : avail_image_time;
  
    /* Image time util returns the time available for slices.
       If cardiac, imgtimutil subtracts off the cardiac trigger delay.
    */
  
    if (existcv(opcgate) && (opcgate == PSD_ON)) {
        /* act_tr is used in powermon routines */
        act_tr  = _act_tr.fixedflag ?  
                                 ((void)(RUP_GRD((int)((float)(exist(ophrep))*(60.0/exist(ophrate))*1e6))), act_tr) : RUP_GRD((int)((float)(exist(ophrep))*(60.0/exist(ophrate))*1e6));
    }
  
/* Start inline from touch.e TouchTRCalc */
if( touch_flag )
{
    int touch_burst_per_tr;

    /* TR needs to be dividable by driver cycles, calculate cycles based
     * on the given TR  */
    touch_burst_count  = _touch_burst_count.fixedflag ?   ((void)(ceil((double)act_tr/(double)slquant1/(double)touch_period_motion)), touch_burst_count) : ceil((double)act_tr/(double)slquant1/(double)touch_period_motion);
    touch_burst_per_tr = touch_burst_count * slquant1;
    act_tr  = _act_tr.fixedflag ?    ((void)(RUP_GRD(touch_burst_per_tr*touch_period_motion)), act_tr) : RUP_GRD(touch_burst_per_tr*touch_period_motion);
    pitouchcycnub=0;
    pideftouchcyc = touch_burst_count;
    avmaxtouchcyc = touch_burst_count;
    avmintouchcyc = touch_burst_count;
    cvoverride(optouchcyc, touch_burst_count, PSD_FIX_ON, PSD_EXIST_ON);
    pitouchcyc = touch_burst_count;
}
else
{
    pitouchcyc = 0;
}
/* End inline from touch.e TouchTRCalc */


    act_tr  = _act_tr.fixedflag ?  ((void)(RUP_HRD(act_tr)), act_tr) : RUP_HRD(act_tr);
    avail_image_time  = _avail_image_time.fixedflag ?  ((void)(RUP_HRD(avail_image_time)), avail_image_time) : RUP_HRD(avail_image_time);
  
    rhptsize  = _rhptsize.fixedflag ?  ((void)(exist(opptsize)), rhptsize) : exist(opptsize);
  
    /* BJM: MRIge60610 */
    /* MRIge92386 */
    if(num_overscan > 0) {
        rhnframes  = _rhnframes.fixedflag ?    ((void)((short)(ceilf((float)exist(opyres)*asset_factor/rup_factor)*rup_factor*fn*nop-ky_offset)), rhnframes) : (short)(ceilf((float)exist(opyres)*asset_factor/rup_factor)*rup_factor*fn*nop-ky_offset);
    } else {
        rhnframes  = _rhnframes.fixedflag ?  ((void)((short)(ceilf((float)exist(opyres)*asset_factor/rup_factor)*rup_factor*fn*nop)), rhnframes) : (short)(ceilf((float)exist(opyres)*asset_factor/rup_factor)*rup_factor*fn*nop);
    }

    /* internref: iref_frames */
    iref_frames  = _iref_frames.fixedflag ?    ((void)(iref_etl*intleaves), iref_frames) : iref_etl*intleaves;

    if (rawdata) {
        slice_size  = _slice_size.fixedflag ?  
            ((void)((1+baseline+rhnframes+rhhnover+iref_frames)*2*rhptsize*rhfrsize*nex*exist(opnecho)), slice_size) : (1+baseline+rhnframes+rhhnover+iref_frames)*2*rhptsize*rhfrsize*nex*exist(opnecho);
    } else {
        slice_size  = _slice_size.fixedflag ?  
            ((void)((1+rhnframes+rhhnover+iref_frames)*2*rhptsize*rhfrsize*exist(opnecho)), slice_size) : (1+rhnframes+rhhnover+iref_frames)*2*rhptsize*rhfrsize*exist(opnecho);
    }
  
    rhdayres  = _rhdayres.fixedflag ?        ((void)(rhnframes+rhhnover+iref_frames+1), rhdayres) : rhnframes+rhhnover+iref_frames+1;
    if (exist(opxres) > 256 && exist(opxres) <= 512)
        rhimsize  = _rhimsize.fixedflag ?  ((void)(512), rhimsize) : 512;
    else
        rhimsize  = _rhimsize.fixedflag ?  ((void)(256), rhimsize) : 256;

    /* internref: rhcv calculations */
    if( ky_dir == PSD_BOTTOM_UP ){
        rhextra_frames_top  = _rhextra_frames_top.fixedflag ?  ((void)(0), rhextra_frames_top) : 0;
        rhextra_frames_bot  = _rhextra_frames_bot.fixedflag ?  ((void)(iref_frames), rhextra_frames_bot) : iref_frames;
        rhpc_ref_start  = _rhpc_ref_start.fixedflag ?      ((void)(rhdayres-intleaves-1), rhpc_ref_start) : rhdayres-intleaves-1;
        rhpc_ref_stop  = _rhpc_ref_stop.fixedflag ?      ((void)(rhdayres-iref_frames+intleaves), rhpc_ref_stop) : rhdayres-iref_frames+intleaves;
    }else if( ky_dir == PSD_TOP_DOWN ){
        rhextra_frames_top  = _rhextra_frames_top.fixedflag ?  ((void)(iref_frames), rhextra_frames_top) : iref_frames;
        rhextra_frames_bot  = _rhextra_frames_bot.fixedflag ?  ((void)(0), rhextra_frames_bot) : 0;
        rhpc_ref_start  = _rhpc_ref_start.fixedflag ?    ((void)(intleaves+1), rhpc_ref_start) : intleaves+1;
        rhpc_ref_stop  = _rhpc_ref_stop.fixedflag ?    ((void)(iref_frames-intleaves), rhpc_ref_stop) : iref_frames-intleaves;
    }

    /* prepare for maxslquanttps calculation */
    opslquant_old  = _opslquant_old.fixedflag ?  ((void)(opslquant), opslquant_old) : opslquant;
    if ( mph_flag == PSD_ON ) {
        if (acqmode == 0)
            opslquant  = _opslquant.fixedflag ?  ((void)(opslquant_old), opslquant) : opslquant_old;
        else if (acqmode == 1)
            opslquant  = _opslquant.fixedflag ?  ((void)(exist(opfphases)), opslquant) : exist(opfphases);
    }
  
    if (maxslquanttps(_max_bamslice.fixedflag ? (_temp543_max_bamslice=max_bamslice,&_temp543_max_bamslice) : &max_bamslice, (int)rhimsize, slice_size, 1, NULL) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "maxslquanttps");
        return FAILURE; /* MRIhc24685: Added return Failure to avoid warnings being printed on the scan window. */
    }

    /* return opslquant to its original value */
    opslquant  = _opslquant.fixedflag ?  ((void)(opslquant_old), opslquant) : opslquant_old;
  
    ta_gxwn  = _ta_gxwn.fixedflag ?  ((void)((-1.0)*a_gxw), ta_gxwn) : (-1.0)*a_gxw;
    gradx[GXWP_SLOT].num = etl/2+(iref_etl/2+iref_etl%2);
    gradx[GXWN_SLOT].num = (etl+1)/2+iref_etl/2;
    gradx[GXWN_SLOT].amp = _ta_gxwn.fixedflag ? (_temp544_ta_gxwn=ta_gxwn,&_temp544_ta_gxwn) : &ta_gxwn;
    grady[GY1_SLOT].num = 1;
    grady[GY_BLIP_SLOT].num = etl - 1;
  
    if (eoskillers == PSD_ON) {
        gradx[GXK_SLOT].num = ((eosxkiller==1) ? 1 : 0);
        grady[GYK_SLOT].num = ((eosykiller==1) ? 1 : 0);
        gradz[GZK_SLOT].num = ((eoszkiller==1) ? 1 : 0);
    } else {
        gradx[GXK_SLOT].num = 0;
        grady[GYK_SLOT].num = 0;
        gradz[GZK_SLOT].num = 0;
    }
  
    grady[GY1_SLOT].ptype = G_TRAP;
    grady[GY1_SLOT].attack = _pw_gy1a.fixedflag ? (_temp545_pw_gy1a=pw_gy1a,&_temp545_pw_gy1a) : &pw_gy1a;
    grady[GY1_SLOT].decay = _pw_gy1d.fixedflag ? (_temp546_pw_gy1d=pw_gy1d,&_temp546_pw_gy1d) : &pw_gy1d;
    grady[GY1_SLOT].pw = _pw_gy1.fixedflag ? (_temp547_pw_gy1=pw_gy1,&_temp547_pw_gy1) : &pw_gy1;


    {    /* Code inlined from BroadBand.e BBcveval */

        STATUS status;

        specnuc  = _specnuc.fixedflag ?  ((void)(coilInfo[0].rxNucleus), specnuc) : coilInfo[0].rxNucleus;

        if( !isValidNucleus( specnuc, cffield ) )
        {
            if(cfbbmod == PSD_ON) {
                epic_error(use_ermes,
                           "Choose an allowed value for nucleus excited",
                           EM_PSD_SPEC_NUC_INCOMPATIBLE,0);
            } else {
                epic_error(use_ermes,"Broadband not enabled, set cfbbmod",
                           EM_PSD_BB_SPEC_NOT_AVAILABLE,0);
            }
            return FAILURE;
        }

        if((status = BBcveval(specnuc)) != SUCCESS) {
            return status;
        }

    }    /* End of code inlined from BroadBand.e BBcveval */

/* need 1H for AutoShim - but this is taken care of in BBPrescanS so set to specnuc here SJK */    
specparamset(_GAM.fixedflag ? (_temp548_GAM=GAM,&_temp548_GAM) : &GAM, _pibbandfilt.fixedflag ? (_temp549_pibbandfilt=pibbandfilt,&_temp549_pibbandfilt) : &pibbandfilt, _pixmtband.fixedflag ? (_temp550_pixmtband=pixmtband,&_temp550_pixmtband) : &pixmtband, PSD_PROTON);  
    { /* Start of code inlined from Prescan.e PScveval */
        /*********************************************************************
         *                     PRESCAN.E HOST SECTION                        *
         *                           PScveval                                *
         *                                                                   *
         * Write here the code unique to the Host PSD process. All code to   *
         * be executed in cveval() must be written here.                     *
         *********************************************************************/

        /* MRIhc49539: check current nucleus against coil DB: */
        if(specnuc != coilInfo[0].rxNucleus)
        {
            epic_error(use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "This PSD", STRING_ARG, "the selected coil");
            return FAILURE; 
        }
         
        TGspf  = _TGspf.fixedflag ?        ((void)(((0==getAps1Mod())&&opspf)), TGspf) : ((0==getAps1Mod())&&opspf);
    	read_axis = TGspf ? YGRAD : XGRAD;
        if(read_axis == XGRAD)
        {
            killer_axis = YGRAD;
        }
        else
        {
            killer_axis = XGRAD;
        }

        if (psddebugcode)
        {
            psd_dump_coil_info();
        }

        if (FAILURE==PScveval())
        {
            return FAILURE;
        }
        if (FAILURE==FTGcveval())
        {
            return FAILURE;
        }
        if (FAILURE==XTGcveval())
        {
            return FAILURE;
        }
        if (FAILURE==AScveval())
        {
            return FAILURE;
        }
        if (FAILURE==RGcveval())
        {
            return FAILURE;
        }

    } /* End of code inlined from Prescan.e PScveval */


specparamset(_GAM.fixedflag ? (_temp551_GAM=GAM,&_temp551_GAM) : &GAM, _pibbandfilt.fixedflag ? (_temp552_pibbandfilt=pibbandfilt,&_temp552_pibbandfilt) : &pibbandfilt, _pixmtband.fixedflag ? (_temp553_pixmtband=pixmtband,&_temp553_pixmtband) : &pixmtband, specnuc);


/*jwg BBboardsRho calls for RF pulses go here*/
/*need to add calls for when se_ref = 1 and for a SE scan*/
/*If place these in pulsegen, RHO2 not set correctly*/
/*and prescan freezes up when specnuc != 1*/
BBboardsRho(acquire_type,_wg_rf1.fixedflag ? (_temp554_wg_rf1=wg_rf1,&_temp554_wg_rf1) : &wg_rf1);
BBboardsFreq(acquire_type,_wg_omegarf1.fixedflag ? (_temp555_wg_omegarf1=wg_omegarf1,&_temp555_wg_omegarf1) : &wg_omegarf1); /*used in EFFSLICESELZ_SPSP_JWG*/
BBboardsFreq(acquire_type,_wg_omegaro1.fixedflag ? (_temp556_wg_omegaro1=wg_omegaro1,&_temp556_wg_omegaro1) : &wg_omegaro1); /*used in trapezoid call below*/
if(thetaflag == 1) 
{
	BBboardsPhase(acquire_type, _wg_phaserf1.fixedflag ? (_temp557_wg_phaserf1=wg_phaserf1,&_temp557_wg_phaserf1) : &wg_phaserf1);
}	
BBboardsRho( acquire_type, _wg_rf1mps1.fixedflag ? (_temp558_wg_rf1mps1=wg_rf1mps1,&_temp558_wg_rf1mps1) : &wg_rf1mps1);
BBboardsRho( acquire_type, _wg_rf2mps1.fixedflag ? (_temp559_wg_rf2mps1=wg_rf2mps1,&_temp559_wg_rf2mps1) : &wg_rf2mps1);
BBboardsRho( acquire_type, _wg_rf1cfl.fixedflag ? (_temp560_wg_rf1cfl=wg_rf1cfl,&_temp560_wg_rf1cfl) : &wg_rf1cfl);
BBboardsRho(acquire_type, _wg_rf0cfh.fixedflag ? (_temp561_wg_rf0cfh=wg_rf0cfh,&_temp561_wg_rf0cfh) : &wg_rf0cfh);
BBboardsPhase(acquire_type, _wg_omegarf0cfh.fixedflag ? (_temp562_wg_omegarf0cfh=wg_omegarf0cfh,&_temp562_wg_omegarf0cfh) : &wg_omegarf0cfh);
BBboardsRho(acquire_type, _wg_rf1cfh.fixedflag ? (_temp563_wg_rf1cfh=wg_rf1cfh,&_temp563_wg_rf1cfh) : &wg_rf1cfh);
BBboardsRho(acquire_type, _wg_rf2cfh.fixedflag ? (_temp564_wg_rf2cfh=wg_rf2cfh,&_temp564_wg_rf2cfh) : &wg_rf2cfh);
if( presscfh_ctrl != PRESSCFH_NONE ){ /* for presscfh_ctrl */
  BBboardsRho(acquire_type, _wg_rf3cfh.fixedflag ? (_temp565_wg_rf3cfh=wg_rf3cfh,&_temp565_wg_rf3cfh) : &wg_rf3cfh);
 } 
BBboardsRho(acquire_type, _wg_rf1ftg.fixedflag ? (_temp566_wg_rf1ftg=wg_rf1ftg,&_temp566_wg_rf1ftg) : &wg_rf1ftg);
BBboardsRho(acquire_type, _wg_rf2ftg.fixedflag ? (_temp567_wg_rf2ftg=wg_rf2ftg,&_temp567_wg_rf2ftg) : &wg_rf2ftg);
BBboardsRho(acquire_type, _wg_rf3ftg.fixedflag ? (_temp568_wg_rf3ftg=wg_rf3ftg,&_temp568_wg_rf3ftg) : &wg_rf3ftg);
BBboardsRho(acquire_type, _wg_rf1as.fixedflag ? (_temp569_wg_rf1as=wg_rf1as,&_temp569_wg_rf1as) : &wg_rf1as);
/*jwg end*/  

    /* Set some MRE MEG properties */
/* Start inline from touch.e TouchEvalGrad */
/* Set MEG pulse width and amplitude values. */
if( touch_flag )
{
    gating  = _gating.fixedflag ?  ((void)(TRIG_INTERN), gating) : TRIG_INTERN;

    a_gxtouchu  = _a_gxtouchu.fixedflag ?  ((void)(touch_gamp), a_gxtouchu) : touch_gamp;
    pw_gxtouchu  = _pw_gxtouchu.fixedflag ?  ((void)(touch_pwcon), pw_gxtouchu) : touch_pwcon;
    pw_gxtouchud  = _pw_gxtouchud.fixedflag ?  ((void)(touch_pwramp), pw_gxtouchud) : touch_pwramp;
    pw_gxtouchua  = _pw_gxtouchua.fixedflag ?  ((void)(touch_pwramp), pw_gxtouchua) : touch_pwramp;
    a_gytouchu  = _a_gytouchu.fixedflag ?  ((void)(touch_gamp), a_gytouchu) : touch_gamp;
    pw_gytouchu  = _pw_gytouchu.fixedflag ?  ((void)(touch_pwcon), pw_gytouchu) : touch_pwcon;
    pw_gytouchud  = _pw_gytouchud.fixedflag ?  ((void)(touch_pwramp), pw_gytouchud) : touch_pwramp;
    pw_gytouchua  = _pw_gytouchua.fixedflag ?  ((void)(touch_pwramp), pw_gytouchua) : touch_pwramp;
    a_gztouchu  = _a_gztouchu.fixedflag ?  ((void)(touch_gamp), a_gztouchu) : touch_gamp;
    pw_gztouchu  = _pw_gztouchu.fixedflag ?  ((void)(touch_pwcon), pw_gztouchu) : touch_pwcon;
    pw_gztouchud  = _pw_gztouchud.fixedflag ?  ((void)(touch_pwramp), pw_gztouchud) : touch_pwramp;
    pw_gztouchua  = _pw_gztouchua.fixedflag ?  ((void)(touch_pwramp), pw_gztouchua) : touch_pwramp;

    a_gxtouchd  = _a_gxtouchd.fixedflag ?  ((void)(-touch_gamp), a_gxtouchd) : -touch_gamp;
    pw_gxtouchd  = _pw_gxtouchd.fixedflag ?  ((void)(touch_pwcon), pw_gxtouchd) : touch_pwcon;
    pw_gxtouchdd  = _pw_gxtouchdd.fixedflag ?  ((void)(touch_pwramp), pw_gxtouchdd) : touch_pwramp;
    pw_gxtouchda  = _pw_gxtouchda.fixedflag ?  ((void)(touch_pwramp), pw_gxtouchda) : touch_pwramp;
    a_gytouchd  = _a_gytouchd.fixedflag ?  ((void)(-touch_gamp), a_gytouchd) : -touch_gamp;
    pw_gytouchd  = _pw_gytouchd.fixedflag ?  ((void)(touch_pwcon), pw_gytouchd) : touch_pwcon;
    pw_gytouchdd  = _pw_gytouchdd.fixedflag ?  ((void)(touch_pwramp), pw_gytouchdd) : touch_pwramp;
    pw_gytouchda  = _pw_gytouchda.fixedflag ?  ((void)(touch_pwramp), pw_gytouchda) : touch_pwramp;
    a_gztouchd  = _a_gztouchd.fixedflag ?  ((void)(-touch_gamp), a_gztouchd) : -touch_gamp;
    pw_gztouchd  = _pw_gztouchd.fixedflag ?  ((void)(touch_pwcon), pw_gztouchd) : touch_pwcon;
    pw_gztouchdd  = _pw_gztouchdd.fixedflag ?  ((void)(touch_pwramp), pw_gztouchdd) : touch_pwramp;
    pw_gztouchda  = _pw_gztouchda.fixedflag ?  ((void)(touch_pwramp), pw_gztouchda) : touch_pwramp;

    if( touch_fcomp == 1 )
    {
        a_gxtouchf  = _a_gxtouchf.fixedflag ?   ((void)(touch_gamp/2), a_gxtouchf) : touch_gamp/2;
        pw_gxtouchf  = _pw_gxtouchf.fixedflag ?  ((void)(touch_pwcon), pw_gxtouchf) : touch_pwcon;
        pw_gxtouchfd  = _pw_gxtouchfd.fixedflag ?  ((void)(touch_pwramp), pw_gxtouchfd) : touch_pwramp;
        pw_gxtouchfa  = _pw_gxtouchfa.fixedflag ?  ((void)(touch_pwramp), pw_gxtouchfa) : touch_pwramp;
        a_gytouchf  = _a_gytouchf.fixedflag ?   ((void)(touch_gamp/2), a_gytouchf) : touch_gamp/2;
        pw_gytouchf  = _pw_gytouchf.fixedflag ?  ((void)(touch_pwcon), pw_gytouchf) : touch_pwcon;
        pw_gytouchfd  = _pw_gytouchfd.fixedflag ?  ((void)(touch_pwramp), pw_gytouchfd) : touch_pwramp;
        pw_gytouchfa  = _pw_gytouchfa.fixedflag ?  ((void)(touch_pwramp), pw_gytouchfa) : touch_pwramp;
        a_gztouchf  = _a_gztouchf.fixedflag ?   ((void)(touch_gamp/2), a_gztouchf) : touch_gamp/2;
        pw_gztouchf  = _pw_gztouchf.fixedflag ?  ((void)(touch_pwcon), pw_gztouchf) : touch_pwcon;
        pw_gztouchfd  = _pw_gztouchfd.fixedflag ?  ((void)(touch_pwramp), pw_gztouchfd) : touch_pwramp;
        pw_gztouchfa  = _pw_gztouchfa.fixedflag ?  ((void)(touch_pwramp), pw_gztouchfa) : touch_pwramp;
    }
    else if( touch_fcomp == 2 )
    {
        a_gxtouchf  = _a_gxtouchf.fixedflag ?  ((void)(touch_gamp), a_gxtouchf) : touch_gamp;
        pw_gxtouchf  = _pw_gxtouchf.fixedflag ?   ((void)(touch_pwcon/2), pw_gxtouchf) : touch_pwcon/2;
        pw_gxtouchfd  = _pw_gxtouchfd.fixedflag ?   ((void)(touch_pwramp/2), pw_gxtouchfd) : touch_pwramp/2;
        pw_gxtouchfa  = _pw_gxtouchfa.fixedflag ?   ((void)(touch_pwramp/2), pw_gxtouchfa) : touch_pwramp/2;
        a_gytouchf  = _a_gytouchf.fixedflag ?  ((void)(touch_gamp), a_gytouchf) : touch_gamp;
        pw_gytouchf  = _pw_gytouchf.fixedflag ?   ((void)(touch_pwcon/2), pw_gytouchf) : touch_pwcon/2;
        pw_gytouchfd  = _pw_gytouchfd.fixedflag ?   ((void)(touch_pwramp/2), pw_gytouchfd) : touch_pwramp/2;
        pw_gytouchfa  = _pw_gytouchfa.fixedflag ?   ((void)(touch_pwramp/2), pw_gytouchfa) : touch_pwramp/2;
        a_gztouchf  = _a_gztouchf.fixedflag ?  ((void)(touch_gamp), a_gztouchf) : touch_gamp;
        pw_gztouchf  = _pw_gztouchf.fixedflag ?   ((void)(touch_pwcon/2), pw_gztouchf) : touch_pwcon/2;
        pw_gztouchfd  = _pw_gztouchfd.fixedflag ?   ((void)(touch_pwramp/2), pw_gztouchfd) : touch_pwramp/2;
        pw_gztouchfa  = _pw_gztouchfa.fixedflag ?   ((void)(touch_pwramp/2), pw_gztouchfa) : touch_pwramp/2;
    }

    /* 2nd set of MEGs for after RF2 */
    a_gxtouchu2  = _a_gxtouchu2.fixedflag ?  ((void)(touch_gamp), a_gxtouchu2) : touch_gamp;
    pw_gxtouchu2  = _pw_gxtouchu2.fixedflag ?  ((void)(touch_pwcon), pw_gxtouchu2) : touch_pwcon;
    pw_gxtouchu2d  = _pw_gxtouchu2d.fixedflag ?  ((void)(touch_pwramp), pw_gxtouchu2d) : touch_pwramp;
    pw_gxtouchu2a  = _pw_gxtouchu2a.fixedflag ?  ((void)(touch_pwramp), pw_gxtouchu2a) : touch_pwramp;
    a_gytouchu2  = _a_gytouchu2.fixedflag ?  ((void)(touch_gamp), a_gytouchu2) : touch_gamp;
    pw_gytouchu2  = _pw_gytouchu2.fixedflag ?  ((void)(touch_pwcon), pw_gytouchu2) : touch_pwcon;
    pw_gytouchu2d  = _pw_gytouchu2d.fixedflag ?  ((void)(touch_pwramp), pw_gytouchu2d) : touch_pwramp;
    pw_gytouchu2a  = _pw_gytouchu2a.fixedflag ?  ((void)(touch_pwramp), pw_gytouchu2a) : touch_pwramp;
    a_gztouchu2  = _a_gztouchu2.fixedflag ?  ((void)(touch_gamp), a_gztouchu2) : touch_gamp;
    pw_gztouchu2  = _pw_gztouchu2.fixedflag ?  ((void)(touch_pwcon), pw_gztouchu2) : touch_pwcon;
    pw_gztouchu2d  = _pw_gztouchu2d.fixedflag ?  ((void)(touch_pwramp), pw_gztouchu2d) : touch_pwramp;
    pw_gztouchu2a  = _pw_gztouchu2a.fixedflag ?  ((void)(touch_pwramp), pw_gztouchu2a) : touch_pwramp;

    a_gxtouchd2  = _a_gxtouchd2.fixedflag ?  ((void)(-touch_gamp), a_gxtouchd2) : -touch_gamp;
    pw_gxtouchd2  = _pw_gxtouchd2.fixedflag ?  ((void)(touch_pwcon), pw_gxtouchd2) : touch_pwcon;
    pw_gxtouchd2d  = _pw_gxtouchd2d.fixedflag ?  ((void)(touch_pwramp), pw_gxtouchd2d) : touch_pwramp;
    pw_gxtouchd2a  = _pw_gxtouchd2a.fixedflag ?  ((void)(touch_pwramp), pw_gxtouchd2a) : touch_pwramp;
    a_gytouchd2  = _a_gytouchd2.fixedflag ?  ((void)(-touch_gamp), a_gytouchd2) : -touch_gamp;
    pw_gytouchd2  = _pw_gytouchd2.fixedflag ?  ((void)(touch_pwcon), pw_gytouchd2) : touch_pwcon;
    pw_gytouchd2d  = _pw_gytouchd2d.fixedflag ?  ((void)(touch_pwramp), pw_gytouchd2d) : touch_pwramp;
    pw_gytouchd2a  = _pw_gytouchd2a.fixedflag ?  ((void)(touch_pwramp), pw_gytouchd2a) : touch_pwramp;
    a_gztouchd2  = _a_gztouchd2.fixedflag ?  ((void)(-touch_gamp), a_gztouchd2) : -touch_gamp;
    pw_gztouchd2  = _pw_gztouchd2.fixedflag ?  ((void)(touch_pwcon), pw_gztouchd2) : touch_pwcon;
    pw_gztouchd2d  = _pw_gztouchd2d.fixedflag ?  ((void)(touch_pwramp), pw_gztouchd2d) : touch_pwramp;
    pw_gztouchd2a  = _pw_gztouchd2a.fixedflag ?  ((void)(touch_pwramp), pw_gztouchd2a) : touch_pwramp;

    if( touch_fcomp == 1 )
    {
        a_gxtouchf2  = _a_gxtouchf2.fixedflag ?   ((void)(touch_gamp/2), a_gxtouchf2) : touch_gamp/2;
        pw_gxtouchf2  = _pw_gxtouchf2.fixedflag ?  ((void)(touch_pwcon), pw_gxtouchf2) : touch_pwcon;
        pw_gxtouchf2d  = _pw_gxtouchf2d.fixedflag ?  ((void)(touch_pwramp), pw_gxtouchf2d) : touch_pwramp;
        pw_gxtouchf2a  = _pw_gxtouchf2a.fixedflag ?  ((void)(touch_pwramp), pw_gxtouchf2a) : touch_pwramp;
        a_gytouchf2  = _a_gytouchf2.fixedflag ?   ((void)(touch_gamp/2), a_gytouchf2) : touch_gamp/2;
        pw_gytouchf2  = _pw_gytouchf2.fixedflag ?  ((void)(touch_pwcon), pw_gytouchf2) : touch_pwcon;
        pw_gytouchf2d  = _pw_gytouchf2d.fixedflag ?  ((void)(touch_pwramp), pw_gytouchf2d) : touch_pwramp;
        pw_gytouchf2a  = _pw_gytouchf2a.fixedflag ?  ((void)(touch_pwramp), pw_gytouchf2a) : touch_pwramp;
        a_gztouchf2  = _a_gztouchf2.fixedflag ?   ((void)(touch_gamp/2), a_gztouchf2) : touch_gamp/2;
        pw_gztouchf2  = _pw_gztouchf2.fixedflag ?  ((void)(touch_pwcon), pw_gztouchf2) : touch_pwcon;
        pw_gztouchf2d  = _pw_gztouchf2d.fixedflag ?  ((void)(touch_pwramp), pw_gztouchf2d) : touch_pwramp;
        pw_gztouchf2a  = _pw_gztouchf2a.fixedflag ?  ((void)(touch_pwramp), pw_gztouchf2a) : touch_pwramp;
    }
    else if( touch_fcomp == 2 )
    {
        a_gxtouchf2  = _a_gxtouchf2.fixedflag ?  ((void)(touch_gamp), a_gxtouchf2) : touch_gamp;
        pw_gxtouchf2  = _pw_gxtouchf2.fixedflag ?   ((void)(touch_pwcon/2), pw_gxtouchf2) : touch_pwcon/2;
        pw_gxtouchf2d  = _pw_gxtouchf2d.fixedflag ?   ((void)(touch_pwramp/2), pw_gxtouchf2d) : touch_pwramp/2;
        pw_gxtouchf2a  = _pw_gxtouchf2a.fixedflag ?   ((void)(touch_pwramp/2), pw_gxtouchf2a) : touch_pwramp/2;
        a_gytouchf2  = _a_gytouchf2.fixedflag ?  ((void)(touch_gamp), a_gytouchf2) : touch_gamp;
        pw_gytouchf2  = _pw_gytouchf2.fixedflag ?   ((void)(touch_pwcon/2), pw_gytouchf2) : touch_pwcon/2;
        pw_gytouchf2d  = _pw_gytouchf2d.fixedflag ?   ((void)(touch_pwramp/2), pw_gytouchf2d) : touch_pwramp/2;
        pw_gytouchf2a  = _pw_gytouchf2a.fixedflag ?   ((void)(touch_pwramp/2), pw_gytouchf2a) : touch_pwramp/2;
        a_gztouchf2  = _a_gztouchf2.fixedflag ?  ((void)(touch_gamp), a_gztouchf2) : touch_gamp;
        pw_gztouchf2  = _pw_gztouchf2.fixedflag ?   ((void)(touch_pwcon/2), pw_gztouchf2) : touch_pwcon/2;
        pw_gztouchf2d  = _pw_gztouchf2d.fixedflag ?   ((void)(touch_pwramp/2), pw_gztouchf2d) : touch_pwramp/2;
        pw_gztouchf2a  = _pw_gztouchf2a.fixedflag ?   ((void)(touch_pwramp/2), pw_gztouchf2a) : touch_pwramp/2;
    }

    if( opphysplane != PSD_OBL )
    {
        gradx[TOUCH_GXU_SLOT].powscale = 1.0;
        gradx[TOUCH_GXD_SLOT].powscale = 1.0;
        gradx[TOUCH_GXF_SLOT].powscale = 1.0;
        grady[TOUCH_GYU_SLOT].powscale = 1.0;
        grady[TOUCH_GYD_SLOT].powscale = 1.0;
        grady[TOUCH_GYF_SLOT].powscale = 1.0;
        gradz[TOUCH_GZU_SLOT].powscale = 1.0;
        gradz[TOUCH_GZD_SLOT].powscale = 1.0;
        gradz[TOUCH_GZF_SLOT].powscale = 1.0;
        gradx[TOUCH_GXU2_SLOT].powscale = 1.0;
        gradx[TOUCH_GXD2_SLOT].powscale = 1.0;
        gradx[TOUCH_GXF2_SLOT].powscale = 1.0;
        grady[TOUCH_GYU2_SLOT].powscale = 1.0;
        grady[TOUCH_GYD2_SLOT].powscale = 1.0;
        grady[TOUCH_GYF2_SLOT].powscale = 1.0;
        gradz[TOUCH_GZU2_SLOT].powscale = 1.0;
        gradz[TOUCH_GZD2_SLOT].powscale = 1.0;
        gradz[TOUCH_GZF2_SLOT].powscale = 1.0;
    }
    else
    {
        float touch_powscale_factor;

        /* touch_powscale_factor = touch_gamp; */
        touch_powscale_factor = touch_target;

        gradx[TOUCH_GXU_SLOT].powscale = loggrd.xfs/ touch_powscale_factor;
        gradx[TOUCH_GXD_SLOT].powscale = loggrd.xfs/ touch_powscale_factor;
        gradx[TOUCH_GXF_SLOT].powscale = loggrd.xfs/ touch_powscale_factor;
        grady[TOUCH_GYU_SLOT].powscale = loggrd.yfs/ touch_powscale_factor;
        grady[TOUCH_GYD_SLOT].powscale = loggrd.yfs/ touch_powscale_factor;
        grady[TOUCH_GYF_SLOT].powscale = loggrd.yfs/ touch_powscale_factor;
        gradz[TOUCH_GZU_SLOT].powscale = loggrd.zfs/ touch_powscale_factor;
        gradz[TOUCH_GZD_SLOT].powscale = loggrd.zfs/ touch_powscale_factor;
        gradz[TOUCH_GZF_SLOT].powscale = loggrd.zfs/ touch_powscale_factor;
        gradx[TOUCH_GXU2_SLOT].powscale = loggrd.xfs/ touch_powscale_factor;
        gradx[TOUCH_GXD2_SLOT].powscale = loggrd.xfs/ touch_powscale_factor;
        gradx[TOUCH_GXF2_SLOT].powscale = loggrd.xfs/ touch_powscale_factor;
        grady[TOUCH_GYU2_SLOT].powscale = loggrd.yfs/ touch_powscale_factor;
        grady[TOUCH_GYD2_SLOT].powscale = loggrd.yfs/ touch_powscale_factor;
        grady[TOUCH_GYF2_SLOT].powscale = loggrd.yfs/ touch_powscale_factor;
        gradz[TOUCH_GZU2_SLOT].powscale = loggrd.zfs/ touch_powscale_factor;
        gradz[TOUCH_GZD2_SLOT].powscale = loggrd.zfs/ touch_powscale_factor;
        gradz[TOUCH_GZF2_SLOT].powscale = loggrd.zfs/ touch_powscale_factor;
    }
}
/* End inline from touch.e TouchEvalGrad */


    /* Gradient driver and coil heating calculations */
    if (exist(opplane) != PSD_OBL) {
        gradx[GX1_SLOT].powscale = 1.0;
        gradx[GXWP_SLOT].powscale = 1.0;
        gradx[GXWN_SLOT].powscale = 1.0;
        gradx[GXK_SLOT].powscale = 1.0;
        grady[GY1_SLOT].powscale = 1.0;
        grady[GY_BLIP_SLOT].powscale = 1.0;
        grady[GYK_SLOT].powscale = 1.0;
        grady[GYKCS_SLOT].powscale = 1.0;
        grady[GYRF2IV_SLOT].powscale = 1.0;
        grady[GYK0_SLOT].powscale = 1.0;
        gradz[GZRF1_SLOT].powscale = 1.0;
        gradz[GZRF2L1_SLOT].powscale = 1.0;
        gradz[GZRF2R1_SLOT].powscale = 1.0;
        gradz[GZRF2_SLOT].powscale = 1.0;
        gradz[GZRF0_SLOT].powscale = 1.0;
        gradz[GZK_SLOT].powscale = 1.0;
        gradz[GZ1_SLOT].powscale = 1.0;
        gradz[GZMN_SLOT].powscale = 1.0;
    } else {
        gradx[GX1_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
        gradx[GXWP_SLOT].powscale = loggrd.xfs/loggrd.tx_xy;
        gradx[GXWN_SLOT].powscale = loggrd.xfs/loggrd.tx_xy;
        gradx[GXK_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
        grady[GY1_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;
        grady[GY_BLIP_SLOT].powscale = loggrd.yfs/loggrd.ty_xy;
        grady[GYK_SLOT].powscale     = loggrd.yfs/loggrd.ty_xyz;
        grady[GYK0_SLOT].powscale    = loggrd.yfs/loggrd.ty_xyz;
        grady[GYKCS_SLOT].powscale   = loggrd.yfs/loggrd.ty_xyz;
        grady[GYRF2IV_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;
        gradz[GZRF1_SLOT].powscale = loggrd.yfs/loggrd.tz;
        gradz[GZRF2L1_SLOT].powscale = loggrd.yfs/loggrd.tz_xyz;
        gradz[GZRF2R1_SLOT].powscale = loggrd.yfs/loggrd.tz_xyz;
        gradz[GZRF2_SLOT].powscale   = loggrd.yfs/loggrd.tz_xyz;
        gradz[GZRF0_SLOT].powscale   = loggrd.zfs/loggrd.tz_xyz;
        gradz[GZK_SLOT].powscale     = loggrd.zfs/loggrd.tz_xyz;
        gradz[GZ1_SLOT].powscale     = loggrd.zfs/loggrd.tz_xyz;
        gradz[GZMN_SLOT].powscale    = loggrd.zfs/loggrd.tz_xyz;
    }
  
 
    /* RF Pulse Scaling (to peak B1)  ************************/
    /* First, find the peak B1 for the whole sequence. */
   if (findMaxB1Seq(&maxB1Seq, maxB1, MAX_ENTRY_POINTS, rfpulse, RF_FREE) == FAILURE)
   {
   	epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"findMaxB1Seq");
	return FAILURE;
   }
  
    /* Throw in an extra scale factor to account for xmtadd. */
    if (setScale(L_SCAN, RF_FREE, rfpulse, maxB1[L_SCAN],
                 maxB1[L_SCAN]/maxB1Seq) == FAILURE) {
        epic_error( use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                    EE_ARGS(1), STRING_ARG, "setScale" );
        return FAILURE;
    }
  
    minseqcoil_esp  = _minseqcoil_esp.fixedflag ?  ((void)(esp), minseqcoil_esp) : esp;     /* MRIhc16090 */ 
    /* Perform gradient safety checks for main sequence (idx_seqcore) */

    seqEntryIndex  = _seqEntryIndex.fixedflag ?  ((void)(idx_seqcore), seqEntryIndex) : idx_seqcore;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp570_min_seqgrad=min_seqgrad,&_temp570_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, seqEntryIndex, tsamp,
                            avail_image_time,
                            use_ermes, seg_debug ) ) 
    {
        epic_error( use_ermes, "%s failed.", EM_PSD_ROUTINE_FAILURE,
                    EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
  
    /* RF amp, SAR, and system limitations on seq time */
    if (minseqrfamp_b1scale(_min_seqrfamp.fixedflag ? (_temp571_min_seqrfamp=min_seqrfamp,&_temp571_min_seqrfamp) : &min_seqrfamp,(int)RF_FREE,rfpulse, 
                            L_SCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "minseqrfamp_b1scale");
        return FAILURE;
    }
  
    /* Note: this routine still uses the old coefficients */
    if (maxslicesar_b1scale(_max_slicesar.fixedflag ? (_temp572_max_slicesar=max_slicesar,&_temp572_max_slicesar) : &max_slicesar, (int)RF_FREE,rfpulse, 
                            L_SCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "maxslicesar_b1scale");
        return FAILURE;
    }
    
    /* Calculate minimum sequence time based on coil, gradient driver,
       GRAM, pulse width modulation, RF amplifier, and playout */

  if( (PSD_XRMB_COIL != cfgcoiltype) && (PSD_XRMW_COIL != cfgcoiltype) ) 
  {    
    if( (mph_flag == PSD_ON) && ((opfphases * opslquant) > 2048) ) 
    {
        float drf = 1.0;

        drf = (-0.0009*(esp)+ 2.29)/1.25;
        if (drf < 1.0) {
            drf = 1.0;
        }

        if ( exist(opresearch) == PSD_ON ) {
            FILE *fp = NULL;

            if ((fp=fopen("/usr/g/bin/.fmri_research", "r")) !=NULL) {
                drf = 1.0;
                fclose(fp);
            }         
        } 
        fmri_coil_limit  = _fmri_coil_limit.fixedflag ?  ((void)((INT)minseqcoil_t*drf), fmri_coil_limit) : (INT)minseqcoil_t*drf;
    } else {
        fmri_coil_limit  = _fmri_coil_limit.fixedflag ?  ((void)(0), fmri_coil_limit) : 0;
    }
  }
  else /* MRIhc27495: fmri_coil_limit is required only for pre XRM systems*/     
  {
	 fmri_coil_limit  = _fmri_coil_limit.fixedflag ?  ((void)(0), fmri_coil_limit) : 0;
  }

    
    tmin_total  = _tmin_total.fixedflag ?         ((void)(IMax(5,fmri_coil_limit,min_seqgrad,min_seqrfamp,tmin,saved_tmin_total)), tmin_total) : IMax(5,fmri_coil_limit,min_seqgrad,min_seqrfamp,tmin,saved_tmin_total);

    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "min_seqgrad = %d\n", min_seqgrad );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "min_seqrfamp = %d\n", min_seqrfamp );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "tmin = %d\n", tmin );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "fmri coil limit = %d\n", fmri_coil_limit);
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "tmin_total = %d\n", tmin_total );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "fps = %f\n", (float)optr/tmin_total);


    /* Used for cardiac intersequence time.  Round up to integer number of ms
     * but report to scan in us. */
    avmintseq = tmin_total;
    advroundup(&avmintseq);
    if ((exist(opcgate) == PSD_ON) && existcv(opcgate)) {
        advroundup(_tmin_total.fixedflag ? (_temp573_tmin_total=tmin_total,&_temp573_tmin_total) : &tmin_total); /* this is the min seq time cardiac
                                    can run at.
                                    Needed for adv. panel validity until all 
                                    cardiac buttons exist. */
        if (existcv(opcardseq)) {
            switch (exist(opcardseq)) {
            case PSD_CARD_INTER_MIN:
                psd_tseq  = _psd_tseq.fixedflag ?  ((void)(avmintseq), psd_tseq) : avmintseq;
                tmin_total  = _tmin_total.fixedflag ?  ((void)(avmintseq), tmin_total) : avmintseq;
                break;
            case PSD_CARD_INTER_OTHER:
                psd_tseq  = _psd_tseq.fixedflag ?  ((void)(optseq), psd_tseq) : optseq;
                if (optseq > tmin_total)
                    tmin_total  = _tmin_total.fixedflag ?  ((void)(optseq), tmin_total) : optseq;
                break;
            case PSD_CARD_INTER_EVEN:
                /* Roundup tmin_total for the routines ahead. */
                advroundup(_tmin_total.fixedflag ? (_temp574_tmin_total=tmin_total,&_temp574_tmin_total) : &tmin_total);
                break;
            }
        }	else {
            psd_tseq  = _psd_tseq.fixedflag ?  ((void)(avmintseq), psd_tseq) : avmintseq;
        }
    }
    other_slice_limit  = _other_slice_limit.fixedflag ?    ((void)(IMin(2,max_slicesar,max_bamslice)), other_slice_limit) : IMin(2,max_slicesar,max_bamslice);
  
    if (maxphases(&av_temp_int, tmin_total, seq_type,
                  other_slice_limit) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "maxphases");
        return FAILURE;
    }
  
    if (maxslquant(&av_temp_int, avail_image_time, other_slice_limit,
                   seq_type, tmin_total) == FAILURE) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "maxslquant");
        return FAILURE;
    }


    if (exist(opirmode) == PSD_SEQMODE_ON)
        avmaxslquant = 1;
    else {
        if (opautotr == PSD_ON)
            avmaxslquant = SLTAB_MAX;
    }

    /* YMSmr06515: # of slice locations expansion */
    if(avmaxslquant > MAX_SLICES_PER_PASS){
        avmaxslquant = MAX_SLICES_PER_PASS;
    }
  
    
    temp_maxslquant = avmaxslquant; 
    if (maxpass(_acqs.fixedflag ? (_temp575_acqs=acqs,&_temp575_acqs) : &acqs,seq_type,(int)exist(opslquant), temp_maxslquant)
        == FAILURE) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "maxpass");
        return FAILURE;
    }
  
    if (slicein1(_slquant_per_trig.fixedflag ? (_temp576_slquant_per_trig=slquant_per_trig,&_temp576_slquant_per_trig) : &slquant_per_trig, acqs, seq_type) == FAILURE) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "slicein1");
        slquant_per_trig  = _slquant_per_trig.fixedflag ? ((void)(1), slquant_per_trig) : 1; /* just try to get out of eval to catch
                                the problem in cvcheck */
    }
  
    if ( (mph_flag==PSD_ON) && (acqmode == 1) ) /* sequential multiphase */
        slquant_per_trig  = _slquant_per_trig.fixedflag ?  ((void)(1), slquant_per_trig) : 1;
  
    if (slquant_per_trig == 0) {
        epic_error(use_ermes,"slquant_per_trig is 0",EM_PSD_SLQUANT_ZERO,0);
        return FAILURE;
    }
  
    /*jwg bb doesn't this semm... backwards? This is why we're not getting slice incrementing, b/c it's set to 1*/
    if (seq_type == TYPXRR)
        slquant1  = _slquant1.fixedflag ?  ((void)(opslquant), slquant1) : opslquant;
    else
        slquant1  = _slquant1.fixedflag ?  ((void)(slquant_per_trig), slquant1) : slquant_per_trig;

    /* YMSmr06515: # of slice locations expansion */ 
    if ( (acqs > MAX_PASSES) && (existcv(opslquant)) )
    {
        epic_error(use_ermes,
                   "Maximum of %d acqs exceeded.  Increase locations/acq or decrease number of slices.",
                   EM_PSD_MAX_ACQS, 1, INT_ARG, MAX_PASSES);
        return FAILURE;
    }

    if ( (slquant1 > MAX_SLICES_PER_PASS) && (existcv(opslquant)) )
    {
        epic_error(use_ermes,
                   "The no. of locations/acquisition cannot exceed the max no. of per acq = %d.",
                   EM_PSD_LOC_PER_ACQS_EXCEEDED_MAX_SL_PER_ACQ, 1, INT_ARG, MAX_SLICES_PER_PASS);
        return FAILURE;
    }
  
    /* ****************************
       Calculate extra sat time
       ************************** */
    SatCatRelaxtime(acqs,(act_tr/slquant1),seq_type);
  
  
    /* Calculate inter-sequence delay time for 
       even spacing. */
    if ((exist(opcardseq) == PSD_CARD_INTER_EVEN) && existcv(opcardseq)) {
        psd_tseq  = _psd_tseq.fixedflag ?  ((void)(piait/slquant_per_trig), psd_tseq) : piait/slquant_per_trig;
        advrounddown(_psd_tseq.fixedflag ? (_temp577_psd_tseq=psd_tseq,&_temp577_psd_tseq) : &psd_tseq);
    }
    pitseq = avmintseq; /* Value scan displays in min inter-sequence
                           display button */

    /* Set optseq to inter-seq delay value for adv. panel routines. */
    _optseq.fixedflag = 0;
    optseq  = _optseq.fixedflag ?  ((void)(psd_tseq), optseq) : psd_tseq;
    /* Have existence of optseq follow opcardseq. */
    _optseq.existflag = _opcardseq.existflag;
  
    if (seqtime(_max_seqtime.fixedflag ? (_temp578_max_seqtime=max_seqtime,&_temp578_max_seqtime) : &max_seqtime, avail_image_time, slquant_per_trig, seq_type)
        == FAILURE) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "seqtime");
        return FAILURE;
    }
  
    avround  = _avround.fixedflag ?  ((void)(1), avround) : 1;
    if (maxte1(&av_temp_int,max_seqtime, TYPNVEMP, non_tetime, 0)
        == FAILURE) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "maxte1");
        return FAILURE;
    }

  
    if (mintr(&av_temp_int, seq_type, tmin_total*temp_slquant, slquant_per_trig,
              gating) == FAILURE) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "mintr");
        return FAILURE;
    }

    if( tmin_total > avmintr )
    {
        avmintr = tmin_total;
        advroundup(&avmintr);
    }

    if ( (mph_flag==PSD_ON) && (acqmode == 1) ) { /* sequential multiphase */
        acqs  = _acqs.fixedflag ?  ((void)(exist(opslquant)), acqs) : exist(opslquant);
        avmaxacqs = acqs;
        avmaxslquant = 1;
    }
  
    if (touch_flag)
    {
        /* Use a minimum of 2 sec disdaq to allow the motion to get
         * to a steady state */
        dda  = _dda.fixedflag ?  ((void)((int)ceil(((double)2000000/(double)optr))), dda) : (int)ceil(((double)2000000/(double)optr));
        dda  = _dda.fixedflag ?  ((void)(IMax(2,dda,1)), dda) : IMax(2,dda,1);
    } else {
        /* need a more elaborate algorithm here for disdaq determination */
        if (intleaves > 1) {
            /* MRIge51638 crude dda calculation   -KVA (agilandk@mr) */
            dda  = _dda.fixedflag ?  ((void)((int)ceil(((double)1500000/(double)optr))), dda) : (int)ceil(((double)1500000/(double)optr));
        } else {
            dda  = _dda.fixedflag ?  ((void)(0), dda) : 0;
        }
    }

     /*jwg bb this is the scancore structure here*/
    /* Looping structure in rsp:
	   
    pass_reps
    ---------
    |
    | pass
    | --------
    | |  baseline           }
    | |  ---------          }
    | |  | reps             }
    | |  | ------           } baseline time (first pass only)
    | |  | | slices         }
    | |  | --------         }
    | |  |--------
    | |
    | |  disdaqs:           }
    | |  ileaves            }
    | |  ----------         } disdaq_shots
    | |  | slices           }
    | |  | ----------       }
    | |
    | |  cmdir_rep          }
    | |  -----------        }
    | |  | core_reps        }
    | |  | -----------      }
    | |  | |                }
    | |  | | ileaves        }
    | |  | | ----------     }
    | |  | | |              }
    | |  | | | nex          }
    | |  | | | ----------   } core_shots
    | |  | | | |            }
    | |  | | | | slices     }
    | |  | | | | ---------  }
    | |  | | | ----------   }
    | |  | | ---------      }
    | |  | ----------       }
    | |  -----------        }
    | |
    | | pass packet
    | --------
    |
    |--------
    burst mode (not supported in MGD)
     
    */
  
    passr_shots  = _passr_shots.fixedflag ?  ((void)(pass_reps), passr_shots) : pass_reps;
    pass_shots  = _pass_shots.fixedflag ?  ((void)(acqs), pass_shots) : acqs;
    disdaq_shots  = _disdaq_shots.fixedflag ?  ((void)(dda), disdaq_shots) : dda;
    core_shots  = _core_shots.fixedflag ?  ((void)(intleaves), core_shots) : intleaves; /* *core_reps */
  
    /* Add more time for the last TR of the baseline scan to fix MRIge29749. */  
    /* BJM: added additional 1 second for case below for MRIge44199. */
    if(vrgfsamp == PSD_ON && opyres >= 256) bl_acq_tr2  = _bl_acq_tr2.fixedflag ?  ((void)(2000000), bl_acq_tr2) : 2000000;	

    if (baseline > 0)
        bline_time  = _bline_time.fixedflag ?    ((void)((baseline-1)*bl_acq_tr1+bl_acq_tr2), bline_time) : (baseline-1)*bl_acq_tr1+bl_acq_tr2;
    else
        bline_time  = _bline_time.fixedflag ?  ((void)(0), bline_time) : 0;
  

    pass_time  = _pass_time.fixedflag ?  ((void)(pass_delay*num_passdelay), pass_time) : pass_delay*num_passdelay;
  
    /* BJM MRIge50951 - fixed scan time bug w/opccsat */
    /* MRIge59645 - added bline_time to time */ 
    /*MRIhc08588 - no pass_delay after last acquisition */
    if (exist(opcgate) == PSD_ON) {
        scan_time  = _scan_time.fixedflag ?    
                                           
                                           ((void)((float)(passr_shots*(ccs_relaxtime+pass_shots*((float)act_tr*(float)(disdaq_shots+nex*core_shots*reps)+(float)pass_time)))-(float)pass_time), scan_time) : (float)(passr_shots*(ccs_relaxtime+pass_shots*((float)act_tr*(float)(disdaq_shots+nex*core_shots*reps)+(float)pass_time)))-(float)pass_time;
    } else {
        int touch_ndir_tmp;
        if( touch_flag )
        {
            touch_ndir_tmp = touch_ndir;
        }
        else
        {
            touch_ndir_tmp = 1;
        }
      		/*jwg bb update scan time correctly, but use old calcs if uninitialized*/
		if (num_mets == 0 || num_frames == 0) {
	        scan_time  = _scan_time.fixedflag ?    
        	                                 
                	                            
                        	                   ((void)((float)(passr_shots*(ccs_relaxtime+pass_shots*((float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0))*(float)(disdaq_shots+nex*core_shots*reps*touch_ndir_tmp)+(float)pass_time)))-(float)pass_time), scan_time) : (float)(passr_shots*(ccs_relaxtime+pass_shots*((float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0))*(float)(disdaq_shots+nex*core_shots*reps*touch_ndir_tmp)+(float)pass_time)))-(float)pass_time;
		} else {
		/* passr_shots should be # of timeframes, pass_shots is equals to acqs, or # of slices * num_mets*/
		/* but remember that only play out opsldelay (pass_time) once all num_mets are run! */
	        scan_time  = _scan_time.fixedflag ?    
        	                                 
                	                            
                        	                   ((void)((float)(num_frames*(ccs_relaxtime+pass_shots*num_mets*((float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0))*(float)(disdaq_shots+nex*core_shots*reps*touch_ndir_tmp)+(float)pass_time/num_mets)))-(float)pass_time), scan_time) : (float)(num_frames*(ccs_relaxtime+pass_shots*num_mets*((float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0))*(float)(disdaq_shots+nex*core_shots*reps*touch_ndir_tmp)+(float)pass_time/num_mets)))-(float)pass_time;	
	
	}
    }


    if(baseline > 0)
        scan_time  = _scan_time.fixedflag ?    ((void)(scan_time+bline_time*acqs), scan_time) : scan_time+bline_time*acqs;

    avmintscan  = _avmintscan.fixedflag ?  ((void)(scan_time), avmintscan) : scan_time;
    pitscan  = _pitscan.fixedflag ?  ((void)(avmintscan), pitscan) : avmintscan; /* This value shown in clock */
    pisctim1 = pitscan; 

    nreps  = _nreps.fixedflag ?      ((void)(pass_reps*acqs*(dda+(nex+dex)*intleaves*reps)), nreps) : pass_reps*acqs*(dda+(nex+dex)*intleaves*reps);
    nreps  = _nreps.fixedflag ?            ((void)(((rawdata==PSD_ON&&rhref==1)?2:1)), nreps) : nreps*((rawdata==PSD_ON&&rhref==1)?2:1);
  
    /* set effective Ky samp freq in KHz */
    if (esp > 0) {
        if ((fract_ky == PSD_FULL_KY) && (ky_dir==PSD_CENTER_OUT)) {
            /* Ky sampling freq peak (KHz)*/
            frqy  = _frqy.fixedflag ?  ((void)(1000.0*(float)(intleaves/2)/(float)esp), frqy) : 1000.0*(float)(intleaves/2)/(float)esp;
            eesp  = _eesp.fixedflag ?  ((void)(rint((float)esp/(float)(intleaves/2))), eesp) : rint((float)esp/(float)(intleaves/2));
        } else {
            /* Ky sampling freq peak (KHz)*/
            frqy  = _frqy.fixedflag ?  ((void)(1000.0*(float)(intleaves)/(float)esp), frqy) : 1000.0*(float)(intleaves)/(float)esp;
            eesp  = _eesp.fixedflag ?  ((void)(rint((float)esp/(float)intleaves)), eesp) : rint((float)esp/(float)intleaves);
        }
       
    } else {
        frqy  = _frqy.fixedflag ?  ((void)(0), frqy) : 0;
        eesp  = _eesp.fixedflag ?  ((void)(0), eesp) : 0;
    }

    /*Kx sampling freq peak (KHz) */
    frqx  = _frqx.fixedflag ?  ((void)(1000.0/tsp), frqx) : 1000.0/tsp;

    if (b0calmode == 1)
        slice_reset  = _slice_reset.fixedflag ?  ((void)(1), slice_reset) : 1;
    else
        slice_reset  = _slice_reset.fixedflag ?  ((void)(0), slice_reset) : 0;
  
#if defined(RT) && defined(LIM_PROTOCOLS)
    if (lim_protocol() == FAILURE) {
        /* don't send ermes so that underlying ermes will be displayed */
        return FAILURE;
    }

#endif
    
    if( touch_flag )
    {
        pipauval2 = 0;
        pipauval3 = 1;
        pipauval4 = 2;
        pipauval5 = 3;
        pipauval6 = 4;

        pipaunub = acqs * pass_reps;
        if( pipaunub > 6 )
        {
            pipaunub = 6;
        }
        if( touch_flag )
        {
            pitslice  = _pitslice.fixedflag ?     ((void)(pitscan/(acqs*pass_reps)), pitslice) : pitscan/(acqs*pass_reps);
            pisctim2 = pitscan;
            pisctim3 = pipauval3 * pitscan/ (acqs * pass_reps);
            pisctim4 = pipauval4 * pitscan/ (acqs * pass_reps);
            pisctim5 = pipauval5 * pitscan/ (acqs * pass_reps);
            pisctim6 = pipauval6 * pitscan/ (acqs * pass_reps);
        }
    }
    else
    {
        pipaunub = 0;
    }
    
    return SUCCESS;
  
} /* end cveval1 */

STATUS ssEval1(void) 
{

    INT fieldStrength;

    fieldStrength = (int)cffield;

    if (ss_rf1 == PSD_ON)  /* rfpulse selection for spsp */
    {
        fat_delta  = _fat_delta.fixedflag ?    ((void)(-230.0*(float)(cffield/B0_15000)), fat_delta) : -230.0*(float)(cffield/B0_15000);  /*YH*/        
        /* allow for manual selection of spsp pulse through ss_override cv */
        fat_offset  = _fat_offset.fixedflag ?  ((void)((int)(fat_delta/(float)TARDIS_FREQ_RES)), fat_offset) : (int)(fat_delta/(float)TARDIS_FREQ_RES);
        a_rf1  = _a_rf1.fixedflag ?  ((void)(1.0), a_rf1) : 1.0;
        pw_gzrf1  = _pw_gzrf1.fixedflag ?  ((void)(pw_rf1), pw_gzrf1) : pw_rf1;
#if defined(IPG_TGT) || defined(MGD_TGT)
        pw_gzrf1d  = _pw_gzrf1d.fixedflag ?  ((void)(0), pw_gzrf1d) : 0;
        pw_gzrf1a  = _pw_gzrf1a.fixedflag ?  ((void)(0), pw_gzrf1a) : 0;
#endif
        res_gzrf1  = _res_gzrf1.fixedflag ?  ((void)(res_rf1), res_gzrf1) : res_rf1;
        pw_thetarf1  = _pw_thetarf1.fixedflag ?  ((void)(pw_gzrf1), pw_thetarf1) : pw_gzrf1;
        res_thetarf1  = _res_thetarf1.fixedflag ?  ((void)(res_rf1), res_thetarf1) : res_rf1;
        rftype  = _rftype.fixedflag ?  ((void)(PLAY_RFFILE), rftype) : PLAY_RFFILE;
        gztype  = _gztype.fixedflag ?  ((void)(PLAY_GFILE), gztype) : PLAY_GFILE;
        thetatype  = _thetatype.fixedflag ?  ((void)(PLAY_THETA), thetatype) : PLAY_THETA;
        bw_rf1  = _bw_rf1.fixedflag ?  ((void)(rfpulse[RF1_SLOT].nom_bw*rfpulse[RF1_SLOT].nom_pw/pw_rf1), bw_rf1) : rfpulse[RF1_SLOT].nom_bw*rfpulse[RF1_SLOT].nom_pw/pw_rf1;
        flip_rf1  = _flip_rf1.fixedflag ?  ((void)(exist(opflip)), flip_rf1) : exist(opflip);

        /* prevent SPSP 90 degree pulse from violation of RF power limit */
        /* only for 450W, 450, and 750 now*/
        /* need to test for other platforms */

        /* limit to DV platform */
        if (ss_fa_scaling_flag && (cfgcoiltype == PSD_XRMB_COIL || cfgcoiltype == PSD_XRMW_COIL))
        {
            float fa_scaling_factor;
            fa_scaling_factor = get_fa_scaling_factor_ss(_max_ss_fa.fixedflag ? (_temp579_max_ss_fa=max_ss_fa,&_temp579_max_ss_fa) : &max_ss_fa, flip_rf1, rfpulse[RF1_SLOT].nom_fa, rfpulse[RF1_SLOT].max_b1);
            flip_rf1  = _flip_rf1.fixedflag ?  ((void)(floor(flip_rf1*fa_scaling_factor)), flip_rf1) : floor(flip_rf1*fa_scaling_factor);
        }

        if (ampslice(_a_gzrf1.fixedflag ? (_temp580_a_gzrf1=a_gzrf1,&_temp580_a_gzrf1) : &a_gzrf1, bw_rf1, (PSD_3D == (exist(opimode))?exist(opvthick):exist(opslthick)), gscale_rf1, TYPDEF)
            == FAILURE) {
            epic_error(use_ermes, "%s failure for gzrf1",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "ampslice");
            return FAILURE;
        }

        pw_constant  = _pw_constant.fixedflag ?      ((void)(pw_gzrf1lobe-2*pw_ss_rampz), pw_constant) : pw_gzrf1lobe-2*pw_ss_rampz;
        area_gz1  = _area_gz1.fixedflag ?       ((void)(((float)pw_constant+(float)pw_ss_rampz+(float)off90minor)*a_gzrf1/2), area_gz1) : ((float)pw_constant+(float)pw_ss_rampz+(float)off90minor)*a_gzrf1/2;
        a_thetarf1  = _a_thetarf1.fixedflag ?  ((void)(a_gzrf1), a_thetarf1) : a_gzrf1;


        /* Do not do this for Y. Zur's pulses (NDG) */        
        if (!((cffield == B0_30000) || (whichss == 1544022) || (whichss == 1534433))) {
            if ( (oppseq == PSD_SE) && (num_rf1lobe % 2 == 1) )
                area_gz1  = _area_gz1.fixedflag ?   ((void)(-(area_gz1)), area_gz1) : -(area_gz1);
        }

        if (zgmn_type == CALC_GMN1) {
            float zerommt, firstmmt;
            gz1_zero_moment  = _gz1_zero_moment.fixedflag ?  ((void)(0.0), gz1_zero_moment) : 0.0;
            gz1_first_moment  = _gz1_first_moment.fixedflag ?  ((void)(0.0), gz1_first_moment) : 0.0;
            pulsepos  = _pulsepos.fixedflag ?  ((void)(0), pulsepos) : 0;
            invertphase  = _invertphase.fixedflag ?  ((void)(0), invertphase) : 0;
            rampmoments(0.0, a_gzrf1, pw_ss_rampz, invertphase, _pulsepos.fixedflag ? (_temp581_pulsepos=pulsepos,&_temp581_pulsepos) : &pulsepos,
                        &zerommt, &firstmmt, _gz1_zero_moment.fixedflag ? (_temp582_gz1_zero_moment=gz1_zero_moment,&_temp582_gz1_zero_moment) : &gz1_zero_moment, _gz1_first_moment.fixedflag ? (_temp583_gz1_first_moment=gz1_first_moment,&_temp583_gz1_first_moment) : &gz1_first_moment);
            rampmoments(a_gzrf1, a_gzrf1, pw_constant/2, invertphase, _pulsepos.fixedflag ? (_temp584_pulsepos=pulsepos,&_temp584_pulsepos) : &pulsepos,
                        &zerommt, &firstmmt, _gz1_zero_moment.fixedflag ? (_temp585_gz1_zero_moment=gz1_zero_moment,&_temp585_gz1_zero_moment) : &gz1_zero_moment, _gz1_first_moment.fixedflag ? (_temp586_gz1_first_moment=gz1_first_moment,&_temp586_gz1_first_moment) : &gz1_first_moment);
            pos_moment_start  = _pos_moment_start.fixedflag ?        ((void)(pos_start+t_exa+(num_rf1lobe/2)*pw_gzrf1lobe-pw_constant/2), pos_moment_start) : pos_start+t_exa+(num_rf1lobe/2)*pw_gzrf1lobe-pw_constant/2;
        }

    }

    return (SUCCESS);

} /* ssEval1 */

STATUS ssEval2(void) 
{
    INT sl_cnt;
    float ss_minslthk1_rup;
    float max_optloc;
    float dbdt_slthk;    /* MRIge64190 */
    float a_gzrf1_ss_max; 
    float sr_slthk;

    if( (VALUE_SYSTEM_SVEM == value_system_flag) ||
        (VALUE_SYSTEM_SVDM == value_system_flag) ||
        (0 != breast_spsp_flag) )
    { 
        ss_convolution_flag  = _ss_convolution_flag.fixedflag ?  ((void)(PSD_ON), ss_convolution_flag) : PSD_ON;
    }
    else
    {
        ss_convolution_flag  = _ss_convolution_flag.fixedflag ?  ((void)(PSD_OFF), ss_convolution_flag) : PSD_OFF;
    }

    /* Do not do this for Y. Zur's pulses (NDG) */
    if (!((cffield == B0_30000) || (whichss == 1544022) || (whichss == 1534433))) {
        if ( (oppseq != PSD_SE) && (num_rf1lobe % 2 == 1) )
            a_gz1  = _a_gz1.fixedflag ?   ((void)(-(a_gz1)), a_gz1) : -(a_gz1);
    }
    
    if (ss_rf1 == 0) {
        gradz[GZRF1_SLOT].ptype = G_TRAP;

        gradz[GZRF1_SLOT].attack = _pw_gzrf1a.fixedflag ? (_temp587_pw_gzrf1a=pw_gzrf1a,&_temp587_pw_gzrf1a) : &pw_gzrf1a;
        gradz[GZRF1_SLOT].decay = _pw_gzrf1d.fixedflag ? (_temp588_pw_gzrf1d=pw_gzrf1d,&_temp588_pw_gzrf1d) : &pw_gzrf1d;
        gradz[GZRF1_SLOT].pw = _pw_gzrf1.fixedflag ? (_temp589_pw_gzrf1=pw_gzrf1,&_temp589_pw_gzrf1) : &pw_gzrf1;
        gradz[GZRF1_SLOT].scale = 1.0;
        gradz[GZRF1_SLOT].num = 1;

    } else {
        gradz[GZRF1_SLOT].ptype = G_USER;

        gradz[GZRF1_SLOT].attack = _pw_ss_rampz.fixedflag ? (_temp590_pw_ss_rampz=pw_ss_rampz,&_temp590_pw_ss_rampz) : &pw_ss_rampz;
        gradz[GZRF1_SLOT].decay = _pw_ss_rampz.fixedflag ? (_temp591_pw_ss_rampz=pw_ss_rampz,&_temp591_pw_ss_rampz) : &pw_ss_rampz;
        gradz[GZRF1_SLOT].pw = _pw_constant.fixedflag ? (_temp592_pw_constant=pw_constant,&_temp592_pw_constant) : &pw_constant;
        gradz[GZRF1_SLOT].scale = 1.0;
        gradz[GZRF1_SLOT].num = num_rf1lobe;

        {
            float slope;
            double tmppower;
            double gcmfs2amps2;  /* frequently used (Gauss/cm)^2 to Amperes^2
                                    scale factor */
            double gcmfs2amps;   /* frequently used (Gauss/cm) to Amperes
                                    scale factor */

            /* [Amperes/Gauss/cm]^2 */
            gcmfs2amps2 = pow((double)loggrd.zipeak/(double)loggrd.zfs,2.0);
            /* [Amperes/Gauss/cm] */
            gcmfs2amps = (double)loggrd.zipeak/(double)loggrd.zfs;

            /* attack ****************************************************/
            slope = *gradz[GZRF1_SLOT].amp/ *gradz[GZRF1_SLOT].attack;
            tmppower = gcmfs2amps2 * pow((double)slope, 2.0) *
                pow((double)*gradz[GZRF1_SLOT].attack, 3.0)/ 3.0;

            gradz[GZRF1_SLOT].power = tmppower;

            /* Since the spectral spatial gradient waveform is bipolar, split
               power between the positive and negative power summations */
            if (*gradz[GZRF1_SLOT].amp >= 0) {
                gradz[GZRF1_SLOT].powpos = tmppower*
                    (float)((num_rf1lobe+1)/2)/(float)(num_rf1lobe);
                gradz[GZRF1_SLOT].powneg = tmppower/2.0;
            } else {
                gradz[GZRF1_SLOT].powneg = tmppower*
                    (float)((num_rf1lobe+1)/2)/(float)(num_rf1lobe);
                gradz[GZRF1_SLOT].powpos = tmppower/2.0;
            }

            gradz[GZRF1_SLOT].powabs = fabs(gcmfs2amps * (double)slope *
                                            pow((double)*gradz[GZRF1_SLOT].attack,
                                                2.0)/ 2.0);

            gradz[GZRF1_SLOT].amptran = fabs(*gradz[GZRF1_SLOT].amp) *
                loggrd.zipeak/ loggrd.zfs;

            gradz[GZRF1_SLOT].pwm = *gradz[GZRF1_SLOT].attack;

            /* constant *************************************************/
            tmppower = (*gradz[GZRF1_SLOT].pw) *
                pow((double)*gradz[GZRF1_SLOT].amp, 2.0) * gcmfs2amps2;  

            gradz[GZRF1_SLOT].power += tmppower;

            if (*gradz[GZRF1_SLOT].amp >= 0) {
                gradz[GZRF1_SLOT].powpos += tmppower*
                    (float)((num_rf1lobe+1)/2)/(float)(num_rf1lobe);
                gradz[GZRF1_SLOT].powneg += tmppower/2.0;
            } else {
                gradz[GZRF1_SLOT].powneg += tmppower*
                    (float)((num_rf1lobe+1)/2)/(float)(num_rf1lobe);
                gradz[GZRF1_SLOT].powpos += tmppower/2.0;
            }

            gradz[GZRF1_SLOT].powabs += fabs(gcmfs2amps *
                                             (double)(*gradz[GZRF1_SLOT].pw) *
                                             (double)(*gradz[GZRF1_SLOT].amp));

            /* decay ***************************************************/

            slope = - *gradz[GZRF1_SLOT].amp/ *gradz[GZRF1_SLOT].decay;
            tmppower = gcmfs2amps2 * pow((double)slope, 2.0) *
                pow((double)*gradz[GZRF1_SLOT].decay, 3.0)/ 3.0;

            gradz[GZRF1_SLOT].power += tmppower;

            if (*gradz[GZRF1_SLOT].amp >= 0) {
                gradz[GZRF1_SLOT].powpos += tmppower*
                    (float)((num_rf1lobe+1)/2)/(float)(num_rf1lobe);
                gradz[GZRF1_SLOT].powneg += tmppower/2.0;
            } else {
                gradz[GZRF1_SLOT].powneg += tmppower*
                    (float)((num_rf1lobe+1)/2)/(float)(num_rf1lobe);
                gradz[GZRF1_SLOT].powpos += tmppower/2.0;
            }

            gradz[GZRF1_SLOT].powabs += fabs(gcmfs2amps * (double)slope *
                                             pow((double)*gradz[GZRF1_SLOT].decay,
                                                 2.0)/ 2.0);

            gradz[GZRF1_SLOT].amptran += fabs(*gradz[GZRF1_SLOT].amp) *
                loggrd.zipeak/ loggrd.zfs;

            gradz[GZRF1_SLOT].pwm += *gradz[GZRF1_SLOT].decay;

        }
        /* "Normalize" parameters for G_USER pulse */
        gradz[GZRF1_SLOT].power *= 1.0/((float)(*gradz[GZRF1_SLOT].pw) *
                                        pow((double)*gradz[GZRF1_SLOT].amp,2.0));
        gradz[GZRF1_SLOT].powpos *= 1.0/((float)(*gradz[GZRF1_SLOT].pw) *
                                         pow((double)*gradz[GZRF1_SLOT].amp,2.0));
        gradz[GZRF1_SLOT].powneg *= 1.0/((float)(*gradz[GZRF1_SLOT].pw) *
                                         pow((double)*gradz[GZRF1_SLOT].amp,2.0));

        /* BJM: move this here to catch minslice thickness with SpSP */
        /* Note: this makes ssCheck and empty function! */
        /* min slice thickness for ss rf pulses (mm) */
        ss_min_slthk  = _ss_min_slthk.fixedflag ?       ((void)(nbw_ssrf/(loggrd.zfs*(0.1)*GAM)), ss_min_slthk) : nbw_ssrf/(loggrd.zfs*(0.1)*GAM);
        a_gzrf1_ss_max = loggrd.zfs;

        /* MRIge91352 - SAR/dbdt changes for E3 */  

        /* MRIge64190: make sure it adheres to dBdt limits */

        if(cfdbdtper > 0)
        {
            if(ss_convolution_flag)   /* Using Convolution Model to calculate PNS */
            {
                float max_pns, p_pns, tmp_dx;
                int tmp_k, tmp_j;
                float acon[200], tcon[200];
                int tmp_esp;

                /* calculate waveform*/

                tmp_esp=pw_rf1/num_rf1lobe;  /* width of each lobe*/
                tmp_dx=FMax(3, cfdbdtdx, cfdbdtdy, cfdbdtdz);  /* maximal effective distence */

                /* the unit of tcon: s;  the unit of acon: T/m */ 
                for(tmp_j=0;tmp_j<num_rf1lobe;tmp_j++)
                {
                    tcon[tmp_j*3]=(float)(tmp_esp*tmp_j*0.000001);
                    tcon[tmp_j*3+1]=(float)(tmp_esp*tmp_j+pw_ss_rampz)*0.000001;
                    tcon[tmp_j*3+2]=(float)(tmp_esp*(tmp_j+1)-pw_ss_rampz)*0.000001;
                    if( (tmp_j%2) ==1)
                    {
                        acon[tmp_j*3]=0.0;
                        acon[tmp_j*3+1]=a_gzrf1_ss_max*tmp_dx*0.0001;
                        acon[tmp_j*3+2]=a_gzrf1_ss_max*tmp_dx*0.0001;
                    }
                    else
                    {
                        acon[tmp_j*3]=0.0;
                        acon[tmp_j*3+1]=0.0-a_gzrf1_ss_max*tmp_dx*0.0001;
                        acon[tmp_j*3+2]=0.0-a_gzrf1_ss_max*tmp_dx*0.0001;
                    }
                }

                /* calculate PNS with Convolution Model*/
                max_pns=0.0;
                for(tmp_k=1;tmp_k<num_rf1lobe*3;tmp_k++)
                {
                    p_pns=0.0;
                    for(tmp_j=0;tmp_j<tmp_k;tmp_j++)
                    {
                        p_pns=p_pns+(acon[tmp_j+1]-acon[tmp_j])/(tcon[tmp_j+1]-tcon[tmp_j])* 
                                     ((float)cfrfact*0.000001)/cfrinf*
                                     ( 1.0/(((float)cfrfact)*0.000001+tcon[tmp_k]-tcon[tmp_j+1]) - 
                                       1.0/(((float)cfrfact)*0.000001+tcon[tmp_k]-tcon[tmp_j]));
                    }
                    if(fabs(p_pns)>max_pns)
                        max_pns=fabs(p_pns);
                }

                /* set a_gzrf1_ss_max based on max_pns and cfdbdtper */
                /* when shape of waveform is fixed, PNS is propotional to amplitude */
                a_gzrf1_ss_max = a_gzrf1_ss_max * FMin(2,1.0,(float)cfdbdtper/(max_pns*100.0));
            }
            else
            {
                a_gzrf1_ss_max = (cfdbdtper/ 100.0) * (cfrinf * (1.0 + (cfrfact/ (2 * (float)pw_ss_rampz) )))
                                  * (float)pw_ss_rampz/  (FMax(3, cfdbdtdx, cfdbdtdy, cfdbdtdz) * 100.0);
            }
        } 
        else if(cfdbdtts > 0)
        {
            a_gzrf1_ss_max = cfdbdtts * (float)pw_ss_rampz/  (FMax(3, cfdbdtdx, cfdbdtdy, cfdbdtdz) * 100.0);
        }

       dbdt_slthk = (nbw_ssrf/ (a_gzrf1_ss_max * (0.1) * GAM));
        
       /* for EPI, min slthk is based on convolution dbdt calculation model */
       if(opepi == PSD_ON && breast_spsp_flag == PSD_OFF &&
          cffield == B0_30000 && cfgcoiltype == PSD_XRMB_COIL)
       { 
           FILE * fp; 
           if((fp=fopen("/usr/g/bin/.spspReily","r")) == NULL) 
           { 
               if(cfdbdtper >=80 && cfdbdtper < 100) 
                   dbdt_slthk = 3.6; 
               else if(cfdbdtper >= 100 && cfdbdtper <= 114 ) 
                   dbdt_slthk = 2.9; 
           } 
           else 
           { 
               fclose(fp); 
           } 
       }

        ss_min_slthk  = _ss_min_slthk.fixedflag ?             ((void)(ceilf(((dbdt_slthk>ss_min_slthk)?dbdt_slthk:ss_min_slthk)*10.0)/10.0), ss_min_slthk) : ceilf(((dbdt_slthk>ss_min_slthk)?dbdt_slthk:ss_min_slthk)*10.0)/10.0;

        /* slew rate limit */
        sr_slthk = nbw_ssrf/((pw_ss_rampz*(save_gmax/save_ramptime)) * (0.1) * GAM);
        ss_min_slthk  = _ss_min_slthk.fixedflag ?             ((void)(ceilf(((sr_slthk>ss_min_slthk)?sr_slthk:ss_min_slthk)*10.0)/10.0), ss_min_slthk) : ceilf(((sr_slthk>ss_min_slthk)?sr_slthk:ss_min_slthk)*10.0)/10.0;

        /* min slice offset (mm) for the spsp pulse */
        /* the 186.0 (mm) value is a function of the bandwidth of the Omega board
           [+/-78.125kHz and a given slice thickness and set at SR17 mode.  All
           other SR moded are indexed with the loggrd.zfs value */    
        {
            const float tmp = ceilf( exist(opslthick) * 10.0)/ 10.0; 

            /* Maximum Offset for SpSP Pulse (mm) */
            ss_maxoff  = _ss_maxoff.fixedflag ?           
                                                                     ((void)((MAX_OMEGA_OFFSET*tmp/(ss_min_slthk*((loggrd.zfs<a_gzrf1_ss_max)?loggrd.zfs:a_gzrf1_ss_max)))), ss_maxoff) : (MAX_OMEGA_OFFSET*tmp/(ss_min_slthk*((loggrd.zfs<a_gzrf1_ss_max)?loggrd.zfs:a_gzrf1_ss_max)));
        }

        /* Initialize ss max offset flag */
        ss_maxoffex  = _ss_maxoffex.fixedflag ?  ((void)(PSD_OFF), ss_maxoffex) : PSD_OFF;
        /* Check the scan range only after slice thickness, skip,
           and slice number are set MRIge35391*/
        if ( (existcv(opslquant)==PSD_ON) &&
             (existcv(opslthick)==PSD_ON) &&
             (existcv(opslspace)==PSD_ON) ) {

            max_optloc = 0.0;    /* the maximum offset of all slices or groups of slices */

            for (sl_cnt=0; sl_cnt<(PSD_3D == (exist(opimode))?opvquant:opslquant); sl_cnt++) {
                if(fabs(scan_info[sl_cnt].optloc) > max_optloc)
                    max_optloc = fabs(scan_info[sl_cnt].optloc);
            }

            if ( max_optloc > ss_maxoff ) {

                /* MRIge64190: use dbdt limited amp if necessary */
                const float tmp_amp_gzrf1 = (loggrd.zfs < a_gzrf1_ss_max ) ? loggrd.zfs : a_gzrf1_ss_max;

                ss_maxoffex  = _ss_maxoffex.fixedflag ?  ((void)(PSD_ON), ss_maxoffex) : PSD_ON;
                /* New minimum slice thickness to maintain scan coverage */
                ss_minslthk1  = _ss_minslthk1.fixedflag ?  ((void)((max_optloc*ss_min_slthk*tmp_amp_gzrf1/(MAX_OMEGA_OFFSET))), ss_minslthk1) : (max_optloc*ss_min_slthk*tmp_amp_gzrf1/(MAX_OMEGA_OFFSET));

                /* round up ss_minslthk1 in error message to 0.1 mm */
                ss_minslthk1_rup = ceilf( ss_minslthk1 * 10.0 )/ 10.0;

                epic_error( use_ermes,
                            "Use a slice offset < %d mm or use a slice thickness >=%3.1f mm.",
                            EM_PSD_SS_OFFSET_EXCEEDED_F, EE_ARGS(2), INT_ARG, (int)ss_maxoff,
                            FLOAT_ARG, ss_minslthk1_rup );
                return FAILURE;

            } /* if max_optloc */

        } /* if existcv(opslquant) */

    } /* end ss_rf1 = 1 */

    return(SUCCESS);
}

float get_fa_scaling_factor_ss(float * max_fa, float act_fa, float nom_fa, float nom_max_b1)
{
    double max_b1_limit, cur_b1_limit, act_b1;
    INT txIndex[MAX_TX_COIL_SETS];
    INT exciterIndex[MAX_TX_COIL_SETS];
    INT exciterUsed[MAX_TX_COIL_SETS];
    INT numTxIndexUsed = 0;
    INT i;

    if (act_fa <= 0.0 || nom_fa <= 0.0 || nom_max_b1 <= 0.0)
    {
        *max_fa = 180.0;
        return 1.0;
    }

    getTxAndExciter(txIndex, exciterIndex, exciterUsed, &numTxIndexUsed, coilInfo, opncoils);
    coilB1Limit(&max_b1_limit, txCoilInfo[txIndex[0]]);

    /* handle cases with multiple transmit coils (not supposed to be executed for now) */
    for (i = 1; i < numTxIndexUsed; i++)
    {
        coilB1Limit(&cur_b1_limit, txCoilInfo[txIndex[i]]);

        if (cur_b1_limit < max_b1_limit)
        {
            max_b1_limit = cur_b1_limit;
        } 
    }

    max_b1_limit = max_b1_limit/100; /* uT to Gauss conversion */

    *max_fa = (float)floor(max_b1_limit*nom_fa/nom_max_b1);
    if(*max_fa > 180.0) *max_fa = 180.0;

    act_b1 = nom_max_b1*act_fa/nom_fa;

    if (act_b1 <= max_b1_limit)
    {
        return 1.0;
    }

    return (float)(max_b1_limit/act_b1);
}



/* BJM - SE Ref Scan */

INT avmintecalc_ref( void )
{
    int pulsecnt;
    int tdaqhxatemp;
  
    /* All this to find pw_gy1_tot: */
    gy1_offset  = _gy1_offset.fixedflag ?  ((void)(ky_offset*fabs(area_gyb)/intleaves), gy1_offset) : ky_offset*fabs(area_gyb)/intleaves;
    area_gy1  = _area_gy1.fixedflag ?    ((void)(area_gy1+gy1_offset), area_gy1) : area_gy1+gy1_offset;
    area_gy1  = _area_gy1.fixedflag ?  ((void)(fabs(area_gy1)), area_gy1) : fabs(area_gy1);
    endview_iamp  = _endview_iamp.fixedflag ?  ((void)(max_pg_wamp), endview_iamp) : max_pg_wamp;
    endview_scale  = _endview_scale.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iamp), endview_scale) : (float)max_pg_iamp/(float)endview_iamp;
    /* Find the amplitudes and pulse widths of the trapezoidal
       phase encoding pulse. */
    
    if (amppwtpe(_a_gy1a.fixedflag ? (_temp593_a_gy1a=a_gy1a,&_temp593_a_gy1a) : &a_gy1a,_a_gy1b.fixedflag ? (_temp594_a_gy1b=a_gy1b,&_temp594_a_gy1b) : &a_gy1b,_pw_gy1.fixedflag ? (_temp595_pw_gy1=pw_gy1,&_temp595_pw_gy1) : &pw_gy1,_pw_gy1a.fixedflag ? (_temp596_pw_gy1a=pw_gy1a,&_temp596_pw_gy1a) : &pw_gy1a,_pw_gy1d.fixedflag ? (_temp597_pw_gy1d=pw_gy1d,&_temp597_pw_gy1d) : &pw_gy1d,
                 loggrd.ty_xyz/endview_scale,loggrd.yrt,
                 area_gy1) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   1,STRING_ARG,"amppwtpe");
        return FAILURE;
    } 
    
    pw_gy1_tot  = _pw_gy1_tot.fixedflag ?      ((void)(pw_gy1a+pw_gy1+pw_gy1d), pw_gy1_tot) : pw_gy1a+pw_gy1+pw_gy1d;
    
    if (ygmn_type == CALC_GMN1) {
        
        /* set time origin at end of bipolar flow comp lobe/beginning of 
           gy1f phase encoding pulse */
        invertphase  = _invertphase.fixedflag ?  ((void)(0), invertphase) : 0;
        zeromomentsum  = _zeromomentsum.fixedflag ?  ((void)(0.0), zeromomentsum) : 0.0;
        firstmomentsum  = _firstmomentsum.fixedflag ?  ((void)(0.0), firstmomentsum) : 0.0;
        pulsepos  = _pulsepos.fixedflag ?  ((void)(0), pulsepos) : 0;
        
        /* compute moments for blips */
        pulsepos  = _pulsepos.fixedflag ?            ((void)(pw_gy1_tot+pw_gxwad+esp-pw_gxwad/2-pw_gyb/2-pw_gybd), pulsepos) : pw_gy1_tot+pw_gxwad+esp-pw_gxwad/2-pw_gyb/2-pw_gybd;
        if(no_gy1_ol_gxw && iref_etl > 0) pulsepos  = _pulsepos.fixedflag ?  ((void)(esp), pulsepos) : pulsepos+esp;
        for (pulsecnt=0;pulsecnt<blips2cent;pulsecnt++) {
            rampmoments(0.0, a_gyb, pw_gyba, invertphase, _pulsepos.fixedflag ? (_temp598_pulsepos=pulsepos,&_temp598_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp599_zeromoment=zeromoment,&_temp599_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp600_firstmoment=firstmoment,&_temp600_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp601_zeromomentsum=zeromomentsum,&_temp601_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp602_firstmomentsum=firstmomentsum,&_temp602_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gyb, a_gyb, pw_gyb, invertphase, _pulsepos.fixedflag ? (_temp603_pulsepos=pulsepos,&_temp603_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp604_zeromoment=zeromoment,&_temp604_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp605_firstmoment=firstmoment,&_temp605_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp606_zeromomentsum=zeromomentsum,&_temp606_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp607_firstmomentsum=firstmomentsum,&_temp607_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gyb, 0.0, pw_gybd, invertphase, _pulsepos.fixedflag ? (_temp608_pulsepos=pulsepos,&_temp608_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp609_zeromoment=zeromoment,&_temp609_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp610_firstmoment=firstmoment,&_temp610_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp611_zeromomentsum=zeromomentsum,&_temp611_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp612_firstmomentsum=firstmomentsum,&_temp612_firstmomentsum) : &firstmomentsum);
            pulsepos  = _pulsepos.fixedflag ?        ((void)(pulsepos+(esp-pw_gyba-pw_gyb/2)), pulsepos) : pulsepos+(esp-pw_gyba-pw_gyb/2);
        }
        gyb_tot_0thmoment  = _gyb_tot_0thmoment.fixedflag ?  ((void)(zeromomentsum), gyb_tot_0thmoment) : zeromomentsum;
        gyb_tot_1stmoment  = _gyb_tot_1stmoment.fixedflag ?  ((void)(firstmomentsum), gyb_tot_1stmoment) : firstmomentsum;
        
        /* Here we compute the gradient moment nulling pulse parameters
           for a worst case condition: when the gy1f pulse has zero
           amplitude.  Since the gy1f never really steps to zero amplitude,
           this is hardly an optimal solution.  A future option is to
           compute the minimum amplitude of gy1f across all intleaves
           in this calculation. */
        
        amppwygmn(gyb_tot_0thmoment, gyb_tot_1stmoment, pw_gy1a, pw_gy1,
                  pw_gy1d, 0.0, 0.0, loggrd.ty_xyz, (float)loggrd.yrt,
                  0, _pw_gymn2a.fixedflag ? (_temp613_pw_gymn2a=pw_gymn2a,&_temp613_pw_gymn2a) : &pw_gymn2a, _pw_gymn2.fixedflag ? (_temp614_pw_gymn2=pw_gymn2,&_temp614_pw_gymn2) : &pw_gymn2, _pw_gymn2d.fixedflag ? (_temp615_pw_gymn2d=pw_gymn2d,&_temp615_pw_gymn2d) : &pw_gymn2d, _a_gymn2.fixedflag ? (_temp616_a_gymn2=a_gymn2,&_temp616_a_gymn2) : &a_gymn2);
        
        a_gymn2  = _a_gymn2.fixedflag ?  ((void)(-a_gymn2), a_gymn2) : -a_gymn2;
        a_gymn1  = _a_gymn1.fixedflag ?  ((void)(-a_gymn2), a_gymn1) : -a_gymn2;
        pw_gymn1a  = _pw_gymn1a.fixedflag ?  ((void)(pw_gymn2a), pw_gymn1a) : pw_gymn2a;
        pw_gymn1  = _pw_gymn1.fixedflag ?  ((void)(pw_gymn2), pw_gymn1) : pw_gymn2;
        pw_gymn1d  = _pw_gymn1d.fixedflag ?  ((void)(pw_gymn2d), pw_gymn1d) : pw_gymn2d;
        
        pw_gymn1_tot  = _pw_gymn1_tot.fixedflag ?      ((void)(pw_gymn1a+pw_gymn1+pw_gymn1d), pw_gymn1_tot) : pw_gymn1a+pw_gymn1+pw_gymn1d;
        pw_gymn2_tot  = _pw_gymn2_tot.fixedflag ?      ((void)(pw_gymn2a+pw_gymn2+pw_gymn2d), pw_gymn2_tot) : pw_gymn2a+pw_gymn2+pw_gymn2d;
        
    } else {    /* if (ygmn_type != CALC_GMN1) */
        pw_gymn1_tot  = _pw_gymn1_tot.fixedflag ?  ((void)(0), pw_gymn1_tot) : 0;
        pw_gymn2_tot  = _pw_gymn2_tot.fixedflag ?  ((void)(0), pw_gymn2_tot) : 0;
    }

    if( iref_etl != 0 && pw_gy1_tot + pw_gymn1_tot + pw_gymn2_tot > esp ){
       pw_iref_gxwait  = _pw_iref_gxwait.fixedflag ?        ((void)(RUP_GRD(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot-esp)), pw_iref_gxwait) : RUP_GRD(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot-esp);
    }else{
       pw_iref_gxwait  = _pw_iref_gxwait.fixedflag ?  ((void)(0), pw_iref_gxwait) : 0;
    }
    if(no_gy1_ol_gxw && iref_etl > 0)
        pw_iref_gxwait  = _pw_iref_gxwait.fixedflag ?      ((void)(RUP_GRD(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot)), pw_iref_gxwait) : RUP_GRD(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot);

    tdaqhxatemp = tdaqhxa + pw_iref_gxwait;

    /* SSP Timing for Spin-Echo */
    avminssp  = _avminssp.fixedflag ?            ((void)(pw_rf2/2+rfupd+8+pw_wssp+tdaqhxatemp), avminssp) : pw_rf2/2+rfupd+8+pw_wssp+tdaqhxatemp;
    avminssp  = _avminssp.fixedflag ?    ((void)(avminssp+HSDAB_length), avminssp) : avminssp+HSDAB_length;

    if (xtr_offset == 0) {
        avminssp  = _avminssp.fixedflag ?      ((void)(avminssp+(XTRSETLNG+XTR_length[PSD_XCVR2])), avminssp) : avminssp+(XTRSETLNG+XTR_length[PSD_XCVR2]);
    } else {
        avminssp  = _avminssp.fixedflag ?    ((void)(avminssp+xtr_offset), avminssp) : avminssp+xtr_offset;
    }
    
    /* Since spin-echo - need 2*tau */
    avminssp  = _avminssp.fixedflag ?  ((void)(2), avminssp) : avminssp*2;    

    avminxa  = _avminxa.fixedflag ?  ((void)(2*(rfExIso)), avminxa) : 2*(rfExIso);
    avminxb  = _avminxb.fixedflag ?       
                 
                      
                          
                      ((void)(2*(tdaqhxatemp+pw_wgx+pw_rf2/2+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),pw_gzrf2r1_tot))), avminxb) : 2*(tdaqhxatemp+pw_wgx+pw_rf2/2+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),pw_gzrf2r1_tot));

    avminx   = _avminx.fixedflag ?      ((void)((avminxa>avminxb)?avminxa:avminxb), avminx) : (avminxa>avminxb)?avminxa:avminxb;
    

    avminya  = _avminya.fixedflag ?  ((void)(2*(rfExIso)), avminya) : 2*(rfExIso);
    avminyb  = _avminyb.fixedflag ?         
                 
                      
                          
                      ((void)(2*(pw_rf2/2+pw_wgy+tdaqhxatemp+pw_gxwad+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),pw_gzrf2r1_tot))), avminyb) : 2*(pw_rf2/2+pw_wgy+tdaqhxatemp+pw_gxwad+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),pw_gzrf2r1_tot));
    
    avminy   = _avminy.fixedflag ?      ((void)((avminya>avminyb)?avminya:avminyb), avminy) : (avminya>avminyb)?avminya:avminyb;
    
    avminza  = _avminza.fixedflag ?       
                   ((void)(2*(rfExIso+pw_gzrf1d+pw_gz1_tot+pw_gzrf2l1_tot+(pw_rf2/2))), avminza) : 2*(rfExIso+pw_gzrf1d+pw_gz1_tot+pw_gzrf2l1_tot+(pw_rf2/2));
    avminzb  = _avminzb.fixedflag ?           
                 
                      
                          
                      ((void)(2*(8+(pw_rf2/2)+tdaqhxatemp+pw_wgz+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),pw_gzrf2r1_tot))), avminzb) : 2*(8+(pw_rf2/2)+tdaqhxatemp+pw_wgz+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),pw_gzrf2r1_tot));
    avminz   = _avminz.fixedflag ?      ((void)((avminza>avminzb)?avminza:avminzb), avminz) : (avminza>avminzb)?avminza:avminzb;
    
    tempTe_ref  = _tempTe_ref.fixedflag ?      ((void)(((avminy>avminz)?avminy:avminz)), tempTe_ref) : ((avminy>avminz)?avminy:avminz);
    tempTe_ref  = _tempTe_ref.fixedflag ?      ((void)(((avminx>tempTe_ref)?avminx:tempTe_ref)), tempTe_ref) : ((avminx>tempTe_ref)?avminx:tempTe_ref);
    tempTe_ref  = _tempTe_ref.fixedflag ?      ((void)(((avminssp>tempTe_ref)?avminssp:tempTe_ref)), tempTe_ref) : ((avminssp>tempTe_ref)?avminssp:tempTe_ref);

    return tempTe_ref;
}


#ifdef __STDC__ 
STATUS avmintecalc( void )
#else /* !__STDC__ */
    STATUS avmintecalc()
#endif /* __STDC__ */
{

    int pulsecnt;
    int tdaqhxatemp; 
  
    /* All this to find pw_gy1_tot: */
    gy1_offset  = _gy1_offset.fixedflag ?  ((void)(ky_offset*fabs(area_gyb)/intleaves), gy1_offset) : ky_offset*fabs(area_gyb)/intleaves;
    area_gy1  = _area_gy1.fixedflag ?    ((void)(area_gy1+gy1_offset), area_gy1) : area_gy1+gy1_offset;
    area_gy1  = _area_gy1.fixedflag ?  ((void)(fabs(area_gy1)), area_gy1) : fabs(area_gy1);
    endview_iamp  = _endview_iamp.fixedflag ?  ((void)(max_pg_wamp), endview_iamp) : max_pg_wamp;
    endview_scale  = _endview_scale.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iamp), endview_scale) : (float)max_pg_iamp/(float)endview_iamp;
    /* Find the amplitudes and pulse widths of the trapezoidal
       phase encoding pulse. */
    
    if (amppwtpe(_a_gy1a.fixedflag ? (_temp617_a_gy1a=a_gy1a,&_temp617_a_gy1a) : &a_gy1a,_a_gy1b.fixedflag ? (_temp618_a_gy1b=a_gy1b,&_temp618_a_gy1b) : &a_gy1b,_pw_gy1.fixedflag ? (_temp619_pw_gy1=pw_gy1,&_temp619_pw_gy1) : &pw_gy1,_pw_gy1a.fixedflag ? (_temp620_pw_gy1a=pw_gy1a,&_temp620_pw_gy1a) : &pw_gy1a,_pw_gy1d.fixedflag ? (_temp621_pw_gy1d=pw_gy1d,&_temp621_pw_gy1d) : &pw_gy1d,
                 loggrd.ty_xyz/endview_scale,loggrd.yrt,
                 area_gy1) == FAILURE)
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe");
        return FAILURE;
    } 
    
    pw_gy1_tot  = _pw_gy1_tot.fixedflag ?      ((void)(pw_gy1a+pw_gy1+pw_gy1d), pw_gy1_tot) : pw_gy1a+pw_gy1+pw_gy1d;
    
    if (ygmn_type == CALC_GMN1) {
        
        /* set time origin at end of bipolar flow comp lobe/beginning of 
           gy1f phase encoding pulse */
        invertphase  = _invertphase.fixedflag ?  ((void)(0), invertphase) : 0;
        zeromomentsum  = _zeromomentsum.fixedflag ?  ((void)(0.0), zeromomentsum) : 0.0;
        firstmomentsum  = _firstmomentsum.fixedflag ?  ((void)(0.0), firstmomentsum) : 0.0;
        pulsepos  = _pulsepos.fixedflag ?  ((void)(0), pulsepos) : 0;
        
        /* compute moments for blips */
        pulsepos  = _pulsepos.fixedflag ?            ((void)(pw_gy1_tot+pw_gxwad+esp-pw_gxwad/2-pw_gyb/2-pw_gybd), pulsepos) : pw_gy1_tot+pw_gxwad+esp-pw_gxwad/2-pw_gyb/2-pw_gybd;
        if(no_gy1_ol_gxw && iref_etl > 0) pulsepos  = _pulsepos.fixedflag ?  ((void)(esp), pulsepos) : pulsepos+esp;
        for (pulsecnt=0;pulsecnt<blips2cent;pulsecnt++) {
            rampmoments(0.0, a_gyb, pw_gyba, invertphase, _pulsepos.fixedflag ? (_temp622_pulsepos=pulsepos,&_temp622_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp623_zeromoment=zeromoment,&_temp623_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp624_firstmoment=firstmoment,&_temp624_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp625_zeromomentsum=zeromomentsum,&_temp625_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp626_firstmomentsum=firstmomentsum,&_temp626_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gyb, a_gyb, pw_gyb, invertphase, _pulsepos.fixedflag ? (_temp627_pulsepos=pulsepos,&_temp627_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp628_zeromoment=zeromoment,&_temp628_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp629_firstmoment=firstmoment,&_temp629_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp630_zeromomentsum=zeromomentsum,&_temp630_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp631_firstmomentsum=firstmomentsum,&_temp631_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gyb, 0.0, pw_gybd, invertphase, _pulsepos.fixedflag ? (_temp632_pulsepos=pulsepos,&_temp632_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp633_zeromoment=zeromoment,&_temp633_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp634_firstmoment=firstmoment,&_temp634_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp635_zeromomentsum=zeromomentsum,&_temp635_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp636_firstmomentsum=firstmomentsum,&_temp636_firstmomentsum) : &firstmomentsum);
            pulsepos  = _pulsepos.fixedflag ?        ((void)(pulsepos+(esp-pw_gyba-pw_gyb/2)), pulsepos) : pulsepos+(esp-pw_gyba-pw_gyb/2);
	}		
        gyb_tot_0thmoment  = _gyb_tot_0thmoment.fixedflag ?  ((void)(zeromomentsum), gyb_tot_0thmoment) : zeromomentsum;
        gyb_tot_1stmoment  = _gyb_tot_1stmoment.fixedflag ?  ((void)(firstmomentsum), gyb_tot_1stmoment) : firstmomentsum;
        
        /* Here we compute the gradient moment nulling pulse parameters
           for a worst case condition: when the gy1f pulse has zero
           amplitude.  Since the gy1f never really steps to zero amplitude,
           this is hardly an optimal solution.  A future option is to
           compute the minimum amplitude of gy1f across all intleaves
           in this calculation. */
        
        amppwygmn(gyb_tot_0thmoment, gyb_tot_1stmoment, pw_gy1a, pw_gy1,
                  pw_gy1d, 0.0, 0.0, loggrd.ty_xyz, (float)loggrd.yrt,
                  0, _pw_gymn2a.fixedflag ? (_temp637_pw_gymn2a=pw_gymn2a,&_temp637_pw_gymn2a) : &pw_gymn2a, _pw_gymn2.fixedflag ? (_temp638_pw_gymn2=pw_gymn2,&_temp638_pw_gymn2) : &pw_gymn2, _pw_gymn2d.fixedflag ? (_temp639_pw_gymn2d=pw_gymn2d,&_temp639_pw_gymn2d) : &pw_gymn2d, _a_gymn2.fixedflag ? (_temp640_a_gymn2=a_gymn2,&_temp640_a_gymn2) : &a_gymn2);
        
        a_gymn2  = _a_gymn2.fixedflag ?  ((void)(-a_gymn2), a_gymn2) : -a_gymn2;
        a_gymn1  = _a_gymn1.fixedflag ?  ((void)(-a_gymn2), a_gymn1) : -a_gymn2;
        pw_gymn1a  = _pw_gymn1a.fixedflag ?  ((void)(pw_gymn2a), pw_gymn1a) : pw_gymn2a;
        pw_gymn1  = _pw_gymn1.fixedflag ?  ((void)(pw_gymn2), pw_gymn1) : pw_gymn2;
        pw_gymn1d  = _pw_gymn1d.fixedflag ?  ((void)(pw_gymn2d), pw_gymn1d) : pw_gymn2d;
        
        pw_gymn1_tot  = _pw_gymn1_tot.fixedflag ?      ((void)(pw_gymn1a+pw_gymn1+pw_gymn1d), pw_gymn1_tot) : pw_gymn1a+pw_gymn1+pw_gymn1d;
        pw_gymn2_tot  = _pw_gymn2_tot.fixedflag ?      ((void)(pw_gymn2a+pw_gymn2+pw_gymn2d), pw_gymn2_tot) : pw_gymn2a+pw_gymn2+pw_gymn2d;
        
    } else {    /* if (ygmn_type != CALC_GMN1) */
        pw_gymn1_tot  = _pw_gymn1_tot.fixedflag ?  ((void)(0), pw_gymn1_tot) : 0;
        pw_gymn2_tot  = _pw_gymn2_tot.fixedflag ?  ((void)(0), pw_gymn2_tot) : 0;
    }

    if( iref_etl != 0 && pw_gy1_tot + pw_gymn1_tot + pw_gymn2_tot > esp ){
        pw_iref_gxwait  = _pw_iref_gxwait.fixedflag ?        ((void)(RUP_GRD(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot-esp)), pw_iref_gxwait) : RUP_GRD(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot-esp);
    }else{
        pw_iref_gxwait  = _pw_iref_gxwait.fixedflag ?  ((void)(0), pw_iref_gxwait) : 0;
    }
    if(no_gy1_ol_gxw && iref_etl > 0)
        pw_iref_gxwait  = _pw_iref_gxwait.fixedflag ?      ((void)(RUP_GRD(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot)), pw_iref_gxwait) : RUP_GRD(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot);

    tdaqhxatemp = tdaqhxa + pw_iref_gxwait; 

    if (exist(oppseq) == PSD_SE)
        avminssp  = _avminssp.fixedflag ?            ((void)(pw_rf2/2+rfupd+8+pw_wssp+tdaqhxatemp), avminssp) : pw_rf2/2+rfupd+8+pw_wssp+tdaqhxatemp;
    else                         /* gradient echo */
        avminssp  = _avminssp.fixedflag ?            ((void)(rfExIso+rfupd+8+pw_wssp+tdaqhxatemp), avminssp) : rfExIso+rfupd+8+pw_wssp+tdaqhxatemp;
    
    avminssp  = _avminssp.fixedflag ?    ((void)(avminssp+HSDAB_length), avminssp) : avminssp+HSDAB_length;
    if (xtr_offset == 0) {
        avminssp  = _avminssp.fixedflag ?      ((void)(avminssp+(XTRSETLNG+XTR_length[PSD_XCVR2])), avminssp) : avminssp+(XTRSETLNG+XTR_length[PSD_XCVR2]);
    } else {
        avminssp  = _avminssp.fixedflag ?    ((void)(avminssp+xtr_offset), avminssp) : avminssp+xtr_offset;
    }
    if (touch_flag)
    {
        avminssp  = _avminssp.fixedflag ?        ((void)((multi_phases-1.)*touch_delta+cont_drive_ssp_delay), avminssp) : avminssp+(multi_phases-1.)*touch_delta+cont_drive_ssp_delay;
    }
    
    if (exist(oppseq) == PSD_SE)
        avminssp  = _avminssp.fixedflag ?  ((void)(2), avminssp) : avminssp*2;    
 
    /* Use MRE information to update TE-related values */
/* Start inline from touch.e TouchTECalc */
if( touch_flag )
{
    /* If MEGs are put on both sides of RF2, they must be synchronized with the motion the right way so that the phase due the motion and MEG's accrues constructively. */
    /* To do this, calculate how much time is needed for the left MEG and the RF2 gradients, and round this amount of time up to the next appropriate factor of a full or half period of motion to determine where to put the MEG on the right side of RF2 */
    /* rf2_time is going to be the amount of time reserved for RF2 between the end of the left MEG and the beginning of the right MEG */
    {
        int tmp1, tmp2;
        tmp1 = pw_gzrf2l1a + pw_gzrf2l1 + pw_gzrf2l1d + 0 * pw_gzrf2a + pw_gzrf2/ 2;
        tmp2 = pw_gzrf2/ 2 + 0 * pw_gzrf2d + pw_gzrf2r1a + pw_gzrf2r1 + pw_gzrf2r1d;
        pw_gz2_tot  = _pw_gz2_tot.fixedflag ?      ((void)(2*IMax(2,tmp1,tmp2)), pw_gz2_tot) : 2*IMax(2,tmp1,tmp2); /* time needed for the RF2 gradients */
    }

    /* calculate ssp time */
    int tmpssp;
    tmpssp = avminssp/2;

    int time_b4_rf2;
    time_b4_rf2 = IMax(2, touch_time+pw_gz2_tot, tmpssp);

    if( meg_mode == 3 )
    { /* L and R MEGs, minimum TE */
        M_half_periods  = _M_half_periods.fixedflag ?    ((void)((int)ceil(time_b4_rf2/((float)touch_lobe_motion))), M_half_periods) : (int)ceil(time_b4_rf2/((float)touch_lobe_motion));
        rf2_time  = _rf2_time.fixedflag ?      ((void)(M_half_periods*touch_lobe_motion-touch_time), rf2_time) : M_half_periods*touch_lobe_motion-touch_time;
    }
    else if( meg_mode == 2 )
    { /* L and R MEGs, half periods */
        M_half_periods  = _M_half_periods.fixedflag ?    ((void)((int)ceil(time_b4_rf2/((float)touch_lobe_motion))), M_half_periods) : (int)ceil(time_b4_rf2/((float)touch_lobe_motion));
        M_half_periods  = _M_half_periods.fixedflag ?          ((void)(M_half_periods+((M_half_periods%2)?0:1)), M_half_periods) : M_half_periods+((M_half_periods%2)?0:1);
        rf2_time  = _rf2_time.fixedflag ?      ((void)(M_half_periods*touch_lobe_motion-touch_time), rf2_time) : M_half_periods*touch_lobe_motion-touch_time;
    }
    else if( meg_mode == 1 )
    { /* L and R MEGs, integer periods */
        M_half_periods  = _M_half_periods.fixedflag ?    ((void)((int)ceil(time_b4_rf2/((float)touch_lobe_motion))), M_half_periods) : (int)ceil(time_b4_rf2/((float)touch_lobe_motion));
        M_half_periods  = _M_half_periods.fixedflag ?      ((void)(M_half_periods+(M_half_periods%2)), M_half_periods) : M_half_periods+(M_half_periods%2);
        rf2_time  = _rf2_time.fixedflag ?      ((void)(M_half_periods*touch_lobe_motion-touch_time), rf2_time) : M_half_periods*touch_lobe_motion-touch_time;
    }
    else
    { /* Just L MEGs, no restrictions on TE */
        M_half_periods  = _M_half_periods.fixedflag ?  ((void)(0), M_half_periods) : 0;
        rf2_time  = _rf2_time.fixedflag ?  ((void)(pw_gz2_tot), rf2_time) : pw_gz2_tot;
        rf2_time  = _rf2_time.fixedflag ?                      ((void)(RUP_GRD(pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d+0*pw_gzrf2a+pw_gzrf2+0*pw_gzrf2d+pw_gzrf2r1a+pw_gzrf2r1+pw_gzrf2r1d)), rf2_time) : RUP_GRD(pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d+0*pw_gzrf2a+pw_gzrf2+0*pw_gzrf2d+pw_gzrf2r1a+pw_gzrf2r1+pw_gzrf2r1d);
    }
    rf2_time  = _rf2_time.fixedflag ?  ((void)(RUP_GRD(rf2_time)), rf2_time) : RUP_GRD(rf2_time);
}
else
{
    rf2_time  = _rf2_time.fixedflag ?  ((void)(0), rf2_time) : 0;
}
/* End inline from touch.e TouchTECalc */


    if (exist(oppseq) == PSD_SE) {
        if (gx1pos == PSD_POST_180) {
            avminxa  = _avminxa.fixedflag ?  ((void)(2*(rfExIso)), avminxa) : 2*(rfExIso);
            avminxb  = _avminxb.fixedflag ?       
                               ((void)(2*(tdaqhxatemp+pw_wgx+pw_rf2/2+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),pw_gzrf2r1_tot))), avminxb) : 2*(tdaqhxatemp+pw_wgx+pw_rf2/2+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),pw_gzrf2r1_tot));

            if (touch_flag)
            {
                if (meg_mode == 0) {
                    /* Add time for flow comp gradient and MR-Touch gradients and delay */
                    avminxa  = _avminxa.fixedflag ?          ((void)(avminxa+2*(pw_gzrf1d+pw_gz1_tot+pw_gzrf2l1_tot+touch_time)), avminxa) : avminxa+2*(pw_gzrf1d+pw_gz1_tot+pw_gzrf2l1_tot+touch_time);
                } else {
                    avminxa  = _avminxa.fixedflag ?          ((void)(avminxa+2*(pw_gzrf1d+pw_gz1_tot+touch_time+rf2_time/2)), avminxa) : avminxa+2*(pw_gzrf1d+pw_gz1_tot+touch_time+rf2_time/2);
                    avminxb  = _avminxb.fixedflag ?         
                                        ((void)(2*(tdaqhxatemp+pw_wgx+rf2_time/2+touch_time+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),0*pw_gzrf2r1_tot))), avminxb) : 2*(tdaqhxatemp+pw_wgx+rf2_time/2+touch_time+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),0*pw_gzrf2r1_tot));
                }
            }
        } else {
            avminxa  = _avminxa.fixedflag ?  ((void)(2*(rfExIso)), avminxa) : 2*(rfExIso);
            avminxb  = _avminxb.fixedflag ?      ((void)(2*(tdaqhxatemp+pw_wgx+pw_rf2/2)), avminxb) : 2*(tdaqhxatemp+pw_wgx+pw_rf2/2);

            if (touch_flag) {
                if (meg_mode == 0) {
                    avminxa  = _avminxa.fixedflag ?            ((void)(avminxa+2*(pw_gzrf1d+pw_gz1_tot+pw_gzrf2l1_tot+touch_time+pw_gx1_tot)), avminxa) : avminxa+2*(pw_gzrf1d+pw_gz1_tot+pw_gzrf2l1_tot+touch_time+pw_gx1_tot);
                } else {
                    avminxa  = _avminxa.fixedflag ?            ((void)(avminxa+2*(pw_gzrf1d+pw_gz1_tot+touch_time+rf2_time/2+pw_gx1_tot)), avminxa) : avminxa+2*(pw_gzrf1d+pw_gz1_tot+touch_time+rf2_time/2+pw_gx1_tot);
                    avminxb  = _avminxb.fixedflag ?        ((void)(2*(tdaqhxatemp+pw_wgx+rf2_time/2+touch_time)), avminxb) : 2*(tdaqhxatemp+pw_wgx+rf2_time/2+touch_time);
                }
            }
        }

        if(rtb0_flag)
        {
            avminxa  = _avminxa.fixedflag ?          ((void)(2*(IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay)), avminxa) : avminxa+2*(IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay);
        }
        
        avminx   = _avminx.fixedflag ?      ((void)((avminxa>avminxb)?avminxa:avminxb), avminx) : (avminxa>avminxb)?avminxa:avminxb;
      
        if (gy1pos == PSD_POST_180) {
            avminya  = _avminya.fixedflag ?  ((void)(2*(rfExIso)), avminya) : 2*(rfExIso);

            /* internref */
            avminyb  = _avminyb.fixedflag ?         
                             ((void)(2*(pw_rf2/2+pw_wgy+tdaqhxatemp+pw_gxwad+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),pw_gzrf2r1_tot))), avminyb) : 2*(pw_rf2/2+pw_wgy+tdaqhxatemp+pw_gxwad+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),pw_gzrf2r1_tot));
            if (touch_flag) {
                if (meg_mode == 0) {
                    avminya  = _avminya.fixedflag ?          ((void)(2*(rfExIso+pw_gzrf1d+pw_gz1_tot+pw_gzrf2l1_tot+touch_time)), avminya) : 2*(rfExIso+pw_gzrf1d+pw_gz1_tot+pw_gzrf2l1_tot+touch_time);
                    avminyb  = _avminyb.fixedflag ?         
                                        ((void)(2*(pw_rf2/2+pw_wgy+tdaqhxatemp+pw_gxwad+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),pw_gzrf2r1_tot))), avminyb) : 2*(pw_rf2/2+pw_wgy+tdaqhxatemp+pw_gxwad+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),pw_gzrf2r1_tot));
                } else {
                    avminya  = _avminya.fixedflag ?          ((void)(2*(rfExIso+pw_gzrf1d+pw_gz1_tot+touch_time+rf2_time/2)), avminya) : 2*(rfExIso+pw_gzrf1d+pw_gz1_tot+touch_time+rf2_time/2);
                    avminyb  = _avminyb.fixedflag ?           
                                        ((void)(2*(rf2_time/2+touch_time+pw_wgy+tdaqhxatemp+pw_gxwad+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),0*pw_gzrf2r1_tot))), avminyb) : 2*(rf2_time/2+touch_time+pw_wgy+tdaqhxatemp+pw_gxwad+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),0*pw_gzrf2r1_tot));
                }
            }
        } else {
            avminya  = _avminya.fixedflag ?  ((void)(2*(rfExIso)), avminya) : 2*(rfExIso);
            avminyb  = _avminyb.fixedflag ?        ((void)(2*(pw_rf2/2+pw_gxwad+IMax(2,pw_gx1_tot,pw_gzrf2r1_tot))), avminyb) : 2*(pw_rf2/2+pw_gxwad+IMax(2,pw_gx1_tot,pw_gzrf2r1_tot));
            if (touch_flag) {
                if (meg_mode == 0) {
                    avminya  = _avminya.fixedflag ?              ((void)(2*(rfExIso+pw_gzrf1d+pw_gz1_tot+pw_gzrf2l1_tot+touch_time+pw_gy1_tot+pw_wgy)), avminya) : 2*(rfExIso+pw_gzrf1d+pw_gz1_tot+pw_gzrf2l1_tot+touch_time+pw_gy1_tot+pw_wgy);
                    avminyb  = _avminyb.fixedflag ?        ((void)(2*(pw_rf2/2+pw_gxwad+IMax(2,pw_gx1_tot,pw_gzrf2r1_tot))), avminyb) : 2*(pw_rf2/2+pw_gxwad+IMax(2,pw_gx1_tot,pw_gzrf2r1_tot));
                } else {
                    avminya  = _avminya.fixedflag ?              ((void)(2*(rfExIso+pw_gzrf1d+pw_gz1_tot+touch_time+rf2_time/2+pw_gy1_tot+pw_wgy)), avminya) : 2*(rfExIso+pw_gzrf1d+pw_gz1_tot+touch_time+rf2_time/2+pw_gy1_tot+pw_wgy);
                    avminyb  = _avminyb.fixedflag ?          ((void)(2*(rf2_time/2+touch_time+pw_gxwad+IMax(2,pw_gx1_tot,0*pw_gzrf2r1_tot))), avminyb) : 2*(rf2_time/2+touch_time+pw_gxwad+IMax(2,pw_gx1_tot,0*pw_gzrf2r1_tot));
                }
            }  
        }

        if(rtb0_flag)
        {
            avminya  = _avminya.fixedflag ?          ((void)(2*(IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay)), avminya) : avminya+2*(IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay);
        }

        avminy   = _avminy.fixedflag ?      ((void)((avminya>avminyb)?avminya:avminyb), avminy) : (avminya>avminyb)?avminya:avminyb;

        avminza  = _avminza.fixedflag ?          ((void)(2*(rfExIso+pw_gzrf1d+pw_gz1_tot+pw_gzrf2l1_tot+(pw_rf2/2))), avminza) : 2*(rfExIso+pw_gzrf1d+pw_gz1_tot+pw_gzrf2l1_tot+(pw_rf2/2));
        avminzb  = _avminzb.fixedflag ?           
                         ((void)(2*(8+(pw_rf2/2)+tdaqhxatemp+pw_wgz+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),pw_gzrf2r1_tot))), avminzb) : 2*(8+(pw_rf2/2)+tdaqhxatemp+pw_wgz+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),pw_gzrf2r1_tot));
        if (touch_flag) {
            if (meg_mode == 0) {
                avminza  = _avminza.fixedflag ?            ((void)(2*(rfExIso+pw_gzrf1d+pw_gz1_tot+pw_gzrf2l1_tot+touch_time+(pw_rf2/2))), avminza) : 2*(rfExIso+pw_gzrf1d+pw_gz1_tot+pw_gzrf2l1_tot+touch_time+(pw_rf2/2));
                avminzb  = _avminzb.fixedflag ?           
                                    ((void)(2*(8+(pw_rf2/2)+tdaqhxatemp+pw_wgz+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),pw_gzrf2r1_tot))), avminzb) : 2*(8+(pw_rf2/2)+tdaqhxatemp+pw_wgz+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),pw_gzrf2r1_tot));
            } else {
                avminza  = _avminza.fixedflag ?          ((void)(2*(rfExIso+pw_gzrf1d+pw_gz1_tot+touch_time+(rf2_time/2))), avminza) : 2*(rfExIso+pw_gzrf1d+pw_gz1_tot+touch_time+(rf2_time/2));
                avminzb  = _avminzb.fixedflag ?             
                                    ((void)(2*(8+(rf2_time/2)+touch_time+tdaqhxatemp+pw_wgz+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),0*pw_gzrf2r1_tot))), avminzb) : 2*(8+(rf2_time/2)+touch_time+tdaqhxatemp+pw_wgz+IMax(3,pw_gx1_tot,(pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)*(iref_etl==0),0*pw_gzrf2r1_tot));
            }
        }

        if(rtb0_flag)
        {
            avminza  = _avminza.fixedflag ?            ((void)(2*(IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay-pw_gz1_tot)), avminza) : avminza+2*(IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay-pw_gz1_tot);
        }

        avminz   = _avminz.fixedflag ?      ((void)((avminza>avminzb)?avminza:avminzb), avminz) : (avminza>avminzb)?avminza:avminzb;
        
    } else {  /* Gradient echo */
        if (touch_flag) {
            avminx   = _avminx.fixedflag ?                        ((void)(rfExIso+pw_gzrf1d+touch_time+pw_gz1_tot+(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot)*(iref_etl==0)+(pw_gx1a+pw_gx1+pw_gx1d)+tdaqhxatemp+pw_wgx), avminx) : rfExIso+pw_gzrf1d+touch_time+pw_gz1_tot+(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot)*(iref_etl==0)+(pw_gx1a+pw_gx1+pw_gx1d)+tdaqhxatemp+pw_wgx;
            avminy  = _avminy.fixedflag ?                        ((void)(rfExIso+pw_gzrf1d+touch_time+pw_gz1_tot+(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot)*(iref_etl==0)+(pw_gx1a+pw_gx1+pw_gx1d)+pw_wgy+tdaqhxatemp), avminy) : rfExIso+pw_gzrf1d+touch_time+pw_gz1_tot+(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot)*(iref_etl==0)+(pw_gx1a+pw_gx1+pw_gx1d)+pw_wgy+tdaqhxatemp;
            avminz  = _avminz.fixedflag ?                        ((void)(rfExIso+pw_gzrf1d+touch_time+pw_gz1_tot+(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot)*(iref_etl==0)+(pw_gx1a+pw_gx1+pw_gx1d)+pw_wgz+tdaqhxatemp), avminz) : rfExIso+pw_gzrf1d+touch_time+pw_gz1_tot+(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot)*(iref_etl==0)+(pw_gx1a+pw_gx1+pw_gx1d)+pw_wgz+tdaqhxatemp;
        } else {
            avminx  = _avminx.fixedflag ?            ((void)(rfExIso+pw_gx1a+pw_gx1+pw_gx1d+tdaqhxatemp+pw_wgx), avminx) : rfExIso+pw_gx1a+pw_gx1+pw_gx1d+tdaqhxatemp+pw_wgx;
            avminy  = _avminy.fixedflag ?            ((void)(rfExIso+(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot)*(iref_etl==0)+pw_wgy+tdaqhxatemp), avminy) : rfExIso+(pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot)*(iref_etl==0)+pw_wgy+tdaqhxatemp;
            avminz  = _avminz.fixedflag ?          ((void)(rfExIso+pw_gzrf1d+pw_gz1_tot+pw_wgz+tdaqhxatemp), avminz) : rfExIso+pw_gzrf1d+pw_gz1_tot+pw_wgz+tdaqhxatemp;
        }

        if(rtb0_flag)
        {
            avminx  = _avminx.fixedflag ?          ((void)(IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay), avminx) : avminx+IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay;
            avminy  = _avminy.fixedflag ?          ((void)(IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay), avminy) : avminy+IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay;
            avminz  = _avminz.fixedflag ?            ((void)(IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay-pw_gz1_tot), avminz) : avminz+IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay-pw_gz1_tot;
        }
    }

    avmintetemp  = _avmintetemp.fixedflag ?      ((void)(((avminy>avminz)?avminy:avminz)), avmintetemp) : ((avminy>avminz)?avminy:avminz);
    avmintetemp  = _avmintetemp.fixedflag ?      ((void)(((avminx>avmintetemp)?avminx:avmintetemp)), avmintetemp) : ((avminx>avmintetemp)?avminx:avmintetemp);
    avmintetemp  = _avmintetemp.fixedflag ?      ((void)(((avminssp>avmintetemp)?avminssp:avmintetemp)), avmintetemp) : ((avminssp>avmintetemp)?avminssp:avmintetemp);
    
    return SUCCESS;
}

#ifdef __STDC__ 
STATUS nexcalc( void )
#else /* !__STDC__ */
    STATUS nexcalc()
#endif /* __STDC__ */
{ 
    /* This is a similar set of codes as the Nex bookkeeping section, except
       that all the checks have been removed because they have already been
       done once when this routine is called. */

    if (fract_ky == PSD_ON)
        fn  = _fn.fixedflag ?  ((void)(0.5), fn) : 0.5;
    else
        fn  = _fn.fixedflag ?  ((void)(1.0), fn) : 1.0;
  
    nop  = _nop.fixedflag ?  ((void)(1), nop) : 1;
  
    nex  = _nex.fixedflag ?   ((void)(IMax(2,(int)1,(int)(exist(opnex)/nop))), nex) : IMax(2,(int)1,(int)(exist(opnex)/nop));
  
    /* nex buttons */
    pinexnub = 63;
    pinexval2 = 1;
    pinexval3 = 2;
    pinexval4 = 3;
    pinexval5 = 4;
    pinexval6 = 8;
    return  SUCCESS;
  
}

#ifdef __STDC__ 
STATUS setb0rotmats( void )
#else /* !__STDC__ */
    STATUS setb0rotmats()
#endif /* __STDC__ */
{
    int slice, n;
    for (slice=0; slice<3; slice++) {
        for (n=0; n<9; n++)
            scan_info[slice].oprot[n] = 0.0;
    }
  
    /* 1st slice (1st in time order) is an axial */
    scan_info[0].oprot[0] = 1.0; /* readout on physical X */
    scan_info[0].oprot[4] = 1.0; /* blips on physical Y */
    scan_info[0].oprot[8] = 1.0; /* slice on physical Z */
  
    /* 2nd slice (3rd in time order) is a saggital */
    scan_info[1].oprot[3] = 1.0; /* readout on physical Y */
    scan_info[1].oprot[7] = 1.0; /* blips on physical Z */
    scan_info[1].oprot[2] = 1.0; /* slice on physical X */
  
    /* 3rd slice (2nd in time order) is a coronal */
    scan_info[2].oprot[6] = 1.0; /* readout on physical Z */
    scan_info[2].oprot[1] = 1.0; /* blips on physical X */
    scan_info[2].oprot[5] = 1.0; /* slice on physical Y */
  
    /* new geometry info! */
    opnewgeo = 1;
  
    return SUCCESS;
}

/* Add function for more robust resolution selection */
/* Start inline from touch.e TouchMatrixCheck */
/* algorithm for calculating MENC */
void calc_menc( float *menc_factor )
{
    float sc_fact, gamma, N, F, G, T, fc, delta_rt, f_v, tmp1, tmp2, tmp3, q;
    int m_max, ms;

    sc_fact = 0; /* MEG sensitivity (rad/um) */
    gamma = GAM * 2 * PI; /* gyromagnetic ratio (rad/(s*G)) */
    N = touch_gnum; /* number of gradient pairs in single MEG train */
    F = touch_act_freq_meg; /* MEG frequency (Hz) */
    G = touch_gamp; /* MEG amplitude (G/cm) */
    T = touch_period_meg * (1e-6); /* period of MEG train (s) */
    fc = touch_fcomp; /* flow-compensation type (0=none, 1=type-1 (long MEG), 2=type-2 (short MEG)) */
    delta_rt = touch_pwramp * (1e-6); /* rise time from 0 to G (sec) */
    if( fc == 2 )
    {
        delta_rt = delta_rt/ 2.0; /* need rise time of FC lobes for calculations involving this flow comp'ed MEG */
    }
    f_v = touch_act_freq_motion/0.99; /* frequency of vibration (Hz) */

    if( f_v == F )
    { /* motion freq. = MEG freq. */
        if( fc == 0 )
        { /* MEG is not flow compensated */
            N = 2 * N; /*  N is the # of half gradient lobes in this expression since single MEG lobes are supported now */
            sc_fact = (1e-4) * gamma * N * T * T * G * sin(2.0 * PI * delta_rt/ T)/ (2 * PI * PI * delta_rt);
        }
        else if( fc == 1 )
        { /*  type-1 flow compensation */
            sc_fact = (1e-4) * gamma * N * T * T * G * sin(2.0 * PI * delta_rt/ T)/ (PI * PI * delta_rt);
        }
        else if( fc == 2 )
        { /* type-2 flow compensation */
            m_max = 31;
            tmp1 = 0;
            for( ms = -m_max; ms <= m_max; ms += 2 )
            {
                tmp1 += (sin(PI * 4.0 * ms * delta_rt * F)/ (PI * 4.0 * ms * delta_rt * F))/ (2.0 * PI * ms * (ms/ 2.0 - 0.25));
            }
            tmp2 = (2.0 * N - 1.0) * sin(PI * 4.0 * delta_rt * F)/ (PI * 4.0 * delta_rt * F) + tmp1;
            sc_fact = (1e-4) * gamma * T * G * tmp2/ PI;
        }
    }
    else
    {
        /* motion freq. != MEG freq. */
        if( fc == 0 )
        {
            N = 2 * N; /*  N is the # of half gradient lobes in this expression since single MEG lobes are supported now  */
            m_max = 31;
            tmp1 = 0;
            for( ms = -m_max; ms <= m_max; ms += 2 )
            {
                tmp1 += (sin(PI * 2.0 * ms * delta_rt/ T)/ (PI * 2.0 * ms * delta_rt/ T)) * sin(PI * N * (ms - f_v * T)/ 2.0) * pow(-1.0, (N * ms - (((int)N) % 2))/ 2.0)/ (ms * (ms - f_v * T));
            }
            sc_fact = fabs((2.0 * (1e-4) * gamma * T * G/ (PI * PI)) * (tmp1));
        }
        else if( fc == 1 )
        {
            m_max = 31;
            tmp1 = 0;
            for( ms = -m_max; ms <= m_max; ms += 2 )
            {
                tmp1 += (sin(PI * 2.0 * ms * delta_rt/ T)/ (PI * 2.0 * ms * delta_rt/ T))/ (ms * (ms - f_v * T));
            }
            sc_fact = fabs((2.0 * (1e-4) * gamma * T * G * sin(PI * N * f_v * T) * sin(PI * f_v * T/ 2.0)/ (PI * PI)) * (tmp1));
        }
        else if( fc == 2 )
        {
            m_max = 31;
            tmp1 = 0;
            tmp2 = 0;
            q = f_v/ F;
            for( ms = -m_max; ms <= m_max; ms += 2 )
            {
                tmp1 += (-(2.0 * N - 1.0) * cos(PI * q * (N - 0.5)) * (sin(PI * 4.0 * ms * delta_rt * F)/ (PI * 4.0 * ms * delta_rt * F))/ (PI * (N - 0.5) * ms * (ms - q)));
                tmp2 += (cos(PI * q/ 4.0) * (sin(PI * 4.0 * ms * delta_rt * F)/ (PI * 4.0 * ms * delta_rt * F))/ (2.0 * PI * ms * (ms/ 2.0 - q/ 4.0)));
            }
            tmp3 = tmp1 * tmp1 + 2.0 * tmp2 * tmp2 + 4.0 * tmp1 * tmp2 * cos(PI * N * q - PI * q/ 4.0) + 2.0 * tmp2 * tmp2 * cos(PI * q/ 2.0 - 2.0 * PI * N * q);
            if( tmp3 < 0 )
            {
                sc_fact = 0.0;
            }
            else
            {
                sc_fact = (1e-4) * gamma * T * G * pow(tmp3, 0.5)/ PI;
            }
        }
    } /* ends if (f_v == F), else statements */
    /* Assuming +/- phase subtraction with equal-amplitude MEGs, the motion sensitivity will be double what we just calculated, so we need an additional factor of 2. */
    /* We also need another factor of 2 if we are using MEGs after the refocusing pulse. */
    sc_fact = sc_fact * 2 * ((meg_mode > 0) ? 2 : 1);
    if( sc_fact > 0 )
    {
        *menc_factor = PI/ sc_fact; /* MENC definition: touch_menc microns of motion results in PI radians of phase in the phase difference images*/
    }
    else
    {
        *menc_factor = 0;
    }
}
/* End inline from touch.e TouchMatrixCheck */

STATUS 
InversionCheck( void )
{
    if (existcv(opti) && (exist(opti) < avminti)) {
        epic_error(use_ermes, "Increase TI to %d", EM_PSD_TI_OUT_OF_RANGE1, 1, 
                   INT_ARG, avminti/1000);
        return ADVISORY_FAILURE;
    }

    if (existcv(opti) && (exist(opti) > avmaxti)) {
        epic_error(use_ermes, "Decrease TI to %d", EM_PSD_TI_OUT_OF_RANGE2, EE_ARGS(1),
                   INT_ARG, avmaxti/1000);
        return ADVISORY_FAILURE;
    }

    return(SUCCESS);
}


/***********************************************************************/
/* CVCHECK                                                             */
/***********************************************************************/
STATUS
#ifdef __STDC__ 
cvcheck( void )
#else /* !__STDC__ */
    cvcheck() 
#endif /* __STDC__ */
{

    int temp_int;
    
    /* Check for EPI Imaging Option */    
    if (exist(opepi) != PSD_ON) {
        epic_error(use_ermes,
                   "The EPI option is not supported in this scan.", EM_PSD_EPI_INCOMPATIBLE, 0);
        return FAILURE;
    }

    /* YMSmr06515, YMSmr06769 May 2005 KK */
    if (exist(opslquant) > MAXSLQUANT_EPI){
        epic_error( use_ermes, "The number of scan locations selected must be reduced to %d for the current prescription.",
                    EM_PSD_SLQUANT_OUT_OF_RANGE, 1, INT_ARG, MAXSLQUANT_EPI);
        return FAILURE; 
    } 
    
    /* Prescription Level Checks */
    /* Check if the number of opshots are greater than opyres. */
    if ( (existcv(opnex)!=PSD_OFF) && ( (exist(opnshots)) > (exist(opyres)) ) ) {
        epic_error((int)0,
                   "Number of shots must be less than or equal to phase encode lines.",
                   EM_PSD_SUPPORT_FAILURE, 1, STRING_ARG,
                   "Number of shots must be less than or equal to phase encode lines.");
        avminnshots= exist(opyres);
        return ADVISORY_FAILURE;
    }
    
    /* Check if the selected yres is compatible with the chosen opnshots and te */
    if ( (existcv(opnex)!=PSD_OFF) && ((rhnframes + rhhnover) % exist(opnshots) != 0) ) {
        temp_int = exist(opyres)/exist(opnshots);
        if ( (temp_int % 2) == 1) 
            temp_int +=1;
        newyres  = _newyres.fixedflag ?  ((void)(temp_int*exist(opnshots)), newyres) : temp_int*exist(opnshots);

        {
            int temp_yres, temp_frames, calc_sign, icount, max_count;

            max_count = IMax(2, (newyres - avminyres)/2, (avmaxyres - newyres)/2);

            for (icount=0; (icount<=max_count*2); icount++){

                calc_sign = 1 - 2*(icount%2);
                temp_yres = newyres + 2*calc_sign*(icount/2);

                if ((temp_yres >= avminyres) && (temp_yres <= avmaxyres)){
                    if(num_overscan > 0) {
                         temp_frames = (short)(ceilf((float)temp_yres*asset_factor/rup_factor)*rup_factor*fn*nop - ky_offset);
                    } else {
                         temp_frames = (short)(ceilf((float)temp_yres*asset_factor/rup_factor)*rup_factor*fn*nop);
                    }
                    if (((temp_frames + rhhnover) % 2 == 0) &&
                        ((temp_frames + rhhnover) % exist(opnshots) == 0)){
                        newyres  = _newyres.fixedflag ?  ((void)(temp_yres), newyres) : temp_yres;
                        break;
                    }
                }
            }
        }

        epic_error((int)0,
                   "Combination of opnshots and opyres incompatible try opyres of %d.",
                   EM_PSD_SUPPORT_FAILURE, 1, INT_ARG, newyres,
                   "Combination of opshots and opyres incompatible.");
        /* 4/21/96 RJL - Event handler for this error to get choice into popup. This handler
           forces yres to appear with this desired value in the popup */
        avminyres = newyres;
        avmaxyres = newyres;
        return ADVISORY_FAILURE;
    }
    
    /*MRIge42072*/ /*MRIge61054*/ 
    if ( exist(opsquare)==PSD_OFF &&  exist(opphasefov)<0.5) {
        epic_error( use_ermes,"The phasefov is out of range for the current prescription.",
                    EM_PSD_SUPPORT_FAILURE,1, FLOAT_ARG, avminphasefov);
        avminphasefov = 0.5;
        return ADVISORY_FAILURE;
    }
    
    if ( exist(opsquare)==PSD_OFF && exist(opphasefov)>1.0) {
        epic_error( use_ermes,"The phasefov is out of range for the current prescription.",
                    EM_PSD_SUPPORT_FAILURE,1,FLOAT_ARG,avmaxphasefov);
        avmaxphasefov = 1.0;
        return ADVISORY_FAILURE;
    }
    
    if ( (rhnframes + rhhnover)%2 != 0 ) {
        epic_error(use_ermes, 
                   "Illegal combination of phase encode lines, no. of shots, and fract/full TE.",
                   EM_PSD_EPI_ILLEGAL_NFRAMES, 0);
        return FAILURE;
    }
    
    if ((exist(opte) < (float)avminte) && existcv(opte)) {
	epic_error(use_ermes," Minimum TE is %-d ms ",
                   EM_PSD_TE_OUT_OF_RANGE3, 1, INT_ARG, (int)ceil((double)avminte/1000.0));
	return ADVISORY_FAILURE;
    }
    
    if ((exist(oprbw) > avmaxrbw) && existcv(oprbw)) {
        epic_error( use_ermes,"Decrease oprbw to %f.",
                    EM_PSD_MAX_RBW1, 1, FLOAT_ARG, avmaxrbw );
        return ADVISORY_FAILURE;
    }  
    

    if ((exist(opfov) < avminfov) && existcv(opfov)) {
        epic_error( use_ermes,"Minimum FOV is %-f cm ",
                    EM_PSD_FOV_OUT_OF_RANGE, 1, FLOAT_ARG, avminfov/ 10.0 );
        return ADVISORY_FAILURE;
    }  
    
    if (existcv(oprbw) && (exist(oprbw) < avminrbw)) {
        epic_error( use_ermes, "Increase oprbw to %f.",
                    EM_PSD_MIN_RBW1, 1, FLOAT_ARG, avminrbw );
        return ADVISORY_FAILURE;
    }
    
    if ((exist(opfov) > avmaxfov) && existcv(opfov)) {
        epic_error( use_ermes,"Maximum FOV is %-f cm ",
                    EM_PSD_FOV_OUT_OF_RANGE2, 1, FLOAT_ARG, avmaxfov/ 10.0 );
        return ADVISORY_FAILURE;
    }
   
    if( existcv(opxres) && exist(opxres) < avminxres ) {
        epic_error( use_ermes, "The frequency encoding steps must be increased to %d for the current prescription.", EM_PSD_XRES_OUT_OF_RANGE2, EE_ARGS(1), INT_ARG, avminxres );
        return ADVISORY_FAILURE;
    }
    if( existcv(opxres) && exist(opxres) > avmaxxres ) {
        epic_error( use_ermes, "The frequency encodings must be decreased to %d for the current prescription.", EM_PSD_XRES_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, avmaxxres );
        return ADVISORY_FAILURE;
    }

    if (existcv(opxres) && (exist(opxres) % 2) != 0) {
        epic_error(use_ermes, "This XRES selection is not valid.", EM_PSD_EPI_XRES_INVALID, 0);
        return FAILURE;
    }

    /* MRIhc56388: rhfrsize limit for dynamic phasce correction */
    if( iref_etl>0 && existcv(opxres) && rhfrsize > MAXFRAMESIZE_DPC) {
        epic_error(use_ermes, "XRES is out of range",
                   EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "XRES");
        return FAILURE;
    }
    
    if( exist(opsquare)==PSD_ON  && existcv(opxres) && existcv(opyres) && (exist(opyres) > exist(opxres))) {
        epic_error(use_ermes, "This YRES cannot be achieved with current prescription",
                   EM_PSD_YRES_OUT_OF_RANGE, 1, INT_ARG, avmaxyres);
        avmaxyres = exist(opxres);
        return ADVISORY_FAILURE;
    }
    
    if( exist(opsquare)==PSD_ON  && existcv(opxres) && existcv(opyres) && 
        (exist(opyres) < exist(opxres)*avminphasefov)) {
        epic_error(use_ermes, "This YRES cannot be achieved with current prescription",
                   EM_PSD_YRES_OUT_OF_RANGE, 1, INT_ARG, avminyres);
        avminyres = exist(opxres)/2;
        return ADVISORY_FAILURE;
    }
    
    if (existcv(opyres) && (exist(opyres) % 2) != 0) {
        strcpy(estr, " The acquisition matrix size in phase (y resolution) must be even for EPI ");
        epic_error(use_ermes, estr, EM_PSD_EPI_YRES_MUST_BE_EVEN, EE_ARGS(0));
        return FAILURE; 
    }
    
    if(existcv(opnex) && (exist(opnex) ==0.0 )) {
        epic_error(use_ermes, "Improper NEX selected", EM_PSD_NEX_OUT_OF_RANGE, 0);
        return FAILURE ;
    } /*** RJF , MRIge41464 **/
    
    if ( exist(opnex) - (INT)(exist(opnex)) != 0 ) {
	strcpy(estr, "Fractional NEX is not allowed with this scan.");
	epic_error(use_ermes, estr, EM_PSD_FNEX_INCOMPATIBLE, EE_ARGS(0));
	avminnex = 1.0;
	avmaxnex = 1.0;
	return ADVISORY_FAILURE; 
    }
    
    if ( (exist(opcgate)==PSD_ON) && (mph_flag==PSD_ON) && (exist(opacqo)==1) ) {
        sprintf(estr,"The sequential multiphase and cardiac gating options are not compatible for epi. ");
        epic_error(use_ermes, estr, EM_PSD_EPI_SEQMPH_CGATE_INCOMPATIBLE, 1, STRING_ARG,
                   "The sequential multiphase and cardiac gating options are not compatible for epi. ");
        return FAILURE;
    }

    if  ((exist(opnshots) > touch_maxshots) && (exist(optouch) == PSD_ON))  {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "MR-Touch", STRING_ARG, "Multi-Shot EPI)" );
        return FAILURE;                              
    }
     
    if (ygmn_type == CALC_GMN1 && gy1pos == PSD_PRE_180) {
	sprintf(estr, " gy1 pulse pos for fcomp. ");
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, " gy1 pulse pos for fcomp. ");
	return FAILURE;
    }
    
    if (SpSatCheck() == FAILURE) return FAILURE;
    
    /* check for slice thickness */
    if( existcv(opslthick) && (exist(opslthick) < avminslthick) ) 
    {
        epic_error(use_ermes, "Increase the slice thickness to %2f mm", 
                   EM_PSD_SLTHICK_OUT_OF_RANGE, EE_ARGS(1), FLOAT_ARG, avminslthick);
        return ADVISORY_FAILURE;
    }      

    /* MRIge56926 - Removed calculation of avminslthick from inside error conditions */
    if (a_gzrf1 > loggrd.tz) {
        epic_error(use_ermes, "Increase the slice thickness to %2f mm",
                   EM_PSD_SLTHICK_OUT_OF_RANGE, EE_ARGS(1),
                   FLOAT_ARG, avminslthick);
	return ADVISORY_FAILURE;
    }
    
    if (a_gzrf2 > loggrd.tz) {
        epic_error(use_ermes, "Increase the slice thickness to %2f mm",
                   EM_PSD_SLTHICK_OUT_OF_RANGE, EE_ARGS(1),
                   FLOAT_ARG, avminslthick);
	return ADVISORY_FAILURE;
    }
    
    
    /*
     * dB/dt error checks
     */
    /* JAH: MRIge57700 -- only check this when opfov exists, the error should be
       caught more meaningfully when there is a real FOV */
    if ((pidbdtts > cfdbdtts) && (cfdbdtts > 0.0)) {
        epic_error( use_ermes,
                    "Stimulation threshold exceeded (T/s).",
                    EM_PSD_EPI_DBDTTS, 0 );
        printf( "\ndB/dt value of %f T/s exceeds limit of %f T/s\n",
                pidbdtts, cfdbdtts );
        return FAILURE;
    }
    
    if ((pidbdtper > cfdbdtper) && (cfdbdtper > 0.0)) {
        epic_error( use_ermes,
                    "Stimulation threshold exceeded (%%).",
                    EM_PSD_EPI_DBDTPER, 0 );
        printf( "\ndB/dt value of %f percent exceeds limit of %f percent\n",
                pidbdtper, cfdbdtper );
        return FAILURE;  
    }
    
    
    if ( (exist(opxres) > 256) && (vrgfsamp == PSD_ON) ) {
        strcpy(estr, "xres greater than 256 and ramp sampling are not compatible. ");
        epic_error(use_ermes, estr, EM_PSD_EPI_RAMPSAMP_XRES, 0);
        return FAILURE; 
    }
    
    if ( (cffield == B0_5000) && (exist(opfat) !=  PSD_ON) ) {
        strcpy(estr, " Fat suppression must be selected with 0.5T epi. ");
        epic_error(use_ermes, estr, EM_PSD_EPI_HALFT_NOFATSAT, 0);
        return FAILURE; 
    }
    
    /* The number of passes in mph should not excceed max_num_pass. MRIge32615 ypd */
    if( mph_flag == PSD_ON ) {
        if ( existcv(opfphases) && (exist(opfphases) > max_num_pass*SLICE_FACTOR) ) {
            epic_error(use_ermes,"The maximum number of phases is %-d",
                       EM_PSD_NUM_PASS_OUT_OF_RANGE, 1, INT_ARG, max_num_pass);
            return FAILURE;
        }

        if ( existcv(opslquant) && existcv(opfphases) && ((opfphases) > PHASES_MAX) ) {
            epic_error(use_ermes,
                       "Maximum number of phases exceeded, reduce # of slices or phases", EM_PSD_MAXPHASE_EXCEEDED,0);
            return FAILURE;
        }

        if ( existcv(opslquant) && existcv(opfphases) && 
                ((opfphases * opslquant * opphases) > max_slice_limit) ) {
            epic_error(use_ermes, "The number of locations * phases has exceeded %d.", 
                    EM_PSD_SLCPHA_OUT_OF_RANGE ,EE_ARGS(1),INT_ARG,max_slice_limit);

            return FAILURE;
        }

        /* Limit of 256 slices per pass - only a limit for sequential (opacqo = 1) mph */
	if ( existcv(opfphases) && (exist(opfphases) && (exist(opacqo) == 1) > MAXSLQUANT2D) ) {
            epic_error(use_ermes,"The maximum number of phases is %-d",
                       EM_PSD_NUM_PASS_OUT_OF_RANGE, 1, INT_ARG, max_num_pass);
            return FAILURE;
        }

        /* YMSmr06515: # of slice locations expansion -  Limit rhnpasses to MAX_PASSES (=1024) */
        if ( existcv(opfphases) && (exist(opacqo) == 0) && ( (pass_reps * acqs) > MAX_PASSES ) ) { 
            epic_error (use_ermes, "The maximum number of phases is %-d", 
                        EM_PSD_NUM_PASS_OUT_OF_RANGE, 1, INT_ARG, (MAX_PASSES/acqs));
            return FAILURE;
        }

        /*MRIhc00610 -Venkat, Limit phases to 256, for sequential multiphase */ /* YMSmr06515 */
        if ( existcv(opfphases) && (exist(opacqo) == PSD_ON) && (opfphases > MAX_SLICES_PER_PASS) ) { 
            epic_error (use_ermes, "The maximum number of phases is %-d", 
                    EM_PSD_NUM_PASS_OUT_OF_RANGE, 1, INT_ARG, (MAX_SLICES_PER_PASS));


            return FAILURE;
        }
    }
    
    if ( (exist(opnshots) == exist(opyres)) && (exist(opautote) == 2) ) {
        epic_error(use_ermes,
                   "# of Phases should exceed # of shots if Minimum TE is selected",
                   EM_PSD_EPI_NSHOTS_YRES_INCOMPATIBLE2, 0);
        return FAILURE;
    }
    
    /* YMSmr07177 */
    if ((opsldelay < (float)avminsldelay) && existcv(opsldelay)) { 
        epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Delay After Acq" );
	return FAILURE;
    }

    /* YMSmr06685, YMSmr07177 */
    if ((opsldelay > (float)avmaxsldelay) && existcv(opsldelay)) {
        epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Delay After Acq" );
        return FAILURE;
    } 
    
    if (nshots_locks == PSD_ON) {
        if ( exist(opnshots) < min_nshots ) {
            epic_error(use_ermes,
                       "The minimum number of shots for this protocol is %d.", EM_PSD_EPI_MIN_NSHOTS, 1, INT_ARG, avminnshots);
            return ADVISORY_FAILURE; 
        }
    }
    
 
    {
        int status_flag;

        /* Ensure that the coverage and slice thickness are */
        /* supported by the sp-sp pulse */
        status_flag = ssCheck();
        if (status_flag != SUCCESS) return status_flag;
    
        /* Check epi compatibility with Imaging Options */
        status_flag = checkEpiImageOptions();
        if (status_flag != SUCCESS ) return status_flag;
    
        /* Throw warning if cal files are missing */
        status_flag = epiCalFileCVCheck();
        if(status_flag != SUCCESS) return status_flag;
    }   

    /* MRIge92386 */
/* ASSET Scan check */

    /* MRIhc18622 Check option key for all ASSET scans */
    if(PSD_ON == exist(opassetscan))
    {
        int ASSETKey;
#ifdef PSD_HW
        ASSETKey = !checkOptionKey( SOK_ASSET );
#else 
        ASSETKey = PSD_ON;
#endif /* PSD_HW */
        
        if( PSD_OFF == ASSETKey )
        {
            epic_error( use_ermes, "%s is not available without the option key.",
                        EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "ASSET" );
            return FAILURE;
        }
    }


    /* Check for invalid imaging options */
    if( ASSET_SCAN == exist(opasset) )
    {
        if( exist(oppomp) )
        {
            epic_error( use_ermes,
                        "The POMP option is not compatible with ASSET.", 
                        EM_PSD_POMP_ASSET_INCOMPATIBLE, EE_ARGS(0) );
            return FAILURE;
        }

        if( exist(opsquare) )
        {
            epic_error( use_ermes,
                        "The Square Pixel option is not compatible with ASSET.", 
                        EM_PSD_SQUARE_ASSET_INCOMPATIBLE, EE_ARGS(0) );
            return FAILURE;
        }

        if( exist(opnopwrap) )
        {
            epic_error( use_ermes,
                        "The No Phase Wrap option is not compatible with ASSET.", 
                        EM_PSD_NOPWRAP_ASSET_INCOMPATIBLE, EE_ARGS(0) );
            return FAILURE;
        }

        if( exist(oprealtime) )
        {
            epic_error( use_ermes,
                        "The Realtime option is not compatible with ASSET.", 
                        EM_PSD_REALTIME_ASSET_INCOMPATIBLE, EE_ARGS(0) );
            return FAILURE;
        }

        if( exist(opcmon) )
        {
            epic_error( use_ermes,
                        "The Cardiac Compensation option is not compatible with ASSET.", 
                        EM_PSD_CMON_ASSET_INCOMPATIBLE, EE_ARGS(0) );
            return FAILURE;
        }

        if( PSD_ON == exist(opzip1024) )
        {
            epic_error( use_ermes,
                        "1024 ZIP is not compatible with ASSET.",
                        EM_PSD_NO_1024_ZIP_ASSET, EE_ARGS(0) );
            return FAILURE;
        }

        if( exist(opexor) )
        {
            epic_error(use_ermes,"%s is incompatible with %s.",
                       EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG,"Resp Comp",
                       STRING_ARG,"ASSET");
            return FAILURE;
        }
    }

    /* MRIhc32862: Slice ASSET is not supported by any 2D scans */
    if( existcv(opasset) && (PSD_ON == assetsl_flag) && (PSD_2D == exist(opimode)) )
    {
            piaccelscrn = PSD_OFF;
            piaccel_slnub = 0;
            epic_error(use_ermes,"%s is incompatible with %s",EM_PSD_INCOMPATIBLE,
                       EE_ARGS(2),STRING_ARG,"Slice ASSET",STRING_ARG,"this PSD");
            return FAILURE;
    }

    /* BJM: 1024 Support */
    if( ( ( existcv(opxres) && exist(opxres) > 512 ) || ( existcv(opyres) && exist(opyres) > 512 ) ||
           ( (existcv(opyres) && existcv(opphasefov)) && ((exist(opyres)*exist(opphasefov) > 512 )) ) ) 
         && (PSD_ON == exist(opassetscan)) )
    {
        epic_error(use_ermes,"%s is incompatible with %s",EM_PSD_INCOMPATIBLE,
                   EE_ARGS(2),STRING_ARG,"ASSET",STRING_ARG,"an image matrix larger than 512");
        return FAILURE;
    }

    if( (!value_system_flag) && exist(opassetscan) && exist(opepi) && exist(opflair) )
    {
        epic_error( use_ermes,
                    "The ASSET option is not compatible with this PSD.", 
                    EM_PSD_NO_ASSET_SCAN, EE_ARGS(0) );
        return FAILURE;
    }

    /* MRIhc18622: Patient position check is removed for asset and calib scan
       since it is checked by host (MRIhc01471) */

    if( (VALUE_SYSTEM_HDE == value_system_flag) && assetph_flag && (exist(opaccel_ph_stride) > 2.0) && existcv(opaccel_ph_stride) ) {
        epic_error( use_ermes,
	            "Phase Acceleration is out of range", 
                    EM_PSD_CV_OUT_OF_RANGE,EE_ARGS(1),STRING_ARG,"Phase Acceleration");
        return FAILURE;
    }

    if( assetph_flag && (exist(opaccel_ph_stride) > avmaxaccel_ph_stride) && existcv(opaccel_ph_stride) ) {
                epic_error( use_ermes, "The phase acceleration must "
                            "be reduced to %0.2f for this prescription.",
                            EM_PSD_GEM_INVALID_ACCEL, EE_ARGS(1),
                            FLOAT_ARG, avmaxaccel_ph_stride);
        return ADVISORY_FAILURE;
    }
    if( assetsl_flag && (exist(opaccel_sl_stride) > avmaxaccel_sl_stride) && existcv(opaccel_sl_stride) ) {
                epic_error( use_ermes, "The Slice acceleration must "
                            "be reduced to %0.2f for this prescription.",
                            EM_PSD_GEM_INVALID_ACCEL, EE_ARGS(1),
                            FLOAT_ARG, avmaxaccel_sl_stride);
        return ADVISORY_FAILURE;
    }

/* ASSET Scan check */
    

    if (ss_fa_scaling_flag && (cfgcoiltype == PSD_XRMB_COIL || cfgcoiltype == PSD_XRMW_COIL) && 
        (ss_rf1 == PSD_ON) && (exist(oppseq) == PSD_GE))
    {
        if((existcv(opflip) == PSD_ON) && (exist(opflip) > avmaxflip)) 
        {
            strcpy(estr, "%s is out of range");
            epic_error(use_ermes,estr,EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Flip angle");
            return ADVISORY_FAILURE;
        }
    }

    return SUCCESS;
  
} /* end CVCHECK */

STATUS ssCheck(void) 
{
    /* BJM: this function is no longer needed as these checks are performed in ssEval2 */
    /*      However, in order to minimize the impact to the epi source, we will keep it */
    /*      around for now....*/

    return SUCCESS;
}


/******************************ssRsp*************************************/

STATUS rtb0Init() 
{
    rtb0_movAvg  = _rtb0_movAvg.fixedflag ?  ((void)(5), rtb0_movAvg) : 5;

    /* For small number of sample points, reduce the num of skipped points */
    if ( (int) ((rhfrsize - rtb0_min_points)/2) < 20 )
    {
        rtb0_first_skip  = _rtb0_first_skip.fixedflag ?   ((void)((int)((rhfrsize-rtb0_min_points)/2)), rtb0_first_skip) : (int)((rhfrsize-rtb0_min_points)/2);
        rtb0_last_skip  = _rtb0_last_skip.fixedflag ?  ((void)(rtb0_first_skip), rtb0_last_skip) : rtb0_first_skip;
    } else {
        rtb0_first_skip  = _rtb0_first_skip.fixedflag ?  ((void)(20), rtb0_first_skip) : 20;
        rtb0_last_skip  = _rtb0_last_skip.fixedflag ?  ((void)(20), rtb0_last_skip) : 20;
    }
    return SUCCESS;
}


/*
 *  predownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
predownload( void )
{
    int off_index;   /* loop index */
    int i, j;     /* counters */
    int sloff;
    int acq_off;
    
    fprintf(stderr,"At top of predownload, pw_gyb and a_gyb are %d and %f \n",pw_gyb,a_gyb);
    if(epigradopt_output) printEpigradoptResult();

    { /* Start of code inlined from vmx.e PreDownLoad */
        if( system_type == 1 )
        {
            rfupa = cv_rfupa;
        }
    } /* End of code inlined from vmx.e PreDownLoad */


    /* To avoid side effects, set pitfeextra before loadrheader */
     pitfeextra = 0; 

    /* Recon variables */
    { /* Start of code inlined from loadrheader.e rheaderinit */

        /*
          rawdata   0=NOREC, 1=NPPROC
          eepf      1 for even echo phase flip
          oepf      1 for odd echo phase flip
          eeff      1 for even echo freq flip
        */

        eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
        oepf  = _oepf.fixedflag ?  ((void)(0), oepf) : 0;
        eeff  = _eeff.fixedflag ?  ((void)(0), eeff) : 0;
        oeff  = _oeff.fixedflag ?  ((void)(0), oeff) : 0;

        pinex = nex; /* initialize for pinex so APS can use it */

        if( nex == 1 )
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(baseline), rhbline) : baseline;
        }
        else if( (((int)exist(opnex))%2) && (exist(opnex) > 2) )
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(baseline), rhbline) : baseline;
        }
        else if( (((int)exist(opnex))%2==0) && (exist(opnex)>5) && (nex%2) )
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(baseline), rhbline) : baseline;
        }
        else
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(0), rhbline) : 0;
        }

        if( opimode == PSD_CINE )
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(0), rhbline) : 0;
            if  ( ( (((int)exist(opnex))%2) && (exist(opnex) > 2) ) ||
                  ( (((int)exist(opnex))%2==0) && (exist(opnex)>5)
                    && (nex%2) ) || (nex < 2) )
                cine_choplet  = _cine_choplet.fixedflag ?  ((void)(PSD_ON), cine_choplet) : PSD_ON;
            else
                cine_choplet  = _cine_choplet.fixedflag ?  ((void)(PSD_OFF), cine_choplet) : PSD_OFF;
        }

        if( rhbline )
        {
            rhblank  = _rhblank.fixedflag ?  ((void)(blank), rhblank) : blank;
        }
        else
        {
            rhblank  = _rhblank.fixedflag ?  ((void)(0), rhblank) : 0;
        }

        rhtype  = _rhtype.fixedflag ?  ((void)(0), rhtype) : 0;
        if( (nex > 1) && (opimode != PSD_CINE) )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPCHP), rhtype) : rhtype+RHTYPCHP;
        }
        if( (((int)exist(opnex))%2) && (exist(opnex) > 2) )
        {
            rhtype  = _rhtype.fixedflag ?  ((void)(0), rhtype) : 0;
        }
        if( (((int)exist(opnex))%2 == 0) && (exist(opnex) > 5) && (nex%2) )
        {
            rhtype  = _rhtype.fixedflag ?  ((void)(0), rhtype) : 0;
        }
        if( (opimode == PSD_CINE) && (!cine_choplet) )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPCHP), rhtype) : rhtype+RHTYPCHP;
        }
        if( opimode == PSD_CINE )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPCINE), rhtype) : rhtype+RHTYPCINE;
        }
        if( oppseq == PSD_GE || 
            oppseq == PSD_TOF || oppseq == PSD_TOFSP ||
            oppseq == PSD_PC  || oppseq == PSD_PCSP ||
            oppseq == PSD_3PLANELOC )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPGR), rhtype) : rhtype+RHTYPGR;
        }
        if( fn == 0.5 )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPFRACTNEX), rhtype) : rhtype+RHTYPFRACTNEX;
        }
        if( opimode == PSD_3D )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYP3D), rhtype) : rhtype+RHTYP3D;
        }
        if( (nop == 2) && (oppomp == PSD_OFF) )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPNPW), rhtype) : rhtype+RHTYPNPW;
        }
        if( pitfeextra > 0 )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPFRACTECHO), rhtype) : rhtype+RHTYPFRACTECHO;
        }
        if( fn == 0.75 )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYP75NEX), rhtype) : rhtype+RHTYP75NEX;
        }
        if( oppomp )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPPOMP), rhtype) : rhtype+RHTYPPOMP;
        }

        rhnecho  = _rhnecho.fixedflag ?  ((void)(opnecho), rhnecho) : opnecho;

        if( (opimode == PSD_CINE)
            && ((oppseq == PSD_PC) || (oppseq == PSD_PCSP)) )
        {
            rhnslices  = _rhnslices.fixedflag ?          ((void)(opslquant*(2+2*(exist(opflaxall)==1))), rhnslices) : opslquant*(2+2*(exist(opflaxall)==1));
        }
        else if( opcgate )
        {
            rhnslices  = _rhnslices.fixedflag ?    ((void)(opslquant*opphases), rhnslices) : opslquant*opphases;
        }
        else
        {
            rhnslices  = _rhnslices.fixedflag ?  ((void)(opslquant), rhnslices) : opslquant;
        }

        rhptsize  = _rhptsize.fixedflag ?  ((void)(opptsize), rhptsize) : opptsize;



     rhnavs  = _rhnavs.fixedflag ?      ((void)(IMax(2,(INT)(nex/2),(INT)1)), rhnavs) : IMax(2,(INT)(nex/2),(INT)1);

        rhformat  = _rhformat.fixedflag ?  ((void)(0), rhformat) : 0;
        if (nofermi)
        {
            rhformat  = _rhformat.fixedflag ?  ((void)(RHF_NO_FERMI), rhformat) : rhformat|RHF_NO_FERMI;
        }
        else
        {
            rhformat  = _rhformat.fixedflag ?  ((void)(~RHF_NO_FERMI), rhformat) : rhformat&~RHF_NO_FERMI;
        }

        if (nograd == PSD_OFF) /* use 2d or 3d gradwarp */
        {
            rhformat  = _rhformat.fixedflag ?  ((void)(~RHF_NO_GRADWARP), rhformat) : rhformat&~RHF_NO_GRADWARP;
            if (op3dgradwarp == PSD_ON) /* do 3d gradwarp */
            {
                rhtype1  = _rhtype1.fixedflag ?  ((void)(RHTYP13DGRADWARP), rhtype1) : rhtype1|RHTYP13DGRADWARP;
            }
            else   /* do 2d gradwarp */
            {
                rhtype1  = _rhtype1.fixedflag ?  ((void)(~RHTYP13DGRADWARP), rhtype1) : rhtype1&~RHTYP13DGRADWARP;
            }
        }
        else  /* no gradwarp */
        {
            rhtype1  = _rhtype1.fixedflag ?  ((void)(~RHTYP13DGRADWARP), rhtype1) : rhtype1&~RHTYP13DGRADWARP;
            rhformat  = _rhformat.fixedflag ?  ((void)(RHF_NO_GRADWARP), rhformat) : rhformat|RHF_NO_GRADWARP;
        }
                
            
        if( opimode == PSD_3D )
        {
            if( zchop )
            {
                rhformat  = _rhformat.fixedflag ?  ((void)(RHF_ZCHOP), rhformat) : rhformat|RHF_ZCHOP;
            }
            else
            {
                rhformat  = _rhformat.fixedflag ?  ((void)(RHF_YCHOP), rhformat) : rhformat|RHF_YCHOP;
            }
        }

        rhapp  = _rhapp.fixedflag ?         
                      ((void)(((PSD_ON==opscic)&&(PSD_OFF==oprealtime)&&(PSD_OFF==opfluorotrigger))), rhapp) : ((PSD_ON==opscic)&&(PSD_OFF==oprealtime)&&(PSD_OFF==opfluorotrigger));

        if( (acq_type == TYPGRAD) && (opimode != PSD_CINE) )
        {
            eeff  = _eeff.fixedflag ?  ((void)(1), eeff) : 1;
        }
        else
        {
            eeff  = _eeff.fixedflag ?  ((void)(0), eeff) : 0;
        }

        if( (acq_type == TYPSPIN) && (opexor == PSD_OFF) )
        {
            eepf  = _eepf.fixedflag ?  ((void)(1), eepf) : 1;
        }
        else if( (acq_type == TYPSPIN) && (opexor == PSD_ON) )
        {
            eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
        }
        else
        {
            eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
        }

        /* set bit0 in rhdacqctrl with rawdata */
        if( rawdata )
        {
            rhdacqctrl  = _rhdacqctrl.fixedflag ?  ((void)(RHDC_RAWDATA), rhdacqctrl) : rhdacqctrl|RHDC_RAWDATA; 
        }
        else
        {
            rhdacqctrl  = _rhdacqctrl.fixedflag ?  ((void)(~(RHDC_RAWDATA)), rhdacqctrl) : rhdacqctrl&~(RHDC_RAWDATA);
        }

        set_echo_flip(_rhdacqctrl.fixedflag ? (_temp641_rhdacqctrl=rhdacqctrl,&_temp641_rhdacqctrl) : &rhdacqctrl, &chksum_rhdacqctrl, eepf, oepf, eeff, oeff);

        rhexecctrl  = _rhexecctrl.fixedflag ?    ((void)(9+2*autolock+64*saveinter), rhexecctrl) : 9+2*autolock+64*saveinter;

        /* Begin RTIA comment --- RJF */

        /*
          For RTIA, we don't need the images to be routed to TIR.
          Neither do we want them to be displayed in autoview.
          Here is the bit definitions for rhexecctrl.

          RDB_AUTO_DISPLAY               0x0001    1 
          RDB_AUTO_LOCK                  0x0002    2 
          RDB_AUTO_PERM                  0x0004    4 
          RDB_XFER_IM                    0x0008    8 
          RDB_SAVE_IM                    0x0010    16 
          RDB_TAPE_LOCK                  0x0020    32 
          RDB_INTERMEDIATE               0x0040    64 
          RDB_OVERRIDE_BROADCAST         0x0080    128 
          RDB_OVERRIDE_IMG_INSTALL       0x0100    256 
          RDB_OVERRIDE_AUTODISPLAY       0x0200    512 
          RDB_RTD_XFER_IM_REMOTE         0x0400    1024 
          RDB_RTD_SCAN                   0x0800    2048 
          RDB_REF_SCAN                   0x1000    4096 
          RDB_DONT_WRITE_OR_INSTALL      0x2000    8192 
          RDB_RTD_XFER_ALL_IM_PER_PASS   0x4000    16384 
          RDB_XFER_IMG_RIR               0x8000    32768 
        */
        /*  End RTIA comment */

        /* Begin RTIA */

        if( (oprealtime == PSD_ON) || (opfluorotrigger == PSD_ON) )
        { 
            rhexecctrl  = _rhexecctrl.fixedflag ?        ((void)(0x8000+0x2000+0x0800+0x0100), rhexecctrl) : 0x8000+0x2000+0x0800+0x0100; 

            /* Added for Enabling Autoview for RTIA debug */
#ifdef RTIA_AUTOVIEW_ENABLE
            rhexecctrl  = _rhexecctrl.fixedflag ?   ((void)(1), rhexecctrl) : rhexecctrl+1; 
#endif
        }

        /* MRIge66773 */
        if( opfluorotrigger == PSD_ON )
        {
            rhexecctrl  = _rhexecctrl.fixedflag ?  ((void)((2*autolock)), rhexecctrl) : rhexecctrl+(2*autolock);
        }
 
        /* End RTIA */
        rhvquant  = _rhvquant.fixedflag ?  ((void)(opvquant), rhvquant) : opvquant;
        rhslblank  = _rhslblank.fixedflag ?  ((void)(pislblank), rhslblank) : pislblank;
        rhzeroph  = _rhzeroph.fixedflag ?         ((void)((eg_phaseres*nop/2)*(opphasefov)+0.5), rhzeroph) : (eg_phaseres*nop/2)*(opphasefov)+0.5;
        if( pitfeextra > 0 )
        {
            rhnwin  = _rhnwin.fixedflag ?  ((void)(8), rhnwin) : 8;
        }
        else
        {
            rhnwin  = _rhnwin.fixedflag ?  ((void)(0), rhnwin) : 0;
        }

        if( (pitfeextra > 0) || ((fn == 0.5) && (nop == 2)) )
        {
            rhntran  = _rhntran.fixedflag ?  ((void)(4), rhntran) : 4;
        }
        else
        {
            rhntran  = _rhntran.fixedflag ?  ((void)(2), rhntran) : 2;
        }

        rhfermr  = _rhfermr.fixedflag ?    ((void)(fermi_rc*(float)exist(opxres)), rhfermr) : fermi_rc*(float)exist(opxres);
        rhfermw  = _rhfermw.fixedflag ?    ((void)(fermi_wc*(float)10.0), rhfermw) : fermi_wc*(float)10.0;

        /* JAH: MRIge68280 -- need to use this more robust means of defining
           the eccentricity of the fermi filter so the radius in the X and Y
           directions need not be equal or based on data acquisition or
           reconstruction sizes as determined in recon. */
        /* KVA: MRIge73462 Square pixel rhferme addition */

        if( (PSD_ON == opspiral) || (PSD_ON == exist(opsilentmr)) || 
            (PSD_SPECTRO == opimode) )
        {
            rhferme  = _rhferme.fixedflag ?  ((void)(1.0), rhferme) : 1.0;
        }
        else if( (PSD_ON == opepi) || (PSD_ON == opsquare) )
        {
            rhferme  = _rhferme.fixedflag ?    ((void)(opxres/(opyres*nop)), rhferme) : opxres/(opyres*nop);
        }
        else
        {
            rhferme  = _rhferme.fixedflag ?      ((void)(opxres/(opyres*opphasefov*nop)), rhferme) : opxres/(opyres*opphasefov*nop);
        }

        rhnpasses  = _rhnpasses.fixedflag ?  ((void)(acqs), rhnpasses) : acqs;

        rhdab0s  = _rhdab0s.fixedflag ?  ((void)(cfrecvst), rhdab0s) : cfrecvst;
        rhdab0e  = _rhdab0e.fixedflag ?  ((void)(cfrecvend), rhdab0e) : cfrecvend;

        /*MRIge91361 add rhpure for PURE*/
        if (exist(oppurecal))
        {
            rhpure  = _rhpure.fixedflag ?  ((void)(PURE_CAL), rhpure) : PURE_CAL;
        }
        else
        {
            rhpure  = _rhpure.fixedflag ?  ((void)(exist(oppure)), rhpure) : exist(oppure);
        }

        /*MRIge93538 set rhpurefilter to 1 as default*/
        rhpurefilter  = _rhpurefilter.fixedflag ?  ((void)(1), rhpurefilter) : 1;

        rhpure_filtering_mode  = _rhpure_filtering_mode.fixedflag ?  ((void)(exist(cfpure_filtering_mode)), rhpure_filtering_mode) : exist(cfpure_filtering_mode);
        rhpure_lambda  = _rhpure_lambda.fixedflag ?  ((void)(coilInfo[0].pureLambda), rhpure_lambda) : coilInfo[0].pureLambda;
        rhpure_tuning_factor_surface  = _rhpure_tuning_factor_surface.fixedflag ?  ((void)(coilInfo[0].pureTuningFactorSurface), rhpure_tuning_factor_surface) : coilInfo[0].pureTuningFactorSurface;
        rhpure_tuning_factor_body  = _rhpure_tuning_factor_body.fixedflag ?  ((void)(coilInfo[0].pureTuningFactorBody), rhpure_tuning_factor_body) : coilInfo[0].pureTuningFactorBody;

        if( truenex <= 0 )
        {
            /* PSDs which do not use truenex, as tools, and Spectro,
               will use nex. Truenex is used in Odd Nex NPW cases */
            truenex  = _truenex.fixedflag ?  ((void)(nex), truenex) : nex;
        }

        /* Set NEX for unacquired encodes for when zero-fill BAM is enabled */
        rhnex_unacquired  = _rhnex_unacquired.fixedflag ?  ((void)((int)(ceil(truenex))), rhnex_unacquired) : (int)(ceil(truenex));

        if( opimode==PSD_CINE )
        {
            rhrawsize = (n64)opclocs * (n64)opnecho * (n64)rhfrsize
                * (n64)((oppseq == PSD_PC || oppseq == PSD_PCSP) ?
                        (2 + (opflaxall == 1 ? 2 : 0)) : 1)
                * (n64)(2*rhptsize) * (n64)opcphases
                * (n64)ceil((float)(1 + (rhbline * rawdata) + rhnframes + rhhnover)
                            * ((float)(1 - rawdata) + (truenex * (float)rawdata)));

        }
        else
        {
            rhrawsize = (n64)slquant1 * (n64)opnecho * (n64)rhfrsize * (n64)(2*rhptsize)
                * (n64)ceil((float)(1 + (rhbline * rawdata) + rhnframes + rhhnover)
                            * ((exnex * (float)(1 - rawdata)) + (truenex * (float)rawdata)));

            /*a MRIge91983 - RDP - minimal acquisition size (single coil, single slice, 50 views) */
            if (rotateflag == 2)
            {
                rhrawsize = (n64)opnecho * (n64)rhfrsize * (n64)(2*rhptsize)
                    * (n64)ceil((float)(1 + (rhbline * rawdata) + 50 + rhhnover)
                                * ((exnex * (float)(1 - rawdata)) + (truenex * (float)rawdata)));
            }
        }


     if( oppomp )
     {
         if( opxres == 512 )
         {
             rhrcyres  = _rhrcyres.fixedflag ?  ((void)(1024), rhrcyres) : 1024;
         }
         else
         {
             rhrcyres  = _rhrcyres.fixedflag ?  ((void)(512), rhrcyres) : 512;
         }
     }
     else
     {
         rhrcyres  = _rhrcyres.fixedflag ?  ((void)(eg_phaseres), rhrcyres) : eg_phaseres;
     }

        if( ((exist(opzip512) == PSD_ON) && (existcv(opzip512)) )
            || (exist(opxres) > 256) )
        {
            rhrcxres  = _rhrcxres.fixedflag ?  ((void)(512), rhrcxres) : 512;           /* 512 ZIP or standard 512 recon */
        }
        else 
        {
            rhrcxres  = _rhrcxres.fixedflag ?  ((void)(256), rhrcxres) : 256;           /* Standard 256 recon */
        }

        rhmethod  = _rhmethod.fixedflag ?  ((void)(oppomp), rhmethod) : oppomp;
        rhdaxres  = _rhdaxres.fixedflag ?  ((void)(opxres), rhdaxres) : opxres;

        rhrcctrl  = _rhrcctrl.fixedflag ?      ((void)(RHRCMAG+rawmode*RHRCRAW), rhrcctrl) : RHRCMAG+rawmode*RHRCRAW;
        if( cfcompress < 100 )
        {
            rhrcctrl  = _rhrcctrl.fixedflag ?  ((void)(RHRCCOMP), rhrcctrl) : rhrcctrl+RHRCCOMP;
        }

        if( opimode==PSD_CINE )
        {
            rhcphases  = _rhcphases.fixedflag ?  ((void)(opcphases), rhcphases) : opcphases;
            /*have to convert this from uSec to Sec */
            rhctr  = _rhctr.fixedflag ?  ((void)((FLOAT)optr/1000000.0), rhctr) : (FLOAT)optr/1000000.0;
            rhcrrtime  = _rhcrrtime.fixedflag ?  ((void)(60.0/(FLOAT)opchrate), rhcrrtime) : 60.0/(FLOAT)opchrate; /* also in Sec */
        }

        /* Support choice of gradient coil for twin gradient coils (Gili) */
        rhgradmode  = _rhgradmode.fixedflag ?  ((void)(opgradmode), rhgradmode) : opgradmode;

        rhte  = _rhte.fixedflag ?  ((void)(opte), rhte) : opte;
        rhte2  = _rhte2.fixedflag ?  ((void)(opte2), rhte2) : opte2;
        
        rhscancent  = _rhscancent.fixedflag ?  ((void)(piscancenter), rhscancent) : piscancenter;
       
        if(PSD_MINTE == exist(opautote))
        {
          /* EPI - MinTE with ramp sampling will be a problem hence not supported
             SSFSE - MinTE but full acquisition is done , disabled temporarily */
          if((PSD_ON == exist(opepi)) || (PSD_ON == exist(opssfse)) || (PSD_ON == exist(opspiral)))
            rhfeextra  = _rhfeextra.fixedflag ?  ((void)(0), rhfeextra) : 0;
          else if((PSD_3D == exist(opimode)) && (PSD_ON == exist(opdixon)))
            rhfeextra  = _rhfeextra.fixedflag ?       ((void)((int)((fnecho_lim-0.5)*rhfrsize+0.5)), rhfeextra) : (int)((fnecho_lim-0.5)*rhfrsize+0.5);
          else
           rhfeextra  = _rhfeextra.fixedflag ?    ((void)(rhfrsize-exist(opxres)/2), rhfeextra) : rhfrsize-exist(opxres)/2;
        }
        else
        {
          rhfeextra  = _rhfeextra.fixedflag ?  ((void)(0), rhfeextra) : 0;
        }
    } /* End of code inlined from loadrheader.e rheaderint */



    /* MRIge92386 */

/* AssetSetRhVars  inlined from Asset.e */
/* THIS CODE NEEDS TO BE INLINED AFTER */
/* @inline loadrheader.e rheaderinit in predownload */

    /*ASSET*/
    rhasset  = _rhasset.fixedflag ?  ((void)(exist(opasset)), rhasset) : exist(opasset);
    rhasset_calthresh  = _rhasset_calthresh.fixedflag ?  ((void)(coilInfo[0].assetCalThreshold), rhasset_calthresh) : coilInfo[0].assetCalThreshold;
    rhasset_R  = _rhasset_R.fixedflag ?  ((void)(asset_factor), rhasset_R) : asset_factor;
    rhassetsl_R  = _rhassetsl_R.fixedflag ?  ((void)(assetsl_factor), rhassetsl_R) : assetsl_factor;
    rhasset_phases  = _rhasset_phases.fixedflag ?  ((void)(1), rhasset_phases) : 1;       /* The number of phases in a pass */

    /* ASSET: reset rhferme after rheaderinit to divide out
       the ASSET R factor */
    if( existcv(opasset) && (PSD_ON == assetph_flag) )
    {
        rhferme  = _rhferme.fixedflag ?   ((void)(rhferme/rhasset_R), rhferme) : rhferme/rhasset_R;
    }

    /* MRIhc18622 Set AR-ASSET tuning factors */
    if( PSD_ON == exist(opassetscan) )
    {
        char * coil_name = coilInfo[0].coilName;
        int sag_cor_flag = ((PSD_SAG == exist(opplane))
                            || (PSD_COR == exist(opplane)) 
                            || (PSD_OBL == exist(opplane)
                                && ((PSD_SAG == exist(opobplane))
                                    || (PSD_COR == exist(opobplane)))
                               )
                           ); 

        int torso_flag = ((NULL != strstr(coil_name,"AA only")
                           || NULL != strstr(coil_name,"Body")
                           || NULL != strstr(coil_name,"BODY")
                           || NULL != strstr(coil_name,"Card") /* Include 32ChCardAntOnly. */
                           || NULL != strstr(coil_name,"CARDIAC")
                           || NULL != strstr(coil_name,"Chest")
                           || NULL != strstr(coil_name,"FOVs")
                           || NULL != strstr(coil_name,"Torso")
                           || NULL != strstr(coil_name,"TORSO")
                           || (sag_cor_flag && (NULL != strstr(coil_name,"Lower Limb")
                                                || NULL != strstr(coil_name,"PV UL")))
                          ) && ((rhdab0e - rhdab0s + 1) > 1)
                         );

        int localTx_flag = ((NULL != strstr(coil_name,"TRknee")
                             || NULL != strstr(coil_name,"TR Knee"))
                            && ((rhdab0e - rhdab0s + 1) > 1)
                            && (TX_COIL_LOCAL == getTxCoilType())
                           );

        /* Set rhasset_torso for any coil that can be used for breathhold 
           acquisitions in the torso.  Also include for Sag & Cor scans with
           Lower Limb and PV UL modes for ASSET artifacts at edge of FOV */
        if( 0 != torso_flag )
        {
            rhasset_torso  = _rhasset_torso.fixedflag ?  ((void)(1), rhasset_torso) : 1;
        }
        else
        {
            rhasset_torso  = _rhasset_torso.fixedflag ?  ((void)(0), rhasset_torso) : 0;
        }

        /* Set rhasset_localTx for local Tx phased array coils */
        if( 0 != localTx_flag  )
        {
            rhasset_localTx  = _rhasset_localTx.fixedflag ?  ((void)(1), rhasset_localTx) : 1;
        }
        else
        {
            rhasset_localTx  = _rhasset_localTx.fixedflag ?  ((void)(0), rhasset_localTx) : 0;
        }

        /* Use different calibration apodization for 3D TOF 
           in the head transmit position (MRIhc20285) */
        if( ((PSD_3D == exist(opimode)) || (PSD_3DM == exist(opimode)))
             && ((PSD_TOF == exist(oppseq)) || (PSD_TOFSP == exist(oppseq)))
             && (TX_POS_HEAD == getTxPosition()))
        {
            rhasset_alt_cal  = _rhasset_alt_cal.fixedflag ?  ((void)(1), rhasset_alt_cal) : 1;
        }
        else
        {
            rhasset_alt_cal  = _rhasset_alt_cal.fixedflag ?  ((void)(0), rhasset_alt_cal) : 0;
        }
    }
    else
    {
        rhasset_torso  = _rhasset_torso.fixedflag ?  ((void)(0), rhasset_torso) : 0;
        rhasset_alt_cal  = _rhasset_alt_cal.fixedflag ?  ((void)(0), rhasset_alt_cal) : 0;
    }
/* AssetSetRhVars  inlined from Asset.e */



  /*jwg adding more BB stuff*/
    if ((acquire_type == SPECPSD_MASTER_H1)
        || (acquire_type == SPECPSD_MASTER_MNS)){
        rfconf  = _rfconf.fixedflag ?      
                     ((void)((ENBL_RHO1|ENBL_THETA|ENBL_OMEGA|ENBL_OMEGA_FREQ_XTR1|ENBL_THETA_PHASE_XTR1)), rfconf) : (ENBL_RHO1|ENBL_THETA|ENBL_OMEGA|ENBL_OMEGA_FREQ_XTR1|ENBL_THETA_PHASE_XTR1);
    } else {
        rfconf  = _rfconf.fixedflag ?      
                     ((void)((ENBL_RHO2|ENBL_THETA|ENBL_OMEGA|ENBL_OMEGA_PHASE_XTR2|ENBL_THETA_FREQ_XTR2)), rfconf) : (ENBL_RHO2|ENBL_THETA|ENBL_OMEGA|ENBL_OMEGA_PHASE_XTR2|ENBL_THETA_FREQ_XTR2);
    }    

    /* > 1024 im/ser -Venkat
     * rhformat(14th bit) : 0=Normal 1=Multiphase scan
     * rhmphasetype       : 0=Int MPh 1=Seq Mph
     * rhnphases          : No of phases in a multiphase scan
     */
    if ( enable_1024 )
    {
        rhformat  = _rhformat.fixedflag ?  ((void)(RHF_SINGLE_PHASE_INFO), rhformat) : rhformat|RHF_SINGLE_PHASE_INFO;

        if (opacqo == PSD_OFF) 
        {
            rhmphasetype  = _rhmphasetype.fixedflag ?  ((void)(0), rhmphasetype) : 0; /* Interleaved multiphase*/
        }
        else
        {
            rhmphasetype  = _rhmphasetype.fixedflag ?  ((void)(1), rhmphasetype) : 1; /* sequential multiphase*/
        }

        rhnphases  = _rhnphases.fixedflag ?  ((void)(exist(opfphases)), rhnphases) : exist(opfphases); /* No of phases in a multiphase scan*/
    }
    else
    {
        rhformat  = _rhformat.fixedflag ?  ((void)(~RHF_SINGLE_PHASE_INFO), rhformat) : rhformat&~RHF_SINGLE_PHASE_INFO;
        rhnphases  = _rhnphases.fixedflag ?  ((void)(1), rhnphases) : 1; /* MRIhc35883 MRIhc36882*/
    }


    /* Now set it for fract ky annotation */ 
     pitfeextra = fract_ky; 

    /******************************
      Slice Ordering
    ****************************/
    if (rotateflag == PSD_ON) {
        rotatescan();
    }
    else if (exist(use_myscan)==1) {
        myscan();
    }

    if (exist(opslquant) == 3 && b0calmode == 1)
    {
	setb0rotmats();
    }

    if (slice_reset == 1)
    {
	for (off_index=0;off_index<opslquant;off_index++)
        {
            scan_info[off_index].optloc = slice_loc;
        }
    }
  
    if (scan_offset != 0 )
    {
	for (off_index=0;off_index<opslquant;off_index++)
        {
            scan_info[off_index].optloc += (float)scan_offset;
        }
    }
  
    if (debug_scan)
    {
        psd_dump_scan_info();
    }

    order_routine  = _order_routine.fixedflag ?  ((void)(seq_type), order_routine) : seq_type;

    if( opslice_order == PSD_OFF) {
        order_routine  = _order_routine.fixedflag ?  ((void)(TYPNORMORDER), order_routine) : TYPNORMORDER;
    }

    if (orderslice(order_routine, opslquant, slquant1, gating) == FAILURE)
    {
        epic_error( use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                    EE_ARGS(1), STRING_ARG, "orderslice" );
	return FAILURE;
    }

    /* Value1.5T May 2005 KK */
    if(ghost_check&&gck_offset_fov)
        rsp_info[0].rspphasoff = opfov/4.0;

    /* BJM - MRIge50915: add TYPCAT for opccsat scans */    
    if ( (order_routine == TYPNCAT || order_routine == TYPCAT || order_routine == TYPNORMORDER) && opfphases > 1 )
    {
	acq_off = reps*slquant1;

	if (acqmode == 0)  /* interleaved */
	{
            /*Venkat > 1024 im/ser */
            /* do nothing ! */
	} /* end if interleaved */
        else if (acqmode == 1)  /* sequential */
	{
            for (i=0; i<acqs; i++)  /* slices loop */
            {
                /*Venkat > 1024 im/ser*/
                for (j=0; j<1; j++)
                {
                    sloff = i;
                    data_acq_order[sloff].slloc = i;
                    data_acq_order[sloff].slpass = i;
                    data_acq_order[sloff].sltime = j;
                }
            }
	} /* end if sequential */
    }
    else if ( pass_reps > 1 ) {
        /* Cardiac gated multi-reps */ 
        /* do nothing ! */
    } /* if pass_reps > 1 */
       

    if (debug_order)
    {
	printf("\nslloc\tslpass\tsltime\t\n");
	for (i = 0; i < opslquant*opphases; i++)
        {
            printf("%d\t%d\t%d\n",data_acq_order[i].slloc,
                   data_acq_order[i].slpass,
                   data_acq_order[i].sltime);
	}
    }
    fflush(stdout);

    trig_scan  = _trig_scan.fixedflag ?  ((void)(gating), trig_scan) : gating; 
  
    if (debug_scan)
    {
        psd_dump_rsp_info();
    }

    /* Saved unscaled version of rotation matrices */
    for ( i = 0 ; i < (opslquant * opphases) ; i++ )
    {
        if (obl_debug == PSD_ON)
        {
            printf( "Slice %d\n", i );
        }
        for ( j = 0 ; j < 9 ; j++ )
        {
            rsprot_unscaled[i][j] = rsprot[i][j];
            if (obl_debug == PSD_ON)
            {
                printf( "rsprot_unscaled[%d] = %ld\n", j, rsprot_unscaled[i][j] );
            }
        }
    }

    /* Rotate rotation matrices */
    if (scalerotmats( rsprot, &loggrd, &phygrd, 
                  (int)(opslquant * opphases), obl_debug ) == FAILURE)
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD. \nPlease try again or restart the system.",
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }

    /***************************************
      Image Header CVs
    ***************************************/

    /* The routine imgtimutil() rounds down optr to full integer line cycles
     * and subtracts TR_SLOP in the calculation of act_tr. Therefore, act_tr is
     * never greater than optr, except in epi. In epi, act_tr is rounded up
     * to hrdwr_period (=64us) at the call of imgtimutil(). Because of this,
     * act_tr + TR_SLOP could be greater than optr. When this happens (ie,
     * ihtr>optr), we get download failure. In order to avoid this download 
     * failure, it is fixed by replacing:
     *     ihtr = act_tr + ((gating==TRIG_LINE) ? TR_SLOP :0);
     * with:
     *     ihtr = act_tr + ((gating==TRIG_LINE) ? TR_SLOP :0);
     *     if(gating==TRIG_LINE) {
     *         ihtr = ihtr - hrdwr_period;
     *     }
     * MRIge34441, ypd
     */
    if ( (opcgate == PSD_OFF) && (mph_flag == PSD_OFF) ) {
        ihtr  = _ihtr.fixedflag ?       ((void)(act_tr+((gating==TRIG_LINE)?TR_SLOP:0)), ihtr) : act_tr+((gating==TRIG_LINE)?TR_SLOP:0);
        if(gating == TRIG_LINE) {
            ihtr  = _ihtr.fixedflag ?    ((void)(ihtr-hrdwr_period), ihtr) : ihtr-hrdwr_period;
        }

	ihtdel1  = _ihtdel1.fixedflag ?  ((void)(MIN_TDEL1), ihtdel1) : MIN_TDEL1;
    } else if ( (mph_flag == PSD_ON) && (opcgate == PSD_OFF)) {
        ihtr  = _ihtr.fixedflag ?       ((void)(act_tr+((gating==TRIG_LINE)?TR_SLOP:0)), ihtr) : act_tr+((gating==TRIG_LINE)?TR_SLOP:0);
        if(gating==TRIG_LINE) ihtr  = _ihtr.fixedflag ?    ((void)(ihtr-hrdwr_period), ihtr) : ihtr-hrdwr_period;
	free(ihtdeltab);

	ihtdeltab = (int *)malloc(opslquant*sizeof(int));
	exportaddr(ihtdeltab, (int)(opslquant*sizeof(int)));
	for (i=0; i<opslquant; i++) {
            /* YMSmr06832 */
            if (acqmode == 0)  /* interleaved */
                ihtdeltab[i] =
                    (data_acq_order[i].slpass) *
                    (disdaq_shots + nex*reps*core_shots) * act_tr +
                    (disdaq_shots + nex*reps*core_shots-1) * act_tr +
                    (data_acq_order[i].sltime + 1)*(act_tr/(float)slquant1) +
                    (data_acq_order[i].slpass) * pass_delay*num_passdelay;
            else if (acqmode == 1)  /* sequential */
                ihtdeltab[i] = 
                    (data_acq_order[i].slpass + 1) * 
                    (disdaq_shots/(float)reps + nex*core_shots) * act_tr +
                    (data_acq_order[i].sltime)*(act_tr/(float)slquant1) +
                    (data_acq_order[i].slpass) * pass_delay*num_passdelay;
        }

    } else {
        ihtdeltab = (int *)malloc(opphases*opslquant*sizeof(int));
        exportaddr(ihtdeltab, (int)(opphases*opslquant*sizeof(int)));
        ihtrtab = (int *)malloc(opphases*opslquant*sizeof(int));
        exportaddr(ihtrtab, (int)(opphases*opslquant*sizeof(int)));

        if (opphases > 1) {
            for (i = 0; i < opphases*opslquant; i++) {
                if (data_acq_order[i].sltime < opslquant) {
                    ihtrtab[i] = (act_tr - ((opphases/opslquant) - 1) *
                                  opslquant * psd_tseq);
                } else {
                    ihtrtab[i] = opslquant * psd_tseq;
                }
            }
            for (i = 0; i < opphases*opslquant; i++) {
                ihtdeltab[i] = optdel1 + psd_tseq*data_acq_order[i].sltime;
            }
        } else {
            /* Cross R-R */
            j= 0;
            for (i = 0; i < opslquant; i++) {
                j = (i%opslquant)/ophrep;
                ihtdeltab[i] = optdel1 + psd_tseq*j;
                ihtrtab[i] = act_tr;
            } /* for (i = ... */
        } /* if (opphases > 1) */
        if(debug_tdel)
        {
            for(i=0;i< opphases*opslquant; i++)
            {
                printf("ihtrtab[%d] = %d\n",i,ihtrtab[i]);
            }
        }

    } /* if (opcgate == PSD_OFF) */

    if(debug_tdel && (opmph == PSD_ON))
    {
        for(i=0;i< opphases*opslquant; i++)
        {
            printf("ihtdeltab[%d] = %d\n",i,ihtdeltab[i]);
        }
    }

    
    /* set ihmaxtdelphase
     * This is the tdel value for the last acquired slice for the first phase
     * Used in ifcc to calculate the tdel values for the rest of the phases
     * -- 1024 im/ser -Venkat
     */ 
    if( enable_1024 )
    {
        /* YMSmr06832 */
        ihmaxtdelphase = 0;
        for(i=0;i<opslquant*opphases;i++) 
        { 
            if((ihmaxtdelphase < ihtdeltab[i]) && 
               (data_acq_order[i].slpass == 0 )){ 
                ihmaxtdelphase = ihtdeltab[i];
            }
        }
 
                ihmaxtdelphase = ihmaxtdelphase + opsldelay;
                ihmaxtdelphase = ihmaxtdelphase * acqs;
                printf("ihmaxtdelphase = %10d\n",ihmaxtdelphase);
    }
    else
        ihmaxtdelphase = 0;
    if(debug_tdel)
    {
        printf("ihmaxtdelphase = %10d\n",ihmaxtdelphase);
    }
    fflush(stdout);

 
    ihte1  = _ihte1.fixedflag ?  ((void)(opte), ihte1) : opte;

    /* Nex annotation requirements changed at a late date per MRIge24292 */
    ihnex  = _ihnex.fixedflag ?  ((void)(nex*nop), ihnex) : nex*nop;

    ihflip  = _ihflip.fixedflag ?  ((void)(flip_rf1), ihflip) : flip_rf1;
    ihvbw1  = _ihvbw1.fixedflag ?  ((void)((FLOAT)(rint(oprbw))), ihvbw1) : (FLOAT)(rint(oprbw));
    iheesp  = _iheesp.fixedflag ?  ((void)(eesp), iheesp) : eesp;

    /**********************
      SAT Positioning
    *********************/
    if(SatPlacement(acqs) == FAILURE)
    {
        epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"SatPlacement");
        return FAILURE;
    }

    rhnpasses  = _rhnpasses.fixedflag ?  ((void)(acqs*pass_reps), rhnpasses) : acqs*pass_reps;
    eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
    
    /* If phase enc grad is flipped, inform recon */
    if (pepolar == PSD_ON)
    {
        oepf  = _oepf.fixedflag ?  ((void)(1), oepf) : 1;
    }
    else
    {
        oepf  = _oepf.fixedflag ?  ((void)(0), oepf) : 0;
    }
   
    set_echo_flip(_rhdacqctrl.fixedflag ? (_temp642_rhdacqctrl=rhdacqctrl,&_temp642_rhdacqctrl) : &rhdacqctrl, &chksum_rhdacqctrl, eepf, oepf, eeff, oeff); /* clear bit 1 - flips image in phase dir */
    rhdaxres  = _rhdaxres.fixedflag ?  ((void)(rhfrsize), rhdaxres) : rhfrsize;

    /* Turn on new epi phase correction algorithm */
    /* BJM: 2 = Nearest Neighbor processing */
    rhref  = _rhref.fixedflag ?  ((void)(2), rhref) : 2; /* 0=old algorithm, 1 = new algorithm */
    /* internref: if internal ref scan, set rhref to 3 */
    /* set rhref to 4 for self-navigated dynamic phase correction */
    if( iref_etl > 0 ){
        if((epira3_flag == PSD_ON || epiRTra3_flag == PSD_ON) && (ra3_sndpc_flag == PSD_OFF))
            rhref  = _rhref.fixedflag ?  ((void)(3), rhref) : 3;
        else
            rhref  = _rhref.fixedflag ?  ((void)(4), rhref) : 4;
    }

    if(vrgf_reorder == PSD_ON) {
        rhtype1  = _rhtype1.fixedflag ?  ((void)(VRGF_AFTER_PCOR_ALT), rhtype1) : rhtype1|VRGF_AFTER_PCOR_ALT;
    } else {
        rhtype1  = _rhtype1.fixedflag ?  ((void)(~VRGF_AFTER_PCOR_ALT), rhtype1) : rhtype1&~VRGF_AFTER_PCOR_ALT;
    }
    
    rhileaves  = _rhileaves.fixedflag ?  ((void)(intleaves), rhileaves) : intleaves;
    rhkydir  = _rhkydir.fixedflag ?  ((void)(ky_dir), rhkydir) : ky_dir;
    rhalt  = _rhalt.fixedflag ?  ((void)(ep_alt), rhalt) : ep_alt;

    /*MRIhc09115,YMSmr07202*/
    if (mph_flag != PSD_OFF)
    {
        rhreps  = _rhreps.fixedflag ?  ((void)(exist(opfphases)), rhreps) : exist(opfphases);
    }
    else
    {
        rhreps  = _rhreps.fixedflag ?  ((void)(reps), rhreps) : reps;
    }

    if (touch_flag)
    {
        rhmethod  = _rhmethod.fixedflag ?  ((void)(0), rhmethod) : 0;
    }
    else
    {
        rhmethod  = _rhmethod.fixedflag ?  ((void)(1), rhmethod) : 1;  /* enable reduced image size */
    }

    {
	int power;
	float temp;

	if (rhmethod == 1)
        {

            if (vrgfsamp == 1)
            {
                
                temp = (float)opxres;
		power = 0;
		
		while (temp > 1)
                {
                    temp/= 2.0;
                    ++power;
		}
		
		fft_xsize  = _fft_xsize.fixedflag ?  ((void)((int)pow(2.0,(double)power)), fft_xsize) : (int)pow(2.0,(double)power);
		
                temp = (float)opyres;
		power = 0;
		
		while (temp > 1)
                {
                    temp/= 2.0;
                    ++power;
		}
		
		fft_ysize  = _fft_ysize.fixedflag ?  ((void)((int)pow(2.0,(double)power)), fft_ysize) : (int)pow(2.0,(double)power);
		
		image_size  = _image_size.fixedflag ?    ((void)(IMax(2,fft_xsize,fft_ysize)), image_size) : IMax(2,fft_xsize,fft_ysize);
		fft_xsize  = _fft_xsize.fixedflag ?  ((void)(image_size), fft_xsize) : image_size;
		fft_ysize  = _fft_ysize.fixedflag ?  ((void)(image_size), fft_ysize) : image_size;
		
		rhrcxres  = _rhrcxres.fixedflag ?  ((void)(fft_xsize), rhrcxres) : fft_xsize;
		rhrcyres  = _rhrcyres.fixedflag ?  ((void)(fft_ysize), rhrcyres) : fft_ysize;
		rhimsize  = _rhimsize.fixedflag ?  ((void)(image_size), rhimsize) : image_size;
		
            }
            else
            {
                
                /* non-VRGF */
                temp = (float)rhdaxres;
		power = 0;
		
		while (temp > 1)
                {
                    temp/= 2.0;
                    ++power;
		}
		
		fft_xsize  = _fft_xsize.fixedflag ?  ((void)((int)pow(2.0,(double)power)), fft_xsize) : (int)pow(2.0,(double)power);
		
                temp = (float)opyres;
		power = 0;
		
		while (temp > 1)
                {
                    temp/= 2.0;
                    ++power;
		}
		
		fft_ysize  = _fft_ysize.fixedflag ?  ((void)((int)pow(2.0,(double)power)), fft_ysize) : (int)pow(2.0,(double)power);
		
		image_size  = _image_size.fixedflag ?    ((void)(IMax(2,fft_xsize,fft_ysize)), image_size) : IMax(2,fft_xsize,fft_ysize);
		fft_xsize  = _fft_xsize.fixedflag ?  ((void)(image_size), fft_xsize) : image_size;
		fft_ysize  = _fft_ysize.fixedflag ?  ((void)(image_size), fft_ysize) : image_size;
		
		rhrcxres  = _rhrcxres.fixedflag ?  ((void)(fft_xsize), rhrcxres) : fft_xsize;
		rhrcyres  = _rhrcyres.fixedflag ?  ((void)(fft_ysize), rhrcyres) : fft_ysize;
		rhimsize  = _rhimsize.fixedflag ?  ((void)(image_size), rhimsize) : image_size;
            }
	  
	}
        else
        {

            if (touch_flag)
            {
                /* MR-Touch post-processing only supports 256 matrix size*/
                fft_xsize  = _fft_xsize.fixedflag ?  ((void)(256), fft_xsize) : 256;
                fft_ysize  = _fft_ysize.fixedflag ?  ((void)(256), fft_ysize) : 256;
                image_size  = _image_size.fixedflag ?  ((void)(256), image_size) : 256;
                rhrcxres  = _rhrcxres.fixedflag ?  ((void)(image_size), rhrcxres) : image_size;
                rhrcyres  = _rhrcyres.fixedflag ?  ((void)(image_size), rhrcyres) : image_size;
                rhimsize  = _rhimsize.fixedflag ?  ((void)(image_size), rhimsize) : image_size;
            }
            else
            {
                temp = (float)exist(opxres);
                power = 0;
                while (temp > 1)
                {
                    temp/= 2.0;
                    ++power;
                }

                fft_xsize  = _fft_xsize.fixedflag ?  ((void)((int)pow(2.0,(double)power)), fft_xsize) : (int)pow(2.0,(double)power);

                temp = (float)exist(opyres);
                power = 0;
                while (temp > 1)
                {
                    temp/= 2.0;
                    ++power;
                }
                fft_ysize  = _fft_ysize.fixedflag ?  ((void)((int)pow(2.0,(double)power)), fft_ysize) : (int)pow(2.0,(double)power);

                rhrcxres  = _rhrcxres.fixedflag ?  ((void)(opxres), rhrcxres) : opxres;
                rhrcyres  = _rhrcyres.fixedflag ?  ((void)(eg_phaseres), rhrcyres) : eg_phaseres;
                rhimsize  = _rhimsize.fixedflag ?  ((void)(image_size), rhimsize) : image_size;
            }
        }
  
        /* Number of points to exclude, beginning and end,
           for phase correction */
        pckeeppct  = _pckeeppct.fixedflag ?         ((void)(((exist(opfov)<=300.0)?100.0:(300.0/exist(opfov))*100.0)), pckeeppct) : ((exist(opfov)<=300.0)?100.0:(300.0/exist(opfov))*100.0);
	rhpcdiscbeg  = _rhpcdiscbeg.fixedflag ?    ((void)((fft_xsize*(100.0-pckeeppct)/100.0)/2.0), rhpcdiscbeg) : (fft_xsize*(100.0-pckeeppct)/100.0)/2.0;
	rhpcdiscbeg  = _rhpcdiscbeg.fixedflag ?    ((void)(IMax(2,rhpcdiscbeg,2)), rhpcdiscbeg) : IMax(2,rhpcdiscbeg,2);
	rhpcdiscend  = _rhpcdiscend.fixedflag ?  ((void)(rhpcdiscbeg), rhpcdiscend) : rhpcdiscbeg;

        /* BJM: set discard pts = 0 */
        if(rhref >= 2) {
            rhpcdiscbeg  = _rhpcdiscbeg.fixedflag ?  ((void)(0), rhpcdiscbeg) : 0;
            rhpcdiscend  = _rhpcdiscend.fixedflag ?  ((void)(0), rhpcdiscend) : 0;
        }
    }

    /* BJM: SE Ref Scan */
    /*      Moved setting of recon phase control vars */
    /* into inline file */
    /* Number of points to exclude, center of post RFT frame */
    /* The number of points dicarded is controlled by:   */
    /* rhpcdiscmid = 'X' points at the center of the frame */
    /* rhpcdiscbeg = 'X' points at beginning of frame */
    /* rhpcdiscend = 'X' points at end of frame */
    rhpcdiscmid  = _rhpcdiscmid.fixedflag ?  ((void)(0), rhpcdiscmid) : 0;

    /* Number of interleaves to acquire for phase correction (ref) */ 
    /* rhpcileave = 0 (collect all of them) */
    /* rhpcileave = X (collect one an interpolate results */
    rhpcileave  = _rhpcileave.fixedflag ?  ((void)(0), rhpcileave) : 0;   /* collect them all */

    /* Pick the "best" Ky line to fit the data along Ky */
    /* Since this is a spin echo reference, we will use the */
    /* point of the Hahn Echo in the readout train - the views */
    /* are number from the top (0) to the bottom (opyres) so the max */
    /* value is determined if the scan if a fract_ky scan */
    if (fract_ky == PSD_FRACT_KY) {

        cvmax(rhpcbestky, rhnframes+rhhnover+1);

    } else {

        cvmax(rhpcbestky, rhnframes+1);

    }

    /* Set up linear & constant remap across Ky */
    if(reMap == PSD_ON) {

        rhpclinfix  = _rhpclinfix.fixedflag ?  ((void)(1), rhpclinfix) : 1; /* fit phase correction values vs. Ky */
        rhpcconfix  = _rhpcconfix.fixedflag ?  ((void)(1), rhpcconfix) : 1; 

    } else {

        rhpclinfix  = _rhpclinfix.fixedflag ?  ((void)(2), rhpclinfix) : 2;  /* take avg. across Ky (force slope = 0) */
        rhpcconfix  = _rhpcconfix.fixedflag ?  ((void)(2), rhpcconfix) : 2;
 
        rhpclinslope  = _rhpclinslope.fixedflag ?  ((void)(0.0), rhpclinslope) : 0.0;
        rhpcconslope  = _rhpcconslope.fixedflag ?  ((void)(0.0), rhpcconslope) : 0.0;
    }
    
    /* Pick the rhpcbestky "point" based on the trajectory */
    if(se_ref == PSD_ON) { 

        /* Spin echo Ref -> best line coincident w/ Hahn echo */  
        if (fract_ky == PSD_FULL_KY && ky_dir == PSD_TOP_DOWN) {
            
            rhpcbestky  = _rhpcbestky.fixedflag ?    ((void)((float)(rhnframes+1)/2.0+ky_offset), rhpcbestky) : (float)(rhnframes+1)/2.0+ky_offset;
            
        } else if (fract_ky == PSD_FULL_KY && ky_dir == PSD_BOTTOM_UP) {
            
            rhpcbestky  = _rhpcbestky.fixedflag ?    ((void)((float)(rhnframes+1)/2.0-ky_offset), rhpcbestky) : (float)(rhnframes+1)/2.0-ky_offset;
            
        } else if (fract_ky == PSD_FRACT_KY || ky_dir == PSD_BOTTOM_UP) {
            
            rhpcbestky  = _rhpcbestky.fixedflag ?    ((void)((float)(2*rhnframes+1)/2.0-ky_offset), rhpcbestky) : (float)(2*rhnframes+1)/2.0-ky_offset;
            
        } else if (fract_ky == PSD_FULL_KY || ky_dir == PSD_CENTER_OUT) {

            rhpcbestky  = _rhpcbestky.fixedflag ?  ((void)((float)(rhnframes+1)/2.0), rhpcbestky) : (float)(rhnframes+1)/2.0;
        }

    } else {

        /* Gradient echo - best line is 1st in time */
        if (fract_ky == PSD_FULL_KY && ky_dir == PSD_TOP_DOWN) {
            
            rhpcbestky  = _rhpcbestky.fixedflag ?         ((void)((1.0+(float)(rhnframes+1)/2.0)/2.0), rhpcbestky) : (1.0+(float)(rhnframes+1)/2.0)/2.0;          
            
        } else if (fract_ky == PSD_FULL_KY && ky_dir == PSD_BOTTOM_UP) {
            
            rhpcbestky  = _rhpcbestky.fixedflag ?         ((void)(((float)rhnframes+(float)(rhnframes+1)/2.0)/2.0), rhpcbestky) : ((float)rhnframes+(float)(rhnframes+1)/2.0)/2.0;

        } else if (fract_ky == PSD_FRACT_KY || ky_dir == PSD_BOTTOM_UP) {

            rhpcbestky  = _rhpcbestky.fixedflag ?  ((void)(rhnframes), rhpcbestky) : rhnframes;

        } else if (fract_ky == PSD_FULL_KY || ky_dir == PSD_CENTER_OUT) {

            rhpcbestky  = _rhpcbestky.fixedflag ?  ((void)((float)(rhnframes+1)/2.0), rhpcbestky) : (float)(rhnframes+1)/2.0;

        }

    } /* end se_ref if/else */

    /* This centers the data in the recon buffer for minTE scans */ 
    if (fract_ky == PSD_FRACT_KY) rhhdbestky  = _rhhdbestky.fixedflag ?  ((void)(opyres/2), rhhdbestky) : opyres/2;

    /* Coil Selection */
    cvmax(rhpccoil, (INT)((cfrecvend - cfrecvst)+1));
    cvmin(rhpccoil, (INT)-1);
    {
        INT numcoils = ((cfrecvend - cfrecvst)+1);
 
        /* BJM: use coil #4 for phase correcion with 8 channel */
        /* head coil */
        /* 11.0 update - use all coils, rhpccoil = 0 */

        if(numcoils > 1)
            rhpccoil  = _rhpccoil.fixedflag ?  ((void)(0), rhpccoil) : 0; /* (INT)(numcoils)/2.0; */
        else
            rhpccoil  = _rhpccoil.fixedflag ?  ((void)(1), rhpccoil) : 1;

        /* MRIge91081 - disable ref scan per coil for Asset */
        /* asset = 2 for scans, 1 for calibration */
        if(exist(opasset) == 2) { 
            rhpccoil  = _rhpccoil.fixedflag ?  ((void)((INT)-1), rhpccoil) : (INT)-1; 
        }
    }

    /* Turn on linear & constant correction */
    rhpclin  = _rhpclin.fixedflag ?  ((void)(1), rhpclin) : 1;
    rhpccon  = _rhpccon.fixedflag ?  ((void)(1), rhpccon) : 1;

    /* for single-shot ref scan, minimum fit orders are 1 */
    if ( rhpcileave > 0 )
    {
        cvmod(rhpcconorder, 1, 4, 2,
              "Constant fit order: 0=vu spcfc;1=Kybest;2=line;3,4=poly",0," ");
        cvmod(rhpclinorder, 1, 4, 2,
              "Constant fit order: 0=vu spcfc;1=Kybest;2=line;3,4=poly",0," ");
    }
    else
    {
        cvmod(rhpcconorder, 0, 4, 2,
              "Linear fit order: 0=vu spcfc;1=Kybest;2=line;3,4=poly",0," ");
        cvmod(rhpclinorder, 0, 4, 2,
              "Linear fit order: 0=vu spcfc;1=Kybest;2=line;3,4=poly",0," ");
    }

    cvmax(rhpcshotfirst, intleaves-1);
    rhpcshotfirst  = _rhpcshotfirst.fixedflag ?  ((void)(0), rhpcshotfirst) : 0;
    cvmin(rhpcshotlast, rhpcshotfirst);
    cvmax(rhpcshotlast, intleaves - 1);
    rhpcshotlast  = _rhpcshotlast.fixedflag ?    ((void)(intleaves-1), rhpcshotlast) : intleaves-1;

    /* set con and lin orders: 0=vu spcfc, 1=kybest, 2=line, 3,4=poly */
    rhpcconorder  = _rhpcconorder.fixedflag ?  ((void)(2), rhpcconorder) : 2;
    rhpclinorder  = _rhpclinorder.fixedflag ?  ((void)(2), rhpclinorder) : 2;

    /* set con and lin #pts */
    cvmax(rhpcconnpts, 4);
    cvmax(rhpclinnpts, 4);
    rhpcconnpts  = _rhpcconnpts.fixedflag ?  ((void)(4), rhpcconnpts) : 4;
    if (etl > 3)
    {
        while (rhpcconnpts > etl/2)
        {
            rhpcconnpts  = _rhpcconnpts.fixedflag ?    ((void)(rhpcconnpts-1), rhpcconnpts) : rhpcconnpts-1;
        }
        cvmax(rhpcconnpts, etl/2);
    } 
    else
    {
        rhpcconorder  = _rhpcconorder.fixedflag ?  ((void)(1), rhpcconorder) : 1;
    }

    if (etl>3)
    {
        rhpclinnpts  = _rhpclinnpts.fixedflag ?    ((void)(IMin(2,4,etl/2)), rhpclinnpts) : IMin(2,4,etl/2);
        cvmax(rhpclinnpts, etl/2);
    }
    else
    {
        rhpclinnpts  = _rhpclinnpts.fixedflag ?  ((void)(3), rhpclinnpts) : 3; /* value does not matter */
        rhpclinorder  = _rhpclinorder.fixedflag ?  ((void)(1), rhpclinorder) : 1;
    }

    /* BJM: turn off phase correction via button */
    if ( (etl == 1) )
    {
        rhpccon  = _rhpccon.fixedflag ?  ((void)(0), rhpccon) : 0;
        rhpclin  = _rhpclin.fixedflag ?  ((void)(0), rhpclin) : 0;
        rhpcconorder  = _rhpcconorder.fixedflag ?  ((void)(1), rhpcconorder) : 1;
        rhpclinorder  = _rhpclinorder.fixedflag ?  ((void)(1), rhpclinorder) : 1;
    }
    
    if ((TX_COIL_BODY == getTxCoilType()) && (RX_COIL_LOCAL == getRxCoilType()))
    {
        rhpclinnorm  = _rhpclinnorm.fixedflag ?  ((void)(1), rhpclinnorm) : 1;
        rhpcconnorm  = _rhpcconnorm.fixedflag ?  ((void)(1), rhpcconnorm) : 1;
    }
    else
    {
        rhpclinnorm  = _rhpclinnorm.fixedflag ?  ((void)(0), rhpclinnorm) : 0;
        rhpcconnorm  = _rhpcconnorm.fixedflag ?  ((void)(0), rhpcconnorm) : 0;
    }

    rhpclinfitwt  = _rhpclinfitwt.fixedflag ?  ((void)(0), rhpclinfitwt) : 0;
    cvmax(rhpclinfitwt, 0);
    rhpclinavg  = _rhpclinavg.fixedflag ?  ((void)(0), rhpclinavg) : 0;

    cvmax(rhpcthrespts, 32);
  
    rhpcconfitwt  = _rhpcconfitwt.fixedflag ?  ((void)(0), rhpcconfitwt) : 0;


    /* Value1.5T May 2005 KK */
    if(ghost_check == 1) {
      rhpccon  = _rhpccon.fixedflag ?  ((void)(0), rhpccon) : 0;
      rhpclin  = _rhpclin.fixedflag ?  ((void)(0), rhpclin) : 0;
    }
    else if(ghost_check == 2){ 
      rhpccon  = _rhpccon.fixedflag ?  ((void)(1), rhpccon) : 1;
      rhpclin  = _rhpclin.fixedflag ?  ((void)(1), rhpclin) : 1;
    }

    rhvrgfxres  = _rhvrgfxres.fixedflag ?  ((void)(exist(opxres)), rhvrgfxres) : exist(opxres);
    rhvrgf  = _rhvrgf.fixedflag ?  ((void)(vrgfsamp), rhvrgf) : vrgfsamp;

    rhdab0s  = _rhdab0s.fixedflag ?  ((void)(cfrecvst), rhdab0s) : cfrecvst;
    rhdab0e  = _rhdab0e.fixedflag ?  ((void)(cfrecvend), rhdab0e) : cfrecvend;

    if(touch_flag)
    {
        rhnecho  = _rhnecho.fixedflag ?  ((void)(touch_ndir), rhnecho) : touch_ndir;
        rhrawsize = slquant1 * (1 + (rhbline * rawdata) + rhnframes + rhhnover) * 2
                    * rhptsize * ((exnex * (1 - rawdata)) + (nex * rawdata))
                    * rhnecho * rhfrsize;
    }
    else{
        if (rhref == 1 && baseline > 0 && rawdata == PSD_ON) {
            rhrawsize = 2*slquant1*(1+rhbline+rhnframes+rhhnover)*2
                *rhptsize*nex*rhfrsize;
        }
        else {
            /* internref: consider iref_frames*/ /*MRIhc04836*/
            rhrawsize = slquant1*(1+rhbline*rawdata+rhnframes+rhhnover+iref_frames)*2
                *rhptsize*nex*rhfrsize;
        }
        rhrawsize *= reps*exist(opphases);
        rhnecho  = _rhnecho.fixedflag ?  ((void)(1), rhnecho) : 1;
    }

    /*In case opfphases is not reset to 1 by SCAN when "Mph" is turned off. YP Du. MRIge32705 */
    if(mph_flag==PSD_ON)
    {
        rhnslices  = _rhnslices.fixedflag ?  ((void)(exist(opslquant)*exist(opphases)*exist(opfphases)), rhnslices) : exist(opslquant)*exist(opphases)*exist(opfphases);
    }
    else
    {
        rhnslices  = _rhnslices.fixedflag ?  ((void)(exist(opslquant)*exist(opphases)), rhnslices) : exist(opslquant)*exist(opphases);
    }

    if ((rhdab0e - rhdab0s) == 0) {
        rhtype1  = _rhtype1.fixedflag ?    ((void)(rhtype1&~RHTYP1AUTOPASS), rhtype1) : rhtype1&~RHTYP1AUTOPASS;  /* clear automatic scan/pass detection bit */
    }

    /* Tell TARDIS there is a hyperscan dab packet and to use HRECON. */
    rhformat  = _rhformat.fixedflag ?    ((void)(rhformat|64), rhformat) : rhformat|64;

    /* Turn on row-flipping */
    rhformat  = _rhformat.fixedflag ?    ((void)(rhformat|2048), rhformat) : rhformat|2048;
  
    if (touch_flag)
    {
        rhrcctrl  = _rhrcctrl.fixedflag ?    ((void)(RHRCMAG+RHRCCOMP), rhrcctrl) : RHRCMAG+RHRCCOMP;
    }
    else
    {
        /* Turn off image compression */
        rhrcctrl  = _rhrcctrl.fixedflag ?    ((void)(RHRCMAG+rawmode*RHRCRAW), rhrcctrl) : RHRCMAG+rawmode*RHRCRAW;
    }

    if (dc_chop == 1) {
	rhtype  = _rhtype.fixedflag ?    ((void)(rhtype&~RHTYPCHP), rhtype) : rhtype&~RHTYPCHP;  /* clear chopper bit */
	rhblank  = _rhblank.fixedflag ?  ((void)(blank), rhblank) : blank;
    } else {
	rhtype  = _rhtype.fixedflag ?    ((void)(rhtype|RHTYPCHP), rhtype) : rhtype|RHTYPCHP;   /* set chopper bit */
	rhblank  = _rhblank.fixedflag ?  ((void)(0), rhblank) : 0;
    }
    if (touch_flag){
        rhtype  = _rhtype.fixedflag ?  ((void)(~RHTYPFRACTNEX), rhtype) : rhtype&~RHTYPFRACTNEX;
    }

    /* number of points to blank on display */
    if (image_size < 256)
        rhblank  = _rhblank.fixedflag ?  ((void)((4*image_size)/256), rhblank) : (4*image_size)/256;

    /* Fermi filter control - different for epi due to vrgf */
    rhfermr  = _rhfermr.fixedflag ?  ((void)(exist(opxres)/2), rhfermr) : exist(opxres)/2;

    /* Set recon header variables based on MRE information */
/* Start inline from touch.e TouchRhheader */
/* Set recon header variables */
if( touch_flag )
{

    mag_mask  = _mag_mask.fixedflag ?  ((void)(0), mag_mask) : 0; /* turn off magnitude masks that might be applied to the data */

    rhyoff  = _rhyoff.fixedflag ?  ((void)(0), rhyoff) : 0;
    rhslblank  = _rhslblank.fixedflag ?  ((void)(0), rhslblank) : 0;
    rhvenc  = _rhvenc.fixedflag ?  ((void)(1000.0), rhvenc) : 1000.0; /* this will scale the phase data by 1000 so it can be treated as integer values without significant discretizing artifacts (could even do 10000) */
    maxpc_cor  = _maxpc_cor.fixedflag ?  ((void)(PSD_OFF), maxpc_cor) : PSD_OFF;

    /* Set TEs and BWs to the same values for all echos since we are using
     * "echo" for motion encoding direction */
    ihte2  = _ihte2.fixedflag ?  ((void)(ihte1), ihte2) : ihte1;
    ihte3  = _ihte3.fixedflag ?  ((void)(ihte1), ihte3) : ihte1;
    ihte4  = _ihte4.fixedflag ?  ((void)(ihte1), ihte4) : ihte1;
    ihte5  = _ihte5.fixedflag ?  ((void)(ihte1), ihte5) : ihte1;
    ihte6  = _ihte6.fixedflag ?  ((void)(ihte1), ihte6) : ihte1;
    ihvbw2  = _ihvbw2.fixedflag ?  ((void)(ihvbw1), ihvbw2) : ihvbw1;
    ihvbw3  = _ihvbw3.fixedflag ?  ((void)(ihvbw1), ihvbw3) : ihvbw1;
    ihvbw4  = _ihvbw4.fixedflag ?  ((void)(ihvbw1), ihvbw4) : ihvbw1;
    ihvbw5  = _ihvbw5.fixedflag ?  ((void)(ihvbw1), ihvbw5) : ihvbw1;
    ihvbw6  = _ihvbw6.fixedflag ?  ((void)(ihvbw1), ihvbw6) : ihvbw1;

    phase_cor  = _phase_cor.fixedflag ?  ((void)(0), phase_cor) : 0;

    /* Setup phase constrast recon echo combination */
    rhvcoefxa  = _rhvcoefxa.fixedflag ?  ((void)(1.0), rhvcoefxa) : 1.0;
    rhvcoefxb  = _rhvcoefxb.fixedflag ?  ((void)(2.0), rhvcoefxb) : 2.0;
    rhvcoefxc  = _rhvcoefxc.fixedflag ?  ((void)(2.0), rhvcoefxc) : 2.0;
    rhvcoefxd  = _rhvcoefxd.fixedflag ?  ((void)(1.0), rhvcoefxd) : 1.0;
    rhvcoefya  = _rhvcoefya.fixedflag ?  ((void)(3.0), rhvcoefya) : 3.0;
    rhvcoefyb  = _rhvcoefyb.fixedflag ?  ((void)(1.0), rhvcoefyb) : 1.0;
    rhvcoefyc  = _rhvcoefyc.fixedflag ?  ((void)(3.0), rhvcoefyc) : 3.0;
    rhvcoefyd  = _rhvcoefyd.fixedflag ?  ((void)(1.0), rhvcoefyd) : 1.0;
    rhvcoefza  = _rhvcoefza.fixedflag ?  ((void)(4.0), rhvcoefza) : 4.0;
    rhvcoefzb  = _rhvcoefzb.fixedflag ?  ((void)(1.0), rhvcoefzb) : 1.0;
    rhvcoefzc  = _rhvcoefzc.fixedflag ?  ((void)(4.0), rhvcoefzc) : 4.0;
    rhvcoefzd  = _rhvcoefzd.fixedflag ?  ((void)(1.0), rhvcoefzd) : 1.0;

    rhvmcoef1  = _rhvmcoef1.fixedflag ?  ((void)(0.5), rhvmcoef1) : 0.5;
    rhvmcoef2  = _rhvmcoef2.fixedflag ?  ((void)(0.5), rhvmcoef2) : 0.5;
    rhvmcoef3  = _rhvmcoef3.fixedflag ?  ((void)(0.25), rhvmcoef3) : 0.25;
    rhvmcoef4  = _rhvmcoef4.fixedflag ?  ((void)(0.25), rhvmcoef4) : 0.25;

    rhvtype  = _rhvtype.fixedflag ?        ((void)(VASCULAR+PHASE_CON+MAGNITUDE*opmagc), rhvtype) : VASCULAR+PHASE_CON+MAGNITUDE*opmagc;
}
else
{
    rhvtype  = _rhvtype.fixedflag ?  ((void)(0), rhvtype) : 0;
}
/* End inline from touch.e TouchRhheader */


    /* Split predownlaod into two modules so gcc assembler can process */
    if (predownload1()==FAILURE) {
        return FAILURE;
    }

    /* Set pulse parameters */
    if ( FAILURE == calcPulseParams() )
    {
        return FAILURE;
    }

    if (ss_fa_scaling_flag && (cfgcoiltype == PSD_XRMB_COIL || cfgcoiltype == PSD_XRMW_COIL))
    {
        override_fatsat_high_weight  = _override_fatsat_high_weight.fixedflag ?  ((void)(PSD_ON), override_fatsat_high_weight) : PSD_ON;
    }

    if (PSD_OFF == override_fatsat_high_weight)
    { 
        if((opweight > 158) && (ss_rf1 == PSD_ON)) { 
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_IMGOPT_PSD1, EE_ARGS(2), STRING_ARG, "SPSP RF (Chem Sat=None/water)", STRING_ARG, "high pat. weight (>158kg) for EPI" ); 
            return FAILURE; 
        }
    }

#ifndef SIM
    if (bigpat_warning_flag == PSD_ON)
    {
        if ((flip_rf1 < exist(opflip)) && (exist(oppseq) == PSD_SE) && (ss_rf1 == PSD_ON))
        {
            epic_warning( "Image quality may be degraded due to reduced flip angle at high patient weights" );
            bigpat_warning_flag  = _bigpat_warning_flag.fixedflag ?  ((void)(PSD_OFF), bigpat_warning_flag) : PSD_OFF;
        }
    }
#endif

/* Start inline from touch.e TouchAcqOrder */
if( touch_flag )
{
    if( opacqo == 0 )
    {
        /* set multiphase with interleaved slices */
        int i, j, sloff;

        sloff = opslquant * opphases;

        for( j = 1; j < multi_phases; j++ )
        {
            for( i = 0; i < opslquant * opphases; i++ )
            {
                data_acq_order[sloff].slloc = data_acq_order[i].slloc;
                data_acq_order[sloff].slpass = data_acq_order[i].slpass + j * acqs;
                data_acq_order[sloff].sltime = data_acq_order[i].sltime;

                sloff++;
            }
        }

    }
    else
    {
        int i, j, sloff = 0;
        /* set multiphase with sequential slices */
        for( i = 0; i < opslquant * opphases; i++ )
        {
            for( j = 0; j < multi_phases; j++ )
            {
                data_acq_order[sloff].slloc = i;
                data_acq_order[sloff].slpass = sloff;
                data_acq_order[sloff].sltime = 0;
                sloff++;
            }
        }
    }
}
/* End inline from touch.e TouchAcqOrder */

/* Start inline from touch.e TouchPredownloadIhtdel */
if( touch_flag )
{
    int i, j, ij;

    free(ihtdeltab);
    ihtdeltab = (int *)malloc(multi_phases * opslquant * sizeof(int));
    if( ihtdeltab == NULL )
    {
        epic_error(use_ermes, "malloc failed for %s.", EM_MALLOC_ERMES, EE_ARGS(1), STRING_ARG, "ihtdeltab");
        return FAILURE;
    }

    exportaddr(ihtdeltab, (int)(multi_phases * opslquant * sizeof(int)));
    ij = 0;
    for( i = 0; i < opslquant; i++ )
    {
        for( j = 0; j < multi_phases; j++ )
        {
            ihtdeltab[ij] = touch_delta * j;
            ij++;
        }
    }
}
/* End inline from touch.e TouchPredownloadIhtdel */


    if(rtb0_flag)
    {
        rtb0_midsliceindex  = _rtb0_midsliceindex.fixedflag ?  ((void)(pre_slice), rtb0_midsliceindex) : pre_slice;
        rtb0_outlier_nTRs  = _rtb0_outlier_nTRs.fixedflag ?  ((void)((int)ceil(rtb0_outlier_duration*1000000.0/exist(optr))), rtb0_outlier_nTRs) : (int)ceil(rtb0_outlier_duration*1000000.0/exist(optr));
        rtb0Init();
    }

    return SUCCESS;
    fprintf(stderr,"At end of predownload, pw_gyb and a_gyb are %d and %f \n",pw_gyb,a_gyb);    
}   /* end predownload() */


/*
 *  predownload1
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
#ifdef __STDC__
predownload1( void )
#else /* !__STDC__ */
    predownload1()
#endif /* __STDC__ */
{
    int i;

    /* Prescan Slice Calc **********************/
    if (prescanslice(_pre_pass.fixedflag ? (_temp643_pre_pass=pre_pass,&_temp643_pre_pass) : &pre_pass, _pre_slice.fixedflag ? (_temp644_pre_slice=pre_slice,&_temp644_pre_slice) : &pre_slice, opslquant) == FAILURE) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "prescanslice");
	return FAILURE;
    }
  
    /* Find the corresponding spacial slice/pass for the prescan/center slice location */
    {
	int savei = 0;

	for (i = 0; i < opphases*opslquant; i++) {
            if (data_acq_order[i].sltime == pre_slice) {
		savei = i;
		i = opphases*opslquant;
            }
	}

	if ( (mph_flag==PSD_ON) && (acqmode==1) ) {  /* multi-phase sequential */
            for (i = 0; i < reps*opphases*opslquant; i++) {
		if (data_acq_order[i].slpass == pre_pass) {
                    savei = i;
                    i = reps*opphases*opslquant;
		}
            }
	}

	slice_num  = _slice_num.fixedflag ?    ((void)(savei+1), slice_num) : savei+1;
    }

    rhpctemporal  = _rhpctemporal.fixedflag ?  ((void)(1), rhpctemporal) : 1;          /* use first temporal position */

    /* mph, seq, play 1 rep */
    if ( (mph_flag==PSD_ON) && (acqmode==1) && (rhpctemporal==1) )
	slice_num  = _slice_num.fixedflag ?    ((void)(data_acq_order[slice_num-1].slpass+1), slice_num) : data_acq_order[slice_num-1].slpass+1;
	
    /* figure out rhpcpspacial given refSliceNum value */
    if(exist(refSliceNum) != -1 && exist(refSliceNum) != 0) {
        
        /* Is refSliceNum in a valid prescription range */
        if(existcv(opslquant) && exist(opslquant) >= exist(refSliceNum)) {
            
            /* Figure out temporal position of desired ref slice (interleaved order) */
            /* the slice prescribed is in terms of the spatial order.  This converts */
            /* the spatial index to the temporal position in the pass.               */
            /* Note: the must subtract 1 since slice index starts @ 0!               */
            
            temp_rhpcspacial  = _temp_rhpcspacial.fixedflag ?    ((void)((INT)(data_acq_order[(INT)(exist(refSliceNum)-1)].sltime+1)), temp_rhpcspacial) : (INT)(data_acq_order[(INT)(exist(refSliceNum)-1)].sltime+1);
            pre_slice  = _pre_slice.fixedflag ?     ((void)(temp_rhpcspacial-1), pre_slice) : temp_rhpcspacial-1;
            
        } else {
            
            epic_error( 0, "Error!: Ref Scan Slice Index > number of slices",
                        EM_PSD_SUPPORT_FAILURE, 1, STRING_ARG, "predownload" );
            return FAILURE;
        }
        
        if( exist(refSliceNum) != -1 && acqs > 1) {
            epic_error( 0, "Error!: refSliceNum != -1 & acqs > 1 not compatible",
                        EM_PSD_SUPPORT_FAILURE, 1, STRING_ARG, "predownload" );
            return FAILURE;
        }
        
    } else {
        /* MRIhc19933 */ 
        /* One ref for all, using prescan slice */
        temp_rhpcspacial  = _temp_rhpcspacial.fixedflag ?  ((void)(0), temp_rhpcspacial) : 0;            /* use all slices */
        if ( (mph_flag==PSD_ON) && (acqmode==1) ) /* multi-phase sequential */
        {
            temp_rhpcspacial  = _temp_rhpcspacial.fixedflag ?  ((void)(1), temp_rhpcspacial) : 1;
        }
    }
   
    /*MRIhc06466 MRIhc06308*/
    if (PSD_OBL==exist(opplane)) {
       rhpcspacial  = _rhpcspacial.fixedflag ?  ((void)(0), rhpcspacial) : 0;
       rhpcspacial_dynamic  = _rhpcspacial_dynamic.fixedflag ?  ((void)(temp_rhpcspacial), rhpcspacial_dynamic) : temp_rhpcspacial;
    } else if ( iref_etl > 0 ) { /* Temp fix for 14.0ME to make dynamic pc
                                    work.  Please remove this 'else if' section
                                    when fixed */
       rhpcspacial  = _rhpcspacial.fixedflag ?  ((void)(0), rhpcspacial) : 0;
       rhpcspacial_dynamic  = _rhpcspacial_dynamic.fixedflag ?  ((void)(temp_rhpcspacial), rhpcspacial_dynamic) : temp_rhpcspacial;
    } else {
       rhpcspacial  = _rhpcspacial.fixedflag ?  ((void)(temp_rhpcspacial), rhpcspacial) : temp_rhpcspacial;
       rhpcspacial_dynamic  = _rhpcspacial_dynamic.fixedflag ?  ((void)(temp_rhpcspacial), rhpcspacial_dynamic) : temp_rhpcspacial;
    } 

    /* set rhscnframe and rhpasframe */
    if (acqmode == 0) {   /* interleaved */
    	/*Total number of frames acquired for an entire SCAN*/
	rhscnframe  = _rhscnframe.fixedflag ?    ((void)(rhnslices*(opnex*(rhnframes+rhhnover+iref_frames)+baseline)), rhscnframe) : rhnslices*(opnex*(rhnframes+rhhnover+iref_frames)+baseline);
	
	/*Number of frames per pass*/
	rhpasframe  = _rhpasframe.fixedflag ?    ((void)(slquant1*(opnex*(rhnframes+rhhnover+iref_frames)+baseline)), rhpasframe) : slquant1*(opnex*(rhnframes+rhhnover+iref_frames)+baseline);
    } else if (acqmode == 1) {  /* sequential */
	rhscnframe  = _rhscnframe.fixedflag ?    ((void)(rhnslices*(opnex*(rhnframes+rhhnover+iref_frames)+baseline)), rhscnframe) : rhnslices*(opnex*(rhnframes+rhhnover+iref_frames)+baseline);
	rhpasframe  = _rhpasframe.fixedflag ?    ((void)(reps*(opnex*(rhnframes+rhhnover+iref_frames)+baseline)), rhpasframe) : reps*(opnex*(rhnframes+rhhnover+iref_frames)+baseline);
    }

    
    if ( rhpcspacial == 0 )
	ref_mode  = _ref_mode.fixedflag ?  ((void)(0), ref_mode) : 0;
    else
	ref_mode  = _ref_mode.fixedflag ?  ((void)(1), ref_mode) : 1; /* loop to the center slice */

    if (rhpcileave == 0)
	refnframes  = _refnframes.fixedflag ?  ((void)(rhnframes), refnframes) : rhnframes;
    else
	refnframes  = _refnframes.fixedflag ?  ((void)(rhnframes/intleaves), refnframes) : rhnframes/intleaves;


    /* set rhrefframes and rhrefframep */
    if (ref_mode == 0) {            /* Excite all slices in ref scan */
  	if (acqmode == 0) {         /* Interleaved */
            if (rhpctemporal == 0)
                rhrefframes  = _rhrefframes.fixedflag ?  ((void)(rhnslices*(refnframes+rhhnover+iref_frames+baseline)), rhrefframes) : rhnslices*(refnframes+rhhnover+iref_frames+baseline);
            else
                rhrefframes  = _rhrefframes.fixedflag ?  ((void)((rhnslices/reps)*(refnframes+rhhnover+iref_frames+baseline)), rhrefframes) : (rhnslices/reps)*(refnframes+rhhnover+iref_frames+baseline);
            rhrefframep  = _rhrefframep.fixedflag ?    ((void)(slquant1*((refnframes+rhhnover+iref_frames)+baseline)), rhrefframep) : slquant1*((refnframes+rhhnover+iref_frames)+baseline);

	} else if (acqmode == 1) {   /* Sequential */

            if (rhpctemporal == 0)
                rhrefframes  = _rhrefframes.fixedflag ?    ((void)(rhnslices*((refnframes+rhhnover+iref_frames)+baseline)), rhrefframes) : rhnslices*((refnframes+rhhnover+iref_frames)+baseline);
            else
                rhrefframes  = _rhrefframes.fixedflag ?    ((void)((rhnslices/reps)*((refnframes+rhhnover+iref_frames)+baseline)), rhrefframes) : (rhnslices/reps)*((refnframes+rhhnover+iref_frames)+baseline);
            rhrefframep  = _rhrefframep.fixedflag ?    ((void)(reps*((refnframes+rhhnover+iref_frames)+baseline)), rhrefframep) : reps*((refnframes+rhhnover+iref_frames)+baseline);

	}
    } else if (ref_mode == 1) {  /* loop to center slice in ref scan */

  	if (acqmode == 0) {   /* Interleaved */
            rhrefframes  = _rhrefframes.fixedflag ?    ((void)((pre_slice+1)*((refnframes+rhhnover+iref_frames)+baseline)), rhrefframes) : (pre_slice+1)*((refnframes+rhhnover+iref_frames)+baseline);
            rhrefframep  = _rhrefframep.fixedflag ?    ((void)((pre_slice+1)*((refnframes+rhhnover+iref_frames)+baseline)), rhrefframep) : (pre_slice+1)*((refnframes+rhhnover+iref_frames)+baseline);
	} else if (acqmode == 1) {  /* sequential */
            rhrefframes  = _rhrefframes.fixedflag ?    ((void)((pre_pass+1)*((refnframes+rhhnover+iref_frames)+baseline)), rhrefframes) : (pre_pass+1)*((refnframes+rhhnover+iref_frames)+baseline);
            rhrefframep  = _rhrefframep.fixedflag ?    ((void)(reps*((refnframes+rhhnover+iref_frames)+baseline)), rhrefframep) : reps*((refnframes+rhhnover+iref_frames)+baseline);
	}

    } else if (ref_mode == 2) {  /* Excite center slice only in ref scan */

  	if (acqmode == 0) {   /* interleaved */
            rhrefframes  = _rhrefframes.fixedflag ?    ((void)(((refnframes+rhhnover+iref_frames)+baseline)), rhrefframes) : ((refnframes+rhhnover+iref_frames)+baseline);
            rhrefframep  = _rhrefframep.fixedflag ?    ((void)(((refnframes+rhhnover+iref_frames)+baseline)), rhrefframep) : ((refnframes+rhhnover+iref_frames)+baseline);
	} else if (acqmode == 1) {  /* sequential */
            rhrefframes  = _rhrefframes.fixedflag ?    ((void)(((refnframes+rhhnover+iref_frames)+baseline)), rhrefframes) : ((refnframes+rhhnover+iref_frames)+baseline);
            rhrefframep  = _rhrefframep.fixedflag ?   ((void)(((refnframes+rhhnover+iref_frames)+baseline)), rhrefframep) : ((refnframes+rhhnover+iref_frames)+baseline);
	}

    } else {
	epic_error(use_ermes,"invalid ref_mode value, use 0, 1, or 2",EM_PSD_REF_MODE_ERROR,0);
	return FAILURE;
    }

    /* *******************************
       Entry Point Table Evaluation
       ******************************* */
  
    if (entrytabinit(entry_point_table, (int)ENTRY_POINT_MAX) == FAILURE)
	return FAILURE;
  
    /* Scan entry point */
    strcpy(entry_point_table[L_SCAN].epname, "scan");
  
    /* Set xmtadd according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtadd is too big. 
       Add in coilatten, too. */
    xmtaddScan  = _xmtaddScan.fixedflag ?    
        ((void)(-200*log10(maxB1[L_SCAN]/maxB1Seq)+txCoilInfo[getTxIndex(coilInfo[0])].coilAtten), xmtaddScan) : -200*log10(maxB1[L_SCAN]/maxB1Seq)+txCoilInfo[getTxIndex(coilInfo[0])].coilAtten;
	
    /*JWG BB 13C power prescan done with fidcsi. In that psd, xmtaddScan = 0, so force 0 when specnuc != 1*/
    if (specnuc != 1) xmtaddScan  = _xmtaddScan.fixedflag ?  ((void)(0), xmtaddScan) : 0;	
	
    if (xmtaddScan > cfdbmax) {
        extraScale  = _extraScale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddScan)/200.0)), extraScale) : (float)pow(10.0,(cfdbmax-xmtaddScan)/200.0);
        xmtaddScan  = _xmtaddScan.fixedflag ?  ((void)(cfdbmax), xmtaddScan) : cfdbmax;
    } else {
        extraScale  = _extraScale.fixedflag ?  ((void)(1.0), extraScale) : 1.0;
    }
  
    if (setScale(L_SCAN, RF_FREE, rfpulse, maxB1[L_SCAN], 
                 extraScale) == FAILURE) {
        epic_error(use_ermes, "%s failed for scan.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale");
        return FAILURE;
    }
  
    entry_point_table[L_SCAN].epxmtadd = (short) rint((double)xmtaddScan);
  
    if (cs_sat == PSD_ON)
	rfpulse[RFCSSAT_SLOT].num = 1;
  
    /* MRIge75651*/
    if (powermon(&entry_point_table[L_SCAN], L_SCAN, (int)RF_FREE,
                         rfpulse, (int)(act_tr/slquant1)) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon");
        return FAILURE;
    }

    /* Store SAR power monitor values in CVs for debugging */
    extractActivePowerMonValues( &entry_point_table[L_SCAN],
                                 txCoilInfo[getTxIndex(coilInfo[0])],
                                 _sar_amp.fixedflag ? (_temp645_sar_amp=sar_amp,&_temp645_sar_amp) : &sar_amp, _sar_width.fixedflag ? (_temp646_sar_width=sar_width,&_temp646_sar_width) : &sar_width, _sar_cycle.fixedflag ? (_temp647_sar_cycle=sar_cycle,&_temp647_sar_cycle) : &sar_cycle );
  
    entry_point_table[L_SCAN].epfilter = (unsigned char)echo1_filt.fslot;
    entry_point_table[L_SCAN].epprexres = rhfrsize;
    entry_point_table[L_SCAN].epstartrec = rhdab0s;
    entry_point_table[L_SCAN].ependrec = rhdab0e;
  
    /* Now copy into APS2, MPS2, REF */
    entry_point_table[L_APS2] = entry_point_table[L_MPS2] =
	entry_point_table[L_REF] = entry_point_table[L_SCAN];
    
    strcpy(entry_point_table[L_MPS2].epname, "mps2");
    strcpy(entry_point_table[L_APS2].epname, "aps2");
    strcpy(entry_point_table[L_REF].epname, "ref");
  
    /* MPS (Prescan) uses two frames to substract in the default window */
    etot  = _etot.fixedflag ?  ((void)(2), etot) : 2;

    if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FRACT_KY) {
        emid  = _emid.fixedflag ?     ((void)(num_overscan/intleaves-1), emid) : num_overscan/intleaves-1;
        emid  = _emid.fixedflag ?   ((void)(ky_offset/intleaves), emid) : emid+ky_offset/intleaves;
    } else if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FULL_KY) {
	emid  = _emid.fixedflag ?  ((void)(0), emid) : 0;
    } else if ((ky_dir==PSD_TOP_DOWN || ky_dir==PSD_BOTTOM_UP) &&
               fract_ky == PSD_FULL_KY) {
        emid  = _emid.fixedflag ?   ((void)((etl-1)/2), emid) : (etl-1)/2; 
        emid  = _emid.fixedflag ?     ((void)(ky_offset/intleaves+iref_etl), emid) : emid+ky_offset/intleaves+iref_etl;
    } else if ((ky_dir==PSD_TOP_DOWN || ky_dir==PSD_BOTTOM_UP) &&
               fract_ky == PSD_FRACT_KY) {
        emid  = _emid.fixedflag ?     ((void)(num_overscan/intleaves-1), emid) : num_overscan/intleaves-1;
        emid  = _emid.fixedflag ?     ((void)(ky_offset/intleaves+iref_etl), emid) : emid+ky_offset/intleaves+iref_etl;
    } else {
        emid  = _emid.fixedflag ?  ((void)(0), emid) : 0;
    }

    /* First echo in train to send to MPS2 */
    if (exist(oppseq) == PSD_SE) {
        /* spin echo epi */
        e1st  = _e1st.fixedflag ?     ((void)(emid-etot/2), e1st) : emid-etot/2;
    } else if (exist(oppseq) == PSD_GE) {
        /* gradient echo epi */
        e1st  = _e1st.fixedflag ?  ((void)(0), e1st) : 0;
    } else {
        /* default */
        e1st  = _e1st.fixedflag ?  ((void)(0), e1st) : 0;
    }

    /* check for negative values */
    emid  = _emid.fixedflag ?        ((void)(((emid<0)?0:emid)), emid) : ((emid<0)?0:emid);
    e1st  = _e1st.fixedflag ?        ((void)(((e1st<0)?0:e1st)), e1st) : ((e1st<0)?0:e1st);

    entry_point_table[L_MPS2].epprexres = rhfrsize;
    entry_point_table[L_APS2].epprexres = rhfrsize;
    

    {    /* Code inlined from BroadBand.e BBpredownload */

        STATUS status;

        if((status = BBpredownload(entry_point_table,
                                   ENTRY_POINT_ALL, specnuc)) != SUCCESS) {
            return status;
        }

    }    /* End of code inlined from BroadBand.e BBpredownload */



    if (debug_scan) {
        psd_dump_scan_info();
        psd_dump_rsp_info();
    }

    /* *****************************
       Auto Prescan Init
	 
       Inform Auto Prescan about
       prescan parameters.
       *************************** */
  
    pitr = prescan1_tr; /* first pass prescan TR */
    pichop = 0; /* no chop for APS */
    picalmode = 0;
    pislquant = etot*slquant1; /* Number of slices in 2nd pass prescan */
  
    /* Must be called before first setfilter() call in predownload */
    initfilter();

    if (setfilter( &echo1_filt, SCAN) == FAILURE) {
        epic_error(use_ermes,"setfilter failed",EM_PSD_SUPPORT_FAILURE,1,STRING_ARG, "setfilter");
        return FAILURE;
    }

    /* set CV for EP_TRAIN macro */
    scanslot  = _scanslot.fixedflag ?  ((void)(echo1_filt.fslot), scanslot) : echo1_filt.fslot;

    if(rtb0_flag)
    {
        filter_rtb0echo  = _filter_rtb0echo.fixedflag ?  ((void)(scanslot), filter_rtb0echo) : scanslot;
    }

{ /* Start of code inlined from Prescan.e PSfilter */
    /*********************************************************************
     *                     PRESCAN.E HOST SECTION                        *
     *                            PSfilter                               *
     *                                                                   *
     * Write here the code unique to the Host PSD process.               *
     *********************************************************************/
    /* PS filter must be called with no arguments. num_filter_slot 
       is a CV which comes from individual PSDs, which get incremented 
       in the PSD so that Prescan filter generation takes place for 
       the next slot in psd_filter_spec. - RJF 13/Oct/1998 */
    /* vmx 10/13/94 YI */
    PSfilter();
    /* end vmx */

    if(psddebugcode)
    {
        dump_runtime_filter_info(psd_filt_spec);
    }
} /* End of code inlined from Prescan.e PSfilter */


    /* For fast receiver, determine low pass filter setting based on
       sampling period.  This will be selected via an ssp packet */
    rhfast_rec  = _rhfast_rec.fixedflag ?  ((void)(0), rhfast_rec) : 0;

    field_strength = cffield;
    frtime  = _frtime.fixedflag ?  ((void)((float)((rhfrsize-1)*tsp)), frtime) : (float)((rhfrsize-1)*tsp);

    /* Open /usr/g/bin/vrgf.param and write out the VRGF parameters
       If auto mode, request that scan call the vrgf program */
    piforkvrgf  = _piforkvrgf.fixedflag ?  ((void)(0), piforkvrgf) : 0;
    if (vrgfsamp == PSD_ON) {
	if (genVRGF(&gradout,
                    (int)exist(opxres),
                    tsp,
                    a_gxw,
                    (float)(pw_gxwl + pw_gxw/2)/1.0e6,
                    (float)(pw_gxwad)/1.0e6,
                    2.0/(epiloggrd.xbeta + 1.0),
                    epiloggrd.xbeta) == FAILURE)
            return FAILURE;
        if (autovrgf == PSD_ON){
            piforkvrgf  = _piforkvrgf.fixedflag ?  ((void)(1), piforkvrgf) : 1;
        }

/* MRIhc15230 - vrgf for fMRI now called by scn instead of system call */
#ifdef RT

#ifndef SIM
        if (autovrgf == PSD_ON){
            rhtype1  = _rhtype1.fixedflag ?  ((void)(FAST_VRGF_ALT), rhtype1) : rhtype1|FAST_VRGF_ALT;
        }
#endif

#endif

    }
 
    /* Turn on/off bandpass asymmetry correction */
    if( PSDDVMR != psd_board_type ) 
    { 
        if(((rhdab0e - rhdab0s + 1) > number_of_bc_files) || value_system_flag) { 
            rhbp_corr  = _rhbp_corr.fixedflag ?  ((void)(0), rhbp_corr) : 0; /* turn it off if the number of BC files */
                           /* does not match the number of active receivers */
        } 
        else 
        {
            rhbp_corr  = _rhbp_corr.fixedflag ?  ((void)(1), rhbp_corr) : 1; /* else turn it on */
        }
    }
    else
    {
        rhbp_corr  = _rhbp_corr.fixedflag ?  ((void)(0), rhbp_corr) : 0; /* MRIhc24730: Bandpass asymmetry correction */ 
                       /* will not be applied for DVMR receive chain hardware*/
    }

    /* Local scope block */
    {
	float delta_freq;  /* delta frequency (Hz) */
	float full_bw;     /* full bandwidth  (Hz) */
	float read_offset; /* readout offset (Hz) */

	full_bw = 1.0/(tsp*1.0e-6);
	delta_freq = full_bw/(float)rhfrsize;

	/*	read_offset = a_gxw * GAM * scan_info[0].oprloc / 10.0; */
	read_offset = 0.0;
	rhrecv_freq_s  = _rhrecv_freq_s.fixedflag ?      ((void)(-((float)rhfrsize*delta_freq/2.0+read_offset)+0.5), rhrecv_freq_s) : -((float)rhfrsize*delta_freq/2.0+read_offset)+0.5;
	rhrecv_freq_e  = _rhrecv_freq_e.fixedflag ?    ((void)((float)((rhfrsize-1)/2)*delta_freq+read_offset), rhrecv_freq_e) : (float)((rhfrsize-1)/2)*delta_freq+read_offset;
    }

    if (vrgfsamp == PSD_ON) {
        dacq_adjust  = _dacq_adjust.fixedflag ?      
                             
                            ((void)(((float)pw_gxw/2.0+(float)(pw_gxwad)-(float)(pw_gyba+pw_gyb+pw_gybd)/2.0-tsp*((float)rhfrsize-1.0)/2.0)), dacq_adjust) : ((float)pw_gxw/2.0+(float)(pw_gxwad)-(float)(pw_gyba+pw_gyb+pw_gybd)/2.0-tsp*((float)rhfrsize-1.0)/2.0);
    } else {
        dacq_adjust  = _dacq_adjust.fixedflag ?          ((void)((float)pw_gxw/2.0-tsp*((float)rhfrsize-1.0)/2.0), dacq_adjust) : (float)pw_gxw/2.0-tsp*((float)rhfrsize-1.0)/2.0;
    }

    /* protect against negative adjustment */
    dacq_adjust  = _dacq_adjust.fixedflag ?        ((void)(((dacq_adjust<0)?0:dacq_adjust)), dacq_adjust) : ((dacq_adjust<0)?0:dacq_adjust);

#ifndef SIM
    /* Compute interpolated time delays for phase-encode blip correction method */
    if ( FAILURE == blipcorrdel( _bc_delx.fixedflag ? (_temp648_bc_delx=bc_delx,&_temp648_bc_delx) : &bc_delx, _bc_dely.fixedflag ? (_temp649_bc_dely=bc_dely,&_temp649_bc_dely) : &bc_dely, _bc_delz.fixedflag ? (_temp650_bc_delz=bc_delz,&_temp650_bc_delz) : &bc_delz, esp,
                                 txCoilInfo[getTxIndex(coilInfo[0])].txCoilType,
                                 debug_oblcorr) ) {
        epic_error( use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                    EE_ARGS(1), STRING_ARG, "blipcorrdel" );
        return FAILURE;
    }
#endif /* !SIM */

    return SUCCESS;
} /* end Predownload1 */


/*
 *  calcPulseParams
 *  
 *  Type: Public Function
 *  
 *  Description:
 *    This function sets pulse widths and instruction amplitudes needed
 *    for pulse generation.
 */
STATUS
#ifdef __STDC__ 
calcPulseParams( void )
#else /* !__STDC__ */
    calcPulseParams() 
#endif /* __STDC__ */
{

    /* Include EPIC-generated code */
#include "predownload.in"

/* Inversion Recovery predownload */
    { /* Start of code inlined from Inversion.e InversionPredownload */
        if (silver_hoult == PSD_ON) 
            rfconf = _rfconf.fixedflag ? ((void)(141), rfconf) : 141;

        if (ir_on == PSD_ON) {
            irslquant  = _irslquant.fixedflag ?  ((void)(1), irslquant) : 1;
            tmpslthick  = _tmpslthick.fixedflag ?  ((void)(opslthick), tmpslthick) : opslthick;
        }

        if (flair_on == PSD_ON) {
            irslquant  = _irslquant.fixedflag ?  ((void)(slquant1+(t2flair_extra_ir_flag?1:0)), irslquant) : slquant1+(t2flair_extra_ir_flag?1:0);
            tmpslthick  = _tmpslthick.fixedflag ?  ((void)(invthick), tmpslthick) : invthick;
        }

        if ((ir_on == PSD_ON) || (flair_on == PSD_ON))
        {
            ihti  = _ihti.fixedflag ?  ((void)(opti), ihti) : opti;
            setexist(ihti,PSD_ON);

            if ( existcv(opti) && (exist(opti) > 1500000) )
                prescan1_tr  = _prescan1_tr.fixedflag ?    ((void)(opti+500000), prescan1_tr) : opti+500000;
            else
                prescan1_tr  = _prescan1_tr.fixedflag ?  ((void)(2000000), prescan1_tr) : 2000000; 

            ia_rf0  = _ia_rf0.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF0_SLOT].amp)), ia_rf0) : max_pg_iamp*(*rfpulse[RF0_SLOT].amp);

            if (silver_hoult == PSD_ON) {
                pw_omegarf0 = _pw_omegarf0.fixedflag ? ((void)(pw_rf0), pw_omegarf0) : pw_rf0;
                ia_omegarf0 = _ia_omegarf0.fixedflag ? ((void)(-max_pg_iamp), ia_omegarf0) : -max_pg_iamp;
                res_omegarf0  = _res_omegarf0.fixedflag ?  ((void)(res_rf0), res_omegarf0) : res_rf0;
            }
        }
        else if (PSD_ON==exist(opspecir))
        {   /* ASPIR */
            ihti  = _ihti.fixedflag ?  ((void)(exist(opti)), ihti) : exist(opti);
            setexist(ihti,PSD_ON);
        } 
        else 
        {
            setexist(ihti,PSD_OFF);
        }

        rf0_phase  = _rf0_phase.fixedflag ?  ((void)(0.25), rf0_phase) : 0.25;
    } /* End of code inlined from Inversion.e InversionPredownload */


/*jwg bb placing this here gets rfconf automatically set correctly*/
    if ((acquire_type == SPECPSD_MASTER_H1)
        || (acquire_type == SPECPSD_MASTER_MNS)){
        rfconf  = _rfconf.fixedflag ?      
                     ((void)((ENBL_RHO1|ENBL_THETA|ENBL_OMEGA|ENBL_OMEGA_FREQ_XTR1|ENBL_THETA_PHASE_XTR1)), rfconf) : (ENBL_RHO1|ENBL_THETA|ENBL_OMEGA|ENBL_OMEGA_FREQ_XTR1|ENBL_THETA_PHASE_XTR1);
    } else {
        rfconf  = _rfconf.fixedflag ?      
                     ((void)((ENBL_RHO2|ENBL_THETA|ENBL_OMEGA|ENBL_OMEGA_PHASE_XTR2|ENBL_THETA_FREQ_XTR2)), rfconf) : (ENBL_RHO2|ENBL_THETA|ENBL_OMEGA|ENBL_OMEGA_PHASE_XTR2|ENBL_THETA_FREQ_XTR2);
    }   


{ /* Start of code inlined from Prescan.e PSpredownload */
    /*********************************************************************
     *                     PRESCAN.E HOST SECTION                        *
     *                         PSpredownload                             *
     *                                                                   *
     * Write here the code unique to the Host PSD process. All code to   *
     * be executed in predownload() must be written here.                *
     *********************************************************************/
    if (FAILURE==PSpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==FTGpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==XTGpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==ASpredownload())
    {
        return FAILURE;
    }
} /* End of code inlined from Prescan.e PSpredownload */




    /*****************************
      Timing for SCAN entrypoint
    ****************************/
  
    /*************************************************************************
      pos_start marks the position of the start of the attack ramp of
      the gradient for the excitation pulse.  If Sat or other prep pulses
      are played before excitation, then the pos_start marker is incremented
      accordingly to account for the prep time.
      
      Because the rf unblank must be played at least -rfupa us prior to
      the excitation pulse, pos_start must allow enough space for this
      unblank if the attack of the ramp is not long enough.  Rather than
      arbitrarily making the attack pulse longer, the start position is
      adjusted and the attack ramp is optimized.
      
      Note also that rfupa is a negative number, so it is negated in
      the following calculation to make it a positive number.
    ************************************************************************/
    pos_start  = _pos_start.fixedflag ?    ((void)(RUP_GRD((int)tlead+GRAD_UPDATE_TIME)), pos_start) : RUP_GRD((int)tlead+GRAD_UPDATE_TIME);


    if ((pos_start + pw_gzrf1a) < -rfupa) {
        pos_start  = _pos_start.fixedflag ?      ((void)(RUP_GRD((int)(-rfupa-pw_gzrf1a+GRAD_UPDATE_TIME))), pos_start) : RUP_GRD((int)(-rfupa-pw_gzrf1a+GRAD_UPDATE_TIME));
    }

    /*
      Ordering of pulse is for non cardiac:
      spatial sat, chemsat, 90 (180) readout and killer.

      For cardiac:
      90 (180) readout, spatial sat, chemsat, and killer
    */
    sp_satcard_loc  = _sp_satcard_loc.fixedflag ?  ((void)(0), sp_satcard_loc) : 0;
    if ( (existcv(opcgate)) && (exist(opcgate)==PSD_ON) ) {
	/* Set some values for the scan clock */
	pidmode  = _pidmode.fixedflag ?  ((void)(PSD_CLOCK_CARDIAC), pidmode) : PSD_CLOCK_CARDIAC; /* Display views  and clock */
	/*
          piclckcnt 
          piclckcnt is used is estimating the scan time remaining in
          a cardiac scan.  It is the number of cardiac triggers within
          an effective TR interval used by the PSD to initiate a 
          sequence after the initial  cardiac trigger 
          
          piviews
          piviews is used by the Tgt in cardiac scans to display the
          number of heart beat triggers the PSD will use 
          to complete a scan 
          
          trigger_time
          Amount of time to leave for the cardiac trigger.
        */
        ctlend  = _ctlend.fixedflag ?   
                       
                            ((void)(IMax(2,(int)GRAD_UPDATE_TIME,RDN_GRD(psd_tseq-tmin-time_ssi))), ctlend) : IMax(2,(int)GRAD_UPDATE_TIME,RDN_GRD(psd_tseq-tmin-time_ssi));
        if (opphases  > 1) {
            piviews  = _piviews.fixedflag ?  ((void)(nreps), piviews) : nreps; /* used by the Tgt in cardiac scans to display the
                                number of heart beat triggers the PSD will use 
                                to complete a scan */
            piclckcnt  = _piclckcnt.fixedflag ?  ((void)(0), piclckcnt) : 0;
            trigger_time  = _trigger_time.fixedflag ?         
                                             ((void)(RDN_GRD((int)(0.01*oparr*(60.0/ophrate)*1e6*ophrep))), trigger_time) : RDN_GRD((int)(0.01*oparr*(60.0/ophrate)*1e6*ophrep));
            ctlend_last  = _ctlend_last.fixedflag ?       
                                         ((void)(RDN_GRD(act_tr-trigger_time-td0-(opphases-1)*psd_tseq-tmin-time_ssi)), ctlend_last) : RDN_GRD(act_tr-trigger_time-td0-(opphases-1)*psd_tseq-tmin-time_ssi);
        } else {
            ctlend_fill  = _ctlend_fill.fixedflag ?     
                                                
                                               ((void)(RDN_GRD(piait-(((int)(opslquant/ophrep)+(opslquant%ophrep?1:0)-1)*psd_tseq)-tmin-time_ssi)), ctlend_fill) : RDN_GRD(piait-(((int)(opslquant/ophrep)+(opslquant%ophrep?1:0)-1)*psd_tseq)-tmin-time_ssi);
            ctlend_unfill  = _ctlend_unfill.fixedflag ?   
                                      ((void)(RDN_GRD(ctlend_fill+(opslquant%ophrep?psd_tseq:0))), ctlend_unfill) : RDN_GRD(ctlend_fill+(opslquant%ophrep?psd_tseq:0));
            /* Cross R-R */
            if (opslquant >= ophrep) {
                piclckcnt  = _piclckcnt.fixedflag ?    ((void)(ophrep-1), piclckcnt) : ophrep-1;
                piviews  = _piviews.fixedflag ?    ((void)(nreps*ophrep), piviews) : nreps*ophrep;
                trigger_time  = _trigger_time.fixedflag ?       ((void)(.01*oparr*(60.0/ophrate)*1e6), trigger_time) : .01*oparr*(60.0/ophrate)*1e6;
                ctlend_last  = _ctlend_last.fixedflag ?  ((void)(ctlend_unfill), ctlend_last) : ctlend_unfill;
	    } else {
                piclckcnt  = _piclckcnt.fixedflag ?    ((void)(opslquant-1), piclckcnt) : opslquant-1;
                piviews  = _piviews.fixedflag ?    ((void)(nreps*opslquant), piviews) : nreps*opslquant;
                trigger_time  = _trigger_time.fixedflag ?         
                                    ((void)((0.01*oparr*(60.0/ophrate)*1e6*(ophrep+1-opslquant))), trigger_time) : (0.01*oparr*(60.0/ophrate)*1e6*(ophrep+1-opslquant));
                ctlend_last  = _ctlend_last.fixedflag ?       
                                           ((void)(RDN_GRD(ctlend_fill+(ophrep-opslquant)*((1-.01*oparr)*(60.0/ophrate)*1e6))), ctlend_last) : RDN_GRD(ctlend_fill+(ophrep-opslquant)*((1-.01*oparr)*(60.0/ophrate)*1e6));
	    }
        }
	
	ps2_dda  = _ps2_dda.fixedflag ?  ((void)(dda), ps2_dda) : dda;
	if (optdel1 < pitdel1) {
            /* Calculate time from middle of last echo to when 
               spatial sat, chemsat or killer can begin */
            /* BJM: MRIge55066 - added pw_sspshift */
            post_echo_time  = _post_echo_time.fixedflag ?                ((void)(tdaqhxb+pw_gxwad-rfupa+1+gkdelay+gktime+pw_sspshift), post_echo_time) : tdaqhxb+pw_gxwad-rfupa+1+gkdelay+gktime+pw_sspshift;
            postsat  = _postsat.fixedflag ?  ((void)(opsat), postsat) : opsat;
            sp_satstart  = _sp_satstart.fixedflag ?              ((void)(tlead+GRAD_UPDATE_TIME+pw_gzrf1a+t_exa+psd_rf_wait+te_time+post_echo_time), sp_satstart) : tlead+GRAD_UPDATE_TIME+pw_gzrf1a+t_exa+psd_rf_wait+te_time+post_echo_time;
            cs_satstart  = _cs_satstart.fixedflag ?        ((void)(sp_satstart+sp_sattime-rfupa+CHEM_SSP_FREQ_TIME), cs_satstart) : sp_satstart+sp_sattime-rfupa+CHEM_SSP_FREQ_TIME;
            sp_satcard_loc  = _sp_satcard_loc.fixedflag ?  ((void)(1), sp_satcard_loc) : 1;
	} else {
            postsat  = _postsat.fixedflag ?  ((void)(PSD_OFF), postsat) : PSD_OFF;
            sp_satstart  = _sp_satstart.fixedflag ?      ((void)(GRAD_UPDATE_TIME+tlead+ir_time), sp_satstart) : GRAD_UPDATE_TIME+tlead+ir_time;
            cs_satstart  = _cs_satstart.fixedflag ?        ((void)(sp_satstart+sp_sattime-rfupa+CHEM_SSP_FREQ_TIME), cs_satstart) : sp_satstart+sp_sattime-rfupa+CHEM_SSP_FREQ_TIME;
            pos_start  = _pos_start.fixedflag ?          ((void)(pos_start+sp_sattime+cs_sattime+ir_time+satdelay), pos_start) : pos_start+sp_sattime+cs_sattime+ir_time+satdelay;
            sp_satcard_loc  = _sp_satcard_loc.fixedflag ?  ((void)(0), sp_satcard_loc) : 0;
	}
    } else if (touch_flag) {
        /* Enable acqs before pause */
        pipautype = PSD_LABEL_PAU_REP;  /* _LOC=0, _REP=1, _ACQ=2 */
        if (exist(opslicecnt)==0) {
            pidmode  = _pidmode.fixedflag ?  ((void)(PSD_CLOCK_NORM), pidmode) : PSD_CLOCK_NORM;
        } else {
            pidmode  = _pidmode.fixedflag ?  ((void)(PSD_CLOCK_PAUSE), pidmode) : PSD_CLOCK_PAUSE;  /* _NORM=0, _CARDIAC=1, _PAUSE=2, CARDPAUSE=3 */
        }

        postsat  = _postsat.fixedflag ?  ((void)(PSD_OFF), postsat) : PSD_OFF;
        sp_satstart  = _sp_satstart.fixedflag ?      ((void)(GRAD_UPDATE_TIME+tlead+ir_time), sp_satstart) : GRAD_UPDATE_TIME+tlead+ir_time;
        cs_satstart  = _cs_satstart.fixedflag ?        ((void)(sp_satstart+sp_sattime-rfupa+CHEM_SSP_FREQ_TIME), cs_satstart) : sp_satstart+sp_sattime-rfupa+CHEM_SSP_FREQ_TIME;
        pos_start  = _pos_start.fixedflag ?          ((void)(RUP_GRD(pos_start+sp_satstart+sp_sattime+cs_sattime+satdelay)), pos_start) : RUP_GRD(pos_start+sp_satstart+sp_sattime+cs_sattime+satdelay);

    } else {
	pidmode  = _pidmode.fixedflag ?  ((void)(PSD_CLOCK_NORM), pidmode) : PSD_CLOCK_NORM; /* Display scan clock in seconds */
	ps2_dda  = _ps2_dda.fixedflag ?  ((void)(dda), ps2_dda) : dda;
        
	sp_satstart  = _sp_satstart.fixedflag ?    ((void)(pos_start+ir_time), sp_satstart) : pos_start+ir_time;
	cs_satstart  = _cs_satstart.fixedflag ?        ((void)(sp_satstart+sp_sattime-rfupa+CHEM_SSP_FREQ_TIME), cs_satstart) : sp_satstart+sp_sattime-rfupa+CHEM_SSP_FREQ_TIME;
	pos_start  = _pos_start.fixedflag ?          ((void)(pos_start+ir_time+sp_sattime+cs_sattime+satdelay), pos_start) : pos_start+ir_time+sp_sattime+cs_sattime+satdelay;
    }
  
    /* MRIge64197 -- single sequence plays IR-SPsat-EPI. Without 
       sp_satcard_loc, IR pulse gets spatial sat rotation matrix. */
    sp_satcard_loc  = _sp_satcard_loc.fixedflag ?    ((void)(sp_satcard_loc||ir_on), sp_satcard_loc) : sp_satcard_loc||ir_on;

    if (ss_rf1 != PSD_ON) {
        pos_moment_start  = _pos_moment_start.fixedflag ?      ((void)(pos_start+t_exa+pw_gzrf1a), pos_moment_start) : pos_start+t_exa+pw_gzrf1a;
    }
    cs_satstart  = _cs_satstart.fixedflag ?  ((void)(RUP_GRD(cs_satstart)), cs_satstart) : RUP_GRD(cs_satstart);
    sp_satstart  = _sp_satstart.fixedflag ?  ((void)(RUP_GRD(sp_satstart)), sp_satstart) : RUP_GRD(sp_satstart); 
  
    /*
     * Initialize the waits for the cardiac instruction.
     * Pulse widths of wait will be set to td0 for first slice
     * of an R-R in RSP.  All other slices will be set to 
     * the GRAD_UPDATE_TIME.
     */
    pw_x_td0  = _pw_x_td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_x_td0) : GRAD_UPDATE_TIME;
    pw_y_td0  = _pw_y_td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_y_td0) : GRAD_UPDATE_TIME;
    pw_z_td0  = _pw_z_td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_z_td0) : GRAD_UPDATE_TIME;
    pw_rho_td0  = _pw_rho_td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_rho_td0) : GRAD_UPDATE_TIME;
    pw_ssp_td0  = _pw_ssp_td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_ssp_td0) : GRAD_UPDATE_TIME;
    pw_theta_td0  = _pw_theta_td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_theta_td0) : GRAD_UPDATE_TIME;
    pw_omega_td0  = _pw_omega_td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_omega_td0) : GRAD_UPDATE_TIME;

    ia_gx1  = _ia_gx1.fixedflag ?     ((void)((int)(a_gx1*(float)max_pg_iamp/loggrd.tx)), ia_gx1) : (int)(a_gx1*(float)max_pg_iamp/loggrd.tx);
    ia_gxk  = _ia_gxk.fixedflag ?     ((void)((int)(a_gxk*(float)max_pg_iamp/loggrd.tx)), ia_gxk) : (int)(a_gxk*(float)max_pg_iamp/loggrd.tx);

    ia_gy1  = _ia_gy1.fixedflag ?  ((void)(endview_iamp), ia_gy1) : endview_iamp; /* GEHmr01804 */

    if (eoskillers == PSD_ON) {
	ia_gxk  = _ia_gxk.fixedflag ?     ((void)((int)(a_gxk*(float)max_pg_iamp/loggrd.tx)), ia_gxk) : (int)(a_gxk*(float)max_pg_iamp/loggrd.tx);
        if (ky_dir == PSD_TOP_DOWN) {
            ia_gyk  = _ia_gyk.fixedflag ?     ((void)(-1*(int)(a_gyk*(float)max_pg_iamp/loggrd.ty)), ia_gyk) : -1*(int)(a_gyk*(float)max_pg_iamp/loggrd.ty);
        } else {
            ia_gyk  = _ia_gyk.fixedflag ?     ((void)((int)(a_gyk*(float)max_pg_iamp/loggrd.ty)), ia_gyk) : (int)(a_gyk*(float)max_pg_iamp/loggrd.ty);
        }
	ia_gzk  = _ia_gzk.fixedflag ?     ((void)((int)(a_gzk*(float)max_pg_iamp/loggrd.tz)), ia_gzk) : (int)(a_gzk*(float)max_pg_iamp/loggrd.tz);
    }
    ia_rf1  = _ia_rf1.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RF1_SLOT].amp)), ia_rf1) : max_pg_iamp*(*rfpulse[RF1_SLOT].amp);
    ia_rf2  = _ia_rf2.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RF2_SLOT].amp)), ia_rf2) : max_pg_iamp*(*rfpulse[RF2_SLOT].amp);

    SpSatIAmp();

    if (cs_sat == PSD_ON) {
	ia_rfcssat  = _ia_rfcssat.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RFCSSAT_SLOT].amp)), ia_rfcssat) : max_pg_iamp*(*rfpulse[RFCSSAT_SLOT].amp);
    }

    /* BJM: Omega Freq Mod Pulses */
    a_omega  = _a_omega.fixedflag ?  ((void)(1), a_omega) : 1;
    ia_omega  = _ia_omega.fixedflag ?  ((void)((a_omega*max_pg_iamp)/loggrd.tz), ia_omega) : (a_omega*max_pg_iamp)/loggrd.tz;
    
    return SUCCESS;

}   /* end calcPulseParams() */



STATUS SelectSpSpFatSatPulse(void)
{
  double max_b1_limit, cur_b1_limit, act_b1_ultralow, act_b1_low, act_b1_medium, act_b1_high;
  INT txIndex[MAX_TX_COIL_SETS];
  INT exciterIndex[MAX_TX_COIL_SETS];
  INT exciterUsed[MAX_TX_COIL_SETS];
  INT numTxIndexUsed = 0;
  INT i;
      
    /* Reset parameters to zero if SPSP fat sat option is not chosen */
    if (PSD_ON != use_spsp_fatsat)
    {
        ext_pw_rfcssat  = _ext_pw_rfcssat.fixedflag ?  ((void)(0), ext_pw_rfcssat) : 0;
        ext_res_rfcssat  = _ext_res_rfcssat.fixedflag ?  ((void)(0), ext_res_rfcssat) : 0;
        ext_isodelay  = _ext_isodelay.fixedflag ?  ((void)(0), ext_isodelay) : 0;
        ext_water_freq_flag  = _ext_water_freq_flag.fixedflag ?  ((void)(0), ext_water_freq_flag) : 0;
        ext_pw_grad_sub_lobe  = _ext_pw_grad_sub_lobe.fixedflag ?  ((void)(0), ext_pw_grad_sub_lobe) : 0;
        ext_pw_grad_sub_lobe_ramp  = _ext_pw_grad_sub_lobe_ramp.fixedflag ?  ((void)(0), ext_pw_grad_sub_lobe_ramp) : 0;
        ext_num_grad_sub_lobe  = _ext_num_grad_sub_lobe.fixedflag ?  ((void)(0), ext_num_grad_sub_lobe) : 0;
        ext_pw_grad_sub_lobe_norf  = _ext_pw_grad_sub_lobe_norf.fixedflag ?  ((void)(0), ext_pw_grad_sub_lobe_norf) : 0;
        ext_pw_grad_sub_lobe_ramp_norf  = _ext_pw_grad_sub_lobe_ramp_norf.fixedflag ?  ((void)(0), ext_pw_grad_sub_lobe_ramp_norf) : 0;
        ext_num_grad_sub_lobe_norf  = _ext_num_grad_sub_lobe_norf.fixedflag ?  ((void)(0), ext_num_grad_sub_lobe_norf) : 0;
        ext_abswidth  = _ext_abswidth.fixedflag ?  ((void)(0.0), ext_abswidth) : 0.0;
        ext_effwidth  = _ext_effwidth.fixedflag ?  ((void)(0.0), ext_effwidth) : 0.0;
        ext_area  = _ext_area.fixedflag ? ((void)(0.0), ext_area) : 0.0;
        ext_dtycyc  = _ext_dtycyc.fixedflag ?  ((void)(0.0), ext_dtycyc) : 0.0;
        ext_maxpw  = _ext_maxpw.fixedflag ?  ((void)(0.0), ext_maxpw) : 0.0;
        ext_max_b1  = _ext_max_b1.fixedflag ?  ((void)(0.0), ext_max_b1) : 0.0;
        ext_max_int_b1_sq  = _ext_max_int_b1_sq.fixedflag ?  ((void)(0.0), ext_max_int_b1_sq) : 0.0;
        ext_max_rms_b1  = _ext_max_rms_b1.fixedflag ?  ((void)(0.0), ext_max_rms_b1) : 0.0;
        ext_nom_fa  = _ext_nom_fa.fixedflag ?  ((void)(0.0), ext_nom_fa) : 0.0;
        ext_nom_pw  = _ext_nom_pw.fixedflag ?  ((void)(0.0), ext_nom_pw) : 0.0;
        ext_nom_bw  = _ext_nom_bw.fixedflag ?  ((void)(0.0), ext_nom_bw) : 0.0;
        ext_gzrfcssat_scale_fac  = _ext_gzrfcssat_scale_fac.fixedflag ?  ((void)(0.0), ext_gzrfcssat_scale_fac) : 0.0;
        ext_fatsat_min_slthick  = _ext_fatsat_min_slthick.fixedflag ?  ((void)(0.0), ext_fatsat_min_slthick) : 0.0;
        return SUCCESS;	  	
    }
  	
    /* Obtain transmit coil information */    
    getTxAndExciter(txIndex, exciterIndex, exciterUsed, &numTxIndexUsed, coilInfo, opncoils); 

    /* Obtain maximum B1 limit due to RF amplifier capability assuming only one transmit coil is active */
    coilB1Limit(&max_b1_limit, txCoilInfo[txIndex[0]]);

    /* This is the code that handles cases with multiple transmit coils (not supposed to be executed for now) */
    for (i = 1; i < numTxIndexUsed; i++)
    {
        coilB1Limit(&cur_b1_limit, txCoilInfo[txIndex[i]]);
        if (cur_b1_limit < max_b1_limit) max_b1_limit = cur_b1_limit;
    }
  	
    max_b1_limit = max_b1_limit/100;  /* uT to Gauss conversion */
    act_b1_ultralow = SAR_MAX_B1_SPSP_FATSAT_ULTRALOW_B1*flip_rfcssat/SAR_NOM_FA_SPSP_FATSAT_ULTRALOW_B1;
    act_b1_low = SAR_MAX_B1_SPSP_FATSAT_LOW_B1*flip_rfcssat/SAR_NOM_FA_SPSP_FATSAT_LOW_B1;
    act_b1_medium = SAR_MAX_B1_SPSP_FATSAT_MEDIUM_B1*flip_rfcssat/SAR_NOM_FA_SPSP_FATSAT_MEDIUM_B1;
    act_b1_high = SAR_MAX_B1_SPSP_FATSAT_HIGH_B1*flip_rfcssat/SAR_NOM_FA_SPSP_FATSAT_HIGH_B1;
    
    if ((act_b1_high <= max_b1_limit && 0 == spsp_fatsat_pulse_override)|| (1 == spsp_fatsat_pulse_override))  
    /* High amplitude pulse can be used */
    {
        strcpy(ext_spsp_fatsat_rf_filename, RFFILENAME_SPSP_FATSAT_HIGH_B1);
        strcpy(ext_spsp_fatsat_gz_filename, GRADFILENAME_SPSP_FATSAT_HIGH_B1);
  	    ext_pw_rfcssat  = _ext_pw_rfcssat.fixedflag ?  ((void)(PW_SPSP_FATSAT_HIGH_B1), ext_pw_rfcssat) : PW_SPSP_FATSAT_HIGH_B1;
        ext_res_rfcssat  = _ext_res_rfcssat.fixedflag ?  ((void)(RES_SPSP_FATSAT_HIGH_B1), ext_res_rfcssat) : RES_SPSP_FATSAT_HIGH_B1;
        ext_isodelay  = _ext_isodelay.fixedflag ?  ((void)(ISODELAY_SPSP_FATSAT_HIGH_B1), ext_isodelay) : ISODELAY_SPSP_FATSAT_HIGH_B1;
        ext_water_freq_flag  = _ext_water_freq_flag.fixedflag ?  ((void)(WATERFREQ_SPSP_FATSAT_HIGH_B1), ext_water_freq_flag) : WATERFREQ_SPSP_FATSAT_HIGH_B1;
        ext_pw_grad_sub_lobe  = _ext_pw_grad_sub_lobe.fixedflag ?  ((void)(GRADSUBLOBE_SPSP_FATSAT_HIGH_B1), ext_pw_grad_sub_lobe) : GRADSUBLOBE_SPSP_FATSAT_HIGH_B1;
        ext_pw_grad_sub_lobe_ramp  = _ext_pw_grad_sub_lobe_ramp.fixedflag ?  ((void)(GRADSUBLOBERAMP_SPSP_FATSAT_HIGH_B1), ext_pw_grad_sub_lobe_ramp) : GRADSUBLOBERAMP_SPSP_FATSAT_HIGH_B1;
        ext_num_grad_sub_lobe  = _ext_num_grad_sub_lobe.fixedflag ?  ((void)(SUBLOBENUMBER_SPSP_FATSAT_HIGH_B1), ext_num_grad_sub_lobe) : SUBLOBENUMBER_SPSP_FATSAT_HIGH_B1;
        ext_pw_grad_sub_lobe_norf  = _ext_pw_grad_sub_lobe_norf.fixedflag ?  ((void)(GRADSUBLOBENORF_SPSP_FATSAT_HIGH_B1), ext_pw_grad_sub_lobe_norf) : GRADSUBLOBENORF_SPSP_FATSAT_HIGH_B1;
        ext_pw_grad_sub_lobe_ramp_norf  = _ext_pw_grad_sub_lobe_ramp_norf.fixedflag ?  ((void)(GRADSUBLOBENORFRAMP_SPSP_FATSAT_HIGH_B1), ext_pw_grad_sub_lobe_ramp_norf) : GRADSUBLOBENORFRAMP_SPSP_FATSAT_HIGH_B1;
        ext_num_grad_sub_lobe_norf  = _ext_num_grad_sub_lobe_norf.fixedflag ?  ((void)(SUBLOBENORFNUMBER_SPSP_FATSAT_HIGH_B1), ext_num_grad_sub_lobe_norf) : SUBLOBENORFNUMBER_SPSP_FATSAT_HIGH_B1;
        ext_abswidth  = _ext_abswidth.fixedflag ?  ((void)(SAR_ABS_SPSP_FATSAT_HIGH_B1), ext_abswidth) : SAR_ABS_SPSP_FATSAT_HIGH_B1;
        ext_effwidth  = _ext_effwidth.fixedflag ?  ((void)(SAR_EFFWIDTH_SPSP_FATSAT_HIGH_B1), ext_effwidth) : SAR_EFFWIDTH_SPSP_FATSAT_HIGH_B1;
        ext_area  = _ext_area.fixedflag ?  ((void)(SAR_AREA_SPSP_FATSAT_HIGH_B1), ext_area) : SAR_AREA_SPSP_FATSAT_HIGH_B1;
        ext_dtycyc  = _ext_dtycyc.fixedflag ?  ((void)(SAR_DTYCYC_SPSP_FATSAT_HIGH_B1), ext_dtycyc) : SAR_DTYCYC_SPSP_FATSAT_HIGH_B1;
        ext_maxpw  = _ext_maxpw.fixedflag ?  ((void)(SAR_MAXPW_SPSP_FATSAT_HIGH_B1), ext_maxpw) : SAR_MAXPW_SPSP_FATSAT_HIGH_B1;
        ext_max_b1  = _ext_max_b1.fixedflag ?  ((void)(SAR_MAX_B1_SPSP_FATSAT_HIGH_B1), ext_max_b1) : SAR_MAX_B1_SPSP_FATSAT_HIGH_B1;
        ext_max_int_b1_sq  = _ext_max_int_b1_sq.fixedflag ?  ((void)(SAR_MAX_INT_B1_SQ_SPSP_FATSAT_HIGH_B1), ext_max_int_b1_sq) : SAR_MAX_INT_B1_SQ_SPSP_FATSAT_HIGH_B1;
        ext_max_rms_b1  = _ext_max_rms_b1.fixedflag ?  ((void)(SAR_MAX_RMS_B1_SPSP_FATSAT_HIGH_B1), ext_max_rms_b1) : SAR_MAX_RMS_B1_SPSP_FATSAT_HIGH_B1;
        ext_nom_fa  = _ext_nom_fa.fixedflag ?  ((void)(SAR_NOM_FA_SPSP_FATSAT_HIGH_B1), ext_nom_fa) : SAR_NOM_FA_SPSP_FATSAT_HIGH_B1;
        ext_nom_pw  = _ext_nom_pw.fixedflag ?  ((void)(SAR_NOM_PW_SPSP_FATSAT_HIGH_B1), ext_nom_pw) : SAR_NOM_PW_SPSP_FATSAT_HIGH_B1;
        ext_nom_bw  = _ext_nom_bw.fixedflag ?  ((void)(SAR_NOM_BW_SPSP_FATSAT_HIGH_B1), ext_nom_bw) : SAR_NOM_BW_SPSP_FATSAT_HIGH_B1;
        ext_gzrfcssat_scale_fac  = _ext_gzrfcssat_scale_fac.fixedflag ?  ((void)(GZSCALEFAC_SPSP_FATSAT_HIGH_B1), ext_gzrfcssat_scale_fac) : GZSCALEFAC_SPSP_FATSAT_HIGH_B1;
        ext_fatsat_min_slthick  = _ext_fatsat_min_slthick.fixedflag ?  ((void)(MINSLTHICK_SPSP_FATSAT_HIGH_B1), ext_fatsat_min_slthick) : MINSLTHICK_SPSP_FATSAT_HIGH_B1;    	
    }  	
    else if ((act_b1_medium <= max_b1_limit && 0 == spsp_fatsat_pulse_override) || (2 == spsp_fatsat_pulse_override))    
    /* High amplitude pulse violates max B1, but medium amplitude pulse can be used */
    {
        strcpy(ext_spsp_fatsat_rf_filename, RFFILENAME_SPSP_FATSAT_MEDIUM_B1);
        strcpy(ext_spsp_fatsat_gz_filename, GRADFILENAME_SPSP_FATSAT_MEDIUM_B1);
  	    ext_pw_rfcssat  = _ext_pw_rfcssat.fixedflag ?  ((void)(PW_SPSP_FATSAT_MEDIUM_B1), ext_pw_rfcssat) : PW_SPSP_FATSAT_MEDIUM_B1;
        ext_res_rfcssat  = _ext_res_rfcssat.fixedflag ?  ((void)(RES_SPSP_FATSAT_MEDIUM_B1), ext_res_rfcssat) : RES_SPSP_FATSAT_MEDIUM_B1;
        ext_isodelay  = _ext_isodelay.fixedflag ?  ((void)(ISODELAY_SPSP_FATSAT_MEDIUM_B1), ext_isodelay) : ISODELAY_SPSP_FATSAT_MEDIUM_B1;
        ext_water_freq_flag  = _ext_water_freq_flag.fixedflag ?  ((void)(WATERFREQ_SPSP_FATSAT_MEDIUM_B1), ext_water_freq_flag) : WATERFREQ_SPSP_FATSAT_MEDIUM_B1;
        ext_pw_grad_sub_lobe  = _ext_pw_grad_sub_lobe.fixedflag ?  ((void)(GRADSUBLOBE_SPSP_FATSAT_MEDIUM_B1), ext_pw_grad_sub_lobe) : GRADSUBLOBE_SPSP_FATSAT_MEDIUM_B1;
        ext_pw_grad_sub_lobe_ramp  = _ext_pw_grad_sub_lobe_ramp.fixedflag ?  ((void)(GRADSUBLOBERAMP_SPSP_FATSAT_MEDIUM_B1), ext_pw_grad_sub_lobe_ramp) : GRADSUBLOBERAMP_SPSP_FATSAT_MEDIUM_B1;
        ext_num_grad_sub_lobe  = _ext_num_grad_sub_lobe.fixedflag ?  ((void)(SUBLOBENUMBER_SPSP_FATSAT_MEDIUM_B1), ext_num_grad_sub_lobe) : SUBLOBENUMBER_SPSP_FATSAT_MEDIUM_B1;
        ext_pw_grad_sub_lobe_norf  = _ext_pw_grad_sub_lobe_norf.fixedflag ?  ((void)(GRADSUBLOBENORF_SPSP_FATSAT_MEDIUM_B1), ext_pw_grad_sub_lobe_norf) : GRADSUBLOBENORF_SPSP_FATSAT_MEDIUM_B1;
        ext_pw_grad_sub_lobe_ramp_norf  = _ext_pw_grad_sub_lobe_ramp_norf.fixedflag ?  ((void)(GRADSUBLOBENORFRAMP_SPSP_FATSAT_MEDIUM_B1), ext_pw_grad_sub_lobe_ramp_norf) : GRADSUBLOBENORFRAMP_SPSP_FATSAT_MEDIUM_B1;
        ext_num_grad_sub_lobe_norf  = _ext_num_grad_sub_lobe_norf.fixedflag ?  ((void)(SUBLOBENORFNUMBER_SPSP_FATSAT_MEDIUM_B1), ext_num_grad_sub_lobe_norf) : SUBLOBENORFNUMBER_SPSP_FATSAT_MEDIUM_B1;
        ext_abswidth  = _ext_abswidth.fixedflag ?  ((void)(SAR_ABS_SPSP_FATSAT_MEDIUM_B1), ext_abswidth) : SAR_ABS_SPSP_FATSAT_MEDIUM_B1;
        ext_effwidth  = _ext_effwidth.fixedflag ?  ((void)(SAR_EFFWIDTH_SPSP_FATSAT_MEDIUM_B1), ext_effwidth) : SAR_EFFWIDTH_SPSP_FATSAT_MEDIUM_B1;
        ext_area  = _ext_area.fixedflag ?  ((void)(SAR_AREA_SPSP_FATSAT_MEDIUM_B1), ext_area) : SAR_AREA_SPSP_FATSAT_MEDIUM_B1;
        ext_dtycyc  = _ext_dtycyc.fixedflag ?  ((void)(SAR_DTYCYC_SPSP_FATSAT_MEDIUM_B1), ext_dtycyc) : SAR_DTYCYC_SPSP_FATSAT_MEDIUM_B1;
        ext_maxpw  = _ext_maxpw.fixedflag ?  ((void)(SAR_MAXPW_SPSP_FATSAT_MEDIUM_B1), ext_maxpw) : SAR_MAXPW_SPSP_FATSAT_MEDIUM_B1;
        ext_max_b1  = _ext_max_b1.fixedflag ?  ((void)(SAR_MAX_B1_SPSP_FATSAT_MEDIUM_B1), ext_max_b1) : SAR_MAX_B1_SPSP_FATSAT_MEDIUM_B1;
        ext_max_int_b1_sq  = _ext_max_int_b1_sq.fixedflag ?  ((void)(SAR_MAX_INT_B1_SQ_SPSP_FATSAT_MEDIUM_B1), ext_max_int_b1_sq) : SAR_MAX_INT_B1_SQ_SPSP_FATSAT_MEDIUM_B1;
        ext_max_rms_b1  = _ext_max_rms_b1.fixedflag ?  ((void)(SAR_MAX_RMS_B1_SPSP_FATSAT_MEDIUM_B1), ext_max_rms_b1) : SAR_MAX_RMS_B1_SPSP_FATSAT_MEDIUM_B1;
        ext_nom_fa  = _ext_nom_fa.fixedflag ?  ((void)(SAR_NOM_FA_SPSP_FATSAT_MEDIUM_B1), ext_nom_fa) : SAR_NOM_FA_SPSP_FATSAT_MEDIUM_B1;
        ext_nom_pw  = _ext_nom_pw.fixedflag ?  ((void)(SAR_NOM_PW_SPSP_FATSAT_MEDIUM_B1), ext_nom_pw) : SAR_NOM_PW_SPSP_FATSAT_MEDIUM_B1;
        ext_nom_bw  = _ext_nom_bw.fixedflag ?  ((void)(SAR_NOM_BW_SPSP_FATSAT_MEDIUM_B1), ext_nom_bw) : SAR_NOM_BW_SPSP_FATSAT_MEDIUM_B1;
        ext_gzrfcssat_scale_fac  = _ext_gzrfcssat_scale_fac.fixedflag ?  ((void)(GZSCALEFAC_SPSP_FATSAT_MEDIUM_B1), ext_gzrfcssat_scale_fac) : GZSCALEFAC_SPSP_FATSAT_MEDIUM_B1;
        ext_fatsat_min_slthick  = _ext_fatsat_min_slthick.fixedflag ?  ((void)(MINSLTHICK_SPSP_FATSAT_MEDIUM_B1), ext_fatsat_min_slthick) : MINSLTHICK_SPSP_FATSAT_MEDIUM_B1;    	
    }
    else if ((act_b1_low <= max_b1_limit && 0 == spsp_fatsat_pulse_override) || (3 == spsp_fatsat_pulse_override))    
    /* High and medium amplitude pulses both violate max B1, but low amplitude pulse can be used */
    {
        strcpy(ext_spsp_fatsat_rf_filename, RFFILENAME_SPSP_FATSAT_LOW_B1);
        strcpy(ext_spsp_fatsat_gz_filename, GRADFILENAME_SPSP_FATSAT_LOW_B1);
  	    ext_pw_rfcssat  = _ext_pw_rfcssat.fixedflag ?  ((void)(PW_SPSP_FATSAT_LOW_B1), ext_pw_rfcssat) : PW_SPSP_FATSAT_LOW_B1;
        ext_res_rfcssat  = _ext_res_rfcssat.fixedflag ?  ((void)(RES_SPSP_FATSAT_LOW_B1), ext_res_rfcssat) : RES_SPSP_FATSAT_LOW_B1;
        ext_isodelay  = _ext_isodelay.fixedflag ?  ((void)(ISODELAY_SPSP_FATSAT_LOW_B1), ext_isodelay) : ISODELAY_SPSP_FATSAT_LOW_B1;
        ext_water_freq_flag  = _ext_water_freq_flag.fixedflag ?  ((void)(WATERFREQ_SPSP_FATSAT_LOW_B1), ext_water_freq_flag) : WATERFREQ_SPSP_FATSAT_LOW_B1;
        ext_pw_grad_sub_lobe  = _ext_pw_grad_sub_lobe.fixedflag ?  ((void)(GRADSUBLOBE_SPSP_FATSAT_LOW_B1), ext_pw_grad_sub_lobe) : GRADSUBLOBE_SPSP_FATSAT_LOW_B1;
        ext_pw_grad_sub_lobe_ramp  = _ext_pw_grad_sub_lobe_ramp.fixedflag ?  ((void)(GRADSUBLOBERAMP_SPSP_FATSAT_LOW_B1), ext_pw_grad_sub_lobe_ramp) : GRADSUBLOBERAMP_SPSP_FATSAT_LOW_B1;
        ext_num_grad_sub_lobe  = _ext_num_grad_sub_lobe.fixedflag ?  ((void)(SUBLOBENUMBER_SPSP_FATSAT_LOW_B1), ext_num_grad_sub_lobe) : SUBLOBENUMBER_SPSP_FATSAT_LOW_B1;
        ext_pw_grad_sub_lobe_norf  = _ext_pw_grad_sub_lobe_norf.fixedflag ?  ((void)(GRADSUBLOBENORF_SPSP_FATSAT_LOW_B1), ext_pw_grad_sub_lobe_norf) : GRADSUBLOBENORF_SPSP_FATSAT_LOW_B1;
        ext_pw_grad_sub_lobe_ramp_norf  = _ext_pw_grad_sub_lobe_ramp_norf.fixedflag ?  ((void)(GRADSUBLOBENORFRAMP_SPSP_FATSAT_LOW_B1), ext_pw_grad_sub_lobe_ramp_norf) : GRADSUBLOBENORFRAMP_SPSP_FATSAT_LOW_B1;
        ext_num_grad_sub_lobe_norf  = _ext_num_grad_sub_lobe_norf.fixedflag ?  ((void)(SUBLOBENORFNUMBER_SPSP_FATSAT_LOW_B1), ext_num_grad_sub_lobe_norf) : SUBLOBENORFNUMBER_SPSP_FATSAT_LOW_B1;
        ext_abswidth  = _ext_abswidth.fixedflag ?  ((void)(SAR_ABS_SPSP_FATSAT_LOW_B1), ext_abswidth) : SAR_ABS_SPSP_FATSAT_LOW_B1;
        ext_effwidth  = _ext_effwidth.fixedflag ?  ((void)(SAR_EFFWIDTH_SPSP_FATSAT_LOW_B1), ext_effwidth) : SAR_EFFWIDTH_SPSP_FATSAT_LOW_B1;
        ext_area  = _ext_area.fixedflag ?  ((void)(SAR_AREA_SPSP_FATSAT_LOW_B1), ext_area) : SAR_AREA_SPSP_FATSAT_LOW_B1;
        ext_dtycyc  = _ext_dtycyc.fixedflag ?  ((void)(SAR_DTYCYC_SPSP_FATSAT_LOW_B1), ext_dtycyc) : SAR_DTYCYC_SPSP_FATSAT_LOW_B1;
        ext_maxpw  = _ext_maxpw.fixedflag ?  ((void)(SAR_MAXPW_SPSP_FATSAT_LOW_B1), ext_maxpw) : SAR_MAXPW_SPSP_FATSAT_LOW_B1;
        ext_max_b1  = _ext_max_b1.fixedflag ?  ((void)(SAR_MAX_B1_SPSP_FATSAT_LOW_B1), ext_max_b1) : SAR_MAX_B1_SPSP_FATSAT_LOW_B1;
        ext_max_int_b1_sq  = _ext_max_int_b1_sq.fixedflag ?  ((void)(SAR_MAX_INT_B1_SQ_SPSP_FATSAT_LOW_B1), ext_max_int_b1_sq) : SAR_MAX_INT_B1_SQ_SPSP_FATSAT_LOW_B1;
        ext_max_rms_b1  = _ext_max_rms_b1.fixedflag ?  ((void)(SAR_MAX_RMS_B1_SPSP_FATSAT_LOW_B1), ext_max_rms_b1) : SAR_MAX_RMS_B1_SPSP_FATSAT_LOW_B1;
        ext_nom_fa  = _ext_nom_fa.fixedflag ?  ((void)(SAR_NOM_FA_SPSP_FATSAT_LOW_B1), ext_nom_fa) : SAR_NOM_FA_SPSP_FATSAT_LOW_B1;
        ext_nom_pw  = _ext_nom_pw.fixedflag ?  ((void)(SAR_NOM_PW_SPSP_FATSAT_LOW_B1), ext_nom_pw) : SAR_NOM_PW_SPSP_FATSAT_LOW_B1;
        ext_nom_bw  = _ext_nom_bw.fixedflag ?  ((void)(SAR_NOM_BW_SPSP_FATSAT_LOW_B1), ext_nom_bw) : SAR_NOM_BW_SPSP_FATSAT_LOW_B1;
        ext_gzrfcssat_scale_fac  = _ext_gzrfcssat_scale_fac.fixedflag ?  ((void)(GZSCALEFAC_SPSP_FATSAT_LOW_B1), ext_gzrfcssat_scale_fac) : GZSCALEFAC_SPSP_FATSAT_LOW_B1;
        ext_fatsat_min_slthick  = _ext_fatsat_min_slthick.fixedflag ?  ((void)(MINSLTHICK_SPSP_FATSAT_LOW_B1), ext_fatsat_min_slthick) : MINSLTHICK_SPSP_FATSAT_LOW_B1;    	
    }
    else if ((act_b1_ultralow <= max_b1_limit && 0 == spsp_fatsat_pulse_override) || (4 == spsp_fatsat_pulse_override))
    /* High, medium, and low amplitude pulses both violate max B1, but ultralow amplitude pulse can be used */
    {
        strcpy(ext_spsp_fatsat_rf_filename, RFFILENAME_SPSP_FATSAT_ULTRALOW_B1);
        strcpy(ext_spsp_fatsat_gz_filename, GRADFILENAME_SPSP_FATSAT_ULTRALOW_B1);
  	    ext_pw_rfcssat  = _ext_pw_rfcssat.fixedflag ?  ((void)(PW_SPSP_FATSAT_ULTRALOW_B1), ext_pw_rfcssat) : PW_SPSP_FATSAT_ULTRALOW_B1;
        ext_res_rfcssat  = _ext_res_rfcssat.fixedflag ?  ((void)(RES_SPSP_FATSAT_ULTRALOW_B1), ext_res_rfcssat) : RES_SPSP_FATSAT_ULTRALOW_B1;
        ext_isodelay  = _ext_isodelay.fixedflag ?  ((void)(ISODELAY_SPSP_FATSAT_ULTRALOW_B1), ext_isodelay) : ISODELAY_SPSP_FATSAT_ULTRALOW_B1;
        ext_water_freq_flag  = _ext_water_freq_flag.fixedflag ?  ((void)(WATERFREQ_SPSP_FATSAT_ULTRALOW_B1), ext_water_freq_flag) : WATERFREQ_SPSP_FATSAT_ULTRALOW_B1;
        ext_pw_grad_sub_lobe  = _ext_pw_grad_sub_lobe.fixedflag ?  ((void)(GRADSUBLOBE_SPSP_FATSAT_ULTRALOW_B1), ext_pw_grad_sub_lobe) : GRADSUBLOBE_SPSP_FATSAT_ULTRALOW_B1;
        ext_pw_grad_sub_lobe_ramp  = _ext_pw_grad_sub_lobe_ramp.fixedflag ?  ((void)(GRADSUBLOBERAMP_SPSP_FATSAT_ULTRALOW_B1), ext_pw_grad_sub_lobe_ramp) : GRADSUBLOBERAMP_SPSP_FATSAT_ULTRALOW_B1;
        ext_num_grad_sub_lobe  = _ext_num_grad_sub_lobe.fixedflag ?  ((void)(SUBLOBENUMBER_SPSP_FATSAT_ULTRALOW_B1), ext_num_grad_sub_lobe) : SUBLOBENUMBER_SPSP_FATSAT_ULTRALOW_B1;
        ext_pw_grad_sub_lobe_norf  = _ext_pw_grad_sub_lobe_norf.fixedflag ?  ((void)(GRADSUBLOBENORF_SPSP_FATSAT_ULTRALOW_B1), ext_pw_grad_sub_lobe_norf) : GRADSUBLOBENORF_SPSP_FATSAT_ULTRALOW_B1;
        ext_pw_grad_sub_lobe_ramp_norf  = _ext_pw_grad_sub_lobe_ramp_norf.fixedflag ?  ((void)(GRADSUBLOBENORFRAMP_SPSP_FATSAT_ULTRALOW_B1), ext_pw_grad_sub_lobe_ramp_norf) : GRADSUBLOBENORFRAMP_SPSP_FATSAT_ULTRALOW_B1;
        ext_num_grad_sub_lobe_norf  = _ext_num_grad_sub_lobe_norf.fixedflag ?  ((void)(SUBLOBENORFNUMBER_SPSP_FATSAT_ULTRALOW_B1), ext_num_grad_sub_lobe_norf) : SUBLOBENORFNUMBER_SPSP_FATSAT_ULTRALOW_B1;
        ext_abswidth  = _ext_abswidth.fixedflag ?  ((void)(SAR_ABS_SPSP_FATSAT_ULTRALOW_B1), ext_abswidth) : SAR_ABS_SPSP_FATSAT_ULTRALOW_B1;
        ext_effwidth  = _ext_effwidth.fixedflag ?  ((void)(SAR_EFFWIDTH_SPSP_FATSAT_ULTRALOW_B1), ext_effwidth) : SAR_EFFWIDTH_SPSP_FATSAT_ULTRALOW_B1;
        ext_area  = _ext_area.fixedflag ?  ((void)(SAR_AREA_SPSP_FATSAT_ULTRALOW_B1), ext_area) : SAR_AREA_SPSP_FATSAT_ULTRALOW_B1;
        ext_dtycyc  = _ext_dtycyc.fixedflag ?  ((void)(SAR_DTYCYC_SPSP_FATSAT_ULTRALOW_B1), ext_dtycyc) : SAR_DTYCYC_SPSP_FATSAT_ULTRALOW_B1;
        ext_maxpw  = _ext_maxpw.fixedflag ?  ((void)(SAR_MAXPW_SPSP_FATSAT_ULTRALOW_B1), ext_maxpw) : SAR_MAXPW_SPSP_FATSAT_ULTRALOW_B1;
        ext_max_b1  = _ext_max_b1.fixedflag ?  ((void)(SAR_MAX_B1_SPSP_FATSAT_ULTRALOW_B1), ext_max_b1) : SAR_MAX_B1_SPSP_FATSAT_ULTRALOW_B1;
        ext_max_int_b1_sq  = _ext_max_int_b1_sq.fixedflag ?  ((void)(SAR_MAX_INT_B1_SQ_SPSP_FATSAT_ULTRALOW_B1), ext_max_int_b1_sq) : SAR_MAX_INT_B1_SQ_SPSP_FATSAT_ULTRALOW_B1;
        ext_max_rms_b1  = _ext_max_rms_b1.fixedflag ?  ((void)(SAR_MAX_RMS_B1_SPSP_FATSAT_ULTRALOW_B1), ext_max_rms_b1) : SAR_MAX_RMS_B1_SPSP_FATSAT_ULTRALOW_B1;
        ext_nom_fa  = _ext_nom_fa.fixedflag ?  ((void)(SAR_NOM_FA_SPSP_FATSAT_ULTRALOW_B1), ext_nom_fa) : SAR_NOM_FA_SPSP_FATSAT_ULTRALOW_B1;
        ext_nom_pw  = _ext_nom_pw.fixedflag ?  ((void)(SAR_NOM_PW_SPSP_FATSAT_ULTRALOW_B1), ext_nom_pw) : SAR_NOM_PW_SPSP_FATSAT_ULTRALOW_B1;
        ext_nom_bw  = _ext_nom_bw.fixedflag ?  ((void)(SAR_NOM_BW_SPSP_FATSAT_ULTRALOW_B1), ext_nom_bw) : SAR_NOM_BW_SPSP_FATSAT_ULTRALOW_B1;
        ext_gzrfcssat_scale_fac  = _ext_gzrfcssat_scale_fac.fixedflag ?  ((void)(GZSCALEFAC_SPSP_FATSAT_ULTRALOW_B1), ext_gzrfcssat_scale_fac) : GZSCALEFAC_SPSP_FATSAT_ULTRALOW_B1;
        ext_fatsat_min_slthick  = _ext_fatsat_min_slthick.fixedflag ?  ((void)(MINSLTHICK_SPSP_FATSAT_ULTRALOW_B1), ext_fatsat_min_slthick) : MINSLTHICK_SPSP_FATSAT_ULTRALOW_B1;    	
    }
    else    /* No pulse satisfies the maximum B1 limit */
    {
        epic_error(use_ermes, "%s failed in ChemSatEval",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"SelectSpSpFatSatPulse");
        return FAILURE;
    }
    	      	
    return SUCCESS;
}

STATUS 
ChemSatEval( INT *time_cssat )
{
    FLOAT target_amp_x, target_amp_y, target_amp_z;
    INT csxkiller_flag, cszkiller_flag;
#ifdef CSYKILLERA
    INT csyakiller_flag;
#endif /* CSYKILLERA */

    if(cfpwrmontyp == PMTYP_VMX) {
        csat_sys_type  = _csat_sys_type.fixedflag ?  ((void)(1), csat_sys_type) : 1;
        rfupa = csat_rfupa;
    }

    fatFlag  = _fatFlag.fixedflag ?  ((void)(PSD_OFF), fatFlag) : PSD_OFF;

    if ( exist (opfat) || exist (opfatcl) || exist (opspecir) ) { 
        fatFlag  = _fatFlag.fixedflag ?  ((void)(PSD_ON), fatFlag) : PSD_ON;
    } 

    /* pulse widths need to be set up in ChemSatEval to allow for 
       possible pulse type switching */

    /* ****************************************************** *
     * Added to support the change of the rf flip angle setup *
     * the actual flip angle of the ChemSat RF pulse, SGT     *
     * ****************************************************** */
    if (cffield == B0_15000) {
/* FATSAT FACTOR addition - HH June 2005 */
        flip_sat  = _flip_sat.fixedflag ?    ((void)(OVERDRIVE_FA_1_5T*acos(1.0-fatsat_factor)/acos(0.0)), flip_sat) : OVERDRIVE_FA_1_5T*acos(1.0-fatsat_factor)/acos(0.0);
        flip_satcfh  = _flip_satcfh.fixedflag ?  ((void)(OVERDRIVE_FA_1_5T), flip_satcfh) : OVERDRIVE_FA_1_5T;
    } else if (cffield == B0_10000) {
        flip_sat  = _flip_sat.fixedflag ?  ((void)(OVERDRIVE_FA_1_0T), flip_sat) : OVERDRIVE_FA_1_0T;
        flip_satcfh  = _flip_satcfh.fixedflag ?  ((void)(OVERDRIVE_FA_1_0T), flip_satcfh) : OVERDRIVE_FA_1_0T;
    } else if (cffield==B0_2000 || cffield==B0_5000 || cffield == B0_3500) { /* MFO,Hino, Feb/02/00 MM */
        flip_sat  = _flip_sat.fixedflag ?  ((void)(OVERDRIVE_FA_0_5T), flip_sat) : OVERDRIVE_FA_0_5T;
        flip_satcfh  = _flip_satcfh.fixedflag ?  ((void)(OVERDRIVE_FA_0_5T), flip_satcfh) : OVERDRIVE_FA_0_5T;
    } else if (cffield == B0_40000) {
        /* REDFLAG : Using 1.5 T values (CHANGE !!!) */
        flip_sat  = _flip_sat.fixedflag ?  ((void)(OVERDRIVE_FA_4_0T), flip_sat) : OVERDRIVE_FA_4_0T;
        flip_satcfh  = _flip_satcfh.fixedflag ?  ((void)(OVERDRIVE_FA_4_0T), flip_satcfh) : OVERDRIVE_FA_4_0T;
        DEBUG_4_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
    } else if (cffield == B0_30000) {
        /* REDFLAG : Using 1.5 T values (CHANGE !!!) */
/* FATSAT FACTOR addition - HH June 2005 */
        flip_sat  = _flip_sat.fixedflag ?    ((void)(OVERDRIVE_FA_3_0T*acos(1.0-fatsat_factor)/acos(0.0)), flip_sat) : OVERDRIVE_FA_3_0T*acos(1.0-fatsat_factor)/acos(0.0);
        flip_satcfh  = _flip_satcfh.fixedflag ?  ((void)(OVERDRIVE_FA_3_0T), flip_satcfh) : OVERDRIVE_FA_3_0T;
        DEBUG_3_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
    } else if (cffield == B0_7000) {
        flip_sat  = _flip_sat.fixedflag ?  ((void)(OVERDRIVE_FA_0_7T), flip_sat) : OVERDRIVE_FA_0_7T;
        flip_satcfh  = _flip_satcfh.fixedflag ?  ((void)(OVERDRIVE_FA_0_7T), flip_satcfh) : OVERDRIVE_FA_0_7T;
        DEBUG_0_7(SD_PSD_SUPPORT,__FILE__,__LINE__);
    } else {
        SDL_PrintFStrengthWarning(SD_PSD_SUPPORT,cffield,__FILE__,__LINE__);
    }

    /* MRIge46643. The new optimized fat sat recalculates 
       the optimal flip angle for the chemsat pulse in ChemSatFlip.
       In cases where the sequence is limited by SAR (eg. ssfse), we need to
       over-estimate the flip angle before calculating the maxseqsar time  
       such that the actual SAR calculated in powermon_b1scale  
       never exceeds the safety limit. See SPR for details.
       - PRA/RJF 26May99 */

    /* Note, the condition must also check that it is not water suppression */ 
    /* flip_sat is initialized to 180.0 for new chemsat only, not for classic */
    /* MRIge85932 : Added oppseq in the logic to ensure only Spin Echo scans
       set flip_sat to 180. Gradient Echo scans do not have the new chemsat */

    if ( (exist(oppseq) == PSD_SE) && (exist(opfat) == PSD_ON) && (exist(opepi) == PSD_OFF) ) { 
        flip_sat  = _flip_sat.fixedflag ?   ((void)(180.0), flip_sat) : 180.0; 
    } 
 
    if( (cffield == B0_5000) || (cffield == B0_2000) || (cffield == B0_3500)) {
        ChemSatPulse  = _ChemSatPulse.fixedflag ?  ((void)(CSMIN8_PULSE), ChemSatPulse) : CSMIN8_PULSE;
    } else if(cffield > B0_15000) {
        ChemSatPulse  = _ChemSatPulse.fixedflag ?  ((void)(CS3T_PULSE), ChemSatPulse) : CS3T_PULSE;		/*3T/4T default *YH*/
    	if (PSD_ON == use_spsp_fatsat && cffield == B0_30000)
    	    ChemSatPulse  = _ChemSatPulse.fixedflag ?  ((void)(SPSP_FATSAT_PULSE), ChemSatPulse) : SPSP_FATSAT_PULSE;
    } else {
        ChemSatPulse  = _ChemSatPulse.fixedflag ?  ((void)(CSM_PULSE), ChemSatPulse) : CSM_PULSE;
    }

    /* MRIhc26321 */ 
    /* AMR - FOR MRIhc27960 */
    if( (cffield >= B0_15000) && ( (PSD_ON == exist(opfatcl)) || (PSD_ON == exist(opfat)) )
        && (PSD_ON == exist(opcube)) )
    {
        aspir_flag  = _aspir_flag.fixedflag ?  ((void)(PSD_ON), aspir_flag) : PSD_ON;
    }
    else if ((cffield >= B0_15000) && (PSD_ON==exist(opspecir)))
    {
        aspir_flag  = _aspir_flag.fixedflag ?  ((void)(PSD_ON), aspir_flag) : PSD_ON;
    }
    else
    {
        aspir_flag  = _aspir_flag.fixedflag ?  ((void)(PSD_OFF), aspir_flag) : PSD_OFF;
    }

    if( (((opweight > 150) && (PSD_XRMB_COIL != cfgcoiltype && PSD_XRMW_COIL != cfgcoiltype)) 
        || ((opweight > 215) && (PSD_XRMB_COIL == cfgcoiltype || PSD_XRMW_COIL == cfgcoiltype)))
        && (cffield >= B0_30000) && (TX_COIL_BODY == getTxCoilType()) && (aspir_flag == 1))
    {
        aspir_fa_scaling_flag  = _aspir_fa_scaling_flag.fixedflag ?  ((void)(PSD_ON), aspir_fa_scaling_flag) : PSD_ON;
    }
    else
    {
        aspir_fa_scaling_flag  = _aspir_fa_scaling_flag.fixedflag ?  ((void)(PSD_OFF), aspir_fa_scaling_flag) : PSD_OFF;
    }

    if((cfrfmpwh < 20000) && (cfrfmpwb < 20000))
        aspir_flag  = _aspir_flag.fixedflag ?  ((void)(PSD_OFF), aspir_flag) : PSD_OFF;

    if(aspir_flag)
    {
       flip_sat  = _flip_sat.fixedflag ?  ((void)(180), flip_sat) : 180;
       flip_satcfh  = _flip_satcfh.fixedflag ?  ((void)(180), flip_satcfh) : 180;
       if ((cfrfmpwh>=40000) && (cfrfmpwb>=40000))
       {
           ChemSatPulse  = _ChemSatPulse.fixedflag ?  ((void)(CS_HS), ChemSatPulse) : CS_HS;  /* 40ms */
       }
       else if ((cfrfmpwh>=20000) && (cfrfmpwb>=20000))
       {   
           ChemSatPulse  = _ChemSatPulse.fixedflag ?  ((void)(CS_HS_20MS), ChemSatPulse) : CS_HS_20MS;
       }
       else
       {
          epic_error(use_ermes, "%s is incompatible with %s",
                     EM_PSD_INCOMPATIBLE, EE_ARGS(2), 
                     STRING_ARG, "ASPIR",
                     STRING_ARG, "the RF amplifier");
          return FAILURE;
       }
    } 
    /* AMR - FOR MRIhc27960 */
    else
    {
        aspir_cfoffset  = _aspir_cfoffset.fixedflag ?  ((void)(0), aspir_cfoffset) : 0;
        aspir_delay     = _aspir_delay.fixedflag ?  ((void)(0), aspir_delay) : 0;
    }
   
    /* FEC : Exploiting linear relationship with field Strength */

    fStrength = _fStrength.fixedflag ? ((void)(cffield), fStrength) : cffield;
    if (cffield==B0_2000) {
        fStrength = _fStrength.fixedflag ? ((void)(B0_5000), fStrength) : B0_5000;      /* ChemSat is not done in 0.2T systems !!! */
    }

    switch(ChemSatPulse)
    {
    case SINC_PULSE:
    default:
        switch((int ) cffield) {
        case B0_5000:
        case B0_3500: /* MFO,Hino, Feb/02/00 MM */
        case B0_2000:
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(600), res_rfcssat) : 600;
            break;
        case B0_15000:
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(200), res_rfcssat) : 200; /* default 1.5T value */
            break;
        case B0_10000:
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(300), res_rfcssat) : 300;
            break;
        case B0_40000:
            /* REDFLAG : Using same value as 1.5T. */
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(200), res_rfcssat) : 200; 
            DEBUG_4_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
            break;
        case B0_30000:
            /* REDFLAG : Using same value as 1.5T. */
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(200), res_rfcssat) : 200; 
            DEBUG_3_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
            break;
        case B0_7000:
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(300), res_rfcssat) : 300;
            DEBUG_0_7(SD_PSD_SUPPORT,__FILE__,__LINE__);
            break;
        default:
            SDL_PrintFStrengthWarning(SD_PSD_SUPPORT,cffield,__FILE__,__LINE__);
        }
        pw_rfcssat  = _pw_rfcssat.fixedflag ?   ((void)(RNEAREST_RF((int)(FS_SCALEUP(fStrength)*16000),res_rfcssat)), pw_rfcssat) : RNEAREST_RF((int)(FS_SCALEUP(fStrength)*16000),res_rfcssat);
        cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(RDN_RF((pw_rfcssat>>1))), cs_isodelay) : RDN_RF((pw_rfcssat>>1));         /* Divide by 2 */

        break;

    case CSM_PULSE:

        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFCSM), res_rfcssat) : RES_RFCSM;
        pw_rfcssat   = _pw_rfcssat.fixedflag ?   ((void)(RNEAREST_RF((int)(FS_SCALEUP(fStrength)*16000),res_rfcssat)), pw_rfcssat) : RNEAREST_RF((int)(FS_SCALEUP(fStrength)*16000),res_rfcssat);
        cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(RDN_RF((int)(pw_rfcssat/(3.16957)))), cs_isodelay) : RDN_RF((int)(pw_rfcssat/(3.16957)));

        break;


    /* SPSP fat sat pulse */
    case SPSP_FATSAT_PULSE:	    	  

        if (FAILURE == SelectSpSpFatSatPulse()) {
          epic_error(use_ermes, "%s failed in ChemSatEval",
                     EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"SelectSpSpFatSatPulse");
          return FAILURE;
        }
        
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(ext_res_rfcssat), res_rfcssat) : ext_res_rfcssat;  /* *rfpulse[RFCSSAT_SLOT].res */
        pw_rfcssat  = _pw_rfcssat.fixedflag ?  ((void)(ext_pw_rfcssat), pw_rfcssat) : ext_pw_rfcssat;  /* *rfpulse[RFCSSAT_SLOT].pw */

        pw_gzrfcssat  = _pw_gzrfcssat.fixedflag ?  ((void)(pw_rfcssat), pw_gzrfcssat) : pw_rfcssat;
        res_gzrfcssat  = _res_gzrfcssat.fixedflag ?  ((void)(res_rfcssat), res_gzrfcssat) : res_rfcssat;

        a_thetarfcssat  = _a_thetarfcssat.fixedflag ?  ((void)(0), a_thetarfcssat) : 0;
        pw_thetarfcssat  = _pw_thetarfcssat.fixedflag ?  ((void)(pw_rfcssat), pw_thetarfcssat) : pw_rfcssat;
        res_thetarfcssat  = _res_thetarfcssat.fixedflag ?  ((void)(res_rfcssat), res_thetarfcssat) : res_rfcssat;
        bw_rfcssat  = _bw_rfcssat.fixedflag ?  ((void)(rfpulse[RFCSSAT_SLOT].nom_bw*rfpulse[RFCSSAT_SLOT].nom_pw/pw_rfcssat), bw_rfcssat) : rfpulse[RFCSSAT_SLOT].nom_bw*rfpulse[RFCSSAT_SLOT].nom_pw/pw_rfcssat;
        spsp_fatsat_slthick  = _spsp_fatsat_slthick.fixedflag ?    ((void)(FMax(2,ext_fatsat_min_slthick,2.0*exist(opslthick))), spsp_fatsat_slthick) : FMax(2,ext_fatsat_min_slthick,2.0*exist(opslthick));
        if (cffield == B0_30000 && cfsrmode == PSD_SR77)
        {
            spsp_fatsat_slthick  = _spsp_fatsat_slthick.fixedflag ?    ((void)(FMax(2,spsp_fatsat_slthick,40.0)), spsp_fatsat_slthick) : FMax(2,spsp_fatsat_slthick,40.0);
        }

        if (ampslice(_a_gzrfcssat.fixedflag ? (_temp651_a_gzrfcssat=a_gzrfcssat,&_temp651_a_gzrfcssat) : &a_gzrfcssat, bw_rfcssat, spsp_fatsat_slthick, 1.0, TYPDEF) == FAILURE)
        {
          epic_error(use_ermes, "%s failed for gzrfcssat", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "ampslice");
          return FAILURE;
        }

        a_gzrfcssat_wrf  = _a_gzrfcssat_wrf.fixedflag ?  ((void)(a_gzrfcssat), a_gzrfcssat_wrf) : a_gzrfcssat;
        /* When rewinder gradient has a higher amplitude than the RF gradient 
           lobe, we need this extra scaling factor */
        a_gzrfcssat  = _a_gzrfcssat.fixedflag ?  ((void)(a_gzrfcssat*ext_gzrfcssat_scale_fac), a_gzrfcssat) : a_gzrfcssat*ext_gzrfcssat_scale_fac;
        a_thetarfcssat  = _a_thetarfcssat.fixedflag ?  ((void)(a_gzrfcssat), a_thetarfcssat) : a_gzrfcssat;

        if (debug_spsp_fatsat)
        {
            FILE * debug_file_ptr;
            debug_file_ptr = fopen("/usr/g/service/log/dbgdata_bw_rfcssat", "w");

            if (NULL != debug_file_ptr)
            {
                fprintf(debug_file_ptr, "nom_bw = %f Hz\nnom_pw = %f us\npw_rfcssat = %d us\n"
                        "bw_rfcssat = %d Hz\nslice thickness for rfcssat = %f mm\n", 
                        rfpulse[RFCSSAT_SLOT].nom_bw, rfpulse[RFCSSAT_SLOT].nom_pw, 
                        pw_rfcssat, bw_rfcssat, spsp_fatsat_slthick);
                fclose(debug_file_ptr);
            }
        }

        ia_gzrfcssat  = _ia_gzrfcssat.fixedflag ?     ((void)(a_gzrfcssat*max_pg_iamp/loggrd.tz), ia_gzrfcssat) : a_gzrfcssat*max_pg_iamp/loggrd.tz; 
        ia_thetarfcssat  = _ia_thetarfcssat.fixedflag ?      ((void)(a_thetarfcssat*max_pg_iamp/loggrd.tz), ia_thetarfcssat) : a_thetarfcssat*max_pg_iamp/loggrd.tz; 

        break;
        
    case CSMIN8_PULSE:

        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFCSMIN8), res_rfcssat) : RES_RFCSMIN8;
        pw_rfcssat   = _pw_rfcssat.fixedflag ?   ((void)(RNEAREST_RF((int)(FS_SCALEUP(fStrength)*8000),res_rfcssat)), pw_rfcssat) : RNEAREST_RF((int)(FS_SCALEUP(fStrength)*8000),res_rfcssat);
        cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(RDN_RF((int)(pw_rfcssat/(1.8957346)))), cs_isodelay) : RDN_RF((int)(pw_rfcssat/(1.8957346)));

        break;

    case CSMAX8_PULSE:

        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFCSMAX8), res_rfcssat) : RES_RFCSMAX8;
        pw_rfcssat   = _pw_rfcssat.fixedflag ?   ((void)(RNEAREST_RF((int)(FS_SCALEUP(fStrength)*8000),res_rfcssat)), pw_rfcssat) : RNEAREST_RF((int)(FS_SCALEUP(fStrength)*8000),res_rfcssat);
        cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(RDN_RF((int)(pw_rfcssat/(1.7857143)))), cs_isodelay) : RDN_RF((int)(pw_rfcssat/(1.7857143)));

        break;

    case CS3T_PULSE:				/*new pulse for 3T/4T	*YH*/

        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFCS3T), res_rfcssat) : RES_RFCS3T;	/*200*/
        pw_rfcssat   = _pw_rfcssat.fixedflag ?  ((void)(RNEAREST_RF((int)(FS_SCALEUP(fStrength)*16000),res_rfcssat*4)), pw_rfcssat) : RNEAREST_RF((int)(FS_SCALEUP(fStrength)*16000),res_rfcssat*4);
        cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(RDN_RF((pw_rfcssat>>1))), cs_isodelay) : RDN_RF((pw_rfcssat>>1));         /* Divide by 2 */

        break;

    case CS_HS:
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFHS), res_rfcssat) : RES_RFHS;
        pw_rfcssat  = _pw_rfcssat.fixedflag ?  ((void)(NOM_PW_HS), pw_rfcssat) : NOM_PW_HS;
        cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(RDN_RF(pw_rfcssat>>1)), cs_isodelay) : RDN_RF(pw_rfcssat>>1);
        res_omega_hs_rfcssat  = _res_omega_hs_rfcssat.fixedflag ?  ((void)(RES_RFHS), res_omega_hs_rfcssat) : RES_RFHS;
        pw_omega_hs_rfcssat  = _pw_omega_hs_rfcssat.fixedflag ?  ((void)(pw_rfcssat), pw_omega_hs_rfcssat) : pw_rfcssat;
        a_omega_hs_rfcssat  = _a_omega_hs_rfcssat.fixedflag ?  ((void)(-1.0), a_omega_hs_rfcssat) : -1.0;
        ia_omega_hs_rfcssat  = _ia_omega_hs_rfcssat.fixedflag ?  ((void)(-max_pg_iamp), ia_omega_hs_rfcssat) : -max_pg_iamp;
        break;

    case CS_HS_20MS:
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFHS_20MS), res_rfcssat) : RES_RFHS_20MS;
        pw_rfcssat  = _pw_rfcssat.fixedflag ?  ((void)(NOM_PW_HS_20MS), pw_rfcssat) : NOM_PW_HS_20MS;
        cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(RDN_RF(pw_rfcssat>>1)), cs_isodelay) : RDN_RF(pw_rfcssat>>1);
        res_omega_hs_rfcssat  = _res_omega_hs_rfcssat.fixedflag ?  ((void)(RES_RFHS_20MS), res_omega_hs_rfcssat) : RES_RFHS_20MS;
        pw_omega_hs_rfcssat  = _pw_omega_hs_rfcssat.fixedflag ?  ((void)(pw_rfcssat), pw_omega_hs_rfcssat) : pw_rfcssat;
        a_omega_hs_rfcssat  = _a_omega_hs_rfcssat.fixedflag ?  ((void)(-1.0), a_omega_hs_rfcssat) : -1.0;
        ia_omega_hs_rfcssat  = _ia_omega_hs_rfcssat.fixedflag ?  ((void)(-max_pg_iamp), ia_omega_hs_rfcssat) : -max_pg_iamp;
        break;
    }
    pw_rfcssatcfh  = _pw_rfcssatcfh.fixedflag ?  ((void)(pw_rfcssat), pw_rfcssatcfh) : pw_rfcssat;  /* MRIhc06663: set cfh cssat pulse */

    if (PSD_ON ==  selectiveChemsat)
    {
        /* empirically determined to have optimum IQ benefit to minimize
         * MT effect and still ensure adequate FAT suppression. Used
         * with 3dtof */ 
        if (cffield == B0_30000)
            bw_rfchemsat  = _bw_rfchemsat.fixedflag ?  ((void)(200), bw_rfchemsat) : 200;
        else
            bw_rfchemsat  = _bw_rfchemsat.fixedflag ?  ((void)(100), bw_rfchemsat) : 100;
        pw_gzrfcs  = _pw_gzrfcs.fixedflag ?  ((void)(pw_rfcssat), pw_gzrfcs) : pw_rfcssat;

       if (ampslice(_a_gzrfcs.fixedflag ? (_temp652_a_gzrfcs=a_gzrfcs,&_temp652_a_gzrfcs) : &a_gzrfcs, bw_rfchemsat, numSlabs*opvthick, 1.0, TYPDEF) == FAILURE)
       {
          epic_error(use_ermes, "%s failed for gzrfcssat", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "ampslice");
          return FAILURE;
       }
       pw_gzrfcsa  = _pw_gzrfcsa.fixedflag ?    ((void)(RUP_GRD((int)((loggrd.zrt)/(loggrd.zfs)*a_gzrfcs))), pw_gzrfcsa) : RUP_GRD((int)((loggrd.zrt)/(loggrd.zfs)*a_gzrfcs));
       if (pw_gzrfcsa < MIN_PLATEAU_TIME)
          pw_gzrfcsa  = _pw_gzrfcsa.fixedflag ?  ((void)(MIN_PLATEAU_TIME), pw_gzrfcsa) : MIN_PLATEAU_TIME; 
       pw_gzrfcsd  = _pw_gzrfcsd.fixedflag ?  ((void)(pw_gzrfcsa), pw_gzrfcsd) : pw_gzrfcsa;
    }
    else
    {
      pw_gzrfcsa  = _pw_gzrfcsa.fixedflag ?  ((void)(0), pw_gzrfcsa) : 0;
      pw_gzrfcsd  = _pw_gzrfcsd.fixedflag ?  ((void)(0), pw_gzrfcsd) : 0;
      a_gzrfcs  = _a_gzrfcs.fixedflag ?  ((void)(0.0), a_gzrfcs) : 0.0;
      pw_gzrfcs  = _pw_gzrfcs.fixedflag ?  ((void)(0), pw_gzrfcs) : 0;

    }
    /* Exception for 0.2T and 0.5T field Strengths */
    /* MFO,Hino, Feb/02/00 MM */
    if ((ChemSatPulse==CSMIN8_PULSE) && (cffield==B0_2000 || cffield==B0_5000 || cffield==B0_3500)) {
        if ( (((exist(oppseq)==PSD_GE)||(exist(oppseq)==PSD_SPGR)) &&
              ((exist(opfast)==PSD_ON) || (exist(opimode)==PSD_3D))) ||
             (((exist(oppseq)==PSD_TOF)||(exist(oppseq)==PSD_TOFSP)) &&
              (exist(opimode)==PSD_3D)) ) {
            pw_rfcssat  = _pw_rfcssat.fixedflag ?  ((void)(16000), pw_rfcssat) : 16000;
            cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(8440), cs_isodelay) : 8440;
            pw_rfcssatcfh  = _pw_rfcssatcfh.fixedflag ?  ((void)(16000), pw_rfcssatcfh) : 16000;
        }
    }

	
    if ( (PSD_ON == fatFlag) || (exist(opwater) == PSD_ON)) {

        csxkiller_flag=cszkiller_flag=0;
        area_gxkcs = _area_gxkcs.fixedflag ? ((void)(3450), area_gxkcs) : 3450;
        area_gykcs = _area_gykcs.fixedflag ? ((void)(3220), area_gykcs) : 3220;

	/* need more crusher for ASPIR when combined with spatial sats : RFB 23-Jan-07 */
        if (aspir_flag)
            area_gykcs = _area_gykcs.fixedflag ? ((void)(6440), area_gykcs) : 6440;

#ifdef  ADDYCRUSHER

        /*  Increase the area of gykcs for high resolution 
            fsemaster or SE scans. AC, MRIge83262 */

        if((PSD_SE == exist(oppseq)) && (PSD_ON == fatFlag)) { 

            /* If the area of gy1 trapezoid is large compare to area_gykcs,
               we need to set the area of gykcs fat sat killer pulse to %20
               more of gy1 area (area_gykcs= 1.2 * area_gy1grad). Relevant SPRs:
               MRIge79885 (9.2) and MRIge79887(mgd).  AC */

            float area_gy1gradse = 0.0;

            area_gy1gradse = fabs(((a_gy1a + a_gy1b) * pw_gy1a/2.0)+ ((a_gy1a + a_gy1b)/2.0)*pw_gy1);

            if (area_gykcs < (1.2 * area_gy1gradse)) {
                area_gykcs = _area_gykcs.fixedflag ?    ((void)(1.2*area_gy1gradse), area_gykcs) : 1.2*area_gy1gradse;
            }
        }

#endif

        area_gyakcs = _area_gyakcs.fixedflag ? ((void)(2470), area_gyakcs) : 2470;
        area_gzkcs = _area_gzkcs.fixedflag ? ((void)(3450), area_gzkcs) : 3450;
        target_amp_x = 0.0;
        target_amp_y = loggrd.ty/csk_derate_factor;
        target_amp_z = 0.0;

#ifdef CSXKILLER
    	csxkiller_flag=1;
#endif

#ifdef CSZKILLER
    	cszkiller_flag=1;
#endif

#ifdef CSYKILLERA
    	csyakiller_flag=1;
#endif
	
        if( (csxkiller_flag==1) && (cszkiller_flag==0) ) 
        {
            target_amp_x = loggrd.tx_xy/csk_derate_factor;
            target_amp_y = loggrd.ty_xy/csk_derate_factor;
        }

        if( (csxkiller_flag==0) && (cszkiller_flag==1) ) 
        {
            target_amp_y = loggrd.ty_yz/csk_derate_factor;
            target_amp_z = loggrd.tz_yz/csk_derate_factor;
        }

        if( (csxkiller_flag==1) && (cszkiller_flag==1) ) 
        {
            target_amp_x = loggrd.tx_xyz/csk_derate_factor;
            target_amp_y = loggrd.ty_xyz/csk_derate_factor;
            target_amp_z = loggrd.tz_xyz/csk_derate_factor;
        }

        if ((amppwgradmethod(&grady[GYKCS_SLOT], area_gykcs, target_amp_y,
                             0.0, 0.0,loggrd.yrt*csk_derate_factor,
                             MIN_PLATEAU_TIME))==FAILURE) {
            epic_error(use_ermes, "%s failed in ChemSatEval",
                       EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"amppwgradmethod:gykcs");
            return FAILURE;
        }
 
        grady[GYKCS_SLOT].num = 1;
        grady[GYKCS_SLOT].powscale = loggrd.yfs/target_amp_y;
 
 
#ifdef CSXKILLER
         
        if ((amppwgradmethod(&gradx[GXKCS_SLOT], area_gxkcs, target_amp_x,
                             0.0, 0.0,loggrd.xrt*csk_derate_factor,
                             MIN_PLATEAU_TIME))==FAILURE) {
            epic_error(use_ermes, "%s failed in ChemSatEval",
                       EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"amppwgradmethod:gxkcs");
            return FAILURE;
        }

        gradx[GXKCS_SLOT].num = 1;
        gradx[GXKCS_SLOT].powscale = loggrd.xfs/target_amp_x;  /*  QT*/

#endif

#ifdef CSYKILLERA
        
        if ((amppwgradmethod(&grady[GYKCS_SLOT], area_gyakcs, target_amp_y,
                             0.0, 0.0,loggrd.yrt*csk_derate_factor,
                             MIN_PLATEAU_TIME)) == FAILURE) {
            epic_error(use_ermes, "%s failed in ChemSatEval",
                       EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,
                       "amppwgradmethod:gyakcs");
            return FAILURE;
        }
 
        grady[GYKCS_SLOT].num = 1;
        grady[GYKCS_SLOT].powscale = loggrd.yfs/target_amp_y;  /* QT*/
 
#endif
 
#ifdef CSZKILLER
 
        if ((amppwgradmethod(&gradz[GZKCS_SLOT], area_gzkcs, target_amp_z,
                             0.0, 0.0,loggrd.zrt*csk_derate_factor,
                             MIN_PLATEAU_TIME))==FAILURE) {
    	    epic_error(use_ermes, "%s failed in ChemSatEval",
                       EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,
                       "amppwgradmethod:gzkcs");
    	    return FAILURE;
        }
 
        gradz[GZKCS_SLOT].num = 1;
        gradz[GZKCS_SLOT].powscale = loggrd.xfs/target_amp_z;  /* QT*/
 
#endif
        rfpulse[RFCSSAT_SLOT].num = 1;
 
        *time_cssat = RUP_GRD(-rfupa + CHEM_SSP_FREQ_TIME + pw_rfcssat +
                              IMax(3,
                                   pw_gxkcsa+ pw_gxkcs+pw_gxkcsd,
                                   pw_gykcsa+ pw_gykcs+pw_gykcsd,
                                   pw_gzkcsa+ pw_gzkcs+pw_gzkcsd) 
                              );

        if (aspir_flag)
        {
           if(PSD_ON==exist(opspecir))
           {
              aspir_minti = _aspir_minti.fixedflag ?   
                                      
                                              
                                               
                                      ((void)(RUP_GRD(cs_isodelay+IMax(3,pw_gxkcsa+pw_gxkcs+pw_gxkcsd,pw_gykcsa+pw_gykcs+pw_gykcsd,pw_gzkcsa+pw_gzkcs+pw_gzkcsd)+time_ssi+GRAD_UPDATE_TIME)), aspir_minti) : RUP_GRD(cs_isodelay+IMax(3,pw_gxkcsa+pw_gxkcs+pw_gxkcsd,pw_gykcsa+pw_gykcs+pw_gykcsd,pw_gzkcsa+pw_gzkcs+pw_gzkcsd)+time_ssi+GRAD_UPDATE_TIME); 
              if (exist(opti)>aspir_minti) 
              {
                 aspir_delay = _aspir_delay.fixedflag ? ((void)(RUP_GRD(exist(opti)-aspir_minti)), aspir_delay) : RUP_GRD(exist(opti)-aspir_minti); 
              } else {
                 aspir_delay = _aspir_delay.fixedflag ? ((void)(0), aspir_delay) : 0; 
              }
           }
           *time_cssat += aspir_delay;
        }
 
        cs_sat  = _cs_sat.fixedflag ?  ((void)(1), cs_sat) : 1;
 
        rfpulse[RFCSSAT_SLOT].activity = PSD_APS2_ON + PSD_MPS2_ON +
            PSD_SCAN_ON;

        rfpulse[RFCSSAT_CFH_SLOT].activity = PSD_CFH_ON;

    } else {
    
        /* If no water or fat suppression requested */

        grady[GYKCS_SLOT].num = 0;

#ifdef CSXKILLER
        gradx[GXKCS_SLOT].num = 0;
#endif

#ifdef CSZKILLER
        gradz[GZKCS_SLOT].num = 0;
#endif
        rfpulse[RFCSSAT_SLOT].num = 0;
        cs_sat  = _cs_sat.fixedflag ?  ((void)(0), cs_sat) : 0;
        *time_cssat = 0;
        rfpulse[RFCSSAT_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFCSSAT_CFH_SLOT].activity = PSD_PULSE_OFF;
    }

        gradz[GZCSSAT_SLOT].num = 0;
        gradz[GZCSSATNORF_SLOT].num = 0;

    switch (ChemSatPulse) {

    /* SPSP fat sat pulse */
    case SPSP_FATSAT_PULSE:    	    	    	  
        /* Fill in RF_PULSE structure */                        	                                	
        rfpulse[RFCSSAT_SLOT].abswidth = ext_abswidth;
        rfpulse[RFCSSAT_SLOT].effwidth = ext_effwidth;
        rfpulse[RFCSSAT_SLOT].area = ext_area;
        rfpulse[RFCSSAT_SLOT].dtycyc = ext_dtycyc;
        rfpulse[RFCSSAT_SLOT].maxpw = ext_maxpw;
        rfpulse[RFCSSAT_SLOT].max_b1 = ext_max_b1;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = ext_max_int_b1_sq;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = ext_max_rms_b1;
        rfpulse[RFCSSAT_SLOT].nom_fa = ext_nom_fa;
        rfpulse[RFCSSAT_SLOT].nom_pw = ext_nom_pw;
        rfpulse[RFCSSAT_SLOT].nom_bw = ext_nom_bw;
        rfpulse[RFCSSAT_SLOT].activity = PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].isodelay = ext_isodelay;
        rfpulse[RFCSSAT_SLOT].scale = 1.0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;        
        rfpulse[RFCSSAT_SLOT].num = 1;

        rfpulse[RFCSSAT_CFH_SLOT].abswidth = ext_abswidth;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = ext_effwidth;
        rfpulse[RFCSSAT_CFH_SLOT].area = ext_area;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = ext_dtycyc;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = ext_maxpw;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = ext_max_b1;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = ext_max_int_b1_sq;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = ext_max_rms_b1;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = ext_nom_fa;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = ext_nom_pw;
        rfpulse[RFCSSAT_CFH_SLOT].nom_bw = ext_nom_bw;
        rfpulse[RFCSSAT_CFH_SLOT].activity = PSD_PULSE_OFF; /* turn off SPSP FATSAT during CFH */
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].isodelay = ext_isodelay;
        rfpulse[RFCSSAT_CFH_SLOT].scale = 1.0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].num = 0;

        pw_rfcssat  = _pw_rfcssat.fixedflag ?  ((void)(ext_pw_rfcssat), pw_rfcssat) : ext_pw_rfcssat;   
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(ext_res_rfcssat), res_rfcssat) : ext_res_rfcssat; 
        flip_rfcssat  = _flip_rfcssat.fixedflag ?  ((void)(100.0), flip_rfcssat) : 100.0;  
        a_rfcssat  = _a_rfcssat.fixedflag ?  ((void)(flip_rfcssat/ext_nom_fa), a_rfcssat) : flip_rfcssat/ext_nom_fa;  

        /* Fill in GRAD_PULSE structure */
        pw_gzrfcssat_lobe  = _pw_gzrfcssat_lobe.fixedflag ?  ((void)(ext_pw_grad_sub_lobe), pw_gzrfcssat_lobe) : ext_pw_grad_sub_lobe;
        pw_gzrfcssat_rampz  = _pw_gzrfcssat_rampz.fixedflag ?  ((void)(ext_pw_grad_sub_lobe_ramp), pw_gzrfcssat_rampz) : ext_pw_grad_sub_lobe_ramp; 
        pw_gzrfcssat_constant  = _pw_gzrfcssat_constant.fixedflag ?    ((void)(pw_gzrfcssat_lobe-2*pw_gzrfcssat_rampz), pw_gzrfcssat_constant) : pw_gzrfcssat_lobe-2*pw_gzrfcssat_rampz;        
        num_gzrfcssat_lobe  = _num_gzrfcssat_lobe.fixedflag ?  ((void)(ext_num_grad_sub_lobe), num_gzrfcssat_lobe) : ext_num_grad_sub_lobe;

        pw_gzrfcssat_lobe_norf  = _pw_gzrfcssat_lobe_norf.fixedflag ?  ((void)(ext_pw_grad_sub_lobe_norf), pw_gzrfcssat_lobe_norf) : ext_pw_grad_sub_lobe_norf;
        pw_gzrfcssat_rampz_norf  = _pw_gzrfcssat_rampz_norf.fixedflag ?  ((void)(ext_pw_grad_sub_lobe_ramp_norf), pw_gzrfcssat_rampz_norf) : ext_pw_grad_sub_lobe_ramp_norf;
        pw_gzrfcssat_constant_norf  = _pw_gzrfcssat_constant_norf.fixedflag ?    ((void)(pw_gzrfcssat_lobe_norf-2*pw_gzrfcssat_rampz_norf), pw_gzrfcssat_constant_norf) : pw_gzrfcssat_lobe_norf-2*pw_gzrfcssat_rampz_norf;
        num_gzrfcssat_lobe_norf  = _num_gzrfcssat_lobe_norf.fixedflag ?  ((void)(ext_num_grad_sub_lobe_norf), num_gzrfcssat_lobe_norf) : ext_num_grad_sub_lobe_norf;

        gradz[GZCSSAT_SLOT].ptype = G_TRAP;        
        gradz[GZCSSAT_SLOT].attack = _pw_gzrfcssat_rampz.fixedflag ? (_temp653_pw_gzrfcssat_rampz=pw_gzrfcssat_rampz,&_temp653_pw_gzrfcssat_rampz) : &pw_gzrfcssat_rampz;
        gradz[GZCSSAT_SLOT].decay = _pw_gzrfcssat_rampz.fixedflag ? (_temp654_pw_gzrfcssat_rampz=pw_gzrfcssat_rampz,&_temp654_pw_gzrfcssat_rampz) : &pw_gzrfcssat_rampz;
        gradz[GZCSSAT_SLOT].pw = _pw_gzrfcssat_constant.fixedflag ? (_temp655_pw_gzrfcssat_constant=pw_gzrfcssat_constant,&_temp655_pw_gzrfcssat_constant) : &pw_gzrfcssat_constant;
        gradz[GZCSSAT_SLOT].amp = _a_gzrfcssat_wrf.fixedflag ? (_temp656_a_gzrfcssat_wrf=a_gzrfcssat_wrf,&_temp656_a_gzrfcssat_wrf) : &a_gzrfcssat_wrf;
        gradz[GZCSSAT_SLOT].scale = 1.0;
        gradz[GZCSSAT_SLOT].num = num_gzrfcssat_lobe;

        gradz[GZCSSATNORF_SLOT].ptype = G_TRAP;
        gradz[GZCSSATNORF_SLOT].attack = _pw_gzrfcssat_rampz_norf.fixedflag ? (_temp657_pw_gzrfcssat_rampz_norf=pw_gzrfcssat_rampz_norf,&_temp657_pw_gzrfcssat_rampz_norf) : &pw_gzrfcssat_rampz_norf;
        gradz[GZCSSATNORF_SLOT].decay = _pw_gzrfcssat_rampz_norf.fixedflag ? (_temp658_pw_gzrfcssat_rampz_norf=pw_gzrfcssat_rampz_norf,&_temp658_pw_gzrfcssat_rampz_norf) : &pw_gzrfcssat_rampz_norf;
        gradz[GZCSSATNORF_SLOT].pw = _pw_gzrfcssat_constant_norf.fixedflag ? (_temp659_pw_gzrfcssat_constant_norf=pw_gzrfcssat_constant_norf,&_temp659_pw_gzrfcssat_constant_norf) : &pw_gzrfcssat_constant_norf;
        gradz[GZCSSATNORF_SLOT].amp = _a_gzrfcssat.fixedflag ? (_temp660_a_gzrfcssat=a_gzrfcssat,&_temp660_a_gzrfcssat) : &a_gzrfcssat;
        gradz[GZCSSATNORF_SLOT].scale = 1.0;
        gradz[GZCSSATNORF_SLOT].num = num_gzrfcssat_lobe_norf;

        *time_cssat += spsp_fatsat_pulse_extra_time;

        break;
  
    case SINC_PULSE:
    default:

        rfpulse[RFCSSAT_SLOT].abswidth = SAR_ABS_SINC1;

        rfpulse[RFCSSAT_SLOT].effwidth = SAR_PSINC1;
        rfpulse[RFCSSAT_SLOT].area = SAR_ASINC1;
        rfpulse[RFCSSAT_SLOT].dtycyc = SAR_DTYCYC_SINC1;
        rfpulse[RFCSSAT_SLOT].maxpw = SAR_MAXPW_SINC1;
        rfpulse[RFCSSAT_SLOT].max_b1 = MAX_B1_SINC1_90;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
        rfpulse[RFCSSAT_SLOT].nom_fa = 90.0;
        *rfpulse[RFCSSAT_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_SLOT].nom_pw = 3200 ;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].abswidth = SAR_ABS_SINC1;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = SAR_PSINC1;
        rfpulse[RFCSSAT_CFH_SLOT].area = SAR_ASINC1;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = SAR_DTYCYC_SINC1;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = SAR_MAXPW_SINC1;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = MAX_B1_SINC1_90;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = 90.0;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = 3200 ;
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;


        break;

    case CSM_PULSE:

        rfpulse[RFCSSAT_SLOT].abswidth = SAR_CSM_ABS_WIDTH;
        rfpulse[RFCSSAT_SLOT].effwidth = SAR_CSM_EFF_WIDTH;
        rfpulse[RFCSSAT_SLOT].area = SAR_CSM_AREA;
        rfpulse[RFCSSAT_SLOT].dtycyc = SAR_CSM_DUTY_CYC;
        rfpulse[RFCSSAT_SLOT].maxpw = SAR_CSM_MAX_PW;
        rfpulse[RFCSSAT_SLOT].max_b1 = SAR_CSM_MAX_B1;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = SAR_CSM_MAX_INT_B1_SQ;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = SAR_CSM_MAX_RMS_B1;
        rfpulse[RFCSSAT_SLOT].nom_fa = SAR_CSM_NOM_FLIP;
        *rfpulse[RFCSSAT_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_SLOT].nom_pw = SAR_CSM_NOM_PW;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].abswidth = SAR_CSM_ABS_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = SAR_CSM_EFF_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].area = SAR_CSM_AREA;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = SAR_CSM_DUTY_CYC;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = SAR_CSM_MAX_PW;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = SAR_CSM_MAX_B1;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = SAR_CSM_MAX_INT_B1_SQ;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = SAR_CSM_MAX_RMS_B1;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = SAR_CSM_NOM_FLIP;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = SAR_CSM_NOM_PW;
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;

        /* *********************************************************** *
         * There is a major change here. Deleted all the overdrive     *
         * staff. defined CVs flip_sat and flip_satcfh. In the         *
         * ChenSatEval() subroutine, they both equal to the OVERDRIVE  *
         * value. flip_sat will be re-calculated in the new subroutine *
         * ChenSatFlip according to the scan protocol. flip_sat and    *
         * flip_satcfh will not be the same in the new optimized       *
         * ChemSat implementation. The act_fa field is set to flip_sat *
         * directly. flip_rfsat is set to act_fa inside the structure  *
         * directly. SGT                                               *
         * *********************************************************** */

        *rfpulse[RFCSSAT_SLOT].act_fa = flip_sat;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = flip_satcfh;


        if ( ((exist(oppseq)==PSD_GE)||(exist(oppseq)==PSD_SPGR)) &&
             (exist(opfast)==PSD_ON) ) {
            *rfpulse[RFCSSAT_SLOT].act_fa = 100.0;
            *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 100.0;
        }

        break;

    case CSMIN8_PULSE:

        rfpulse[RFCSSAT_SLOT].abswidth = SAR_CSMIN8_ABS_WIDTH;
        rfpulse[RFCSSAT_SLOT].effwidth = SAR_CSMIN8_EFF_WIDTH;
        rfpulse[RFCSSAT_SLOT].area = SAR_CSMIN8_AREA;
        rfpulse[RFCSSAT_SLOT].dtycyc = SAR_CSMIN8_DUTY_CYC;
        rfpulse[RFCSSAT_SLOT].maxpw = SAR_CSMIN8_MAX_PW;
        rfpulse[RFCSSAT_SLOT].max_b1 = SAR_CSMIN8_MAX_B1;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = SAR_CSMIN8_MAX_INT_B1_SQ;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = SAR_CSMIN8_MAX_RMS_B1;
        rfpulse[RFCSSAT_SLOT].nom_fa = SAR_CSMIN8_NOM_FLIP;
        *rfpulse[RFCSSAT_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_SLOT].nom_pw = SAR_CSMIN8_NOM_PW;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].abswidth = SAR_CSMIN8_ABS_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = SAR_CSMIN8_EFF_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].area = SAR_CSMIN8_AREA;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = SAR_CSMIN8_DUTY_CYC;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = SAR_CSMIN8_MAX_PW;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = SAR_CSMIN8_MAX_B1;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = SAR_CSMIN8_MAX_INT_B1_SQ;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = SAR_CSMIN8_MAX_RMS_B1;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = SAR_CSMIN8_NOM_FLIP;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = SAR_CSMIN8_NOM_PW;
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;

        if ( (((exist(oppseq)==PSD_GE)||(exist(oppseq)==PSD_SPGR)) &&
              ((exist(opfast)==PSD_ON) || (exist(opimode)==PSD_3D)))  ||
             (((exist(oppseq)==PSD_TOF)||(exist(oppseq)==PSD_TOFSP)) &&
              (exist(opimode)==PSD_3D)) ) {

            if( (cffield == B0_5000) || (cffield == B0_2000) || (cffield == B0_3500)) {
                *rfpulse[RFCSSAT_SLOT].act_fa = 110.0;
                *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 110.0;
            } else {
                *rfpulse[RFCSSAT_SLOT].act_fa = 100.0;
                *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 100.0;
            }
        }

        break;

    case CSMAX8_PULSE:

        rfpulse[RFCSSAT_SLOT].abswidth = SAR_CSMAX8_ABS_WIDTH;
        rfpulse[RFCSSAT_SLOT].effwidth = SAR_CSMAX8_EFF_WIDTH;
        rfpulse[RFCSSAT_SLOT].area = SAR_CSMAX8_AREA;
        rfpulse[RFCSSAT_SLOT].dtycyc = SAR_CSMAX8_DUTY_CYC;
        rfpulse[RFCSSAT_SLOT].maxpw = SAR_CSMAX8_MAX_PW;
        rfpulse[RFCSSAT_SLOT].max_b1 = SAR_CSMAX8_MAX_B1;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = SAR_CSMAX8_MAX_INT_B1_SQ;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = SAR_CSMAX8_MAX_RMS_B1;
        rfpulse[RFCSSAT_SLOT].nom_fa = SAR_CSMAX8_NOM_FLIP;
        *rfpulse[RFCSSAT_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_SLOT].nom_pw = SAR_CSMAX8_NOM_PW;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].abswidth = SAR_CSMAX8_ABS_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = SAR_CSMAX8_EFF_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].area = SAR_CSMAX8_AREA;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = SAR_CSMAX8_DUTY_CYC;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = SAR_CSMAX8_MAX_PW;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = SAR_CSMAX8_MAX_B1;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = SAR_CSMAX8_MAX_INT_B1_SQ;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = SAR_CSMAX8_MAX_RMS_B1;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = SAR_CSMAX8_NOM_FLIP;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = SAR_CSMAX8_NOM_PW;
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;

        if ( ((exist(oppseq)==PSD_GE)||(exist(oppseq)==PSD_SPGR)) 
             && (exist(opfast)==PSD_ON) ) {
            *rfpulse[RFCSSAT_SLOT].act_fa = 100.0;
            *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 100.0;
        }

        break;

    case CS3T_PULSE:				/*YH*/

        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFCS3T), res_rfcssat) : RES_RFCS3T;
        rfpulse[RFCSSAT_SLOT].abswidth = SAR_CS3T_ABS_WIDTH;
        rfpulse[RFCSSAT_SLOT].effwidth = SAR_CS3T_EFF_WIDTH;
        rfpulse[RFCSSAT_SLOT].area = SAR_CS3T_AREA;
        rfpulse[RFCSSAT_SLOT].dtycyc = SAR_CS3T_DUTY_CYC;
        rfpulse[RFCSSAT_SLOT].maxpw = SAR_CS3T_MAX_PW;
        rfpulse[RFCSSAT_SLOT].max_b1 = SAR_CS3T_MAX_B1;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = SAR_CS3T_MAX_INT_B1_SQ;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = SAR_CS3T_MAX_RMS_B1;
        rfpulse[RFCSSAT_SLOT].nom_fa = SAR_CS3T_NOM_FLIP;
        rfpulse[RFCSSAT_SLOT].nom_pw = SAR_CS3T_NOM_PW;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].abswidth = SAR_CS3T_ABS_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = SAR_CS3T_EFF_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].area = SAR_CS3T_AREA;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = SAR_CS3T_DUTY_CYC;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = SAR_CS3T_MAX_PW;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = SAR_CS3T_MAX_B1;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = SAR_CS3T_MAX_INT_B1_SQ;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = SAR_CS3T_MAX_RMS_B1;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = SAR_CS3T_NOM_FLIP;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = SAR_CS3T_NOM_PW;
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;
        *rfpulse[RFCSSAT_SLOT].act_fa = flip_sat;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = flip_satcfh;

        if ( ((exist(oppseq)==PSD_GE)||(exist(oppseq)==PSD_SPGR)) 
             && (exist(opfast)==PSD_ON) ) {
            *rfpulse[RFCSSAT_SLOT].act_fa = 100.0;
            *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 100.0;
        }

        break;

    case CS_HS:	
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFHS), res_rfcssat) : RES_RFHS;
        rfpulse[RFCSSAT_SLOT].abswidth = SAR_ABS_HS;
        rfpulse[RFCSSAT_SLOT].effwidth = SAR_HS_EFF_WIDTH;
        rfpulse[RFCSSAT_SLOT].area = SAR_AHS;
        rfpulse[RFCSSAT_SLOT].dtycyc = SAR_DTYCYC_HS;
        rfpulse[RFCSSAT_SLOT].maxpw = SAR_MAXPW_HS;
        rfpulse[RFCSSAT_SLOT].max_b1 = MAX_B1_HS;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_HS;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = MAX_RMS_B1_HS;
        rfpulse[RFCSSAT_SLOT].nom_fa = NOM_FLIP_HS;
        rfpulse[RFCSSAT_SLOT].nom_pw = NOM_PW_HS;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].abswidth = SAR_ABS_HS;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = SAR_HS_EFF_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].area = SAR_AHS;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = SAR_DTYCYC_HS;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = SAR_MAXPW_HS;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = MAX_B1_HS;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_HS;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = MAX_RMS_B1_HS;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = NOM_FLIP_HS;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = NOM_PW_HS;
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;
        *rfpulse[RFCSSAT_SLOT].act_fa = 180;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 180;
        break;

    case CS_HS_20MS:
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFHS_20MS), res_rfcssat) : RES_RFHS_20MS;
        rfpulse[RFCSSAT_SLOT].abswidth = SAR_ABS_HS_20MS;
        rfpulse[RFCSSAT_SLOT].effwidth = SAR_HS_EFF_WIDTH_20MS;
        rfpulse[RFCSSAT_SLOT].area = SAR_AHS_20MS;
        rfpulse[RFCSSAT_SLOT].dtycyc = SAR_DTYCYC_HS_20MS;
        rfpulse[RFCSSAT_SLOT].maxpw = SAR_MAXPW_HS_20MS;
        rfpulse[RFCSSAT_SLOT].max_b1 = MAX_B1_HS_20MS;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_HS_20MS;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = MAX_RMS_B1_HS_20MS;
        rfpulse[RFCSSAT_SLOT].nom_fa = NOM_FLIP_HS_20MS;
        rfpulse[RFCSSAT_SLOT].nom_pw = NOM_PW_HS_20MS;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].abswidth = SAR_ABS_HS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = SAR_HS_EFF_WIDTH_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].area = SAR_AHS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = SAR_DTYCYC_HS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = SAR_MAXPW_HS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = MAX_B1_HS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_HS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = MAX_RMS_B1_HS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = NOM_FLIP_HS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = NOM_PW_HS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;
        *rfpulse[RFCSSAT_SLOT].act_fa = 180;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 180;
        break;
    }


    if ( ( ( ((exist(oppseq)==PSD_GE)||(exist(oppseq)==PSD_SPGR)) &&
             ((exist(opfast)==PSD_ON) || (exist(opimode)==PSD_3D)))  ||
           (((exist(oppseq)==PSD_TOF)||(exist(oppseq)==PSD_TOFSP)) &&
            (exist(opimode)==PSD_3D)) ) && ((cffield == B0_5000) || 
                                            (cffield == B0_2000) ||(cffield == B0_3500)) && 
         (ChemSatPulse == CSMIN8_PULSE) ) {

        if (opwater == PSD_ON) {
            off_rfcssat  = _off_rfcssat.fixedflag ?  ((void)(FWCHEMSHIFT_HALF_TESLA_FAST), off_rfcssat) : FWCHEMSHIFT_HALF_TESLA_FAST;
        }

        if ( fatFlag == PSD_ON ) {
            off_rfcssat  = _off_rfcssat.fixedflag ?  ((void)(-FWCHEMSHIFT_HALF_TESLA_FAST), off_rfcssat) : -FWCHEMSHIFT_HALF_TESLA_FAST;
        } 


    } else { 

        if (opwater == PSD_ON) {
            off_rfcssat  = _off_rfcssat.fixedflag ?  ((void)(SDL_GetChemicalShift(cffield)), off_rfcssat) : SDL_GetChemicalShift(cffield);
        }

        if ( fatFlag == PSD_ON) {
            off_rfcssat  = _off_rfcssat.fixedflag ?  ((void)(-SDL_GetChemicalShift(cffield)), off_rfcssat) : -SDL_GetChemicalShift(cffield);
            if (CS_HS == ChemSatPulse )
            {
               off_rfcssat  = _off_rfcssat.fixedflag ?       ((void)(-1.0*((NOM_BW_HS+SDL_GetChemicalShift(cffield))/2)), off_rfcssat) : -1.0*((NOM_BW_HS+SDL_GetChemicalShift(cffield))/2);
            } 
            else if (CS_HS_20MS == ChemSatPulse )
            {
               off_rfcssat  = _off_rfcssat.fixedflag ?       ((void)(-1.0*((NOM_BW_HS_20MS+SDL_GetChemicalShift(cffield))/2)), off_rfcssat) : -1.0*((NOM_BW_HS_20MS+SDL_GetChemicalShift(cffield))/2);
            } 
        }

    }

    if (aspir_fa_scaling_flag)
    {
        double energy_b1_limit;
        double act_b1_rfcssat;
        double dummy_scale = 1.0;
        double NewFA;
        double initFA;

        if( SUCCESS !=  pulseEnergyB1Limit(&energy_b1_limit, &rfpulse[RFCSSAT_SLOT]) )
        {
            epic_error( use_ermes, "Support routine %s failed.",
                        EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                        STRING_ARG, "pulseEnergyB1Limit" );
            return FAILURE;
        }

        if( SUCCESS !=  calcB1Val(&act_b1_rfcssat, &dummy_scale, &rfpulse[RFCSSAT_SLOT],
                                  rfpulse[RFCSSAT_SLOT].num, (UCHAR)1, use_ermes) )
        {
            epic_error( use_ermes, "Support routine %s failed.",
                        EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                        STRING_ARG, "calcB1Val_aspir" );
            return FAILURE;
        }

        initFA =  *rfpulse[RFCSSAT_SLOT].act_fa;
        NewFA= floor((energy_b1_limit/act_b1_rfcssat)* (*rfpulse[RFCSSAT_SLOT].act_fa));
        *rfpulse[RFCSSAT_SLOT].act_fa = NewFA;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = NewFA;

        if (fa_scale_debug == PSD_ON)
        {
            FILE *fp;
            fp = fopen("/usr/g/service/log/fa_scale","ab");

            if (NULL != fp)
            {
                fprintf(fp,"\n ************** ASPIR Scaling **********************");
                fprintf(fp,"\n Initial FA    =%f ", initFA);
                fprintf(fp,"\n Actual B1     =%f ", act_b1_rfcssat);
                fprintf(fp,"\n EnergyB1Limit =%f ", energy_b1_limit);
                fprintf(fp,"\n New FA        =%f ", *rfpulse[RFCSSAT_SLOT].act_fa);
                fprintf(fp,"\n ************** End ********************************");
                fclose(fp);
            }
        }
    }

    return SUCCESS;
}

/* Fat component */
/* 0: Fat component CH3 */
/* 1: Fat component (CH2)n */
/* 2: Fat component O=C-C-CH2-CH2 */
/* 3: Fat component C=C-CH2 */
/* 4: Fat component O=C-CH2 */
/* 5: Fat component C-CH2-C= */
/* 6: Fat component CH2O (right) */
/* 7: Fat component CH2O (left) */
/* 8: Fat component CH=CH and CHO */
float chemsat_amp[9] = { 0.26,  1.00,  0.10,  0.21,  0.11,  0.05,  0.04,  0.04,  0.15};
float chemsat_T1[9]  = {577.0, 226.0, 185.0, 209.0, 210.0, 245.0, 237.0, 242.0, 204.0};  /* T1 in ms */
float chemsat_T2[9]  = {227.0, 107.0,  43.0,  67.0,  71.0, 183.0,  36.0,  36.0, 137.0};  /* T2 in ms */

/* ********************************************************** *
 * Subroutine get called in each psd to calculate the optimal *
 * sat flip angle in the SCAN entry. SGT                      *
 * ********************************************************** */
STATUS
ChemSatFlip( INT delay_time,
             INT tetime,
             INT rc_time,
             INT slquant,
             INT tr_time )
{
    int i,j;
    int flip;
    float seq_time;
    float angle;
    float *amp = chemsat_amp;
    float *T1 = chemsat_T1;
    float *T2 = chemsat_T2;
    float Mz;
    float EE[9];
    float ER[9];
    float ES[9];
    float factor[9];
    float signal_fat;
    float previous_signal;
    float scale = 0.001;
    float T1_inv[9];
    float T2_inv[9];

    /* Sequence time equals tr_time divided by slquant */
    seq_time = (float)(tr_time)/(float)slquant;

    /* Check to make sure all the parameters are valid */
    if ((delay_time <0) ||( tetime < 0) || (rc_time < 0)) {
        epic_error(0,"ChemSatFlip time parameters invalid",0,EE_ARGS(0));
        return FAILURE;
    }

    for (i=0; i<9; i++) {
        T1_inv[i] = 1.0/T1[i]*scale;
        T2_inv[i] = 1.0/T2[i]*scale;

#ifndef __linux__
        EE[i] = fexp(-(float)tetime*T2_inv[i]);
        ES[i] = fexp(-(float)delay_time*T1_inv[i]);
        ER[i] = fexp(-(float)seq_time*T1_inv[i]);
#else
        EE[i] = exp(-(float)tetime*T2_inv[i]);
        ES[i] = exp(-(float)delay_time*T1_inv[i]);
        ER[i] = exp(-(float)seq_time*T1_inv[i]);
#endif
    }

    /* ************************************************** *
     * If cannot find optimal ChemSat flip angle between  *
     * 90 and 180 degrees, then the optimal flip angle is *
     * 180 degree ChemSat RF pulse.                       *
     * ************************************************** */
    flip_sat  = _flip_sat.fixedflag ?  ((void)(180.0), flip_sat) : 180.0;
    previous_signal = 1.0;

    for (flip=90; flip<=180; flip++)
    {
        /* Initialize the fat signal to 0 */
        signal_fat = 0.0;

        for (i=0; i<9; i++)
        {
            if (i<6)
                angle = ((float)flip)*PI/180.0;
            else
                angle = 0.0;

#ifndef __linux__
            factor[i] = fcos(angle);
#else
            factor[i] = cos(angle);
#endif

            /* *********************************************** *
             * Assuming at the TE time, the Mz of the fat is   *
             * zero. At the time of the next ChemSat RF pulse, *
             * the Mz is calculated.                           *
             * *********************************************** */
#ifndef __linux__
            Mz = 1.0 - fexp(-(seq_time-rc_time-delay_time)*T1_inv[i]);
#else
            Mz = 1.0 - exp(-(seq_time-rc_time-delay_time)*T1_inv[i]);
#endif


            /* ************************************************* *
             * Next, slquant-1 number of ChemSat RF pulses with  *
             * interval of seq_time time are played. At the time *
             * of the ChemSat RF pulse the for current slice.    *
             * ************************************************* */
            for (j=0; j<slquant-1; j++)
                Mz = 1.0 + (Mz*factor[i] - 1.0)*ER[i];

            /* At the 90 degree excitation RF pulse */
            Mz = 1.0 + (Mz*factor[i] - 1.0)*ES[i];

            signal_fat += amp[i]*EE[i]*Mz;
        }


        /* ******************************************************* *
         * Find out the flip angle that gives the optimal ChemSat. *
         * Based on MR physics, we only need to search for flip    *
         * angles between 90 and 180 degree.                       *
         * ******************************************************* */
        if ((previous_signal >= 0) && (signal_fat < 0))
        {
            flip_sat  = _flip_sat.fixedflag ?  ((void)((float)(flip-1)), flip_sat) : (float)(flip-1);
            break;
        }

        previous_signal = signal_fat;
    }

    if ( (CS_HS != ChemSatPulse) && (CS_HS_20MS != ChemSatPulse) )
    {
       /* FATSAT FACTOR addition - HH June 2005 */
       flip_sat  = _flip_sat.fixedflag ?    ((void)(acos(1.0-fatsat_factor)/acos(0.0)), flip_sat) : flip_sat*acos(1.0-fatsat_factor)/acos(0.0);
       /* Set the calculated flip angle to the RF structure */
       *rfpulse[RFCSSAT_SLOT].act_fa = flip_sat;
    }

    return SUCCESS;
}


/* ********************************************************** *
 * Subroutine get called in classic T2flair to calculate the  *
 * sat flip angle in the SCAN entry.  Take the optimal sat    *
 * flip angle of the last slice in one group as the final     *
 * optimal sat flip angle.  HS                                *
 * ********************************************************** */
STATUS
ChemSatFlip_T2flair( INT delay_time,
                     INT tetime,
                     INT rc_time,
                     INT slquant1,
                     INT tr_time,
                     INT packs,
                     INT ti_time,
                     INT seq_time,
                     INT ignore_ir )
{
    int i,j,p;
    int flip;
    float angle;
    float *amp = chemsat_amp;
    float *T1 = chemsat_T1;
    float *T2 = chemsat_T2;
    float Mz;
    float EE[9];
    float ER[9];
    float ES[9];
    float factor[9];
    float signal_fat;
    float previous_signal;
    float scale = 0.001;
    float T1_inv[9];
    float T2_inv[9];

    /* Check to make sure all the parameters are valid */
    if ((delay_time <0) ||( tetime < 0) || (rc_time < 0) || (ti_time<0) || (seq_time<0)) {
        epic_error(0,"ChemSatFlip_T2flair time parameters invalid",0,EE_ARGS(0));
        return FAILURE;
    }

    for (i=0; i<9; i++) {
        T1_inv[i] = 1.0/T1[i]*scale;
        T2_inv[i] = 1.0/T2[i]*scale;

#ifndef __linux__
        EE[i] = fexp(-(float)tetime*T2_inv[i]);
        ES[i] = fexp(-(float)delay_time*T1_inv[i]);
        ER[i] = fexp(-(float)seq_time*T1_inv[i]);
#else
        EE[i] = exp(-(float)tetime*T2_inv[i]);
        ES[i] = exp(-(float)delay_time*T1_inv[i]);
        ER[i] = exp(-(float)seq_time*T1_inv[i]);
#endif
    }

    /* ************************************************** *
     * If cannot find optimal ChemSat flip angle between  *
     * 90 and 180 degrees, then the optimal flip angle is *
     * 180 degree ChemSat RF pulse.                       *
     * ************************************************** */
    flip_sat  = _flip_sat.fixedflag ?  ((void)(180.0), flip_sat) : 180.0;
    previous_signal = 1.0;

    for (flip=90; flip<=180; flip++)
    {
        /* Initialize the fat signal to 0 */
        signal_fat = 0.0;

        for (i=0; i<9; i++)
        {
            if (i<6)
                angle = ((float)flip)*PI/180.0;
            else
                angle = 0.0;

#ifndef __linux__
            factor[i] = fcos(angle);
#else
            factor[i] = cos(angle);
#endif

            /* ************************************************ *
             * Assuming at the TE time of the last slice in the *
             * group, the Mz of the fat is zero. At the time of *
             * the end of the sequence, the Mz is calculated.   *
             * ************************************************ */
#ifndef __linux__
            Mz = 1.0 - fexp(-(seq_time-rc_time-delay_time)*T1_inv[i]);
#else
            Mz = 1.0 - exp(-(seq_time-rc_time-delay_time)*T1_inv[i]);
#endif

            /* Will experience packs-1 acquisition groups */
            for (p=0; p<packs-1; p++) {
                /* Next, after a waiting period, next slquant1 number  *
                 * of ChemSat RF pulses with interval of seq_time time *
                 * are played. At the time of the ChemSat RF pulse for *
                 * the first slice of the next group.                  *
                 * *************************************************** */
#ifndef __linux__
                 Mz = 1.0 + (Mz-1.0)*fexp(-(tr_time/(float)packs-slquant1*seq_time)*T1_inv[i]);
#else
                 Mz = 1.0 + (Mz-1.0)*exp(-(tr_time/(float)packs-slquant1*seq_time)*T1_inv[i]);
#endif

                /* ************************************************* *
                 * Next, slquant1 number of ChemSat RF pulses with   *
                 * interval of seq_time time are played. At the time *
                 * of the end of the next group.                     *
                 * ************************************************* */
                for (j=0; j<slquant1; j++)
                    Mz = 1.0 + (Mz*factor[i] - 1.0)*ER[i];
            }

            /* Next, handle the inversion pulse of the slice */
            if (ignore_ir == 0) {
#ifndef __linux__
                /* At the beginning of the inversion pulse */
                Mz = 1.0 + (Mz-1.0)*fexp(-(tr_time/(float)packs-ti_time-seq_time+delay_time)*T1_inv[i]);
                /* At the beginning of the group where the current last slice is. */
                Mz = 1.0 + (-Mz-1.0)*fexp(-(ti_time-delay_time-(slquant1-1)*seq_time)*T1_inv[i]);
#else
                /* At the beginning of the inversion pulse */
                Mz = 1.0 + (Mz-1.0)*exp(-(tr_time/(float)packs-ti_time-seq_time+delay_time)*T1_inv[i]);
                /* At the beginning of the group where the current last slice is. */
                Mz = 1.0 + (-Mz-1.0)*exp(-(ti_time-delay_time-(slquant1-1)*seq_time)*T1_inv[i]);
#endif
            } else {
#ifndef __linux__
                /* At the beginning of the group where the current last slice is. */
                Mz = 1.0 + (Mz-1.0)*fexp(-(tr_time/(float)packs-slquant1*seq_time)*T1_inv[i]);
#else
                /* At the beginning of the group where the current last slice is. */
                Mz = 1.0 + (Mz-1.0)*exp(-(tr_time/(float)packs-slquant1*seq_time)*T1_inv[i]);
#endif
            }

            /* ************************************************* *
             * Next, slquant1-1 number of ChemSat RF pulses with  *
             * interval of seq_time time are played. At the time *
             * of the ChemSat RF pulse the for current slice.    *
             * ************************************************* */
            for (j=0; j<slquant1-1; j++)
                Mz = 1.0 + (Mz*factor[i] - 1.0)*ER[i];

            /* At the 90 degree excitation RF pulse */
            Mz = 1.0 + (Mz*factor[i] - 1.0)*ES[i];

            signal_fat += amp[i]*EE[i]*Mz;
        }

        /* ******************************************************* *
         * Find out the flip angle that gives the optimal ChemSat. *
         * Based on MR physics, we only need to search for flip    *
         * angles between 90 and 180 degree.                       *
         * ******************************************************* */
        if ((previous_signal >= 0) && (signal_fat < 0))
        {
            flip_sat  = _flip_sat.fixedflag ?  ((void)((float)(flip-1)), flip_sat) : (float)(flip-1);
            break;
        }
        previous_signal = signal_fat;
    }

    if ( (CS_HS != ChemSatPulse) && (CS_HS_20MS != ChemSatPulse) )
    {
       /* FATSAT FACTOR addition - HH June 2005 */
       flip_sat  = _flip_sat.fixedflag ?    ((void)(acos(1.0-fatsat_factor)/acos(0.0)), flip_sat) : flip_sat*acos(1.0-fatsat_factor)/acos(0.0);
       /* Set the calculated flip angle to the RF structure */
       *rfpulse[RFCSSAT_SLOT].act_fa = flip_sat;
    }

    return SUCCESS;
}


STATUS
ChemSatCheck( void )
{

    if ( ( fatFlag == PSD_ON )   && (exist(opwater) == PSD_ON) ) { 
        epic_error(use_ermes, "Fat and Water Suppression may not be selected together.",
                   EM_PSD_FW_INCOMPATIBLE,0);
        return FAILURE;
    }

    /* The following 3 conditions should not occur in product by design of the UI, but checked 
       for research handling and debug purposes only. No Error message database used. - RJF */

    if ( exist(opfat) && exist(opfatcl) && existcv(opfat) && existcv(opfatcl) ) { 
        epic_error ( 0, "Classic and New Fat Sat techniques are mutually exclusive.", 
                     0, EE_ARGS(0) );
        return FAILURE;
    }

    if ( exist(opfat) && exist(opspecir) && existcv(opfat) && existcv(opspecir) ) { 
        epic_error ( 0, "SPECIAL and Fat Selections are mutually exclusive.", 
                     0, EE_ARGS(0) );
        return FAILURE;
    }

    if ( exist(opfatcl) && exist(opspecir) && existcv(opfatcl) && existcv(opspecir) ) { 
        epic_error ( 0, "SPECIAL and Classic Fat Selections are mutually exclusive.", 
                     0, EE_ARGS(0) );
        return FAILURE;
    }
 
    return SUCCESS;

}
    
    

static char failstr[]  = "Support routine %s failed";

    /* Subroutine to set rf & gradient pulse structures.  */ 

void
sp_set_num_pulses( RF_PULSE *rf_struct,
                   GRAD_PULSE *grad_struct )
{
    rf_struct->num = 1;
    grad_struct->num = 1;

    /* Set activity masks. */
    rf_struct->activity += PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON;
    
    return;
}

  /* Set rf pulse structure for each sat */

void
sp_set_rfpulse( INT pulse_type,
                RF_PULSE *rf_struct,
                INT *resoln,
                INT *pw_rf,
                INT *bw_rf,
                INT sat_band_type)
{
    switch (pulse_type)
    {
    case SINC_SAT:
        if (*pw_rf == 4800 )
            *resoln = RES_SLRSAT;
        else 
            *resoln = RES_NVRGSAT;
        /*            *pw_rf = 3.2ms;*/
        rf_struct->max_b1 = MAX_B1_SINC1_90;
        rf_struct->max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
        rf_struct->max_rms_b1 = MAX_RMS_B1_SINC1_90;
        rf_struct->effwidth = SAR_PSINC1;
        *bw_rf = (int)(4.*((float)1000000/(float)*pw_rf));
	break;

    case SLR_SAT:
        *resoln = RES_SLRSAT;
        /*            *pw_rf = 4.0ms;*/
        rf_struct->effwidth = SAR_PSLR;
        *bw_rf = (int)(1227.*((float)4000/(float)*pw_rf));
        break;

    case SLR_CSAT:
        *resoln = RES_SLRCSAT;
        *bw_rf = (int) (rf_struct->nom_bw * rf_struct->nom_pw )/ (float) *pw_rf;
        break;

    default:
        break;
    }
    return;
}

/* Subroutine to determine slice select parameters for sat pulses */

STATUS
sp_set_slice_select( INT *pw_slice_select,
                     INT * pw_slice_select_a,
                     INT *pw_slice_select_d,
                     INT pw_rf,
                     FLOAT *amp_slice_select,
                     INT *bw_rf,
                     DOUBLE thickness,
                     DOUBLE targetamp,
                     INT target_rt,
                     INT pulse_type )
{
    *pw_slice_select = pw_rf;
    switch (pulse_type) 
    {

    case SINC_SAT:
	*bw_rf = (int)(4.*((float)1000000/(float)pw_rf));
	break;
	
    case SLR_SAT:
	*bw_rf = (int)(1227.*((float)4000/(float)pw_rf));
        break;

    case SLR_CSAT:
        *bw_rf = (int) ( (float) (12000.0*1000)/ (float) pw_rf );
	break;
	
    default:
	break;
    }
    /* Slice select gradient amplitude for the sat pulse. */
    if (ampslice(amp_slice_select, *bw_rf, thickness, gsat_scale, TYPDEF)
        == FAILURE) 
    {
        epic_error(use_ermes, failstr, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "ampslice");
        return FAILURE;
    }
    /* Now optimize those ramps. */
    if (optramp(pw_slice_select_a, *amp_slice_select,targetamp,
                target_rt,TYPDEF) == FAILURE) 
    {
        epic_error(use_ermes, failstr, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "optramp");
        return FAILURE;
    }

    *pw_slice_select_d = *pw_slice_select_a;

    /* Pad out the attack ramp to allow time for the SSP packets. */
    /*    if (*pw_slice_select_a < 268)
     *pw_slice_select_a = 268;
     */
    /* vmx 3/13/95  YI */
    *pw_slice_select_a = IMax(2,*pw_slice_select_a,
                              RUP_GRD(rffrequency_length[bd_index]-rfupa) );
    /* end vmx */ 
    return (SUCCESS);
}


/* Reinitialize rfpulseInfo structure for given slot number.
   Required in case pulse switches from 4ms to 4.8ms on the fly
 */
STATUS
sp_initrfpulseInfo( RF_PULSE_INFO rfPulseInfo[],
                    INT pulse )
{
    rfPulseInfo[pulse].change = PSD_OFF;
    rfPulseInfo[pulse].newres = 0;

    return SUCCESS;
}

/* routine to determine if pulses require scaling or not. If yes, then
   slice select gradient and bandwidth are modified accordingly */

STATUS
sp_scalerfpulses( DOUBLE weight,
                  INT  gcoiltype,
                  RF_PULSE *rfPulse,
                  INT numentry,
                  RF_PULSE_INFO *rfPulseInfo,
                  INT pulse )
{
    double derateb1;        /* Derated max B1 for patient weight */
    INT entry;              /* temp variable for entry loop */
    double safety_factor = 0.90;

    INT txIndex[MAX_TX_COIL_SETS];
    INT exciterIndex[MAX_TX_COIL_SETS];
    INT exciterUsed[MAX_TX_COIL_SETS];
    INT numTxIndexUsed = 0;

    getTxAndExciter(txIndex, exciterIndex, exciterUsed, &numTxIndexUsed,
                    coilInfo, opncoils);
    
    if (numTxIndexUsed != 1)
    {
        epic_error( use_ermes,
                    "%s does not support more than one transmit coil",
                    EM_PSD_MULTI_TX_NOT_SUPPORTED, EE_ARGS(1), STRING_ARG,
                    "sp_scalerfpulses");
        return FAILURE; 
    }

    /*
      Initialize pulse information structure to zeroes. This requires
      SpSatEval to come after scalerfpulses() in the PSD's. Since we are
      only working on a specific pulse in the structure we will not affect
      other pulses in the PSD.
    */
    /* Handle multiple calls to SpSatEval within 1 cveval call */
    /* Reset the Pulse Info Table to get correct scaling of SAT pulses for each
     * CVEAVL call*/
    rfPulseInfo->change = PSD_OFF;
    rfPulseInfo->newres = 0;

    for( entry = 0; entry < numentry; ++entry ) {

        /*************************************************************************
         * Use equation based on coil type, and patient weight.  If we do not use
         * head coil, then body is the transmit coil.             
         *************************************************************************/
        if( SDL_RFDerating_entry_sat( &derateb1, cffield, weight,
                                      txCoilInfo[txIndex[0]], gcoiltype,
                                      entry, 1.0 ) != SUCCESS )
        {
            return FAILURE;
        }
    
        derateb1 = FMin( 2, 24.0, derateb1 );
        derateb1 *= safety_factor;

        if( rfPulse->extgradfile )
        {
            return SUCCESS;
        }

        scalerfpulses2ut( derateb1, GRAD_UPDATE_TIME, rfPulse, entry,
		          pulse, rfPulseInfo, exciterUsed[0]);
    }

    return SUCCESS;
}

/* Compacts rotation matrices from scan into array used by the psd */

void
sp_get_rot_matrix( float *source,
                   long *dest)
{
    INT  i;

    for (i = 0; i < 9; ++i)
    {
        *dest++ = hostToRspRotMat(*source++);
    }
    return;
}

/* transfers rotation matrix to SCAN_INFO struct for use with obloptimize */

void
sp_get_scaninfo_matrix( float *source,
                        SCAN_INFO *dest )
{
    INT i;
    for (i=0; i<9; i++)
    {
        dest->oprot[i] = *source++;
    }
    return;
}

STATUS
sp_init_satloggrd( LOG_GRAD *sloggrd )
{
    PHYS_GRAD temp_phygrd;  /* dummy struct for calling inittargets */

    if( FAILURE == inittargets(sloggrd,&temp_phygrd) ) {
        return FAILURE;
    }

    return SUCCESS;
}

/* Eval sat code that determines how long sat pulses will take */

STATUS 
SpSatEval( INT *time_spsat )
{
    INT bw_rfsx1, 
        bw_rfsx2, 
        bw_rfsy1, 
        bw_rfsy2, 
        bw_rfsz1, 
        bw_rfsz2,
        bw_rfse1,
        bw_rfse2,
        bw_rfse3, 
        bw_rfse4, 
        bw_rfse5, 
        bw_rfse6;

    INT status;
    INT skip_next_sat;
    INT parallel_mask;
    INT explicit_sat_mask;
    INT array_index;
    INT i, j ;
    SCAN_INFO satscaninfo;

    /* calculate killer areas compatible to 5.4 */
    float killer_length,sr17_scale;
#ifdef  ADDYCRUSHER
    float area_gy1grad;
#endif /* ADDYCRUSHER */
    float sat_scale1,sat_scale2,sat_scale3,sat_scale4,sat_scale5,sat_scale6; 
    float sat_scalex1,sat_scalex2;
    float sat_scaley1,sat_scaley2;
    float sat_scalez1,sat_scalez2;

    /* vmx 3/13/95 YI */
    if( cfpwrmontyp == PMTYP_VMX ) 
    {
        spsat_sys_type  = _spsat_sys_type.fixedflag ?  ((void)(1), spsat_sys_type) : 1;
        rfupa = spsat_rfupa;
    }
    /* end vmx */

    /* Set the cyc_ variables for all of the rf pulses */
    /* cyc_rfs selected in SpSatinit. */
    cyc_rfsx1  = _cyc_rfsx1.fixedflag ?  ((void)(cyc_rfs), cyc_rfsx1) : cyc_rfs;    /* Sinc cycles for default SAT */
    cyc_rfsx2  = _cyc_rfsx2.fixedflag ?  ((void)(cyc_rfs), cyc_rfsx2) : cyc_rfs;
    cyc_rfsy1  = _cyc_rfsy1.fixedflag ?  ((void)(cyc_rfs), cyc_rfsy1) : cyc_rfs;
    cyc_rfsy2  = _cyc_rfsy2.fixedflag ?  ((void)(cyc_rfs), cyc_rfsy2) : cyc_rfs;
    cyc_rfsz1  = _cyc_rfsz1.fixedflag ?  ((void)(cyc_rfs), cyc_rfsz1) : cyc_rfs;
    cyc_rfsz2  = _cyc_rfsz2.fixedflag ?  ((void)(cyc_rfs), cyc_rfsz2) : cyc_rfs;

    cyc_rfse1  = _cyc_rfse1.fixedflag ?  ((void)(cyc_rfs), cyc_rfse1) : cyc_rfs;   /* Sinc cycles for explicit SAT */
    cyc_rfse2  = _cyc_rfse2.fixedflag ?  ((void)(cyc_rfs), cyc_rfse2) : cyc_rfs;
    cyc_rfse3  = _cyc_rfse3.fixedflag ?  ((void)(cyc_rfs), cyc_rfse3) : cyc_rfs;
    cyc_rfse4  = _cyc_rfse4.fixedflag ?  ((void)(cyc_rfs), cyc_rfse4) : cyc_rfs;
    cyc_rfse5  = _cyc_rfse5.fixedflag ?  ((void)(cyc_rfs), cyc_rfse5) : cyc_rfs;
    cyc_rfse6  = _cyc_rfse6.fixedflag ?  ((void)(cyc_rfs), cyc_rfse6) : cyc_rfs;

    sat_newgeo  = _sat_newgeo.fixedflag ?  ((void)(1), sat_newgeo) : 1;
    sat_rot_ex_num  = _sat_rot_ex_num.fixedflag ?  ((void)(0), sat_rot_ex_num) : 0;
    sat_rot_df_num  = _sat_rot_df_num.fixedflag ?  ((void)(0), sat_rot_df_num) : 0;

    for (i=0; i< 13; ++i)
        for (j = 0; j < 9; ++j)
            sat_rot_matrices[i][j] = 0;

    /* Check to see wether we allow ConCat Sat */
    if ((exist(opsat)==PSD_ON) && (exist(opileave)==PSD_OFF) && 
        (exist(opplane)!=PSD_OBL)) 
        piccsatnub = 1;
    else
        piccsatnub = 0;

    /* Turn off sat pulses in gradient and rf pulse structures if
       sat is deselected. */
    if ((exist(opsat) == PSD_OFF) || ((opsatx == PSD_OFF)&&(opsaty == PSD_OFF)
                                      &&(opsatz == PSD_OFF) && (opexsatmask == PSD_OFF)))
    {
        rfpulse[RFSX1_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSX2_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSY1_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSY2_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSZ1_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSZ2_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSE1_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSE2_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSE3_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSE4_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSE5_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSE6_SLOT].activity = PSD_PULSE_OFF;

        gradx[GXRFSX1_SLOT].num = 0;
        gradx[GXRFSX2_SLOT].num = 0;
        grady[GYRFSY1_SLOT].num = 0;
        grady[GYRFSY2_SLOT].num = 0;
        gradz[GZRFSZ1_SLOT].num = 0;
        gradz[GZRFSZ2_SLOT].num = 0;
        gradz[GZRFSE1_SLOT].num = 0;
        gradz[GZRFSE2_SLOT].num = 0;
        gradz[GZRFSE3_SLOT].num = 0;
        gradz[GZRFSE4_SLOT].num = 0;
        gradz[GZRFSE5_SLOT].num = 0;
        gradz[GZRFSE6_SLOT].num = 0;

        grady[GYKSE1_SLOT].num = 0;
        grady[GYKSE2_SLOT].num = 0;
        grady[GYKSE3_SLOT].num = 0;
        grady[GYKSE4_SLOT].num = 0;
        grady[GYKSE5_SLOT].num = 0;
        grady[GYKSE6_SLOT].num = 0;
        grady[GYKSX1_SLOT].num = 0;
        grady[GYKSX2_SLOT].num = 0;
        grady[GYKSY1_SLOT].num = 0;
        grady[GYKSY2_SLOT].num = 0;
        grady[GYKSZ1_SLOT].num = 0;
        grady[GYKSZ2_SLOT].num = 0;

#ifdef SPSATXKILLER
        gradx[GXKSE1_SLOT].num = 0;
        gradx[GXKSE2_SLOT].num = 0;
        gradx[GXKSE3_SLOT].num = 0;
        gradx[GXKSE4_SLOT].num = 0;
        gradx[GXKSE5_SLOT].num = 0;
        gradx[GXKSE6_SLOT].num = 0;
        gradx[GXKSX1_SLOT].num = 0;
        gradx[GXKSX2_SLOT].num = 0;
        gradx[GXKSY1_SLOT].num = 0;
        gradx[GXKSY2_SLOT].num = 0;
        gradx[GXKSZ1_SLOT].num = 0;
        gradx[GXKSZ2_SLOT].num = 0;
#endif

        *time_spsat = 0;
        return (SUCCESS);
    }

    /*   KILLER GRADIENT AREAS FOR DEFAULT SAT

    Killer gradient areas depend on what combination of
    sat pulses are selected.  To maintain the same area
    as in 5.4, calculations are :

    area = (600us + 3ms) * amplitude from table below
    ((5.4 ramp time + 5.4 pulse width) * 5.4 amplitude)

    In addition, if sr17 mode, make sure that the target amplitude
    passed to amppwgrad is limited based on the amplitude values
    below in order to exactly simulate 5.4. 
         

    SAT X alone:    killer for x = .95
    SAT Y alone:    killer for y = .95
    SAT Z alone:    killer for z = .95
    SAT X & Y  :    killer for x = .5
    killer for y = .95
    SAT X & Z  :    killer for x = .5
    killer for z = .95
    SAT Y & Z  :    killer for y = .5
    killer for z = .95
    SAT X,Y,Z  :    killer for x = .5
    killer for y = .5
    killer for z = .95

    */


#ifdef  ADDYCRUSHER
    /* Calculate gy1 gradient area if satbands are selected - AC, MRIge83260 */

    if((PSD_SE == exist(oppseq)) && ((PSD_OFF != exist(opsatz)) || (PSD_OFF != exist(opsaty)) || (PSD_OFF != exist(opsatx))) ) {
                                    
        area_gy1grad = fabs(((a_gy1a * pw_gy1a + a_gy1b*pw_gy1d)/ 2.0)+ ((a_gy1a + a_gy1b)/2.0)*pw_gy1);
    }
#endif

    /* use the pulsewidths defined in 5.4 to calculate the total area */
    killer_length = 600   + 3000;

    /*JAH: MRIge54221 -- With default sats parallel to the slice and no other
      spatial saturation pulses and fat sat on, short TR, small yres,
      frequency direction flow compensated FSE sequences exhibit stripe
      artifacts unless the spatial sat crusher widths are increased.*/

    if((PSD_OFF != exist(opsat)) && (PSD_ON == exist(opfat))
       && ((PSD_OFF != exist(opsatz)) && (PSD_OFF == exist(opsaty))
           && (PSD_OFF == exist(opsatx))) && (PSD_SE == exist(oppseq))
       && (PSD_ON == exist(opfast)) && (PSD_ON == exist(opfcomp))
       && (1 == exist(opfcaxis)))
        killer_length = 1060   + 3000;

#ifdef  ADDYCRUSHER

    /* Set the killer_length area to 2.05 times gy1 grad area to kill the simulation echo path which occurs in high resolution spin echo based sequences - AC, MRIge83262 */

    if((PSD_SE == exist(oppseq)) && ((PSD_OFF != exist(opsatz)) || (PSD_OFF != exist(opsaty)) || (PSD_OFF != exist(opsatx))) ) {

    	if (killer_length < (2.05 * area_gy1grad)) {
            /* Set killer area to a new value to fix fine line artifacts in small FOVs, since
               some spsat crushers are using %50 of killer length, we multiply area_gy1grad by 2.0  AC */
            killer_length = 2.05 * area_gy1grad;
     	}
    }

    /* GEHmr03645 - Increase the crusher widths from 1060us+3ms to 4540, to fix stripe artifacts on SV. */
    /* The minimum crusher area I found necessary to crush the unwanted coherence at all Y-res values was 4310. 
       This translated to an increase in the variable killer_length is 4310/0.95 ~= 4540. Feb/05/2010 */
    if((PSD_OFF != exist(opsat)) && (PSD_ON == exist(opfat))
       && (((PSD_OFF != exist(opsatz)) && (PSD_OFF == exist(opsaty)) && (PSD_OFF == exist(opsatx))) || (opexsatmask > 0)) 
       && (PSD_SE == exist(oppseq)) && (PSD_ON == exist(opfast)) 
       && (PSD_ON == exist(opfcomp)) && (1 == exist(opfcaxis))) {
        killer_length = (4540 > (2.05*area_gy1grad))? 4540: (2.05*area_gy1grad);
    }
    
#endif


    /* find out if we are in sr17 mode */
    /*if (psd_getgradmode() == PSD_SR17)*/ /* MFO,Hino, Feb/02/00 MM */
    if ((psd_getgradmode() == PSD_SR17) || (psd_getgradmode() == PSD_SR25))
        sr17_scale = 1;
    else
        sr17_scale=0;

    /* initialize all scale factors to 1.0 */
    sat_scale1=sat_scale2=sat_scale3=sat_scale4=sat_scale5=sat_scale6=1.0;
    sat_scalex1=sat_scalex2=sat_scaley1=sat_scaley2=sat_scalez1=sat_scalez2=1.0; 

    if ((exist(opsaty) != PSD_OFF)||(exist(opsatz) != PSD_OFF))
    {
        area_gyksx1  = _area_gyksx1.fixedflag ?  ((void)(killer_length*0.5), area_gyksx1) : killer_length*0.5; 
        area_gyksx2  = _area_gyksx2.fixedflag ?  ((void)(killer_length*0.5), area_gyksx2) : killer_length*0.5;
        area_gxksx1  = _area_gxksx1.fixedflag ?  ((void)(0.0), area_gxksx1) : 0.0;
        area_gxksx2  = _area_gxksx2.fixedflag ?  ((void)(0.0), area_gxksx2) : 0.0;
        if (sr17_scale) sat_scalex1=sat_scalex2 = 0.5;
    }
    else 
    {
        if (exist(opsatx) ==  PSD_SATPARA)
        {
            area_gyksx1  = _area_gyksx1.fixedflag ?  ((void)(killer_length*0.5), area_gyksx1) : killer_length*0.5;
            area_gyksx2  = _area_gyksx2.fixedflag ?  ((void)(killer_length*0.95), area_gyksx2) : killer_length*0.95;
            area_gxksx1  = _area_gxksx1.fixedflag ?  ((void)(0.0), area_gxksx1) : 0.0;
            area_gxksx2  = _area_gxksx2.fixedflag ?  ((void)(-killer_length*0.95), area_gxksx2) : -killer_length*0.95;
            if (sr17_scale)
	    {
                sat_scalex1= 0.5;
                sat_scalex2 = 0.95;
	    }
        }
        else
        {
            area_gyksx1  = _area_gyksx1.fixedflag ?  ((void)(killer_length*0.95), area_gyksx1) : killer_length*0.95;
	    area_gyksx2  = _area_gyksx2.fixedflag ?  ((void)(killer_length*0.95), area_gyksx2) : killer_length*0.95;
	    area_gxksx1  = _area_gxksx1.fixedflag ?  ((void)(-killer_length*0.95), area_gxksx1) : -killer_length*0.95;
	    area_gxksx2  = _area_gxksx2.fixedflag ?  ((void)(0.0), area_gxksx2) : 0.0;
            if (sr17_scale) sat_scalex1 = sat_scalex2 = 0.95;
        }
    }
    
    if (exist(opsatz) != PSD_OFF) 
    {
        area_gyksy1  = _area_gyksy1.fixedflag ?  ((void)(killer_length*0.5), area_gyksy1) : killer_length*0.5;
        area_gyksy2  = _area_gyksy2.fixedflag ?  ((void)(killer_length*0.5), area_gyksy2) : killer_length*0.5;
        area_gxksy1  = _area_gxksy1.fixedflag ?  ((void)(0.0), area_gxksy1) : 0.0;
        area_gxksy2  = _area_gxksy2.fixedflag ?  ((void)(0.0), area_gxksy2) : 0.0;
        if (sr17_scale) sat_scaley1 = sat_scaley2 = 0.5;
    }
    else 
    {
        if (exist(opsaty) == PSD_SATPARA)
        {
            area_gyksy1  = _area_gyksy1.fixedflag ?  ((void)(killer_length*0.5), area_gyksy1) : killer_length*0.5;
            area_gyksy2  = _area_gyksy2.fixedflag ?  ((void)(killer_length*0.95), area_gyksy2) : killer_length*0.95;
	    area_gxksy1  = _area_gxksy1.fixedflag ?  ((void)(0.0), area_gxksy1) : 0.0;
	    area_gxksy2  = _area_gxksy2.fixedflag ?  ((void)(-killer_length*0.95), area_gxksy2) : -killer_length*0.95;
            if (sr17_scale)
            {
		sat_scaley1 = 0.5;
            	sat_scaley2 = 0.95;
            }
        }
        else
        {
            area_gyksy1  = _area_gyksy1.fixedflag ?  ((void)(killer_length*0.95), area_gyksy1) : killer_length*0.95;
	    area_gyksy2  = _area_gyksy2.fixedflag ?  ((void)(killer_length*0.95), area_gyksy2) : killer_length*0.95;
	    area_gxksy1  = _area_gxksy1.fixedflag ?  ((void)(-killer_length*0.95), area_gxksy1) : -killer_length*0.95;
	    area_gxksy2  = _area_gxksy2.fixedflag ?  ((void)(0.0), area_gxksy2) : 0.0;
            if (sr17_scale) sat_scaley1 = sat_scaley2 = 0.95;
        }
    }
    
    if (exist(opsatz) == PSD_SATPARA)
    {
        area_gyksz1  = _area_gyksz1.fixedflag ?  ((void)(killer_length*0.5), area_gyksz1) : killer_length*0.5;
        area_gyksz2  = _area_gyksz2.fixedflag ?  ((void)(killer_length*0.95), area_gyksz2) : killer_length*0.95;
        area_gxksz1  = _area_gxksz1.fixedflag ?  ((void)(0.0), area_gxksz1) : 0.0;
        area_gxksz2  = _area_gxksz2.fixedflag ?  ((void)(-killer_length*0.95), area_gxksz2) : -killer_length*0.95;
        if (sr17_scale)
        {
	    sat_scalez1 = 0.5;
	    sat_scalez2 = 0.95;
        }
    }
    else
    {
        area_gyksz1  = _area_gyksz1.fixedflag ?  ((void)(killer_length*0.95), area_gyksz1) : killer_length*0.95;
        area_gyksz2  = _area_gyksz2.fixedflag ?  ((void)(killer_length*0.95), area_gyksz2) : killer_length*0.95;
        area_gxksz1  = _area_gxksz1.fixedflag ?  ((void)(-killer_length*0.95), area_gxksz1) : -killer_length*0.95;
        area_gxksz2  = _area_gxksz2.fixedflag ?  ((void)(0.0), area_gxksz2) : 0.0;
        if (sr17_scale) sat_scalez1 = sat_scalez2 = 0.95;
    }
    
    /* If any default sat are on, all explicit sat killers are .5 */
    if ((exist(opsatx) != PSD_OFF) || (exist(opsaty) != PSD_OFF) ||
	(exist(opsatz) != PSD_OFF))
    {
        area_gykse1  = _area_gykse1.fixedflag ?  ((void)(killer_length*0.5), area_gykse1) : killer_length*0.5;
        area_gykse2  = _area_gykse2.fixedflag ?  ((void)(killer_length*0.5), area_gykse2) : killer_length*0.5;
        area_gykse3  = _area_gykse3.fixedflag ?  ((void)(killer_length*0.5), area_gykse3) : killer_length*0.5;
        area_gykse4  = _area_gykse4.fixedflag ?  ((void)(killer_length*0.5), area_gykse4) : killer_length*0.5;
        area_gykse5  = _area_gykse5.fixedflag ?  ((void)(killer_length*0.5), area_gykse5) : killer_length*0.5;
	area_gykse6  = _area_gykse6.fixedflag ?  ((void)(killer_length*0.5), area_gykse6) : killer_length*0.5; 

        area_gxkse1 = _area_gxkse1.fixedflag ?  ((void)(0.0), area_gxkse1) : 0.0;
        area_gxkse2 = _area_gxkse2.fixedflag ?  ((void)(0.0), area_gxkse2) : 0.0;
        area_gxkse3 = _area_gxkse3.fixedflag ?  ((void)(0.0), area_gxkse3) : 0.0;
        area_gxkse4 = _area_gxkse4.fixedflag ?  ((void)(0.0), area_gxkse4) : 0.0;
        area_gxkse5 = _area_gxkse5.fixedflag ?  ((void)(0.0), area_gxkse5) : 0.0;
        area_gxkse6 = _area_gxkse6.fixedflag ?  ((void)(0.0), area_gxkse6) : 0.0;

        if (sr17_scale)
            sat_scale1=sat_scale2=sat_scale3=sat_scale4=sat_scale5=sat_scale6=0.5;
    }
    else
    {
	/* If no default sats are on, the last explicit sat is set to .95
	   and rest are .5 */
        area_gykse1 = _area_gykse1.fixedflag ?  ((void)(killer_length*0.5), area_gykse1) : killer_length*0.5;
        area_gykse2 = _area_gykse2.fixedflag ?  ((void)(killer_length*0.5), area_gykse2) : killer_length*0.5;
        area_gykse3 = _area_gykse3.fixedflag ?  ((void)(killer_length*0.5), area_gykse3) : killer_length*0.5;
        area_gykse4 = _area_gykse4.fixedflag ?  ((void)(killer_length*0.5), area_gykse4) : killer_length*0.5;
        area_gykse5 = _area_gykse5.fixedflag ?  ((void)(killer_length*0.5), area_gykse5) : killer_length*0.5; 
        area_gykse6 = _area_gykse6.fixedflag ?  ((void)(killer_length*0.5), area_gykse6) : killer_length*0.5;
	
        area_gxkse1 = _area_gxkse1.fixedflag ?  ((void)(0.0), area_gxkse1) : 0.0;
        area_gxkse2 = _area_gxkse2.fixedflag ?  ((void)(0.0), area_gxkse2) : 0.0;
        area_gxkse3 = _area_gxkse3.fixedflag ?  ((void)(0.0), area_gxkse3) : 0.0;
        area_gxkse4 = _area_gxkse4.fixedflag ?  ((void)(0.0), area_gxkse4) : 0.0;
        area_gxkse5 = _area_gxkse5.fixedflag ?  ((void)(0.0), area_gxkse5) : 0.0;
        area_gxkse6 = _area_gxkse6.fixedflag ?  ((void)(0.0), area_gxkse6) : 0.0;
	xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_OFF), xkiller_set) : PSD_OFF;
	
        if (sr17_scale)
            sat_scale1=sat_scale2=sat_scale3=sat_scale4=sat_scale5=sat_scale6=0.5;

	/* Fix for SPR 17235. When a Hadamard pulse is the last pulse in the
           sequence, both killers must be set to .95. Only one is used
           later. */
        if ((exist(opexsatmask) & PSD_EXPLICIT_6) == PSD_EXPLICIT_6)
        {
	    area_gykse6  = _area_gykse6.fixedflag ?  ((void)(killer_length*0.95), area_gykse6) : killer_length*0.95;
	    area_gxkse6  = _area_gxkse6.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse6) : -killer_length*0.95;
	    xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
            if (sr17_scale) sat_scale6 = 0.95;
            if ((exist(opexsatparal) & PSD_3_PARALLEL) == PSD_3_PARALLEL)
            {
                area_gykse5  = _area_gykse5.fixedflag ?  ((void)(killer_length*0.95), area_gykse5) : killer_length*0.95;
		if (area_gxkse6!=0.0)
                {
		    area_gxkse5  = _area_gxkse5.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse5) : -killer_length*0.95;
		    area_gxkse6 = _area_gxkse6.fixedflag ? ((void)(0.0), area_gxkse6) : 0.0;
		    xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
                }
                if (sr17_scale) sat_scale5 = 0.95;
            }
        } 
        else if ((exist(opexsatmask) & PSD_EXPLICIT_5) == PSD_EXPLICIT_5)
        {
            area_gykse5  = _area_gykse5.fixedflag ?  ((void)(killer_length*0.95), area_gykse5) : killer_length*0.95;
	    if (xkiller_set==PSD_OFF)
            {
		area_gxkse5  = _area_gxkse5.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse5) : -killer_length*0.95;
		xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
            }
            if (sr17_scale) sat_scale5= 0.95;
        }
        else if ((exist(opexsatmask) & PSD_EXPLICIT_4) == PSD_EXPLICIT_4)
        {
            area_gykse4  = _area_gykse4.fixedflag ?  ((void)(killer_length*0.95), area_gykse4) : killer_length*0.95;
	    if (xkiller_set==PSD_OFF)
            {
		area_gxkse4  = _area_gxkse4.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse4) : -killer_length*0.95;
		xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
            }
            if (sr17_scale) sat_scale4 = 0.95;
            if ((exist(opexsatparal) & PSD_2_PARALLEL) == PSD_2_PARALLEL)
            {
                area_gykse3  = _area_gykse3.fixedflag ?  ((void)(killer_length*0.95), area_gykse3) : killer_length*0.95;
		if (area_gxkse4!=0.0)
                {
		    area_gxkse3  = _area_gxkse3.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse3) : -killer_length*0.95;
		    area_gxkse4  = _area_gxkse4.fixedflag ?  ((void)(0.0), area_gxkse4) : 0.0;
		    xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
                }
                if (sr17_scale) sat_scale3 = 0.95;
            }
        }
        else if ((exist(opexsatmask) & PSD_EXPLICIT_3) == PSD_EXPLICIT_3)
        {
            area_gykse3  = _area_gykse3.fixedflag ?  ((void)(killer_length*0.95), area_gykse3) : killer_length*0.95;
	    if (xkiller_set==PSD_OFF)
            {
		area_gxkse3  = _area_gxkse3.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse3) : -killer_length*0.95;
		xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
            }
            if (sr17_scale) sat_scale3 = 0.95;
        }
        else if ((exist(opexsatmask) & PSD_EXPLICIT_2) == PSD_EXPLICIT_2)
        {
            area_gykse2  = _area_gykse2.fixedflag ?  ((void)(killer_length*0.95), area_gykse2) : killer_length*0.95;
	    if (xkiller_set==PSD_OFF)
            {
		area_gxkse2  = _area_gxkse2.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse2) : -killer_length*0.95;
		xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
            }
            if (sr17_scale) sat_scale2 = 0.95;
            if ((exist(opexsatparal) & PSD_1_PARALLEL) == PSD_1_PARALLEL)
            {
                area_gykse1  = _area_gykse1.fixedflag ?  ((void)(killer_length*0.95), area_gykse1) : killer_length*0.95;
		if (area_gxkse2!=0.0)
                {
		    area_gxkse1  = _area_gxkse1.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse1) : -killer_length*0.95;
		    area_gxkse2  = _area_gxkse2.fixedflag ?  ((void)(0.0), area_gxkse2) : 0.0;
		    xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
                }
                if (sr17_scale) sat_scale1 = 0.95;
            } 
        }
        else if ((exist(opexsatmask) & PSD_EXPLICIT_1) == PSD_EXPLICIT_1)
        {
            area_gykse1  = _area_gykse1.fixedflag ?  ((void)(killer_length*0.95), area_gykse1) : killer_length*0.95;
	    if (xkiller_set==PSD_OFF)
            {
		area_gxkse1  = _area_gxkse1.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse1) : -killer_length*0.95;
		xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
            }
            if (sr17_scale) sat_scale1 = 0.95;
        }
    }

    /* set the areas to 0 if the XKILLER is not defined, a 0 area turns off pulsegen
       code and modifications */
#ifndef SPSATXKILLER
    area_gxksx1 = _area_gxksx1.fixedflag ?  ((void)(0.0), area_gxksx1) : 0.0;
    area_gxksx2 = _area_gxksx2.fixedflag ?  ((void)(0.0), area_gxksx2) : 0.0;
    area_gxksy1 = _area_gxksy1.fixedflag ?  ((void)(0.0), area_gxksy1) : 0.0;
    area_gxksy2 = _area_gxksy2.fixedflag ?  ((void)(0.0), area_gxksy2) : 0.0;
    area_gxksz1 = _area_gxksz1.fixedflag ?  ((void)(0.0), area_gxksz1) : 0.0;
    area_gxksz2 = _area_gxksz2.fixedflag ?  ((void)(0.0), area_gxksz2) : 0.0;
    area_gxkse1 = _area_gxkse1.fixedflag ?  ((void)(0.0), area_gxkse1) : 0.0;
    area_gxkse2 = _area_gxkse2.fixedflag ?  ((void)(0.0), area_gxkse2) : 0.0;
    area_gxkse3 = _area_gxkse3.fixedflag ?  ((void)(0.0), area_gxkse3) : 0.0;
    area_gxkse4 = _area_gxkse4.fixedflag ?  ((void)(0.0), area_gxkse4) : 0.0;
    area_gxkse5 = _area_gxkse5.fixedflag ?  ((void)(0.0), area_gxkse5) : 0.0;
    area_gxkse6 = _area_gxkse6.fixedflag ?  ((void)(0.0), area_gxkse6) : 0.0;
#endif

    satthickx1  = _satthickx1.fixedflag ?   ((void)((float)exist(opdfsathick1)), satthickx1) : (float)exist(opdfsathick1);
    satthickx2  = _satthickx2.fixedflag ?   ((void)((float)exist(opdfsathick2)), satthickx2) : (float)exist(opdfsathick2);
    satthicky1  = _satthicky1.fixedflag ?   ((void)((float)exist(opdfsathick3)), satthicky1) : (float)exist(opdfsathick3);
    satthicky2  = _satthicky2.fixedflag ?   ((void)((float)exist(opdfsathick4)), satthicky2) : (float)exist(opdfsathick4);
    satthickz1  = _satthickz1.fixedflag ?   ((void)((float)exist(opdfsathick5)), satthickz1) : (float)exist(opdfsathick5);
    satthickz2  = _satthickz2.fixedflag ?   ((void)((float)exist(opdfsathick6)), satthickz2) : (float)exist(opdfsathick6);

    /* If the debug flag is off then use the rotation matrices provided
       by scan for the explicit sat bands.  */ /* 3/13/95 YI */
    if (sat_debug == 0)
    {
        for (i=0; i<6; ++i)
        {
            sat_info[i][0] = eg_sat_rot[i][0];
            sat_info[i][1] = eg_sat_rot[i][3];
            sat_info[i][2] = eg_sat_rot[i][6];
            sat_info[i][3] = eg_sat_rot[i][1];
            sat_info[i][4] = eg_sat_rot[i][4];
            sat_info[i][5] = eg_sat_rot[i][7];
            sat_info[i][6] = eg_sat_rot[i][2];
            sat_info[i][7] = eg_sat_rot[i][5];
            sat_info[i][8] = eg_sat_rot[i][8];
        } 
    }
    /* For debugging purposing, set the rotation matrices to the unit vector.
       Disregard the rotation matrices from scan. */
    else
    {
        for (i = 0; i<6; ++i)
        {
            for (j=0; j <9; ++j)
                sat_info[i][j] = 0.0;

            sat_info[i][8] = 1.0;
        } 
    }

    if (opfluorotrigger)
    {
        for (i = 0; i<6; ++i)
        {
            /* SAT along S/I direction */
            sat_info[i][0] = 1.0;
            sat_info[i][1] = 0.0;
            sat_info[i][2] = 0.0;
            sat_info[i][3] = 0.0;
            sat_info[i][4] = 1.0;
            sat_info[i][5] = 0.0;
            sat_info[i][6] = 0.0;
            sat_info[i][7] = 0.0;
            sat_info[i][8] = 1.0;
        }
    }

    *time_spsat = 0;

    /* If a sat axis is hadamard, its effective width is decreased by a 
       factor of 2 due to the cosine modultation.  Since its amplitude is
       doubled, and power is proportional to the square of the amplitude 
       but only directly proportional to the effective width, a hadamard 
       pulse has twice the SAR as a single sideband pulse. */

    /*********************************************************/
    /* Default SAT band RF and gradient pulse structures.

    Rf pulses   Gradients
    RFSX1         GXSX1    
    RFSX2         GXSX2   
    RFSY1         GYSY1  
    RFSY2         GYSY2 
    RFSZ1         GZSZ1
    RFSZ2         GZSZ2

    Explicit SAT band RF and gradient pulse structures.

    Rf pulses   Gradients
    RFSE1         GZSE1    
    RFSE2         GZSE2   
    RFSE3         GZSE3  
    RFSE4         GZSE4 
    RFSE5         GZSE5
    RFSE6         GZSE6
    *************************************************************/

    /* DEFAULT SAT RF PULSE STRUCTURES */
    rfpulse[RFSX1_SLOT].num = 0;                    
    rfpulse[RFSX1_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSX2_SLOT].num = 0;                    
    rfpulse[RFSX2_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSY1_SLOT].num = 0;
    rfpulse[RFSY1_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSY2_SLOT].num = 0;
    rfpulse[RFSY2_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSZ1_SLOT].num = 0;
    rfpulse[RFSZ1_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSZ2_SLOT].num = 0;
    rfpulse[RFSZ2_SLOT].activity = PSD_PULSE_OFF;

    /* EXPLICIT SAT RF PULSE STRUCTURES */
    rfpulse[RFSE1_SLOT].num = 0;                    
    rfpulse[RFSE1_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSE2_SLOT].num = 0;                    
    rfpulse[RFSE2_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSE3_SLOT].num = 0;
    rfpulse[RFSE3_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSE4_SLOT].num = 0;
    rfpulse[RFSE4_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSE5_SLOT].num = 0;
    rfpulse[RFSE5_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSE6_SLOT].num = 0;
    rfpulse[RFSE6_SLOT].activity = PSD_PULSE_OFF;

    /* DEFAULT SAT X GRADIENT STRUCTURES */
    gradx[GXRFSX1_SLOT].num = 0;
    gradx[GXRFSX2_SLOT].num = 0;
      
    /* DEFAULT SAT Y GRADIENT STRUCTURES */
    grady[GYRFSY1_SLOT].num = 0;
    grady[GYRFSY2_SLOT].num = 0;

    /* DEFAULT SAT Z GRADIENT STRUCTURES */
    gradz[GZRFSZ1_SLOT].num = 0;
    gradz[GZRFSZ2_SLOT].num = 0;

    /* KILLERS FOR DEFAULT SAT GRADIENT STRUCTURES--ALWAYS ON Y */
    grady[GYKSX1_SLOT].num = 0;
    grady[GYKSX2_SLOT].num = 0;
    grady[GYKSY1_SLOT].num = 0;
    grady[GYKSY2_SLOT].num = 0;
    grady[GYKSZ1_SLOT].num = 0;
    grady[GYKSZ2_SLOT].num = 0;

    /* EXPLICIT SAT GRADIENT STRUCTURES */
    gradz[GZRFSE1_SLOT].num = 0;
    gradz[GZRFSE2_SLOT].num = 0;
    gradz[GZRFSE3_SLOT].num = 0;
    gradz[GZRFSE4_SLOT].num = 0;
    gradz[GZRFSE5_SLOT].num = 0;
    gradz[GZRFSE6_SLOT].num = 0;

    /* KILLERS FOR EXPLICIT SAT GRADIENT STRUCTURES--ALWAYS ON Y */
    grady[GYKSE1_SLOT].num = 0;
    grady[GYKSE2_SLOT].num = 0;
    grady[GYKSE3_SLOT].num = 0;
    grady[GYKSE4_SLOT].num = 0;
    grady[GYKSE5_SLOT].num = 0;
    grady[GYKSE6_SLOT].num = 0;

#ifdef SPSATXKILLER
    gradx[GXKSE1_SLOT].num = 0;
    gradx[GXKSE2_SLOT].num = 0;
    gradx[GXKSE3_SLOT].num = 0;
    gradx[GXKSE4_SLOT].num = 0;
    gradx[GXKSE5_SLOT].num = 0;
    gradx[GXKSE6_SLOT].num = 0;
    gradx[GXKSX1_SLOT].num = 0;
    gradx[GXKSX2_SLOT].num = 0;
    gradx[GXKSY1_SLOT].num = 0;
    gradx[GXKSY2_SLOT].num = 0;
    gradx[GXKSZ1_SLOT].num = 0;
    gradx[GXKSZ2_SLOT].num = 0;
#endif

    /* Scale all sat pulses to 1 initially. Scaling is done
       later on a per-entry point basis. */

    sat_rot_index  = _sat_rot_index.fixedflag ?  ((void)(0), sat_rot_index) : 0;
    array_index = 0;
    if ((opsatx != PSD_OFF) || (opsaty != PSD_OFF) || (opsatz != PSD_OFF) ||
        (opexsatmask != PSD_OFF))
    {
        /**********************************************************
          EXPLICIT SAT PROCESSING 

        opexsatmask = mask where each bit represents an explicit sat
                      band ( a limit of 6 bands are allowed)

       1. Check if sat band exists. 
       2. Initialize the rf & gradient pulse structures to the correct
          number of pulses
       3. Place rotation matrix for SAT band in array. Array contains
          rotation matrices in order of playout for SAT bands.
       4. Set up rf pulse structure for correct type of RF pulse
       5. Check if two explicit sat bands are parallel. If so, then a
          Hadamard RF pulse can be used to create both sat bands. 
          Initialize the rf & gradient pulse structures appropriately. 
          The next explicit sat band can be skipped since it has already
          been accounted for the in the Hadamard pulse.
       6. Compute the slice select amplitude. 
       7. Calculate the time needed to play out the sat pulses. 
          The sp_killerdelay occurs between the sat slice select and the 
          killer to accomodate the ISI & matrix update when all gradients 
          are zero. The rot_delay occurs after the killer to update
          rotation matrix when all gradients are zero.
       8. If the next pulse hasn't been accounted for via the Hadamard
          pulse, process the next pulse.

        ****************************************************************/

        parallel_mask = exist(opexsatparal);
        explicit_sat_mask = exist(opexsatmask);

        exsatthick1  = _exsatthick1.fixedflag ?   ((void)((float)exist(opexsathick1)), exsatthick1) : (float)exist(opexsathick1);
        exsatthick2  = _exsatthick2.fixedflag ?   ((void)((float)exist(opexsathick2)), exsatthick2) : (float)exist(opexsathick2);
        exsatthick3  = _exsatthick3.fixedflag ?   ((void)((float)exist(opexsathick3)), exsatthick3) : (float)exist(opexsathick3);
        exsatthick4  = _exsatthick4.fixedflag ?   ((void)((float)exist(opexsathick4)), exsatthick4) : (float)exist(opexsathick4);
        exsatthick5  = _exsatthick5.fixedflag ?   ((void)((float)exist(opexsathick5)), exsatthick5) : (float)exist(opexsathick5);
        exsatthick6  = _exsatthick6.fixedflag ?   ((void)((float)exist(opexsathick6)), exsatthick6) : (float)exist(opexsathick6);

        if (opfluorotrigger)
        {
            float temploc1, temploc2;

            temploc1= -0.5*(exist(opfov)+exist(opexsathick1)-20.0);
            temploc2= +0.5*(exist(opfov)+exist(opexsathick2)-20.0);

            if (temploc1 < -rtia3d_sat_pos )
                temploc1 = -rtia3d_sat_pos;

            if (temploc2 > rtia3d_sat_pos )
	        temploc2 = rtia3d_sat_pos;

            cvoverride( opexsatloc1, temploc1, PSD_FIX_ON, PSD_EXIST_ON); 
            cvoverride( opexsatloc2, temploc2 , PSD_FIX_ON, PSD_EXIST_ON); 
        }
    
        skip_next_sat = 0;
        if ((explicit_sat_mask & PSD_EXPLICIT_1) != 0)
        {
            sp_set_num_pulses(&rfpulse[RFSE1_SLOT], &gradz[GZRFSE1_SLOT]);
            grady[GYKSE1_SLOT].num = 1;

            if ((opweight >= csweight) && 
                (TX_COIL_BODY == getTxCoilType()) && 
                ((exist(opexsatparal) & PSD_1_PARALLEL) == PSD_1_PARALLEL))
            {
                SDL_InitSPSATRFPulseInfo(cffield,RFSE1_SLOT,_pw_rfse1.fixedflag ? (_temp661_pw_rfse1=pw_rfse1,&_temp661_pw_rfse1) : &pw_rfse1,rfpulseInfo);
            }

            sp_get_rot_matrix(&sat_info[0][0],
                              &sat_rot_matrices[array_index][0]);
            /* transfer sat_info to the structure obloptimize needs */
            sp_get_scaninfo_matrix(&sat_info[0][0],&satscaninfo);
            /* call opbloptimize with sat_scaninfo */
            if (obloptimize(&satloggrd, &phygrd, 
                            &satscaninfo, 1,
                            PSD_OBL, SAT_COAX, SAT_OBL_METHOD,
                            sat_obl_debug, _sat_newgeo.fixedflag ? (_temp662_sat_newgeo=sat_newgeo,&_temp662_sat_newgeo) : &sat_newgeo, cfsrmode)==FAILURE) {
                epic_error(use_ermes, failstr, EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "obloptimize:sat");
                return FAILURE;
            }
            sp_set_rfpulse(vrgsat, &rfpulse[RFSE1_SLOT], _res_rfse1.fixedflag ? (_temp663_res_rfse1=res_rfse1,&_temp663_res_rfse1) : &res_rfse1,
                           _pw_rfse1.fixedflag ? (_temp664_pw_rfse1=pw_rfse1,&_temp664_pw_rfse1) : &pw_rfse1, &bw_rfse1, SAT_EXPLICIT);

            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;

            /* Can use Hadamard RF pulse */
            if ((parallel_mask & PSD_1_PARALLEL) != 0)
            {
                skip_next_sat = 1;
              
                rfpulse[RFSE1_SLOT].effwidth = effwidth_sat * 0.5;
                rfpulse[RFSE1_SLOT].abswidth = abswidth_sat * 0.5;
                rfpulse[RFSE1_SLOT].activity += (PSD_APS2_HAD - PSD_APS2_ON) + 
                    (PSD_MPS2_HAD - PSD_MPS2_ON) + (PSD_SCAN_HAD - PSD_SCAN_ON);
            }

            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,cfgcoiltype,&rfpulse[RFSE1_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSE1_SLOT],RFSE1_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gzrfse1.fixedflag ? (_temp665_pw_gzrfse1=pw_gzrfse1,&_temp665_pw_gzrfse1) : &pw_gzrfse1, _pw_gzrfse1a.fixedflag ? (_temp666_pw_gzrfse1a=pw_gzrfse1a,&_temp666_pw_gzrfse1a) : &pw_gzrfse1a, 
                                         _pw_gzrfse1d.fixedflag ? (_temp667_pw_gzrfse1d=pw_gzrfse1d,&_temp667_pw_gzrfse1d) : &pw_gzrfse1d, pw_rfse1, _a_gzrfse1.fixedflag ? (_temp668_a_gzrfse1=a_gzrfse1,&_temp668_a_gzrfse1) : &a_gzrfse1, &bw_rfse1, exsatthick1,
                                         satloggrd.tz,satloggrd.zrt,vrgsat);
            gradz[GZRFSE1_SLOT].powscale = satloggrd.zfs/satloggrd.tz;
            /* set .powscale  QT*/

            if (status == FAILURE)
                return (FAILURE);

            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if(amppwgradmethod(&grady[GYKSE1_SLOT],area_gykse1,
                               loggrd.ty*sat_scale1,0.0,0.0,
                               loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gykse1");
                return FAILURE;
            }	
            grady[GYKSE1_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scale1);
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gykse1a+pw_gykse1+pw_gykse1d), maxkiller_time) : pw_gykse1a+pw_gykse1+pw_gykse1d;


            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (area_gxkse1 != 0.0)
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSE1_SLOT],area_gykse1,
                                   loggrd.ty_xy*sat_scale1,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gykse1");
                    return FAILURE;
                }
                grady[GYKSE1_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scale1);

                gradx[GXKSE1_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSE1_SLOT],area_gxkse1,
                                   loggrd.tx_xy*sat_scale1,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxkse1");
                    return FAILURE;
                }	
                gradx[GXKSE1_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scale1);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gykse1a+pw_gykse1+pw_gykse1d,pw_gxkse1a+pw_gxkse1+pw_gxkse1d)), maxkiller_time) : IMax(2,pw_gykse1a+pw_gykse1+pw_gykse1d,pw_gxkse1a+pw_gxkse1+pw_gxkse1d);
#endif
	    }

            *time_spsat += pw_gzrfse1a + pw_rfse1 +
                RUP_GRD(IMax(2,pw_gzrfse1d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
        }

        if (((explicit_sat_mask & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0))
        {
            sp_set_num_pulses(&rfpulse[RFSE2_SLOT], &gradz[GZRFSE2_SLOT]);
            grady[GYKSE2_SLOT].num = 1;

            sp_get_rot_matrix(&sat_info[1][0],
                              &sat_rot_matrices[array_index][0]);
            /* transfer sat_info to the structure obloptimize needs */
            sp_get_scaninfo_matrix(&sat_info[1][0],&satscaninfo);
            /* call opbloptimize with sat_scaninfo */
            if (obloptimize(&satloggrd, &phygrd, 
                            &satscaninfo, 1,
                            PSD_OBL, SAT_COAX, SAT_OBL_METHOD,
                            sat_obl_debug, _sat_newgeo.fixedflag ? (_temp669_sat_newgeo=sat_newgeo,&_temp669_sat_newgeo) : &sat_newgeo, cfsrmode)==FAILURE) {
                epic_error(use_ermes, failstr, EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "obloptimize:sat");
                return FAILURE;
            }

            sp_set_rfpulse(vrgsat, &rfpulse[RFSE2_SLOT], _res_rfse2.fixedflag ? (_temp670_res_rfse2=res_rfse2,&_temp670_res_rfse2) : &res_rfse2,
                           _pw_rfse2.fixedflag ? (_temp671_pw_rfse2=pw_rfse2,&_temp671_pw_rfse2) : &pw_rfse2, &bw_rfse2, SAT_EXPLICIT);

            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;

            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,cfgcoiltype,&rfpulse[RFSE2_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSE2_SLOT],RFSE2_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gzrfse2.fixedflag ? (_temp672_pw_gzrfse2=pw_gzrfse2,&_temp672_pw_gzrfse2) : &pw_gzrfse2, _pw_gzrfse2a.fixedflag ? (_temp673_pw_gzrfse2a=pw_gzrfse2a,&_temp673_pw_gzrfse2a) : &pw_gzrfse2a, 
                                         _pw_gzrfse2d.fixedflag ? (_temp674_pw_gzrfse2d=pw_gzrfse2d,&_temp674_pw_gzrfse2d) : &pw_gzrfse2d, pw_rfse2, _a_gzrfse2.fixedflag ? (_temp675_a_gzrfse2=a_gzrfse2,&_temp675_a_gzrfse2) : &a_gzrfse2, &bw_rfse2, exsatthick2,
                                         satloggrd.tz,satloggrd.zrt,vrgsat);

            gradz[GZRFSE2_SLOT].powscale = satloggrd.zfs/satloggrd.tz;
            /* set .powscale  QT*/
            if (status == FAILURE)
                return (FAILURE);


            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if(amppwgradmethod(&grady[GYKSE2_SLOT],area_gykse2,
                               loggrd.ty*sat_scale2,0.0,0.0,
                               loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gykse2");
                return FAILURE;
            }	
          
	    grady[GYKSE2_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scale2);
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gykse2a+pw_gykse2+pw_gykse2d), maxkiller_time) : pw_gykse2a+pw_gykse2+pw_gykse2d;

            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (area_gxkse2 != 0.0)
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSE2_SLOT],area_gykse2,
                                   loggrd.ty_xy*sat_scale2,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gykse2");
                    return FAILURE;
                }
          
		grady[GYKSE2_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scale2);

                gradx[GXKSE2_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSE2_SLOT],area_gxkse2,
                                   loggrd.tx_xy*sat_scale2,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxkse2");
                    return FAILURE;
                }	
          
		gradx[GXKSE2_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scale2);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gykse2a+pw_gykse2+pw_gykse2d,pw_gxkse2a+pw_gxkse2+pw_gxkse2d)), maxkiller_time) : IMax(2,pw_gykse2a+pw_gykse2+pw_gykse2d,pw_gxkse2a+pw_gxkse2+pw_gxkse2d);
#endif
	    }
            *time_spsat += pw_gzrfse2a + pw_rfse2 +
                RUP_GRD(IMax(2,pw_gzrfse2d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
        }
     
     
        skip_next_sat = 0;
        if ((explicit_sat_mask & PSD_EXPLICIT_3) != 0)
        {
            sp_set_num_pulses(&rfpulse[RFSE3_SLOT], &gradz[GZRFSE3_SLOT]);
            grady[GYKSE3_SLOT].num = 1;

            if ((opweight >= csweight) && 
                (TX_COIL_BODY == getTxCoilType()) &&
                ((exist(opexsatparal) & PSD_2_PARALLEL) == PSD_2_PARALLEL))
            {
                SDL_InitSPSATRFPulseInfo(cffield,RFSE3_SLOT,_pw_rfse3.fixedflag ? (_temp676_pw_rfse3=pw_rfse3,&_temp676_pw_rfse3) : &pw_rfse3,rfpulseInfo);
            }

            sp_get_rot_matrix(&sat_info[2][0],
                              &sat_rot_matrices[array_index][0]);
            /* transfer sat_info to the structure obloptimize needs */
            sp_get_scaninfo_matrix(&sat_info[2][0],&satscaninfo);
            /* call opbloptimize with sat_scaninfo */
            if (obloptimize(&satloggrd, &phygrd, 
                            &satscaninfo, 1,
                            PSD_OBL, SAT_COAX, SAT_OBL_METHOD,
                            sat_obl_debug, _sat_newgeo.fixedflag ? (_temp677_sat_newgeo=sat_newgeo,&_temp677_sat_newgeo) : &sat_newgeo, cfsrmode)==FAILURE) {
                epic_error(use_ermes, failstr, EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "obloptimize:sat");
                return FAILURE;
            }

            sp_set_rfpulse(vrgsat, &rfpulse[RFSE3_SLOT], _res_rfse3.fixedflag ? (_temp678_res_rfse3=res_rfse3,&_temp678_res_rfse3) : &res_rfse3,
                           _pw_rfse3.fixedflag ? (_temp679_pw_rfse3=pw_rfse3,&_temp679_pw_rfse3) : &pw_rfse3, &bw_rfse3, SAT_EXPLICIT);

            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;

            /* Can use Hadamard RF pulse */
            if ((parallel_mask & PSD_2_PARALLEL) != 0)
            {
                skip_next_sat = 1;
              
                rfpulse[RFSE3_SLOT].effwidth = effwidth_sat * 0.5;
                rfpulse[RFSE3_SLOT].abswidth = abswidth_sat * 0.5;
                rfpulse[RFSE3_SLOT].activity += (PSD_APS2_HAD - PSD_APS2_ON) + 
                    (PSD_MPS2_HAD - PSD_MPS2_ON) + (PSD_SCAN_HAD - PSD_SCAN_ON);
            }

            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,cfgcoiltype,&rfpulse[RFSE3_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSE3_SLOT],RFSE3_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gzrfse3.fixedflag ? (_temp680_pw_gzrfse3=pw_gzrfse3,&_temp680_pw_gzrfse3) : &pw_gzrfse3, _pw_gzrfse3a.fixedflag ? (_temp681_pw_gzrfse3a=pw_gzrfse3a,&_temp681_pw_gzrfse3a) : &pw_gzrfse3a, 
                                         _pw_gzrfse3d.fixedflag ? (_temp682_pw_gzrfse3d=pw_gzrfse3d,&_temp682_pw_gzrfse3d) : &pw_gzrfse3d, pw_rfse3, _a_gzrfse3.fixedflag ? (_temp683_a_gzrfse3=a_gzrfse3,&_temp683_a_gzrfse3) : &a_gzrfse3, &bw_rfse3, exsatthick3,
                                         satloggrd.tz,satloggrd.zrt,vrgsat);
            gradz[GZRFSE3_SLOT].powscale = satloggrd.zfs/satloggrd.tz;
            /* set .powscale  QT*/

            if (status == FAILURE)
                return (FAILURE);

            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if(amppwgradmethod(&grady[GYKSE3_SLOT],area_gykse3,
                               loggrd.ty*sat_scale3,0.0,0.0,
                               loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gykse3");
                return FAILURE;
            }	
            grady[GYKSE3_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scale3);
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gykse3a+pw_gykse3+pw_gykse3d), maxkiller_time) : pw_gykse3a+pw_gykse3+pw_gykse3d;


            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (area_gxkse3 != 0.0)
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSE3_SLOT],area_gykse3,
                                   loggrd.ty_xy*sat_scale3,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gykse3");
                    return FAILURE;
                }
                grady[GYKSE3_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scale3);

                gradx[GXKSE3_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSE3_SLOT],area_gxkse3,
                                   loggrd.tx_xy*sat_scale3,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxkse3");
                    return FAILURE;
                }	
                gradx[GXKSE3_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scale3);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gykse3a+pw_gykse3+pw_gykse3d,pw_gxkse3a+pw_gxkse3+pw_gxkse3d)), maxkiller_time) : IMax(2,pw_gykse3a+pw_gykse3+pw_gykse3d,pw_gxkse3a+pw_gxkse3+pw_gxkse3d);
#endif
	    }
            *time_spsat += pw_gzrfse3a + pw_rfse3 +
                RUP_GRD(IMax(2,pw_gzrfse3d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
        }

        grady[GYKSE4_SLOT].num = 0;
        if (((explicit_sat_mask & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0))
        {
            sp_set_num_pulses(&rfpulse[RFSE4_SLOT], &gradz[GZRFSE4_SLOT]);
            grady[GYKSE4_SLOT].num = 1;
 
            sp_get_rot_matrix(&sat_info[3][0],
                              &sat_rot_matrices[array_index][0]);
            /* transfer sat_info to the structure obloptimize needs */
            sp_get_scaninfo_matrix(&sat_info[3][0],&satscaninfo);
            /* call opbloptimize with sat_scaninfo */
            if (obloptimize(&satloggrd, &phygrd, 
                            &satscaninfo, 1,
                            PSD_OBL, SAT_COAX, SAT_OBL_METHOD,
                            sat_obl_debug, _sat_newgeo.fixedflag ? (_temp684_sat_newgeo=sat_newgeo,&_temp684_sat_newgeo) : &sat_newgeo, cfsrmode)==FAILURE) {
                epic_error(use_ermes, failstr, EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "obloptimize:sat");
                return FAILURE;
            }

            sp_set_rfpulse(vrgsat, &rfpulse[RFSE4_SLOT], _res_rfse4.fixedflag ? (_temp685_res_rfse4=res_rfse4,&_temp685_res_rfse4) : &res_rfse4,
                           _pw_rfse4.fixedflag ? (_temp686_pw_rfse4=pw_rfse4,&_temp686_pw_rfse4) : &pw_rfse4, &bw_rfse4, SAT_EXPLICIT);

            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;

            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,cfgcoiltype,&rfpulse[RFSE4_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSE4_SLOT],RFSE4_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gzrfse4.fixedflag ? (_temp687_pw_gzrfse4=pw_gzrfse4,&_temp687_pw_gzrfse4) : &pw_gzrfse4, _pw_gzrfse4a.fixedflag ? (_temp688_pw_gzrfse4a=pw_gzrfse4a,&_temp688_pw_gzrfse4a) : &pw_gzrfse4a, 
                                         _pw_gzrfse4d.fixedflag ? (_temp689_pw_gzrfse4d=pw_gzrfse4d,&_temp689_pw_gzrfse4d) : &pw_gzrfse4d, pw_rfse4, _a_gzrfse4.fixedflag ? (_temp690_a_gzrfse4=a_gzrfse4,&_temp690_a_gzrfse4) : &a_gzrfse4, &bw_rfse4, exsatthick4,
                                         satloggrd.tz,satloggrd.zrt,vrgsat);
            gradz[GZRFSE4_SLOT].powscale = satloggrd.zfs/satloggrd.tz;
            /* set .powscale    QT*/

            if (status == FAILURE)
                return (FAILURE);

            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if(amppwgradmethod(&grady[GYKSE4_SLOT],area_gykse4,
                               loggrd.ty*sat_scale4,0.0,0.0,
                               loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gykse4");
                return FAILURE;
            }	
            grady[GYKSE4_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scale4);
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gykse4a+pw_gykse4+pw_gykse4d), maxkiller_time) : pw_gykse4a+pw_gykse4+pw_gykse4d;


            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (area_gxkse4 != 0.0)
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSE4_SLOT],area_gykse4,
                                   loggrd.ty_xy*sat_scale4,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gykse4");
                    return FAILURE;
                }
                grady[GYKSE4_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scale4);

                gradx[GXKSE4_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSE4_SLOT],area_gxkse4,
                                   loggrd.tx_xy*sat_scale4,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxkse4");
                    return FAILURE;
                }	
                gradx[GXKSE4_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scale4);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gykse4a+pw_gykse4+pw_gykse4d,pw_gxkse4a+pw_gxkse4+pw_gxkse4d)), maxkiller_time) : IMax(2,pw_gykse4a+pw_gykse4+pw_gykse4d,pw_gxkse4a+pw_gxkse4+pw_gxkse4d);
#endif
	    }
            *time_spsat += pw_gzrfse4a + pw_rfse4 +
                RUP_GRD(IMax(2,pw_gzrfse4d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
        }

        skip_next_sat = 0;
        if ((explicit_sat_mask & PSD_EXPLICIT_5) != 0)
        {
            sp_set_num_pulses(&rfpulse[RFSE5_SLOT], &gradz[GZRFSE5_SLOT]);
            grady[GYKSE5_SLOT].num = 1;

            if ((opweight >= csweight) &&
                (TX_COIL_BODY == getTxCoilType()) &&
                ((exist(opexsatparal) & PSD_3_PARALLEL) == PSD_3_PARALLEL))
            {
                SDL_InitSPSATRFPulseInfo(cffield,RFSE5_SLOT,_pw_rfse5.fixedflag ? (_temp691_pw_rfse5=pw_rfse5,&_temp691_pw_rfse5) : &pw_rfse5,rfpulseInfo);
            }

            sp_get_rot_matrix(&sat_info[4][0],
                              &sat_rot_matrices[array_index][0]);
            /* transfer sat_info to the structure obloptimize needs */
            sp_get_scaninfo_matrix(&sat_info[4][0],&satscaninfo);
            /* call opbloptimize with sat_scaninfo */
            if (obloptimize(&satloggrd, &phygrd, 
                            &satscaninfo, 1,
                            PSD_OBL, SAT_COAX, SAT_OBL_METHOD,
                            sat_obl_debug, _sat_newgeo.fixedflag ? (_temp692_sat_newgeo=sat_newgeo,&_temp692_sat_newgeo) : &sat_newgeo, cfsrmode)==FAILURE) {
                epic_error(use_ermes, failstr, EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "obloptimize:sat");
                return FAILURE;
            }

            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;

            sp_set_rfpulse(vrgsat, &rfpulse[RFSE5_SLOT], _res_rfse5.fixedflag ? (_temp693_res_rfse5=res_rfse5,&_temp693_res_rfse5) : &res_rfse5,
                           _pw_rfse5.fixedflag ? (_temp694_pw_rfse5=pw_rfse5,&_temp694_pw_rfse5) : &pw_rfse5, &bw_rfse5, SAT_EXPLICIT);

            /* Can use Hadamard RF pulse */
            if ((parallel_mask & PSD_3_PARALLEL) != 0)
            {
                skip_next_sat = 1;
              
                rfpulse[RFSE5_SLOT].effwidth = effwidth_sat * 0.5;
                rfpulse[RFSE5_SLOT].abswidth = abswidth_sat * 0.5;
                rfpulse[RFSE5_SLOT].activity += (PSD_APS2_HAD - PSD_APS2_ON) + 
                    (PSD_MPS2_HAD - PSD_MPS2_ON) + (PSD_SCAN_HAD - PSD_SCAN_ON);
            }

            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,cfgcoiltype,&rfpulse[RFSE5_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSE5_SLOT],RFSE5_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gzrfse5.fixedflag ? (_temp695_pw_gzrfse5=pw_gzrfse5,&_temp695_pw_gzrfse5) : &pw_gzrfse5, _pw_gzrfse5a.fixedflag ? (_temp696_pw_gzrfse5a=pw_gzrfse5a,&_temp696_pw_gzrfse5a) : &pw_gzrfse5a, 
                                         _pw_gzrfse5d.fixedflag ? (_temp697_pw_gzrfse5d=pw_gzrfse5d,&_temp697_pw_gzrfse5d) : &pw_gzrfse5d, pw_rfse5, _a_gzrfse5.fixedflag ? (_temp698_a_gzrfse5=a_gzrfse5,&_temp698_a_gzrfse5) : &a_gzrfse5, &bw_rfse5, exsatthick5,
                                         satloggrd.tz,satloggrd.zrt,vrgsat);
            gradz[GZRFSE5_SLOT].powscale = satloggrd.zfs/satloggrd.tz;
            /* set .powscale    QT*/

            if (status == FAILURE)
                return (FAILURE);

            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if(amppwgradmethod(&grady[GYKSE5_SLOT],area_gykse5,
                               loggrd.ty*sat_scale5,0.0,0.0,
                               loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gykse5");
                return FAILURE;
            }	
            grady[GYKSE5_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scale5);
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gykse5a+pw_gykse5+pw_gykse5d), maxkiller_time) : pw_gykse5a+pw_gykse5+pw_gykse5d;


            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (area_gxkse5 != 0.0)
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSE5_SLOT],area_gykse5,
                                   loggrd.ty_xy*sat_scale5,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gykse5");
                    return FAILURE;
                }
                grady[GYKSE5_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scale5);

                gradx[GXKSE5_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSE5_SLOT],area_gxkse5,
                                   loggrd.tx_xy*sat_scale5,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxkse5");
                    return FAILURE;
                }	
                gradx[GXKSE5_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scale5);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gykse5a+pw_gykse5+pw_gykse5d,pw_gxkse5a+pw_gxkse5+pw_gxkse5d)), maxkiller_time) : IMax(2,pw_gykse5a+pw_gykse5+pw_gykse5d,pw_gxkse5a+pw_gxkse5+pw_gxkse5d);
#endif
	    }

            *time_spsat += pw_gzrfse5a + pw_rfse5 +
                RUP_GRD(IMax(2,pw_gzrfse5d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
        }


        grady[GYKSE6_SLOT].num = 0;
        if (((explicit_sat_mask & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0))
        {
            sp_set_num_pulses(&rfpulse[RFSE6_SLOT], &gradz[GZRFSE6_SLOT]);
            grady[GYKSE6_SLOT].num = 1;


            sp_get_rot_matrix(&sat_info[5][0],
                              &sat_rot_matrices[array_index][0]);
            /* transfer sat_info to the structure obloptimize needs */
            sp_get_scaninfo_matrix(&sat_info[5][0],&satscaninfo);
            /* call opbloptimize with sat_scaninfo */
            if (obloptimize(&satloggrd, &phygrd, 
                            &satscaninfo, 1,
                            PSD_OBL, SAT_COAX, SAT_OBL_METHOD,
                            sat_obl_debug, _sat_newgeo.fixedflag ? (_temp699_sat_newgeo=sat_newgeo,&_temp699_sat_newgeo) : &sat_newgeo, cfsrmode)==FAILURE) {
                epic_error(use_ermes, failstr, EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "obloptimize:sat");
                return FAILURE;
            }

            sp_set_rfpulse(vrgsat, &rfpulse[RFSE6_SLOT], _res_rfse6.fixedflag ? (_temp700_res_rfse6=res_rfse6,&_temp700_res_rfse6) : &res_rfse6,
                           _pw_rfse6.fixedflag ? (_temp701_pw_rfse6=pw_rfse6,&_temp701_pw_rfse6) : &pw_rfse6, &bw_rfse6, SAT_EXPLICIT);

            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;


            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,cfgcoiltype,&rfpulse[RFSE6_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSE6_SLOT],RFSE6_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gzrfse6.fixedflag ? (_temp702_pw_gzrfse6=pw_gzrfse6,&_temp702_pw_gzrfse6) : &pw_gzrfse6, _pw_gzrfse6a.fixedflag ? (_temp703_pw_gzrfse6a=pw_gzrfse6a,&_temp703_pw_gzrfse6a) : &pw_gzrfse6a, 
                                         _pw_gzrfse6d.fixedflag ? (_temp704_pw_gzrfse6d=pw_gzrfse6d,&_temp704_pw_gzrfse6d) : &pw_gzrfse6d, pw_rfse6, _a_gzrfse6.fixedflag ? (_temp705_a_gzrfse6=a_gzrfse6,&_temp705_a_gzrfse6) : &a_gzrfse6, &bw_rfse6, exsatthick6,
                                         satloggrd.tz,satloggrd.zrt,vrgsat);
            gradz[GZRFSE6_SLOT].powscale = satloggrd.zfs/satloggrd.tz;
            /* set .powscale    QT*/

            if (status == FAILURE)
                return (FAILURE);

            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if(amppwgradmethod(&grady[GYKSE6_SLOT],area_gykse6,
                               loggrd.ty*sat_scale6,0.0,0.0,
                               loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gykse6");
                return FAILURE;
            }	
            grady[GYKSE6_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scale6);
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gykse6a+pw_gykse6+pw_gykse6d), maxkiller_time) : pw_gykse6a+pw_gykse6+pw_gykse6d;


            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (area_gxkse6 != 0.0)
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSE6_SLOT],area_gykse6,
                                   loggrd.ty_xy*sat_scale6,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gykse6");
                    return FAILURE;
                }
                grady[GYKSE6_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scale6);

                gradx[GXKSE6_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSE6_SLOT],area_gxkse6,
                                   loggrd.tx_xy*sat_scale6,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxkse6");
                    return FAILURE;
                }	
                gradx[GXKSE6_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scale6);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gykse6a+pw_gykse6+pw_gykse6d,pw_gxkse6a+pw_gxkse6+pw_gxkse6d)), maxkiller_time) : IMax(2,pw_gykse6a+pw_gykse6+pw_gykse6d,pw_gxkse6a+pw_gxkse6+pw_gxkse6d);
#endif
	    }

            *time_spsat += pw_gzrfse6a + pw_rfse6 +
                RUP_GRD(IMax(2,pw_gzrfse6d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
	}
      
        sat_rot_ex_num  = _sat_rot_ex_num.fixedflag ?  ((void)(sat_rot_index), sat_rot_ex_num) : sat_rot_index; 

        /***************************************************************
        DEFAULT SAT PROCESSING 

       opsat<x,y,z> = 1   ==>  one direction SAT band
                      2   ==>  opposite direction SAT band
                      3   ==>  2 parallel SAT band with the same thickness
                                 can use Hadamard Rf pulse
                      4   ==>  2 parallel SAT bands but not same thickness 
                                 use two separate RF pulses

       1. Initialize the rf & gradient pulse structures to the correct
          number of pulses
       2. Set up rf pulse structure for correct type of RF pulse
       3. Save place in sat rotation matrix. Filled out during scan.
       4. If 2 sat bands are parallel but not the same thickness, two
          separate RF pulses are required. Initialize the rf & gradient
          pulse structures appropriately.
       5. If 2 sat bands are parallel with the same thickness, 1 haramard
          RF pulse can be used for both bands. Set the rf pulse structure
          appropriately.
       6. Compute the slice select amplitude. For the opsat case equal to
          4, 2 slice select gradients are needed.
       7. Calculate the time needed to play out the sat pulses. 
          The sp_killerdelay occurs between the sat slice select and the 
          killer to accomodate the ISI & matrix update when all gradients 
          are zero. The rot_delay occurs after the killer to update
          rotation matrix when all gradients are zero.
 
        **************************************************************/

        if (exist(opsatx) != PSD_OFF) 
        {
            sp_set_num_pulses(&rfpulse[RFSX1_SLOT], &gradx[GXRFSX1_SLOT]);
            grady[GYKSX1_SLOT].num = 1;
	  
            if ((opweight >= csweight) && 
                (TX_COIL_BODY == getTxCoilType()) &&
                (exist(opsatx) == PSD_SATHAD) )
            {
                SDL_InitSPSATRFPulseInfo(cffield,RFSX1_SLOT,_pw_rfsx1.fixedflag ? (_temp706_pw_rfsx1=pw_rfsx1,&_temp706_pw_rfsx1) : &pw_rfsx1,rfpulseInfo);
            }

            sp_set_rfpulse(vrgsat, &rfpulse[RFSX1_SLOT], _res_rfsx1.fixedflag ? (_temp707_res_rfsx1=res_rfsx1,&_temp707_res_rfsx1) : &res_rfsx1, 
                           _pw_rfsx1.fixedflag ? (_temp708_pw_rfsx1=pw_rfsx1,&_temp708_pw_rfsx1) : &pw_rfsx1, &bw_rfsx1, SAT_DEFAULT);
	  
            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;
	  
            /* 2 parallel SAT band w/distinct thickness => separate RF */
            if (exist(opsatx) == PSD_SATPARA) 
            {
                sp_set_num_pulses(&rfpulse[RFSX2_SLOT], &gradx[GXRFSX2_SLOT]);
                grady[GYKSX2_SLOT].num = 1;
	      
                sp_set_rfpulse(vrgsat, &rfpulse[RFSX2_SLOT], _res_rfsx2.fixedflag ? (_temp709_res_rfsx2=res_rfsx2,&_temp709_res_rfsx2) : &res_rfsx2,
                               _pw_rfsx2.fixedflag ? (_temp710_pw_rfsx2=pw_rfsx2,&_temp710_pw_rfsx2) : &pw_rfsx2, &bw_rfsx2, SAT_DEFAULT);
                sat_rot_index  = _sat_rot_index.fixedflag ?   ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
                array_index += 2;
            }
            else
            {
                rfpulse[RFSX2_SLOT].num = 0;
                gradx[GXRFSX2_SLOT].num = 0;
                grady[GYKSX2_SLOT].num = 0;
            }
	  
	  
            /* 2 parallel SAT bands w/same thickness => Hadamard RF */
            if (exist(opsatx) == PSD_SATHAD)  
            { 
                rfpulse[RFSX1_SLOT].effwidth = effwidth_sat * 0.5;
                rfpulse[RFSX1_SLOT].abswidth = abswidth_sat * 0.5;
	      
                /* Switch to Hadamard activity mask */
                rfpulse[RFSX1_SLOT].activity += (PSD_APS2_HAD - PSD_APS2_ON) + 
                    (PSD_MPS2_HAD - PSD_MPS2_ON) + (PSD_SCAN_HAD - PSD_SCAN_ON);
            }
	  
            if (opsatx == PSD_SATNEG)
                satthickdfx  = _satthickdfx.fixedflag ?  ((void)(satthickx1), satthickdfx) : satthickx1;
            else if (opsatx == PSD_SATPOS)
                satthickdfx  = _satthickdfx.fixedflag ?  ((void)(satthickx2), satthickdfx) : satthickx2;
            else
                satthickdfx  = _satthickdfx.fixedflag ?  ((void)(satthickx1), satthickdfx) : satthickx1;
	  
            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,cfgcoiltype,&rfpulse[RFSX1_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSX1_SLOT],RFSX1_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gxrfsx1.fixedflag ? (_temp711_pw_gxrfsx1=pw_gxrfsx1,&_temp711_pw_gxrfsx1) : &pw_gxrfsx1, _pw_gxrfsx1a.fixedflag ? (_temp712_pw_gxrfsx1a=pw_gxrfsx1a,&_temp712_pw_gxrfsx1a) : &pw_gxrfsx1a, _pw_gxrfsx1d.fixedflag ? (_temp713_pw_gxrfsx1d=pw_gxrfsx1d,&_temp713_pw_gxrfsx1d) : &pw_gxrfsx1d, 
                                         pw_rfsx1, _a_gxrfsx1.fixedflag ? (_temp714_a_gxrfsx1=a_gxrfsx1,&_temp714_a_gxrfsx1) : &a_gxrfsx1, &bw_rfsx1, satthickdfx,
                                         loggrd.tx,loggrd.xrt,vrgsat);
            gradx[GXRFSX1_SLOT].powscale = loggrd.xfs/loggrd.tx;
            /* set .powscale  QT*/
            if (status == FAILURE)
                return (FAILURE);
	  
            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if (amppwgradmethod(&grady[GYKSX1_SLOT],area_gyksx1,
                                loggrd.ty*sat_scalex1,0.0,0.0,
                                loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gyksx1");
                return FAILURE;
            }	
	  
            if (opphysplane!=PSD_OBL)
                grady[GYKSX1_SLOT].powscale = 1.0;
            else
                grady[GYKSX1_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scalex1);
	  
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gyksx1a+pw_gyksx1+pw_gyksx1d), maxkiller_time) : pw_gyksx1a+pw_gyksx1+pw_gyksx1d;

            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (area_gxksx1 != 0.0)
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSX1_SLOT],area_gyksx1,
                                   loggrd.ty_xy*sat_scalex1,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gyksx1");
                    return FAILURE;
                }
                if (opphysplane!=PSD_OBL)
                    grady[GYKSX1_SLOT].powscale = 1.0;
                else
                    grady[GYKSX1_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scalex1);

                gradx[GXKSX1_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSX1_SLOT],area_gxksx1,
                                   loggrd.tx_xy*sat_scalex1,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxksx1");
                    return FAILURE;
                }	
                if (opphysplane!=PSD_OBL)
                    gradx[GXKSX1_SLOT].powscale = 1.0;
                else
                    gradx[GXKSX1_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scalex1);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gyksx1a+pw_gyksx1+pw_gyksx1d,pw_gxksx1a+pw_gxksx1+pw_gxksx1d)), maxkiller_time) : IMax(2,pw_gyksx1a+pw_gyksx1+pw_gyksx1d,pw_gxksx1a+pw_gxksx1+pw_gxksx1d);
#endif
	    }

            *time_spsat += pw_gxrfsx1a + pw_rfsx1 +
                RUP_GRD(IMax(2,pw_gxrfsx1d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
	  
            if (exist(opsatx) == PSD_SATPARA)
            {
                /* perform rfpulse scaling */
                status = sp_scalerfpulses(opweight,cfgcoiltype,&rfpulse[RFSX2_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSX2_SLOT],RFSX2_SLOT);
                if (status == FAILURE)
                    return (FAILURE);

                status = sp_set_slice_select(_pw_gxrfsx2.fixedflag ? (_temp715_pw_gxrfsx2=pw_gxrfsx2,&_temp715_pw_gxrfsx2) : &pw_gxrfsx2, _pw_gxrfsx2a.fixedflag ? (_temp716_pw_gxrfsx2a=pw_gxrfsx2a,&_temp716_pw_gxrfsx2a) : &pw_gxrfsx2a, _pw_gxrfsx2d.fixedflag ? (_temp717_pw_gxrfsx2d=pw_gxrfsx2d,&_temp717_pw_gxrfsx2d) : &pw_gxrfsx2d, 
                                             pw_rfsx2, _a_gxrfsx2.fixedflag ? (_temp718_a_gxrfsx2=a_gxrfsx2,&_temp718_a_gxrfsx2) : &a_gxrfsx2, &bw_rfsx2, satthickx2,
                                             loggrd.tx,loggrd.xrt,vrgsat);
                gradx[GXRFSX2_SLOT].powscale = loggrd.xfs/loggrd.tx;
                /* set .powscale   QT*/
                if (status == FAILURE)
                    return (FAILURE);
	      
                /* call amppwgrad for killer pulse - use the loggrd structure
                   since the rotation matrix changes back to this via ISI interrupt*/
                if (amppwgradmethod(&grady[GYKSX2_SLOT],area_gyksx2,
                                    loggrd.ty*sat_scalex2,0.0,0.0,
                                    loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gyksx2");
                    return FAILURE;
                }	
                if (opphysplane!=PSD_OBL)
                    grady[GYKSX2_SLOT].powscale = 1.0;
                else
                    grady[GYKSX2_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scalex2);
	      
                maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gyksx2a+pw_gyksx2+pw_gyksx2d), maxkiller_time) : pw_gyksx2a+pw_gyksx2+pw_gyksx2d;
	      
                /* if both killers are on, adjust the targets so that obliques are
                   handled correctly */
                if (area_gxksx2 != 0.0)
		{
#ifdef SPSATXKILLER
                    if(amppwgradmethod(&grady[GYKSX2_SLOT],area_gyksx2,
                                       loggrd.ty_xy*sat_scalex2,0.0,0.0,
                                       loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                    {
                        epic_error(use_ermes, "%s failed in SpSat.",
                                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                                   STRING_ARG, "amppwgrad:gyksx2");
                        return FAILURE;
                    }
                    if (opphysplane!=PSD_OBL)
                        grady[GYKSX2_SLOT].powscale = 1.0;
                    else
                        grady[GYKSX2_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scalex2);
		  
                    gradx[GXKSX2_SLOT].num = 1;
                    if(amppwgradmethod(&gradx[GXKSX2_SLOT],area_gxksx2,
                                       loggrd.tx_xy*sat_scalex2,0.0,0.0,
                                       loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                    {
                        epic_error(use_ermes, "%s failed in SpSat.",
                                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                                   STRING_ARG, "amppwgrad:gxksx2");
                        return FAILURE;
                    }	
                    if (opphysplane!=PSD_OBL)
                        gradx[GXKSX2_SLOT].powscale = 1.0;
                    else
                        gradx[GXKSX2_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scalex2);
		  
                    maxkiller_time  = _maxkiller_time.fixedflag ?       
                                              ((void)(IMax(2,pw_gyksx2a+pw_gyksx2+pw_gyksx2d,pw_gxksx2a+pw_gxksx2+pw_gxksx2d)), maxkiller_time) : IMax(2,pw_gyksx2a+pw_gyksx2+pw_gyksx2d,pw_gxksx2a+pw_gxksx2+pw_gxksx2d);
#endif
		}

                *time_spsat += pw_gxrfsx2a + pw_rfsx2 +
                    RUP_GRD(IMax(2,pw_gxrfsx2d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
		    pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                    pw_rotupdate + isi_extra;
            }
	  
        }  /* end if opsatx */

        if (exist(opsaty) != PSD_OFF) 
        { 
            sp_set_num_pulses(&rfpulse[RFSY1_SLOT], &grady[GYRFSY1_SLOT]);
            grady[GYKSY1_SLOT].num = 1;
	  
            if ((opweight >= csweight) && 
                (TX_COIL_BODY == getTxCoilType()) &&
                (exist(opsaty) == PSD_SATHAD))
            {
                SDL_InitSPSATRFPulseInfo(cffield,RFSY1_SLOT,_pw_rfsy1.fixedflag ? (_temp719_pw_rfsy1=pw_rfsy1,&_temp719_pw_rfsy1) : &pw_rfsy1,rfpulseInfo);
            }

            sp_set_rfpulse(vrgsat, &rfpulse[RFSY1_SLOT], _res_rfsy1.fixedflag ? (_temp720_res_rfsy1=res_rfsy1,&_temp720_res_rfsy1) : &res_rfsy1, _pw_rfsy1.fixedflag ? (_temp721_pw_rfsy1=pw_rfsy1,&_temp721_pw_rfsy1) : &pw_rfsy1,
                           &bw_rfsy1, SAT_DEFAULT);
	  
            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;
	  
            /* 2 parallel Sat bands w/distinct thickness => separate RF */
            if (exist(opsaty) == PSD_SATPARA) 
            {
                sp_set_num_pulses(&rfpulse[RFSY2_SLOT], &grady[GYRFSY2_SLOT]);
                grady[GYKSY2_SLOT].num = 1;
	      
                sp_set_rfpulse(vrgsat, &rfpulse[RFSY2_SLOT], _res_rfsy2.fixedflag ? (_temp722_res_rfsy2=res_rfsy2,&_temp722_res_rfsy2) : &res_rfsy2,
                               _pw_rfsy2.fixedflag ? (_temp723_pw_rfsy2=pw_rfsy2,&_temp723_pw_rfsy2) : &pw_rfsy2, &bw_rfsy2, SAT_DEFAULT);
                sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
                array_index += 2;
            }
            else
            {
                rfpulse[RFSY2_SLOT].num = 0;
                grady[GYRFSY2_SLOT].num = 0;
                grady[GYKSY2_SLOT].num = 0;
            }
	  
	  
            /* 2 parallel Sat bands w/same thickness => Hadamard RF */
            if (exist(opsaty) == PSD_SATHAD)   
            { 
                rfpulse[RFSY1_SLOT].effwidth = effwidth_sat * 0.5;
                rfpulse[RFSY1_SLOT].abswidth = abswidth_sat * 0.5;
                /* Switch to Hadamard activity mask */
                rfpulse[RFSY1_SLOT].activity += (PSD_APS2_HAD - PSD_APS2_ON) + 
                    (PSD_MPS2_HAD - PSD_MPS2_ON) + (PSD_SCAN_HAD - PSD_SCAN_ON);
	    }
	  
            if (opsaty == PSD_SATNEG)
                satthickdfy  = _satthickdfy.fixedflag ?  ((void)(satthicky1), satthickdfy) : satthicky1;
            else if (opsaty== PSD_SATPOS)
                satthickdfy  = _satthickdfy.fixedflag ?  ((void)(satthicky2), satthickdfy) : satthicky2;
            else
                satthickdfy  = _satthickdfy.fixedflag ?  ((void)(satthicky1), satthickdfy) : satthicky1;
	  
            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,cfgcoiltype,&rfpulse[RFSY1_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSY1_SLOT],RFSY1_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gyrfsy1.fixedflag ? (_temp724_pw_gyrfsy1=pw_gyrfsy1,&_temp724_pw_gyrfsy1) : &pw_gyrfsy1, _pw_gyrfsy1a.fixedflag ? (_temp725_pw_gyrfsy1a=pw_gyrfsy1a,&_temp725_pw_gyrfsy1a) : &pw_gyrfsy1a, _pw_gyrfsy1d.fixedflag ? (_temp726_pw_gyrfsy1d=pw_gyrfsy1d,&_temp726_pw_gyrfsy1d) : &pw_gyrfsy1d, 
                                         pw_rfsy1, _a_gyrfsy1.fixedflag ? (_temp727_a_gyrfsy1=a_gyrfsy1,&_temp727_a_gyrfsy1) : &a_gyrfsy1, &bw_rfsy1, satthickdfy,
                                         loggrd.ty,loggrd.yrt,vrgsat);
            grady[GYRFSY1_SLOT].powscale = loggrd.yfs/loggrd.ty;
            /* set .powscale   QT*/
	  
            if (status == FAILURE)
                return (FAILURE);

            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if (amppwgradmethod(&grady[GYKSY1_SLOT],area_gyksy1,
                                loggrd.ty*sat_scaley1,0.0,0.0,
                                loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gyksy1");
                return FAILURE;
            }
            if (opphysplane!=PSD_OBL)
                grady[GYKSY1_SLOT].powscale = 1.0;
            else
                grady[GYKSY1_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scaley1);
	  
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gyksy1a+pw_gyksy1+pw_gyksy1d), maxkiller_time) : pw_gyksy1a+pw_gyksy1+pw_gyksy1d;

            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (area_gxksy1 != 0.0)
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSY1_SLOT],area_gyksy1,
                                   loggrd.ty_xy*sat_scaley1,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gyksy1");
                    return FAILURE;
                }
                if (opphysplane!=PSD_OBL)
                    grady[GYKSY1_SLOT].powscale = 1.0;
                else
                    grady[GYKSY1_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scaley1);

                gradx[GXKSY1_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSY1_SLOT],area_gxksy1,
                                   loggrd.tx_xy*sat_scaley1,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxksy1");
                    return FAILURE;
                }	
                if (opphysplane!=PSD_OBL)
                    gradx[GXKSY1_SLOT].powscale = 1.0;
                else
                    gradx[GXKSY1_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scaley1);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gyksy1a+pw_gyksy1+pw_gyksy1d,pw_gxksy1a+pw_gxksy1+pw_gxksy1d)), maxkiller_time) : IMax(2,pw_gyksy1a+pw_gyksy1+pw_gyksy1d,pw_gxksy1a+pw_gxksy1+pw_gxksy1d);
#endif
	    }

            *time_spsat += pw_gyrfsy1a + pw_rfsy1 +
                RUP_GRD(IMax(2,pw_gyrfsy1d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
	  
            if (exist(opsaty) == PSD_SATPARA) 
            {
                /* perform rfpulse scaling */
                status = sp_scalerfpulses(opweight,cfgcoiltype,&rfpulse[RFSY2_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSY2_SLOT],RFSY2_SLOT);
                if (status == FAILURE)
                    return (FAILURE);

                status = sp_set_slice_select(_pw_gyrfsy2.fixedflag ? (_temp728_pw_gyrfsy2=pw_gyrfsy2,&_temp728_pw_gyrfsy2) : &pw_gyrfsy2, _pw_gyrfsy2a.fixedflag ? (_temp729_pw_gyrfsy2a=pw_gyrfsy2a,&_temp729_pw_gyrfsy2a) : &pw_gyrfsy2a, _pw_gyrfsy2d.fixedflag ? (_temp730_pw_gyrfsy2d=pw_gyrfsy2d,&_temp730_pw_gyrfsy2d) : &pw_gyrfsy2d, 
                                             pw_rfsy2, _a_gyrfsy2.fixedflag ? (_temp731_a_gyrfsy2=a_gyrfsy2,&_temp731_a_gyrfsy2) : &a_gyrfsy2, &bw_rfsy2, satthicky2,
                                             loggrd.ty,loggrd.yrt,vrgsat);
                grady[GYRFSY2_SLOT].powscale = loggrd.yfs/loggrd.ty;
                /* set .powscale   QT*/

                if (status == FAILURE)
                    return (FAILURE);

                /* call amppwgrad for killer pulse - use the loggrd structure
                   since the rotation matrix changes back to this via ISI interrupt*/
                if (amppwgradmethod(&grady[GYKSY2_SLOT],area_gyksy2,
                                    loggrd.ty*sat_scaley2,0.0,0.0,
                                    loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gyksy2");
                    return FAILURE;
                }	
	      
                if (opphysplane!=PSD_OBL)
                    grady[GYKSY2_SLOT].powscale = 1.0;
                else
                    grady[GYKSY2_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scaley2);
	      
                maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gyksy2a+pw_gyksy2+pw_gyksy2d), maxkiller_time) : pw_gyksy2a+pw_gyksy2+pw_gyksy2d;
	      
                /* if both killers are on, adjust the targets so that obliques are
                   handled correctly */
                if (area_gxksy2 != 0.0)
		{
#ifdef SPSATXKILLER
                    if(amppwgradmethod(&grady[GYKSY2_SLOT],area_gyksy2,
                                       loggrd.ty_xy*sat_scaley2,0.0,0.0,
                                       loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                    {
                        epic_error(use_ermes, "%s failed in SpSat.",
                                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                                   STRING_ARG, "amppwgrad:gyksy2");
                        return FAILURE;
                    }
                    if (opphysplane!=PSD_OBL)
                        grady[GYKSY2_SLOT].powscale = 1.0;
                    else
                        grady[GYKSY2_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scaley2);
		  
                    gradx[GXKSY2_SLOT].num = 1;
                    if(amppwgradmethod(&gradx[GXKSY2_SLOT],area_gxksy2,
                                       loggrd.tx_xy*sat_scaley2,0.0,0.0,
                                       loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                    {
                        epic_error(use_ermes, "%s failed in SpSat.",
                                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                                   STRING_ARG, "amppwgrad:gxksy2");
                        return FAILURE;
                    }	
                    if (exist(opplane)!=PSD_OBL)
                        gradx[GXKSY2_SLOT].powscale = 1.0;
                    else
                        gradx[GXKSY2_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scaley2);
		  
                    maxkiller_time  = _maxkiller_time.fixedflag ?       
                                              ((void)(IMax(2,pw_gyksy2a+pw_gyksy2+pw_gyksy2d,pw_gxksy2a+pw_gxksy2+pw_gxksy2d)), maxkiller_time) : IMax(2,pw_gyksy2a+pw_gyksy2+pw_gyksy2d,pw_gxksy2a+pw_gxksy2+pw_gxksy2d);
#endif
		}
                *time_spsat += pw_gyrfsy2a + pw_rfsy2 +
                    RUP_GRD(IMax(2,pw_gyrfsy2d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
		    pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                    pw_rotupdate + isi_extra;
            }
	}  /* end of opsaty */

        if (exist(opsatz) != PSD_OFF) 
        {
            sp_set_num_pulses(&rfpulse[RFSZ1_SLOT],&gradz[GZRFSZ1_SLOT]);
            grady[GYKSZ1_SLOT].num = 1;
	  
            if ((opweight >= csweight) &&
                (TX_COIL_BODY == getTxCoilType()) &&
                (exist(opsatz) == PSD_SATHAD) )
            {
                SDL_InitSPSATRFPulseInfo(cffield,RFSZ1_SLOT,_pw_rfsz1.fixedflag ? (_temp732_pw_rfsz1=pw_rfsz1,&_temp732_pw_rfsz1) : &pw_rfsz1,rfpulseInfo);
            }

            sp_set_rfpulse(vrgsat, &rfpulse[RFSZ1_SLOT], _res_rfsz1.fixedflag ? (_temp733_res_rfsz1=res_rfsz1,&_temp733_res_rfsz1) : &res_rfsz1, 
                           _pw_rfsz1.fixedflag ? (_temp734_pw_rfsz1=pw_rfsz1,&_temp734_pw_rfsz1) : &pw_rfsz1, &bw_rfsz1, SAT_DEFAULT);
	  
            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;

	  
            /* 2 parallel Sat pulses w/distinct thickness => separate RF */
            if (exist(opsatz) == PSD_SATPARA) 
            {
                sp_set_num_pulses(&rfpulse[RFSZ2_SLOT],&gradz[GZRFSZ2_SLOT]);
                grady[GYKSZ2_SLOT].num = 1;
                sp_set_rfpulse(vrgsat, &rfpulse[RFSZ2_SLOT], _res_rfsz2.fixedflag ? (_temp735_res_rfsz2=res_rfsz2,&_temp735_res_rfsz2) : &res_rfsz2,
                               _pw_rfsz2.fixedflag ? (_temp736_pw_rfsz2=pw_rfsz2,&_temp736_pw_rfsz2) : &pw_rfsz2, &bw_rfsz2, SAT_DEFAULT);
                sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
                array_index += 2;
            }
            else
            {
                rfpulse[RFSZ2_SLOT].num = 0;
                grady[GZRFSZ2_SLOT].num = 0;
                grady[GYKSZ2_SLOT].num = 0;
            }
	  
            /* 2 parallel Sat pulses w/same thickness => Hadamard Rf */
            if (exist(opsatz) == PSD_SATHAD) 
            { 
                rfpulse[RFSZ1_SLOT].effwidth = effwidth_sat * 0.5;
                rfpulse[RFSZ1_SLOT].abswidth = abswidth_sat * 0.5;
	      
                /* Switch to Hadamard activity mask */
                rfpulse[RFSZ1_SLOT].activity += (PSD_APS2_HAD - PSD_APS2_ON) + 
                    (PSD_MPS2_HAD - PSD_MPS2_ON) + (PSD_SCAN_HAD - PSD_SCAN_ON);
	    }
	  
            if (opsatz == PSD_SATNEG)
                satthickdfz  = _satthickdfz.fixedflag ?  ((void)(satthickz1), satthickdfz) : satthickz1;
            else if (opsatz == PSD_SATPOS)
                satthickdfz  = _satthickdfz.fixedflag ?  ((void)(satthickz2), satthickdfz) : satthickz2;
            else
                satthickdfz  = _satthickdfz.fixedflag ?  ((void)(satthickz1), satthickdfz) : satthickz1;
	  
            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,cfgcoiltype,&rfpulse[RFSZ1_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSZ1_SLOT],RFSZ1_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gzrfsz1.fixedflag ? (_temp737_pw_gzrfsz1=pw_gzrfsz1,&_temp737_pw_gzrfsz1) : &pw_gzrfsz1, _pw_gzrfsz1a.fixedflag ? (_temp738_pw_gzrfsz1a=pw_gzrfsz1a,&_temp738_pw_gzrfsz1a) : &pw_gzrfsz1a, _pw_gzrfsz1d.fixedflag ? (_temp739_pw_gzrfsz1d=pw_gzrfsz1d,&_temp739_pw_gzrfsz1d) : &pw_gzrfsz1d, 
                                         pw_rfsz1, _a_gzrfsz1.fixedflag ? (_temp740_a_gzrfsz1=a_gzrfsz1,&_temp740_a_gzrfsz1) : &a_gzrfsz1, &bw_rfsz1, satthickdfz,
                                         loggrd.tz,loggrd.zrt,vrgsat);
            gradz[GZRFSZ1_SLOT].powscale = loggrd.zfs/loggrd.tz;
            /* set .powscale    QT*/
            if (status == FAILURE)
                return (FAILURE);
	  
            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if (amppwgradmethod(&grady[GYKSZ1_SLOT],area_gyksz1,
                                loggrd.ty*sat_scalez1,0.0,0.0,
                                loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gyksz1");
                return FAILURE;
            }	
            if (opphysplane!=PSD_OBL)
                grady[GYKSZ1_SLOT].powscale = 1.0;
            else
                grady[GYKSZ1_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scalez1);
	  
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gyksz1a+pw_gyksz1+pw_gyksz1d), maxkiller_time) : pw_gyksz1a+pw_gyksz1+pw_gyksz1d;
	  
            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (area_gxksz1 != 0.0)
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSZ1_SLOT],area_gyksz1,
                                   loggrd.ty_xy*sat_scalez1,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gyksz1");
                    return FAILURE;
                }
                if (opphysplane!=PSD_OBL)
                    grady[GYKSZ1_SLOT].powscale = 1.0;
                else
                    grady[GYKSZ1_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scalez1);

                gradx[GXKSZ1_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSZ1_SLOT],area_gxksz1,
                                   loggrd.tx_xy*sat_scalez1,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxksz1");
                    return FAILURE;
                }
                if (opphysplane!=PSD_OBL)
                    gradx[GXKSZ1_SLOT].powscale = 1.0;
                else	
                    gradx[GXKSZ1_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scalez1);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gyksz1a+pw_gyksz1+pw_gyksz1d,pw_gxksz1a+pw_gxksz1+pw_gxksz1d)), maxkiller_time) : IMax(2,pw_gyksz1a+pw_gyksz1+pw_gyksz1d,pw_gxksz1a+pw_gxksz1+pw_gxksz1d);
#endif
	    }
            *time_spsat += pw_gzrfsz1a + pw_rfsz1 +
                RUP_GRD(IMax(2,pw_gzrfsz1d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
	  
            if (exist(opsatz) == PSD_SATPARA)
            {
                /* perform rfpulse scaling */
                status = sp_scalerfpulses(opweight,cfgcoiltype,&rfpulse[RFSZ2_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSZ2_SLOT],RFSZ2_SLOT);
                if (status == FAILURE)
                    return (FAILURE);

                status = sp_set_slice_select(_pw_gzrfsz2.fixedflag ? (_temp741_pw_gzrfsz2=pw_gzrfsz2,&_temp741_pw_gzrfsz2) : &pw_gzrfsz2, _pw_gzrfsz2a.fixedflag ? (_temp742_pw_gzrfsz2a=pw_gzrfsz2a,&_temp742_pw_gzrfsz2a) : &pw_gzrfsz2a, _pw_gzrfsz2d.fixedflag ? (_temp743_pw_gzrfsz2d=pw_gzrfsz2d,&_temp743_pw_gzrfsz2d) : &pw_gzrfsz2d, 
                                             pw_rfsz2, _a_gzrfsz2.fixedflag ? (_temp744_a_gzrfsz2=a_gzrfsz2,&_temp744_a_gzrfsz2) : &a_gzrfsz2, &bw_rfsz2, satthickz2,
                                             loggrd.tz,loggrd.zrt,vrgsat);
                gradz[GZRFSZ2_SLOT].powscale = loggrd.zfs/loggrd.tz;
                /* set .powscale    QT*/
	      
                if (status == FAILURE)
                    return (FAILURE);
	      
                /* call amppwgrad for killer pulse - use the loggrd structure
                   since the rotation matrix changes back to this via ISI interrupt*/
                if (amppwgradmethod(&grady[GYKSZ2_SLOT],area_gyksz2,
                                    loggrd.ty*sat_scalez2,0.0,0.0,
                                    loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gyksz2");
                    return FAILURE;
                }	
                if (opphysplane!=PSD_OBL)
                    grady[GYKSZ2_SLOT].powscale = 1.0;
                else
                    grady[GYKSZ2_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scalez2);
	      
                maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gyksz2a+pw_gyksz2+pw_gyksz2d), maxkiller_time) : pw_gyksz2a+pw_gyksz2+pw_gyksz2d;
	      
                /* if both killers are on, adjust the targets so that obliques are
                   handled correctly */
                if (area_gxksz2 != 0.0)
		{
#ifdef SPSATXKILLER
                    if(amppwgradmethod(&grady[GYKSZ2_SLOT],area_gyksz2,
                                       loggrd.ty_xy*sat_scalez2,0.0,0.0,
                                       loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                    {
                        epic_error(use_ermes, "%s failed in SpSat.",
                                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                                   STRING_ARG, "amppwgrad:gyksz2");
                        return FAILURE;
                    }
                    if (opphysplane!=PSD_OBL)
                        grady[GYKSZ2_SLOT].powscale = 1.0;
                    else
                        grady[GYKSZ2_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scalez2);
		  
                    gradx[GXKSZ2_SLOT].num = 1;
                    if(amppwgradmethod(&gradx[GXKSZ2_SLOT],area_gxksz2,
                                       loggrd.tx_xy*sat_scalez2,0.0,0.0,
                                       loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                    {
                        epic_error(use_ermes, "%s failed in SpSat.",
                                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                                   STRING_ARG, "amppwgrad:gxksz2");
                        return FAILURE;
                    }	
                    if (opphysplane!=PSD_OBL)
                        gradx[GXKSZ2_SLOT].powscale = 1.0;
                    else
                        gradx[GXKSZ2_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scalez2);
		  
                    maxkiller_time  = _maxkiller_time.fixedflag ?       
                                              ((void)(IMax(2,pw_gyksz2a+pw_gyksz2+pw_gyksz2d,pw_gxksz2a+pw_gxksz2+pw_gxksz2d)), maxkiller_time) : IMax(2,pw_gyksz2a+pw_gyksz2+pw_gyksz2d,pw_gxksz2a+pw_gxksz2+pw_gxksz2d);
#endif
		}
                *time_spsat += pw_gzrfsz2a + pw_rfsz2 +
                    RUP_GRD(IMax(2,pw_gzrfsz2d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
		    pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                    pw_rotupdate + isi_extra;
            }
	  
	} /* end of opsatz */
        sat_rot_df_num  = _sat_rot_df_num.fixedflag ?    ((void)(sat_rot_index-sat_rot_ex_num), sat_rot_df_num) : sat_rot_index-sat_rot_ex_num;
      
        /* Covers worst case when an extra ISI is added at the beginning.
           This occurs for scans that move the sat pulses away from the
           beginning of the sequence. */
        *time_spsat += rot_delay + isi_extra + pw_isisat - isi_satdelay; 
        *time_spsat = RUP_GRD(*time_spsat) ;
    } /* if opsat is selected */

#ifdef UNDEF
    if (opsat == PSD_ON)  
    {
        SHORT mask;

        printf("\n opsatx = %d", opsatx);
        printf("\n opsaty = %d", opsaty);
        printf("\n opsatz = %d", opsatz);
        printf("\n opexsatmask = %d", opexsatmask);
        printf("\n opexsatparal = %d", opexsatparal);
        if (opexsatmask != 0)
        {
            printf("\n opexsathick1 = %f",(float) opexsathick1);
            printf("\n opexsathick2 = %f", (float) opexsathick2);
            printf("\n opexsathick3 = %f",(float) opexsathick3);
            printf("\n opexsathick4 = %f",(float) opexsathick4);
            printf("\n opexsathick5 = %f",(float) opexsathick5);
            printf("\n opexsathick6 = %f",(float) opexsathick6);
            printf("\n opexsatloc1 = %f", (float) opexsatloc1);
            printf("\n opexsatloc2 = %f", (float) opexsatloc2);
            printf("\n opexsatloc3 = %f", (float) opexsatloc3);
            printf("\n opexsatloc4 = %f", (float) opexsatloc4);
            printf("\n opexsatloc5 = %f", (float) opexsatloc5);
            printf("\n opexsatloc6 = %f", (float) opexsatloc6);
        }

        if ((opsatx != PSD_SATOFF) || (opsaty != PSD_SATOFF) || (opsatz !=PSD_SATOFF))
        {
            printf("\n opdfsathick1 = %f", (float) opdfsathick1);
            printf("\n opdfsathick2 = %f", (float) opdfsathick2);
            printf("\n opdfsathick3 = %f", (float) opdfsathick3);
            printf("\n opdfsathick4 = %f", (float) opdfsathick4);
            printf("\n opdfsathick5 = %f", (float) opdfsathick5);
            printf("\n opdfsathick6 = %f", (float) opdfsathick6);
        }

        mask = 1;
        for(i=0;i<6;i++,mask = mask<<1)
        {
            if (opexsatmask & mask)
            {
                printf("\n Rotation matrix %d",i);
                for (j=0; j < 9; j=j+3)
                    printf("\n                      %4.2f    %4.2f     %4.2f",   
                           eg_sat_rot[i][j], eg_sat_rot[i][j+1],eg_sat_rot[i][j+2]);	
            }
        }
    }
#endif /* UNDEF */

    return SUCCESS;
}

/************************************************************************/

void
dump_sat_input(void)
{
    int i;
    int justified = 35;
    char file[BUFSIZ] = SPSAT_SCANNER_LOG_DIR;
    char *filename = "spsat_host_sat_rot.log";
    FILE *fp;

    strcpy(file, SPSAT_SCANNER_LOG_DIR);
    strcat(file, filename);

    if ((fp = fopen(file, "w")) == NULL)
    {   
        strcpy(file, SPSAT_LOCAL_LOG_DIR);
        strcat(file, filename);

        if ((fp = fopen(file, "w")) == NULL)
        {
            printf("Error opening %s file\n",file);
            fflush(stdout);
            return;
        } 
    }

    fprintf(fp, "Host-provided Spatial Saturation info\n");

    for( i = 0; i < 6; ++i )
    {
        float location = 0.0;
        float thickness = 0.0;
        float RASnormal[3] = {0.0, 0.0, 0.0};
        float normal_dist = 0.0;
        int frequency = 0;
        char active[4] = "Off";

        switch( i )
        {
            case 0:
                location = opexsatloc1;
                thickness = opexsathick1;
                RASnormal[0] = exsat1_normth_R;
                RASnormal[1] = exsat1_normth_A;
                RASnormal[2] = exsat1_normth_S;
                normal_dist = exsat1_dist;
                strcpy( active, opexsatmask & PSD_EXPLICIT_1 ? "On": "Off" );
                frequency = off_rfse1;
                break;
            case 1:
                location = opexsatloc2;
                thickness = opexsathick2;
                RASnormal[0] = exsat2_normth_R;
                RASnormal[1] = exsat2_normth_A;
                RASnormal[2] = exsat2_normth_S;
                normal_dist = exsat2_dist;
                strcpy( active, opexsatmask & PSD_EXPLICIT_2 ? "On": "Off" );
                frequency = off_rfse2;
                break;
            case 2:
                location = opexsatloc3;
                thickness = opexsathick3;
                RASnormal[0] = exsat3_normth_R;
                RASnormal[1] = exsat3_normth_A;
                RASnormal[2] = exsat3_normth_S;
                normal_dist = exsat3_dist;
                strcpy( active, opexsatmask & PSD_EXPLICIT_3 ? "On": "Off" );
                frequency = off_rfse3;
                break;
            case 3:
                location = opexsatloc4;
                thickness = opexsathick4;
                RASnormal[0] = exsat4_normth_R;
                RASnormal[1] = exsat4_normth_A;
                RASnormal[2] = exsat4_normth_S;
                normal_dist = exsat4_dist;
                strcpy( active, opexsatmask & PSD_EXPLICIT_4 ? "On": "Off" );
                frequency = off_rfse4;
                break;
            case 4:
                location = opexsatloc5;
                thickness = opexsathick5;
                RASnormal[0] = exsat5_normth_R;
                RASnormal[1] = exsat5_normth_A;
                RASnormal[2] = exsat5_normth_S;
                normal_dist = exsat5_dist;
                strcpy( active, opexsatmask & PSD_EXPLICIT_5 ? "On": "Off" );
                frequency = off_rfse5;
                break;
            case 5:
                location = opexsatloc6;
                thickness = opexsathick6;
                RASnormal[0] = exsat6_normth_R;
                RASnormal[1] = exsat6_normth_A;
                RASnormal[2] = exsat6_normth_S;
                normal_dist = exsat6_dist;
                strcpy( active, opexsatmask & PSD_EXPLICIT_6 ? "On": "Off" );
                frequency = off_rfse6;
                break;
        }
        fprintf(fp, "Input\n");
        fprintf(fp, "Saturation Band Index %d is %s\n", i, active);
        fprintf(fp, "%-*s%+10f, %+8f, %+8f\n",
                justified, "", eg_sat_rot[i][0], eg_sat_rot[i][1],
                eg_sat_rot[i][2]);
        fprintf(fp, "%-*s%+10f, %+8f, %+8f\n",
                justified, "Explicit sat rotation matrix:",
                eg_sat_rot[i][3], eg_sat_rot[i][4],
                eg_sat_rot[i][5]);
        fprintf(fp, "%-*s%+10f, %+8f, %+8f\n",
                justified, "", eg_sat_rot[i][6], eg_sat_rot[i][7],
                eg_sat_rot[i][8]);
        fprintf(fp, "%-*s%+8.4f\n",
                justified, "Offset from isocenter (mm):", location);
        fprintf(fp, "%-*s%+10.4f\n",
                justified, "Thickness (mm):", thickness);
        fprintf(fp, "%-*s%+10.4f, %+8.4f, %+8.4f\n",
                justified, "RAS normal vector with thickness:",
                RASnormal[0], RASnormal[1], RASnormal[2]);
        fprintf(fp, "%-*s%+10.4f\n",
                justified, "Offset distance along normal:", normal_dist);
        fprintf(fp, "Calculated\n");
        fprintf(fp, "%-*s%+10d\n",
                justified, "Frequency (Hz):", frequency);
        fprintf(fp, "\n");
    }

    for (i=0;i<sat_rot_ex_num*2; i=i+2)
    {
        fprintf(fp, "Saturation Band Index %d\n",i);
        fprintf(fp, "%-*s%+10ld, %+8ld, %+8ld\n",
                justified, "", sat_rot_matrices[i][0], sat_rot_matrices[i][1],
                sat_rot_matrices[i][2]);
        fprintf(fp, "%-*s%+10ld, %+8ld, %+8ld\n",
                justified, "SpSat rotation matrix:",
                sat_rot_matrices[i][3], sat_rot_matrices[i][4],
                sat_rot_matrices[i][5]);
        fprintf(fp, "%-*s%+10ld, %+8ld, %+8ld\n",
                justified, "", sat_rot_matrices[i][6], sat_rot_matrices[i][7],
                sat_rot_matrices[i][8]);
        fprintf(fp, "\n");

        fprintf(fp, "%-*s%+10ld, %+8ld, %+8ld\n",
                justified, "", sat_rot_matrices[i+1][0], sat_rot_matrices[i+1][1],
                sat_rot_matrices[i+1][2]);
        fprintf(fp, "%-*s%+10ld, %+8ld, %+8ld\n",
                justified, "SpSat slice rotation matrix:",
                sat_rot_matrices[i+1][3], sat_rot_matrices[i+1][4],
                sat_rot_matrices[i+1][5]);
        fprintf(fp, "%-*s%+10ld, %+8ld, %+8ld\n",
                justified, "", sat_rot_matrices[i+1][6], sat_rot_matrices[i+1][7],
                sat_rot_matrices[i+1][8]);
        fprintf(fp, "\n");
    }
            
    fprintf(fp, "Default Saturation Band info\n");

    if( (opsatx & PSD_SATNEG) || opsatx & PSD_SATPARA )
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Negative X Saturation:", "On");
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Position (mm):", satxlocneg);
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Thickness:", opdfsathick1);
        fprintf(fp, "%-*s %7d\n",
                justified, "     Calculated Frequency (Hz):", off_rfsx1);
    }
    else
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Negative X Saturation:", "Off");
    }

    if( opsatx & PSD_SATPOS || opsatx & PSD_SATPARA )
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Positive X Saturation:", "On");
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Position (mm):", satxlocpos);
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Thickness:", opdfsathick2);
        if (opsatx & PSD_SATPARA)
        {
            fprintf(fp, "%-*s %7d\n",
                    justified, "     Calculated Frequency (Hz):", off_rfsx2);
        } else {
            fprintf(fp, "%-*s %7d\n",
                    justified, "     Calculated Frequency (Hz):", off_rfsx1);
        }
    }
    else
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Positive X Saturation:", "Off");
    }

    if( opsaty & PSD_SATNEG || opsaty & PSD_SATPARA )
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Negative Y Saturation:", "On");
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Position (mm):", satylocneg);
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Thickness (mm):", opdfsathick3);
        fprintf(fp, "%-*s %7d\n",
                justified, "     Calculated Frequency (Hz):", off_rfsy1);
    }
    else
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Negative Y Saturation:", "Off");
    }

    if( opsaty & PSD_SATPOS || opsaty & PSD_SATPARA )
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Positive Y Saturation:", "On");
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Position (mm):", satylocpos);
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Thickness (mm):", opdfsathick4);
        if (opsaty & PSD_SATPARA)
        {
            fprintf(fp, "%-*s %7d\n",
                    justified, "     Calculated Frequency (Hz):", off_rfsy2);
        } else {
            fprintf(fp, "%-*s %7d\n",
                    justified, "     Calculated Frequency (Hz):", off_rfsy1);
        }
    }
    else
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Positive Y Saturation:", "Off");
    }

    if( opsatz & PSD_SATNEG || opsatz & PSD_SATPARA )
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Negative Z Saturation:", "On");
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Position (mm):", satzlocneg);
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Thickness (mm):", opdfsathick5);
        fprintf(fp, "%-*s %7d\n",
                justified, "     Calculated Frequency (Hz):", off_rfsz1);
    }
    else
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Negative Z Saturation:", "Off");
    }
    if( opsatz & PSD_SATPOS || opsatz & PSD_SATPARA )
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Positive Z Saturation:", "On");
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Position (mm):", satzlocpos);
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Thickness:", opdfsathick6);
        if ( opsatz & PSD_SATPARA )
        {
            fprintf(fp, "%-*s %7d\n",
                    justified, "     Calculated Frequency (Hz):", off_rfsz2);
        } else {
            fprintf(fp, "%-*s %7d\n",
                    justified, "     Calculated Frequency (Hz):", off_rfsz1);
        }
    }
    else
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Positive Z Saturation:", "Off");
    }

    fclose(fp);

    return;
}

/* Calculates offset frequencies for Z direction SAT bands only for
   concatenated sat */

void
SatGetZOffset( DOUBLE locpos,
               DOUBLE locneg,
               INT *offset1,
               INT *offset2 )
{
    switch (opsatz) 		
    {
    case PSD_SATOFF:
        *offset1 = 0;
        *offset2 = 0;
        break;

    case PSD_SATNEG:		/* Use negative location */
        *offset1 = GAM*a_gzrfsz1 * locneg/10;
        *offset2 = 0;
        break;

    case PSD_SATPOS:		/* Use positive location */
        *offset1 = GAM*a_gzrfsz1* locpos/10;
        *offset2 = 0;
        break;

    case PSD_SATHAD:      /* Find middle of Hadamard and space btwn */
        *offset1 = GAM*a_gzrfsz1* ((locpos+locneg)/2.0)/10;
        *offset2 = *offset1;
        break;

    case PSD_SATPARA:
        /* 2 SAT bands - positive & negative locs */
        *offset1 = GAM*a_gzrfsz1* locneg/10;
        *offset2 = GAM*a_gzrfsz2 * locpos/10;
        break;

    default:
        break;
    }
    return;
}
    /* Calculate amount of time to be burned in relaxers for cat sat */

int
SatCatRelaxtime( INT acqs,
                 INT seq_time,
                 INT seq_type )
{
  
    /* Check if we are doing a Concatenated Sat Non-Sequential Scan */
    if ( ((seq_type == TYPCAT) && (opirmode == PSD_SEQMODE_OFF)
          && !((opepi == PSD_ON) && (opexcitemode == FOCUS)))
         || (seq_type == TYP3DMSCAT) || (seq_type == TYP3DFSECAT) )
    {
        ccs_relaxers  = _ccs_relaxers.fixedflag ?  ((void)(ceil(ccs_dead/(double)seq_time)), ccs_relaxers) : ceil(ccs_dead/(double)seq_time);
        ccs_relaxtime  = _ccs_relaxtime.fixedflag ?  ((void)(RUP_GRD(ccs_relaxers*seq_time*(acqs-1))), ccs_relaxtime) : RUP_GRD(ccs_relaxers*seq_time*(acqs-1));
        ccs_relaxseqtime  = _ccs_relaxseqtime.fixedflag ?  ((void)(RUP_GRD(seq_time)), ccs_relaxseqtime) : RUP_GRD(seq_time);
        SatRelaxers  = _SatRelaxers.fixedflag ?  ((void)(1), SatRelaxers) : 1;
    }
    else 
    {
        ccs_relaxers  = _ccs_relaxers.fixedflag ?  ((void)(0), ccs_relaxers) : 0;
        ccs_relaxtime  = _ccs_relaxtime.fixedflag ?  ((void)(0), ccs_relaxtime) : 0;
        ccs_relaxseqtime  = _ccs_relaxseqtime.fixedflag ?  ((void)(0), ccs_relaxseqtime) : 0;
        SatRelaxers  = _SatRelaxers.fixedflag ?  ((void)(0), SatRelaxers) : 0;
    }
    return(ccs_relaxtime);		    
}

STATUS
SatPlacement( INT numPasses ) 
{
    INT   i;			/* generic indices */
    INT   pass;
    INT   skip_next_sat;
    INT   explicit_sat_mask;
    INT   explicit_sat_paral;
    INT   maxslices;

    DOUBLE max_z, max_x, max_y;			/* maximum z, x, y location */
    DOUBLE min_z, min_x, min_y;			/* minimum z, x, y location */

    DOUBLE max[DATA_ACQ_MAX];	/* storage for finding slice range */
    DOUBLE min[DATA_ACQ_MAX];

    DOUBLE loczaoff;		/* offset for CATSAT positive slice */
    DOUBLE loczboff;		/* offset for CATSAT negative slice */

    if ((opsat == PSD_OFF) || ((opsatx == PSD_OFF)&&(opsaty == PSD_OFF) &&
                               (opsatz == PSD_OFF)&&(opexsatmask == PSD_OFF)))
        return SUCCESS;

    /*  opsat<x,y,z>       Band        Thickness        Satgap    Location
        1 (PSD_SATNEG)   I,P,L       1,3,or 5          neg       neg
        2 (PSD_SATPOS)   S,A,R       2,4,or 6          pos       pos
    */

    if (opimode == PSD_3D)
    {
        maxslices = exist(opslquant) * exist(opvquant);
    }
    else
    {
        maxslices = exist(opslquant);
    }

    /* X Sat placement ------------------------------------*/

    /* sathickx1 goes with opsat set to PSD_SATNEG (1)
       sathickx2 goes with opsat set to PSD_SATPOS (2) */

    satgapxpos  = _satgapxpos.fixedflag ?    ((void)(30.0/80.0*satthickx2), satgapxpos) : 30.0/80.0*satthickx2;
    satgapxneg  = _satgapxneg.fixedflag ?    ((void)(30.0/80.0*satthickx1), satgapxneg) : 30.0/80.0*satthickx1;

    /* MRIhc03229: Search for farthest slice in each direction */
    min_x = max_x = scan_info[0].oprloc;
    for (i=1;i<maxslices;i++) 
    {
       if (scan_info[i].oprloc > max_x )
           max_x = scan_info[i].oprloc;
       else if ( scan_info[i].oprloc < min_x)
       	   min_x = scan_info[i].oprloc;
    }

    satxlocpos  = _satxlocpos.fixedflag ?        ((void)((exist(opfov)+satthickx2)/2+satgapxpos+max_x), satxlocpos) : (exist(opfov)+satthickx2)/2+satgapxpos+max_x;
    satxlocneg  = _satxlocneg.fixedflag ?        ((void)((exist(opfov)+satthickx1)/-2-satgapxneg+min_x), satxlocneg) : (exist(opfov)+satthickx1)/-2-satgapxneg+min_x;

    off_rfsx1  = _off_rfsx1.fixedflag ?  ((void)(0), off_rfsx1) : 0;
    off_rfsx2  = _off_rfsx2.fixedflag ?  ((void)(0), off_rfsx2) : 0;
    satspacex1  = _satspacex1.fixedflag ?  ((void)(0.0), satspacex1) : 0.0;
    satspacex2  = _satspacex2.fixedflag ?  ((void)(0.0), satspacex2) : 0.0;

    switch (opsatx) 		/* Calculate offset frequencies */
    {
    case PSD_SATOFF:
        off_rfsx1  = _off_rfsx1.fixedflag ?  ((void)(0), off_rfsx1) : 0;
        satspacex1  = _satspacex1.fixedflag ?  ((void)(0.0), satspacex1) : 0.0;
        off_rfsx2  = _off_rfsx2.fixedflag ?  ((void)(0), off_rfsx2) : 0;
        satspacex2  = _satspacex2.fixedflag ?  ((void)(0.0), satspacex2) : 0.0;
        break;

    case PSD_SATNEG:		/* Use negative location */
        off_rfsx1  = _off_rfsx1.fixedflag ?   ((void)(GAM*a_gxrfsx1*(satxlocneg)/10), off_rfsx1) : GAM*a_gxrfsx1*(satxlocneg)/10;
        satspacex1  = _satspacex1.fixedflag ?  ((void)(0.0), satspacex1) : 0.0;
        break;

    case PSD_SATPOS:		/* Use positive location */
        off_rfsx1  = _off_rfsx1.fixedflag ?   ((void)(GAM*a_gxrfsx1*(satxlocpos)/10), off_rfsx1) : GAM*a_gxrfsx1*(satxlocpos)/10;
        satspacex1  = _satspacex1.fixedflag ?  ((void)(0.0), satspacex1) : 0.0;
        break;

    case PSD_SATHAD:	/* Find middle of Hadamard and space btwn */
        off_rfsx1  = _off_rfsx1.fixedflag ?   ((void)(GAM*a_gxrfsx1*((satxlocpos+satxlocneg)/2.0)/10), off_rfsx1) : GAM*a_gxrfsx1*((satxlocpos+satxlocneg)/2.0)/10;
        satspacex1  = _satspacex1.fixedflag ?  ((void)(fabs(satxlocpos-satxlocneg)), satspacex1) : fabs(satxlocpos-satxlocneg);

        break;

    case PSD_SATPARA:          /* 2 SAT bands - positive & negative locs */
        off_rfsx1  = _off_rfsx1.fixedflag ?   ((void)(GAM*a_gxrfsx1*(satxlocneg)/10), off_rfsx1) : GAM*a_gxrfsx1*(satxlocneg)/10;
        satspacex1  = _satspacex1.fixedflag ?  ((void)(0.0), satspacex1) : 0.0;
        off_rfsx2  = _off_rfsx2.fixedflag ?   ((void)(GAM*a_gxrfsx2*(satxlocpos)/10), off_rfsx2) : GAM*a_gxrfsx2*(satxlocpos)/10;
        satspacex2  = _satspacex2.fixedflag ?  ((void)(0.0), satspacex2) : 0.0;
        break;

    default:
        break;
    }
  
    /* Y Sat placement ------------------------------------*/

    satgapypos  = _satgapypos.fixedflag ?    ((void)(30.0/80.0*satthicky2), satgapypos) : 30.0/80.0*satthicky2;
    satgapyneg  = _satgapyneg.fixedflag ?    ((void)(30.0/80.0*satthicky1), satgapyneg) : 30.0/80.0*satthicky1;
  
    /* satthicky1 goes with opsat set to PSD_SATNEG (1)
       satthicky2 goes with opsat set to PSD_SATPOS (2) */

    /* MRIhc03229: Search for farthest slice in each direction */
    min_y = max_y = scan_info[0].opphasoff;
    for (i=1;i<maxslices;i++) 
    {
       if (scan_info[i].opphasoff > max_y )
       {
           max_y = scan_info[i].opphasoff;
       }
       else if ( scan_info[i].opphasoff < min_y)
       {
       	   min_y = scan_info[i].opphasoff;
       }
    }

    if ( exist(opphasefov) != 1)
    {
        satylocpos  = _satylocpos.fixedflag ?       
              ((void)((exist(opfov)*exist(opphasefov)+satthicky2)/2+satgapypos+max_y), satylocpos) : (exist(opfov)*exist(opphasefov)+satthicky2)/2+satgapypos+max_y;
        satylocneg  = _satylocneg.fixedflag ?       
              ((void)((exist(opfov)*exist(opphasefov)+satthicky1)/-2-satgapyneg+min_y), satylocneg) : (exist(opfov)*exist(opphasefov)+satthicky1)/-2-satgapyneg+min_y;
    }
    else
    {
        satylocpos  = _satylocpos.fixedflag ?        ((void)((exist(opfov)+satthicky2)/2+satgapypos+max_y), satylocpos) : (exist(opfov)+satthicky2)/2+satgapypos+max_y;
        satylocneg  = _satylocneg.fixedflag ?        ((void)((exist(opfov)+satthicky1)/-2-satgapyneg+min_y), satylocneg) : (exist(opfov)+satthicky1)/-2-satgapyneg+min_y;
    }

    off_rfsy1  = _off_rfsy1.fixedflag ?  ((void)(0), off_rfsy1) : 0;
    off_rfsy2  = _off_rfsy2.fixedflag ?  ((void)(0), off_rfsy2) : 0;
    satspacey1  = _satspacey1.fixedflag ?  ((void)(0.0), satspacey1) : 0.0;
    satspacey2  = _satspacey2.fixedflag ?  ((void)(0.0), satspacey2) : 0.0;

    switch (opsaty) 		/* Calculate offset frequencies */
    {
    case PSD_SATOFF:
        off_rfsy1  = _off_rfsy1.fixedflag ?  ((void)(0), off_rfsy1) : 0;
        satspacey1  = _satspacey1.fixedflag ?  ((void)(0.0), satspacey1) : 0.0;
        off_rfsy2  = _off_rfsy2.fixedflag ?  ((void)(0), off_rfsy2) : 0;
        satspacey2  = _satspacey2.fixedflag ?  ((void)(0.0), satspacey2) : 0.0;
        break;

    case PSD_SATNEG:		/* Use negative location */
        off_rfsy1  = _off_rfsy1.fixedflag ?      ((void)(GAM*a_gyrfsy1*satylocneg/10), off_rfsy1) : GAM*a_gyrfsy1*satylocneg/10;
        satspacey1  = _satspacey1.fixedflag ?  ((void)(0.0), satspacey1) : 0.0;
        break;

    case PSD_SATPOS:		/* Use positive location */
        off_rfsy1  = _off_rfsy1.fixedflag ?      ((void)(GAM*a_gyrfsy1*satylocpos/10), off_rfsy1) : GAM*a_gyrfsy1*satylocpos/10;
        satspacey1  = _satspacey1.fixedflag ?  ((void)(0.0), satspacey1) : 0.0;
        break;

    case PSD_SATHAD:	/* Find middle of Hadamard and space btwn */
        off_rfsy1  = _off_rfsy1.fixedflag ?      ((void)(GAM*a_gyrfsy1*((satylocpos+satylocneg)/2.0)/10), off_rfsy1) : GAM*a_gyrfsy1*((satylocpos+satylocneg)/2.0)/10;
        satspacey1  = _satspacey1.fixedflag ?  ((void)(fabs(satylocpos-satylocneg)), satspacey1) : fabs(satylocpos-satylocneg);
        break;

    case PSD_SATPARA:      /* 2 SAT bands- positive & negative locs */
        off_rfsy1  = _off_rfsy1.fixedflag ?      ((void)(GAM*a_gyrfsy1*satylocneg/10), off_rfsy1) : GAM*a_gyrfsy1*satylocneg/10;
        satspacey1  = _satspacey1.fixedflag ?  ((void)(0.0), satspacey1) : 0.0;
        off_rfsy2  = _off_rfsy2.fixedflag ?      ((void)(GAM*a_gyrfsy2*satylocpos/10), off_rfsy2) : GAM*a_gyrfsy2*satylocpos/10;
        satspacey2  = _satspacey2.fixedflag ?  ((void)(0.0), satspacey2) : 0.0;
        break;
     
    default:
        break;
    }
  
    /* Z Sat placement ------------------------------------*/

    satgapzpos  = _satgapzpos.fixedflag ?  ((void)(30.0), satgapzpos) : 30.0;
    satgapzneg  = _satgapzneg.fixedflag ?  ((void)(30.0), satgapzneg) : 30.0;


    /* Not concatenated SAT */
    if ( (seq_type!=TYPCAT) && (seq_type!=TYP3DMSCAT) &&
            (exist(opccsat) == PSD_OFF) )
    {	
        /* Search for farthest slice in each direction */
        min_z = max_z = scan_info[0].optloc;
	for (i=1;i<maxslices;i++) 
        {
	    if (scan_info[i].optloc > max_z )
                max_z = scan_info[i].optloc;
	    else if ( scan_info[i].optloc < min_z)
		min_z = scan_info[i].optloc;
	}

        /* Place SAT bands at ends of prescribed slices */
        satzlocpos  = _satzlocpos.fixedflag ?        ((void)(max_z+(opslthick/2)+satgapzpos+satthickz2/2.0), satzlocpos) : max_z+(opslthick/2)+satgapzpos+satthickz2/2.0;
        satzlocneg  = _satzlocneg.fixedflag ?        ((void)(min_z-(opslthick/2)-satgapzneg-satthickz1/2.0), satzlocneg) : min_z-(opslthick/2)-satgapzneg-satthickz1/2.0;
    
        off_rfsz1  = _off_rfsz1.fixedflag ?  ((void)(0), off_rfsz1) : 0;
        off_rfsz2  = _off_rfsz2.fixedflag ?  ((void)(0), off_rfsz2) : 0;
        satspacez1  = _satspacez1.fixedflag ?  ((void)(0.0), satspacez1) : 0.0;
        satspacez2  = _satspacez2.fixedflag ?  ((void)(0.0), satspacez2) : 0.0;

        SatGetZOffset(satzlocpos,satzlocneg, _off_rfsz1.fixedflag ? (_temp745_off_rfsz1=off_rfsz1,&_temp745_off_rfsz1) : &off_rfsz1, _off_rfsz2.fixedflag ? (_temp746_off_rfsz2=off_rfsz2,&_temp746_off_rfsz2) : &off_rfsz2);

        if (opsatz==PSD_SATHAD)
	    satspacez1  = _satspacez1.fixedflag ?  ((void)(fabs(satzlocpos-satzlocneg)), satspacez1) : fabs(satzlocpos-satzlocneg);
        else
            satspacez1  = _satspacez1.fixedflag ?  ((void)(0.0), satspacez1) : 0.0;
    } 
    /* Concatenated SAT */
    else 
    {
        /* Initially set a and b sat locations to be the same */
        switch (opsatz)
        {
        case PSD_SATNEG:
            loczaoff = (opslthick/2.0) + satgapzneg + (satthickz1/2.0);
            loczboff = (opslthick/2.0) + satgapzneg + (satthickz1/2.0);
            break;
        
        case PSD_SATPOS:
            loczaoff = (opslthick/2.0) + satgapzpos + (satthickz2/2.0);
            loczboff = (opslthick/2.0) + satgapzpos + (satthickz2/2.0);
            break;

        case PSD_SATHAD:
            loczaoff = (opslthick/2.0) + satgapzpos + (satthickz1/2.0);
            loczboff = (opslthick/2.0) + satgapzpos + (satthickz2/2.0);
            break;

            /* PSD_SATPARA is an illegal selection with concat SAT */
        default:
            break; 
        }
    
        /* For sequential mode, there are always 1 slice per pass.
           To allow the saturated area to return to normal, the
           Z SAT bands are placed around 2 slices instead of the
           around the pass which only contains 1 slice. This allows
           the saturated area to relax before the slice is collected.

           If the direction of the slices prescribed ( i.e. S to I 
           or I to S) is the same as the SAT band selected (i.e. S in 
           the I to S case and I in the S to I case) then the SAT band
           needs to be moved 1 slice. In this case the sat band is 2
           bands away from the slice allowing the saturated area 
           an extra pass of time to relax before it becomes the next 
           slice to be collected. */

        if (opirmode==SIRMODE)
        {
            if (scan_info[0].optloc < scan_info[maxslices-1].optloc)
            {
                loczaoff += opslthick; /* move the sat forward by 1 slice */
            }
            else
            {
                loczboff += opslthick;	/* move the sat back by one slice */
            }
        }
  
        for (i=0;i<numPasses;i++) 	/* Initialize min and max storage */
        {
            max[i] = -1e10;	/* Just some big numbers that are */
            min[i] =  1e10;	/* opposite of what we are looking for */
	}
      
        /* Loop over all locations and check for the extent of the 
           slices in a pass. The scan_info table contains all the 
           slices in a scan. We need to know the slice extent for
           each pass; so only the slices in a particular pass are
           considered. */
        for (i=0;i<maxslices;i++) 
        {
            /* Figure out which pass we are in */
            pass = data_acq_order[i].slpass;

            /* check the range for this pass */
            if (scan_info[i].optloc > max[pass] )
            {
                max[pass] = scan_info[i].optloc;
            }
            if (scan_info[i].optloc < min[pass])
            {
                min[pass] = scan_info[i].optloc;
            }
        }

        /* For each pass, the z sat slice moves to surround that
           pass of slices. (Recall each pass is only 1 slice in sequential
           mode.) That is the definition of concat SAT.
           Concatenated sat is only supported for
           cases SATPOS, SATNEG and SATHAD, which only use one
           rf offset. That is why only the first off_rfsz1 is used. */
        for (i=0; i < numPasses; ++i)
        {
            satzloca  = _satzloca.fixedflag ?    ((void)(max[i]+loczaoff), satzloca) : max[i]+loczaoff;
            satzlocb  = _satzlocb.fixedflag ?    ((void)(min[i]-loczboff), satzlocb) : min[i]-loczboff;

            SatGetZOffset(satzloca,satzlocb, _off_rfsz1.fixedflag ? (_temp747_off_rfsz1=off_rfsz1,&_temp747_off_rfsz1) : &off_rfsz1, _off_rfsz2.fixedflag ? (_temp748_off_rfsz2=off_rfsz2,&_temp748_off_rfsz2) : &off_rfsz2);
            off_rfcsz[i] = off_rfsz1; 
        }
      
        /* Determine sat pulse separation */
        /* First slice always has the widest */
        if (opsatz==PSD_SATHAD)	/* Sat band separation for hadamard */
        {
            satspacez1  = _satspacez1.fixedflag ?  ((void)(((max[0]+loczaoff)-(min[0]-loczboff))), satspacez1) : ((max[0]+loczaoff)-(min[0]-loczboff));
        }
        else			/* otherwise no separation */
        {
            satspacez1  = _satspacez1.fixedflag ?  ((void)(0.0), satspacez1) : 0.0;
        }
    } /* end concat sat */

    /* Explicit SAT processing:
       1. Set Szt location
       2. Set RF offset frequency
       3. Set SAT spacing
       4. Process two SAT bands together if they are parallel
       5. Go to next SAT band unless it has been processed as
       part of parallel pair. */

    explicit_sat_mask = exist(opexsatmask);
    explicit_sat_paral = exist(opexsatparal);
    if (explicit_sat_mask != 0)
    {
        skip_next_sat = 0; 
        if ((explicit_sat_mask & PSD_EXPLICIT_1) != 0)  /* SAT band 1 & 2 */
        {
            satloce1  = _satloce1.fixedflag ?  ((void)(exist(opexsatloc1)), satloce1) : exist(opexsatloc1); 
            off_rfse1  = _off_rfse1.fixedflag ?      ((void)(GAM*a_gzrfse1*satloce1/10), off_rfse1) : GAM*a_gzrfse1*satloce1/10;
            satspace1  = _satspace1.fixedflag ?  ((void)(0), satspace1) : 0;
 
            if ((explicit_sat_paral & PSD_1_PARALLEL) != 0)
            {
                skip_next_sat = 1;
                satloce2  = _satloce2.fixedflag ?  ((void)(exist(opexsatloc2)), satloce2) : exist(opexsatloc2);
                off_rfse1  = _off_rfse1.fixedflag ?        ((void)(GAM*a_gzrfse1*((satloce1+satloce2)/2.)/10), off_rfse1) : GAM*a_gzrfse1*((satloce1+satloce2)/2.)/10;
                satspace1  = _satspace1.fixedflag ?     ((void)(fabs(satloce1-satloce2)), satspace1) : fabs(satloce1-satloce2);
            }
        }

        if (((explicit_sat_mask & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0))
        {
            satloce2  = _satloce2.fixedflag ?  ((void)(exist(opexsatloc2)), satloce2) : exist(opexsatloc2);
            off_rfse2  = _off_rfse2.fixedflag ?      ((void)(GAM*a_gzrfse2*satloce2/10), off_rfse2) : GAM*a_gzrfse2*satloce2/10;
            satspace2  = _satspace2.fixedflag ?  ((void)(0), satspace2) : 0;
        }

        skip_next_sat = 0;
        if ((explicit_sat_mask & PSD_EXPLICIT_3) != 0)  /* SAT band 3 & 4 */
        {
            satloce3  = _satloce3.fixedflag ?  ((void)(exist(opexsatloc3)), satloce3) : exist(opexsatloc3); 
            off_rfse3  = _off_rfse3.fixedflag ?      ((void)(GAM*a_gzrfse3*satloce3/10), off_rfse3) : GAM*a_gzrfse3*satloce3/10;
            satspace3  = _satspace3.fixedflag ?  ((void)(0), satspace3) : 0;
 
            if ((explicit_sat_paral & PSD_2_PARALLEL) != 0)
            {
                skip_next_sat = 1;
                satloce4  = _satloce4.fixedflag ?  ((void)(exist(opexsatloc4)), satloce4) : exist(opexsatloc4);
                off_rfse3  = _off_rfse3.fixedflag ?        ((void)(GAM*a_gzrfse3*((satloce3+satloce4)/2.)/10), off_rfse3) : GAM*a_gzrfse3*((satloce3+satloce4)/2.)/10;
                satspace3  = _satspace3.fixedflag ?     ((void)(fabs(satloce3-satloce4)), satspace3) : fabs(satloce3-satloce4);
            }
        }

        if (((explicit_sat_mask & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0))
        {
            satloce4  = _satloce4.fixedflag ?  ((void)(exist(opexsatloc4)), satloce4) : exist(opexsatloc4);
            off_rfse4  = _off_rfse4.fixedflag ?      ((void)(GAM*a_gzrfse4*satloce4/10), off_rfse4) : GAM*a_gzrfse4*satloce4/10;
            satspace4  = _satspace4.fixedflag ?  ((void)(0), satspace4) : 0;
        }

        skip_next_sat = 0;
        if ((explicit_sat_mask & PSD_EXPLICIT_5) != 0)  /* SAT band 5 & 6 */
        {
            satloce5  = _satloce5.fixedflag ?  ((void)(exist(opexsatloc5)), satloce5) : exist(opexsatloc5); 
            off_rfse5  = _off_rfse5.fixedflag ?      ((void)(GAM*a_gzrfse5*satloce5/10), off_rfse5) : GAM*a_gzrfse5*satloce5/10;
            satspace5  = _satspace5.fixedflag ?  ((void)(0.0), satspace5) : 0.0;
  
            if ((explicit_sat_paral & PSD_3_PARALLEL) != 0)
            {
                skip_next_sat = 1;
                satloce6  = _satloce6.fixedflag ?  ((void)(exist(opexsatloc6)), satloce6) : exist(opexsatloc6);
                off_rfse5  = _off_rfse5.fixedflag ?        ((void)(GAM*a_gzrfse5*((satloce5+satloce6)/2.)/10), off_rfse5) : GAM*a_gzrfse5*((satloce5+satloce6)/2.)/10;
                satspace5  = _satspace5.fixedflag ?     ((void)(fabs(satloce5-satloce6)), satspace5) : fabs(satloce5-satloce6);
            }
        }

        if (((explicit_sat_mask & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0))
        {
            satloce6  = _satloce6.fixedflag ?  ((void)(exist(opexsatloc6)), satloce6) : exist(opexsatloc6);
            off_rfse6  = _off_rfse6.fixedflag ?      ((void)(GAM*a_gzrfse6*satloce6/10), off_rfse6) : GAM*a_gzrfse6*satloce6/10;
            satspace6  = _satspace6.fixedflag ?  ((void)(0), satspace6) : 0;
        }
    } /* end explicit SAT */

	
    /* Scale the explicit rotation matrices, and the interspersed
       killer pulse rotation matrices (based on default rotation matrices).
       At this time the killer matrices are null - they will be copied
       in later in the SpSat_set_sat1_matrix call.  But we scale the
       matrices here in single scalerotmats call, for simplicity's sake */

    if(scalerotmats(sat_rot_matrices, &satloggrd, &phygrd, 2*sat_rot_ex_num,
                 sat_obl_debug) == FAILURE)
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }


    if (spsat_host_debug)
    {
        dump_sat_input();
    }

    return SUCCESS;
}

    /* Sets the internal rf pulse amplitudes. */
STATUS
SpSatIAmp( void )
{
    INT skip_next_sat;

    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return SUCCESS;

    if (exist(opsatx) > PSD_SATOFF)
    {
        ia_rfsx1  = _ia_rfsx1.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RFSX1_SLOT].amp)), ia_rfsx1) : max_pg_iamp*(*rfpulse[RFSX1_SLOT].amp);
        if (exist(opsatx) == PSD_SATPARA)
            ia_rfsx2  = _ia_rfsx2.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RFSX2_SLOT].amp)), ia_rfsx2) : max_pg_iamp*(*rfpulse[RFSX2_SLOT].amp);
    }
    if (exist(opsaty) > PSD_SATOFF)
    {
        ia_rfsy1  = _ia_rfsy1.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RFSY1_SLOT].amp)), ia_rfsy1) : max_pg_iamp*(*rfpulse[RFSY1_SLOT].amp);
        if (exist(opsaty) == PSD_SATPARA) 
            ia_rfsy2  = _ia_rfsy2.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RFSY2_SLOT].amp)), ia_rfsy2) : max_pg_iamp*(*rfpulse[RFSY2_SLOT].amp);
    }
    if (exist(opsatz) > PSD_SATOFF)
    {
        ia_rfsz1  = _ia_rfsz1.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RFSZ1_SLOT].amp)), ia_rfsz1) : max_pg_iamp*(*rfpulse[RFSZ1_SLOT].amp);
        if (exist(opsatz) == PSD_SATPARA)
            ia_rfsz2  = _ia_rfsz2.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RFSZ2_SLOT].amp)), ia_rfsz2) : max_pg_iamp*(*rfpulse[RFSZ2_SLOT].amp);
    }

    skip_next_sat = 0;
    if ((exist(opexsatmask) & PSD_EXPLICIT_1) != 0)
    {
        ia_rfse1  = _ia_rfse1.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RFSE1_SLOT].amp)), ia_rfse1) : max_pg_iamp*(*rfpulse[RFSE1_SLOT].amp);
        if ((exist(opexsatparal) & PSD_1_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((exist(opexsatmask) & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0))
        ia_rfse2  = _ia_rfse2.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RFSE2_SLOT].amp)), ia_rfse2) : max_pg_iamp*(*rfpulse[RFSE2_SLOT].amp);
 
    skip_next_sat = 0;
    if ((exist(opexsatmask) & PSD_EXPLICIT_3) != 0)
    {
        ia_rfse3  = _ia_rfse3.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RFSE3_SLOT].amp)), ia_rfse3) : max_pg_iamp*(*rfpulse[RFSE3_SLOT].amp);
        if ((exist(opexsatparal)& PSD_2_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((exist(opexsatmask) & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0))
        ia_rfse4  = _ia_rfse4.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RFSE4_SLOT].amp)), ia_rfse4) : max_pg_iamp*(*rfpulse[RFSE4_SLOT].amp);

    skip_next_sat = 0;
    if ((exist(opexsatmask) & PSD_EXPLICIT_5) != 0)
    {
        ia_rfse5  = _ia_rfse5.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RFSE5_SLOT].amp)), ia_rfse5) : max_pg_iamp*(*rfpulse[RFSE5_SLOT].amp);
        if ((exist(opexsatparal) & PSD_3_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((exist(opexsatmask) & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0))
        ia_rfse6  = _ia_rfse6.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RFSE6_SLOT].amp)), ia_rfse6) : max_pg_iamp*(*rfpulse[RFSE6_SLOT].amp);

    return SUCCESS;
}


BOOLEAN
isValidNucleus( const int nuclide,
                const int field )
{
    BOOLEAN validity = FALSE;

    switch( nuclide ) {
    case PSD_PROTON:
    case PSD_HELIUM:
    case PSD_LITHIUM:
    case PSD_BORON:
    case PSD_CARBON:
    case PSD_FLUORINE:
    case PSD_SODIUM:
    case PSD_PHOSPHORUS:
    case PSD_XENON:
        validity = TRUE;
        break;
    case PSD_DEUTERIUM:
    case PSD_OXYGEN:
    case PSD_SILICON:
        if( field >= B0_30000 )
        {
            validity = TRUE;
        }
        break;
    }

    return validity;
}

STATUS
BBcveval( int nucleus )
{

    if( (nucleus != PSD_PROTON) && (cfbbmod != PSD_ON) )
    {
        epic_error(use_ermes, "Broadband not enabled, set cfbbmod",
                   EM_PSD_BB_SPEC_NOT_AVAILABLE, EE_ARGS(0));
        return FAILURE;
    }

    cvdesc(opuser2, "nucleus");
    cvmin(opuser2, PSD_PROTON);
    cvmax(opuser2, (PSD_ON == cfbbmod) ? PSD_XENON : PSD_PROTON);
    cvdef(opuser2, PSD_PROTON);

    /* for legacy header information */
    cvoverride(opuser2, nucleus, PSD_FIX_ON, PSD_EXIST_ON);

        /* Specify the primary use of the imaging sequence
           and which exciter board it should use */
    if (nucleus == PSD_PROTON) {
        acquire_type  = _acquire_type.fixedflag ?  ((void)(SPECPSD_MASTER_H1), acquire_type) : SPECPSD_MASTER_H1;
    } else {
        acquire_type  = _acquire_type.fixedflag ?  ((void)(SPECPSD_SLAVE_MNS), acquire_type) : SPECPSD_SLAVE_MNS;
    }

    return specparamset(_GAM.fixedflag ? (_temp749_GAM=GAM,&_temp749_GAM) : &GAM, _pibbandfilt.fixedflag ? (_temp750_pibbandfilt=pibbandfilt,&_temp750_pibbandfilt) : &pibbandfilt, _pixmtband.fixedflag ? (_temp751_pixmtband=pixmtband,&_temp751_pixmtband) : &pixmtband, nucleus);

}

STATUS
BBpredownload( ENTRY_POINT_TABLE *ep_table,
               int entry,
               int nucleus )
{
    int ep;

#ifdef BB_FREQ_INVERT
    freq_inv = (pixmtband != AMP_ERBTEC) ? -1 : 1;
#endif

    /* These are epic.h CVs that will let us change the default
       values when doing research or testing */
    rcvbias  = _rcvbias.fixedflag ?  ((void)(ep_table[L_SCAN].eprcvrbias), rcvbias) : ep_table[L_SCAN].eprcvrbias;
    rcvinput  = _rcvinput.fixedflag ?  ((void)(ep_table[L_SCAN].eprcvrinput), rcvinput) : ep_table[L_SCAN].eprcvrinput;
    trdriver  = _trdriver.fixedflag ?  ((void)(ep_table[L_SCAN].eptrdriver), trdriver) : ep_table[L_SCAN].eptrdriver;
    rcvband  = _rcvband.fixedflag ?  ((void)(PSD_BROADBANDOFF), rcvband) : PSD_BROADBANDOFF;
    if(nucleus != PSD_PROTON) {
        rcvinput  = _rcvinput.fixedflag ?  ((void)(PSD_RP_SPECTRO), rcvinput) : PSD_RP_SPECTRO;
        rcvband  = _rcvband.fixedflag ?  ((void)(PSD_BROADBANDON), rcvband) : PSD_BROADBANDON;
    }

    if (ENTRY_POINT_ALL == entry) {
        for (ep = 0; ep < ENTRY_POINT_MAX; ep++) {
            ep_table[ep].eprcvrband = rcvband;
            ep_table[ep].eprcvrinput = (unsigned)rcvinput;

            ep_table[ep].eprcvrbias = (unsigned)rcvbias;
            ep_table[ep].eptrdriver = (unsigned)trdriver;
        }
    } else if ((entry < ENTRY_POINT_MAX) && (entry >= 0)) {
        ep_table[entry].eprcvrband = rcvband;
        ep_table[entry].eprcvrinput = (unsigned)rcvinput;

        ep_table[entry].eprcvrbias = (unsigned)rcvbias;
        ep_table[entry].eptrdriver = (unsigned)trdriver;
    } else {
        epic_error(0, "Incorrect entry point: %d", EE_ARGS(0), INT_ARG, entry);
        return FAILURE;
    }

    if(BBExciterUsage(acquire_type) != SUCCESS) {
        epic_error(use_ermes, "Support routine %s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "BBExciterUsage");
        return FAILURE;
    }

    return SUCCESS;
}

STATUS
BBExciterUsage( int acqtype )
{

    switch(acqtype) {
    case SPECPSD_SLAVE_H1:
        /* Make first Slave the active exciter on Spectro Prescan */
        rhexciterusage  = _rhexciterusage.fixedflag ?  ((void)(USE_EX2), rhexciterusage) : USE_EX2;
        /* Use proton GAMMA on the Slave exciter */
        rhexciterfreqs  = _rhexciterfreqs.fixedflag ?  ((void)(USE_H1_FRQ), rhexciterfreqs) : USE_H1_FRQ;
        break;
    case SPECPSD_SLAVE_MNS:
        /* Make first Slave the active exciter on Spectro Prescan */
        rhexciterusage  = _rhexciterusage.fixedflag ?  ((void)(USE_EX2), rhexciterusage) : USE_EX2;
        /* Use the selected GAMMA on the Slave exciter */
        rhexciterfreqs  = _rhexciterfreqs.fixedflag ?  ((void)(USE_GAM_EX2), rhexciterfreqs) : USE_GAM_EX2;
        break;
    case SPECPSD_MASTER_MNS:
        /* Make Master the active exciter on Spectro Prescan */
        rhexciterusage  = _rhexciterusage.fixedflag ?  ((void)(USE_EX1), rhexciterusage) : USE_EX1;
        /* Use selected GAMMA on the Master exciter */
        rhexciterfreqs  = _rhexciterfreqs.fixedflag ?  ((void)(USE_GAM_EX1), rhexciterfreqs) : USE_GAM_EX1;
        break;
    case SPECPSD_MASTER_H1:
    default:
        /* Make Master the active exciter on Spectro Prescan */
        rhexciterusage  = _rhexciterusage.fixedflag ?  ((void)(USE_EX1), rhexciterusage) : USE_EX1;
        /* Use proton GAMMA on the Master exciter */
        rhexciterfreqs  = _rhexciterfreqs.fixedflag ?  ((void)(USE_H1_FRQ), rhexciterfreqs) : USE_H1_FRQ;
        break;
    }

    return SUCCESS;
}

/*********************************************************************
 *                     PRESCAN.E HOST SECTION                        *
 *                             PShost                                *
 *                                                                   *
 * Write here the code unique to the Host PSD process.               *
 *********************************************************************/
#include <string.h>
#include "sar_pm.h" 
#include "epic_usercv.h"

/*
 *  set_presscfh_mode
 *  
 *  Type: Private Function
 *  
 *  Description: Set the modes for presscfh
 * 			PRESSCFH_SLICE 1      
 * 			PRESSCFH_SLAB 2                                              
 * 			PRESSCFH_SHIMVOL 3
 * 			PRESSCFH_NONE 4
 * 
 * */

STATUS
set_presscfh_mode (void)
{
    if(exist(oppscvquant) >= 1)
    {
        if (presscfh_override > 0) 
        {
            cvoverride(presscfh, presscfh_override, PSD_FIX_ON, PSD_EXIST_ON);
        }
        else
        {
            switch(exist(opimode)) 
            {
                case PSD_2D:
                case PSD_CINE: 
                    if( (opplane == PSD_3PLANE) || ((exist(oprealtime) == PSD_ON)) )
                    {   /* For 3-Plane or Realtime mode use SHIMVOL Mode*/
                        cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                    }
                    else 
                    {
                        if( exist(opcoax) != 0 ) 
                        {   /* NON-RADIAL MODE */
                            cvoverride(presscfh, PRESSCFH_SLICE, PSD_FIX_ON, PSD_EXIST_ON);
                            if(exist(opassetcal) && existcv(opassetcal) 
                               && ( (1==exist(opasset)) || (exist(opasset) == ASSET_REG_CAL) ) && existcv(opasset)) 
                            {
                                cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                            }
                        } 
                        else if(exist(opcoax) == 0) 
                        {   /* RADIAL MODE */
                            cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                        } 
                        else 
                        {
                            cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);	
                        }
                    }
                    break;
                case PSD_3D:
                case PSD_3DM:
                case PSD_ANGIO:
                    /* If Shim Volume is placed */
                    if( exist(opcoax) != 0 )      /* Non-Radial/Oblique MODE */
                    {
                        if( exist(opvquant) > 1 )     /* Multiple Slabs */
                        {
                            cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);	
                        }
                        else     /* Single Slab */
                        {
                            cvoverride(presscfh, PRESSCFH_SLAB, PSD_FIX_ON, PSD_EXIST_ON);
                        }
                    }
                    else     /* Radial Case or Orthogonal Slabs */
                    {
                        cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                    }
                    break;
                default: 
                    cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);
                    break;
            }
        } 
    }
    else
    {
        cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);
    }
    
    if(presscfh_debug) 
    {
        printf("\n The presscfh is %d (1 - SLICE, 2 - SLAB, 3 - SHIMVOL 4- NONE)\n",presscfh);
        printf("\n The presscfh_ctrl is %d (1 - SLICE, 2 - SLAB, 3 - SHIMVOL 4- NONE), \n",presscfh_ctrl);
        printf("\n The presscfh_override is %d (1 - SLICE, 2 - SLAB, 3 - SHIMVOL 4- NONE)\n",presscfh_override);
        fflush(stdout);
    }
    return SUCCESS;
}

/*
 *  sr_derate
 *  
 *  Type: Private Function
 *  
 *  Description:
 *    update the ramp time for loggrad by *sr_derate_factor  
 *    @param[out] lgrad, logical gradient characteristics
 *    @param[in]  sc_derate_factor, SR derating factor ( >=1.0 ) 
 *
 */

STATUS
sr_derate (LOG_GRAD *lgrad, const float sr_derate_factor)
{
    STATUS status = SUCCESS;

    if(sr_derate_factor < 1.0)
    {
        status = FAILURE;
    }
    else
    {
        lgrad->xrt = lgrad->xrt*sr_derate_factor; 
        lgrad->yrt = lgrad->yrt*sr_derate_factor; 
        lgrad->zrt = lgrad->zrt*sr_derate_factor; 
        lgrad->xft = lgrad->xft*sr_derate_factor;
        lgrad->yft = lgrad->yft*sr_derate_factor;
        lgrad->zft = lgrad->zft*sr_derate_factor;

        status = SUCCESS;
    }

    return status;
}

/*
 *  PS1cvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1cvinit( void )
{
    INT index;

    /* initialize pulse widths */
    pw_rf1mps1  = _pw_rf1mps1.fixedflag ?  ((void)(rfpulse[RF1_APS1_SLOT].nom_pw), pw_rf1mps1) : rfpulse[RF1_APS1_SLOT].nom_pw;
    pw_rf2mps1  = _pw_rf2mps1.fixedflag ?  ((void)(rfpulse[RF2_APS1_SLOT].nom_pw), pw_rf2mps1) : rfpulse[RF2_APS1_SLOT].nom_pw;

    /* initialize resolutions */
    res_rf1mps1  = _res_rf1mps1.fixedflag ?  ((void)(0), res_rf1mps1) : 0;
    res_rf2mps1  = _res_rf2mps1.fixedflag ?  ((void)(0), res_rf2mps1) : 0;

    /* initialize amplitudes */
    a_rf1mps1  = _a_rf1mps1.fixedflag ?  ((void)(0.5), a_rf1mps1) : 0.5;
    a_rf2mps1  = _a_rf2mps1.fixedflag ?  ((void)(1.0), a_rf2mps1) : 1.0;

    /* initialize flip angles */
    flip_rf1mps1  = _flip_rf1mps1.fixedflag ?  ((void)(90), flip_rf1mps1) : 90;
    flip_rf2mps1  = _flip_rf2mps1.fixedflag ?  ((void)(180), flip_rf2mps1) : 180;

    /* initialize sinc cycles */
    cyc_rf1mps1  = _cyc_rf1mps1.fixedflag ?  ((void)(1), cyc_rf1mps1) : 1;
    cyc_rf2mps1  = _cyc_rf2mps1.fixedflag ?  ((void)(1), cyc_rf2mps1) : 1;

    /* initialize gscale values */
    gscale_rf1mps1  = _gscale_rf1mps1.fixedflag ?  ((void)(0.90909), gscale_rf1mps1) : 0.90909;
    gscale_rf2mps1  = _gscale_rf2mps1.fixedflag ?  ((void)(0.4545), gscale_rf2mps1) : 0.4545;

    /* begin aps1_mod changes (GE) */
    if ( 1 == getAps1Mod() )
    {
        for( index = 0; index < 9; index++)
        {
            ps1scan_info[0].oprot[index] = 0.0;
        }

        if (1==getAps1ModPlane()) /* Axial, read=x */
        {
            ps1scan_info[0].oprot[0] = ps1scan_info[0].oprot[4] = ps1scan_info[0].oprot[8] = 1.0;
        }
        if (2==getAps1ModPlane()) /* Sagittal, read=z */
        {
            ps1scan_info[0].oprot[2] = ps1scan_info[0].oprot[4] = ps1scan_info[0].oprot[6] = 1.0;
        }
        if (3==getAps1ModPlane()) /* Coronal, read=z */
        {
            ps1scan_info[0].oprot[1] = ps1scan_info[0].oprot[5] = ps1scan_info[0].oprot[6] = 1.0;
        }
        if (4==getAps1ModPlane()) /* Axial, read=y */
        {
            ps1scan_info[0].oprot[1] = ps1scan_info[0].oprot[3] = ps1scan_info[0].oprot[8] = 1.0;
        }
        if (5==getAps1ModPlane()) /* Sagittal, read=y */
        {
            ps1scan_info[0].oprot[2] = ps1scan_info[0].oprot[3] = ps1scan_info[0].oprot[7] = 1.0;
        }
        if (6==getAps1ModPlane()) /* Coronal, read=x */
        {
            ps1scan_info[0].oprot[0] = ps1scan_info[0].oprot[5] = ps1scan_info[0].oprot[7] = 1.0;
        }
    }
    else
    {
        for (index = 0; index < 9; index++)
        {
            ps1scan_info[0].oprot[index] = scan_info[PSslice_num].oprot[index]; 
        }
    }
    /* end aps1_mod changes (GE) */

    ps1_newgeo  = _ps1_newgeo.fixedflag ?  ((void)(1), ps1_newgeo) : 1;
    if (obloptimize(&ps1loggrd, &phygrd, ps1scan_info, 1, PSD_OBL,
                    0, obl_method, ps1obl_debug, _ps1_newgeo.fixedflag ? (_temp752_ps1_newgeo=ps1_newgeo,&_temp752_ps1_newgeo) : &ps1_newgeo,
                    cfsrmode) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in PS1cvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    /* derate SR for quiet PSC */ 
    sr_derate(&ps1loggrd, PSsr_derate_factor);

    return SUCCESS;
}

/*
 *  CFLcvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLcvinit( void )
{
    /* initialize pulse widths */
    pw_rf1cfl  = _pw_rf1cfl.fixedflag ?  ((void)(rfpulse[RF1_CFL_SLOT].nom_pw), pw_rf1cfl) : rfpulse[RF1_CFL_SLOT].nom_pw;

    /* initialize resolutions */
    res_rf1cfl  = _res_rf1cfl.fixedflag ?   ((void)(0), res_rf1cfl) : 0;

    /* initialize amplitudes */
    a_rf1cfl  = _a_rf1cfl.fixedflag ?  ((void)(0.5), a_rf1cfl) : 0.5;

    /* initialize flip angles */
    flip_rf1cfl  = _flip_rf1cfl.fixedflag ?  ((void)(90), flip_rf1cfl) : 90;

    /* initialize sinc cycles */
    cyc_rf1cfl  = _cyc_rf1cfl.fixedflag ?  ((void)(2), cyc_rf1cfl) : 2; /* MRIhc54366: increased from 1 */

    /* initialize gscale values */
    gscale_rf1cfl  = _gscale_rf1cfl.fixedflag ?  ((void)(0.90909), gscale_rf1cfl) : 0.90909;

    return SUCCESS;
}


/*
 *  RCVNcvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNcvinit( void )
{
    if (CFG_VAL_RECEIVER_RRF == cfreceivertype)
    {
        rcvn_xres  = _rcvn_xres.fixedflag ?  ((void)(1024), rcvn_xres) : 1024;
    }
    else
    {
        rcvn_xres  = _rcvn_xres.fixedflag ?  ((void)(4096), rcvn_xres) : 4096;
    }
    return SUCCESS;
}


/*
 *  CFHcvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHcvinit( void )
{
    /* initialize pulse widths */
    pw_rf0cfh  = _pw_rf0cfh.fixedflag ?  ((void)(rfpulse[RF0_CFH_SLOT].nom_pw), pw_rf0cfh) : rfpulse[RF0_CFH_SLOT].nom_pw;
    pw_rf1cfh  = _pw_rf1cfh.fixedflag ?  ((void)(rfpulse[RF1_CFH_SLOT].nom_pw), pw_rf1cfh) : rfpulse[RF1_CFH_SLOT].nom_pw;
    pw_rf2cfh  = _pw_rf2cfh.fixedflag ?  ((void)(rfpulse[RF2_CFH_SLOT].nom_pw), pw_rf2cfh) : rfpulse[RF2_CFH_SLOT].nom_pw;
    pw_rf3cfh  = _pw_rf3cfh.fixedflag ?  ((void)(rfpulse[RF3_CFH_SLOT].nom_pw), pw_rf3cfh) : rfpulse[RF3_CFH_SLOT].nom_pw; /* For presscfh MRIhc08321 */

    /* initialize resolutions */
    res_rf0cfh  = _res_rf0cfh.fixedflag ?   ((void)(RES_SH_ADIABATIC), res_rf0cfh) : RES_SH_ADIABATIC; /* Adiabatic pulse */
    res_rf1cfh  = _res_rf1cfh.fixedflag ?   ((void)(0), res_rf1cfh) : 0;
    res_rf2cfh  = _res_rf2cfh.fixedflag ?   ((void)(0), res_rf2cfh) : 0;
    res_rf3cfh  = _res_rf3cfh.fixedflag ?   ((void)(0), res_rf3cfh) : 0; /* For presscfh MRIhc08321 */

    /* initialize amplitudes */
    a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(0.61), a_rf0cfh) : 0.61;
    a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5), a_rf1cfh) : 0.5;
    a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(1.0), a_rf2cfh) : 1.0;
    a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(1.0), a_rf3cfh) : 1.0; /* For presscfh MRIhc08321 */

    /* initialize flip angles */
    flip_rf0cfh  = _flip_rf0cfh.fixedflag ?  ((void)(180), flip_rf0cfh) : 180;
    flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(90), flip_rf1cfh) : 90;
    flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(180), flip_rf2cfh) : 180;
    flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(180), flip_rf3cfh) : 180; /* For presscfh MRIhc08321 */

    /* initialize sinc cycles */
    cyc_rf0cfh  = _cyc_rf0cfh.fixedflag ?  ((void)(2), cyc_rf0cfh) : 2; /* Adiabatic pulse */
    cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(1), cyc_rf1cfh) : 1;
    cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(1), cyc_rf2cfh) : 1;
    cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(1), cyc_rf3cfh) : 1; /* For presscfh MRIhc08321 */
    a_gyrf3cfh  = _a_gyrf3cfh.fixedflag ?  ((void)(0.0), a_gyrf3cfh) : 0.0;/*For presscfh MRIhc11621 */
    a_gxrf2cfh  = _a_gxrf2cfh.fixedflag ?  ((void)(0.0), a_gxrf2cfh) : 0.0;/*For  presscfh MRIhc11621 */
    a_gzrf1cfh  = _a_gzrf1cfh.fixedflag ?  ((void)(0.0), a_gzrf1cfh) : 0.0;/*For presscfh MRIhc11621 */
    a_gzrf0cfh  = _a_gzrf0cfh.fixedflag ?  ((void)(0.0), a_gzrf0cfh) : 0.0;/*For presscfh MRIhc11621 */


    /* initialize gscale values */
    gscale_rf1cfh  = _gscale_rf1cfh.fixedflag ?  ((void)(0.90909), gscale_rf1cfh) : 0.90909;

#ifdef PSD_CFH_CHEMSAT
    rfpulse[RFCSSAT_CFH_SLOT].pw = _pw_rfcssatcfh.fixedflag ? (_temp753_pw_rfcssatcfh=pw_rfcssatcfh,&_temp753_pw_rfcssatcfh) : &pw_rfcssatcfh;
    rfpulse[RFCSSAT_CFH_SLOT].amp = _a_rfcssatcfh.fixedflag ? (_temp754_a_rfcssatcfh=a_rfcssatcfh,&_temp754_a_rfcssatcfh) : &a_rfcssatcfh;
    rfpulse[RFCSSAT_CFH_SLOT].act_fa = _flip_rfcssatcfh.fixedflag ? (_temp755_flip_rfcssatcfh=flip_rfcssatcfh,&_temp755_flip_rfcssatcfh) : &flip_rfcssatcfh;
#endif

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp756_pw_rf1cfh=pw_rf1cfh,&_temp756_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp757_a_rf1cfh=a_rf1cfh,&_temp757_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp758_flip_rf1cfh=flip_rf1cfh,&_temp758_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp759_res_rf1cfh=res_rf1cfh,&_temp759_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp760_wg_rf1cfh=wg_rf1cfh,&_temp760_wg_rf1cfh) : &wg_rf1cfh, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp761_pw_rf2cfh=pw_rf2cfh,&_temp761_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp762_a_rf2cfh=a_rf2cfh,&_temp762_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp763_flip_rf2cfh=flip_rf2cfh,&_temp763_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp764_res_rf2cfh=res_rf2cfh,&_temp764_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp765_wg_rf2cfh=wg_rf2cfh,&_temp765_wg_rf2cfh) : &wg_rf2cfh, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp766_pw_rf3cfh=pw_rf3cfh,&_temp766_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp767_a_rf3cfh=a_rf3cfh,&_temp767_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp768_flip_rf3cfh=flip_rf3cfh,&_temp768_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp769_res_rf3cfh=res_rf3cfh,&_temp769_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp770_wg_rf3cfh=wg_rf3cfh,&_temp770_wg_rf3cfh) : &wg_rf3cfh, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(1), a_rf0cfh) : 1;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5464), a_rf1cfh) : 0.5464; /* 0.5/0.61*(60/90) */
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(0.5464), a_rf2cfh) : 0.5464;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(0.5464), a_rf3cfh) : 0.5464; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(60), flip_rf1cfh) : 60;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(60), flip_rf2cfh) : 60;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(60), flip_rf3cfh) : 60; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(3), cyc_rf1cfh) : 3;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(3), cyc_rf2cfh) : 3;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(3), cyc_rf3cfh) : 3; 
    }
    else
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp771_pw_rf1cfh=pw_rf1cfh,&_temp771_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp772_a_rf1cfh=a_rf1cfh,&_temp772_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp773_flip_rf1cfh=flip_rf1cfh,&_temp773_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp774_res_rf1cfh=res_rf1cfh,&_temp774_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp775_wg_rf1cfh=wg_rf1cfh,&_temp775_wg_rf1cfh) : &wg_rf1cfh, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp776_pw_rf2cfh=pw_rf2cfh,&_temp776_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp777_a_rf2cfh=a_rf2cfh,&_temp777_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp778_flip_rf2cfh=flip_rf2cfh,&_temp778_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp779_res_rf2cfh=res_rf2cfh,&_temp779_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp780_wg_rf2cfh=wg_rf2cfh,&_temp780_wg_rf2cfh) : &wg_rf2cfh, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp781_pw_rf3cfh=pw_rf3cfh,&_temp781_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp782_a_rf3cfh=a_rf3cfh,&_temp782_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp783_flip_rf3cfh=flip_rf3cfh,&_temp783_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp784_res_rf3cfh=res_rf3cfh,&_temp784_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp785_wg_rf3cfh=wg_rf3cfh,&_temp785_wg_rf3cfh) : &wg_rf3cfh, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(0.61), a_rf0cfh) : 0.61;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5), a_rf1cfh) : 0.5;
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(1.0), a_rf2cfh) : 1.0;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(1.0), a_rf3cfh) : 1.0; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(90), flip_rf1cfh) : 90;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(180), flip_rf2cfh) : 180;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(180), flip_rf3cfh) : 180; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(1), cyc_rf1cfh) : 1;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(1), cyc_rf2cfh) : 1;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(1), cyc_rf3cfh) : 1; 
    }

    return SUCCESS;
}



/*
 *  PScvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PScvinit( void )
{

    if( (exist(opimode) == PSD_SPECTRO) || (PSD_ON == pimrsapsflg) )
    {
        fastprescan  = _fastprescan.fixedflag ?  ((void)(0), fastprescan) : 0;
    }
    else
    {
        fastprescan  = _fastprescan.fixedflag ?  ((void)(cffastprescan), fastprescan) : cffastprescan;
    }

    /* Set the modes for presscfh */
    set_presscfh_mode();
    
    /* Fix to set CFH,CFL,APS1, FTG slice location to be axial mid slice to ensure
       the presence of signal when sample position is off iso center such as wrist scout scans */
    if (opplane == PSD_3PLANE)
    {
        PSslice_num  = _PSslice_num.fixedflag ?  ((void)((int)(opaxial_slice/2)), PSslice_num) : (int)(opaxial_slice/2);
    }
    else
    {  /* Start of code moved up from PSpredownload section below by SL */
        FLOAT minloc;
        FLOAT maxloc;         /* For MRIge45995 */
        FLOAT midloc;         /* For MRIge45995 */
        FLOAT minimum;        /* For MRIge45995 */
        FLOAT loc;
        INT index;

        /* search through the scan table to find the location nearest
           isocenter. Save the location information for prescan since
           graphic sat and different imaging techniques can alter the
           content and format of the rspinfo structure
        */

        minloc = MAXFLOAT;  /* For MRIge45995 */
        maxloc = -MAXFLOAT; /* For MRIge45995 */

        /* First to find the center of the prescribed region, MRIge45995 */
        for (index=0;index<opslquant*opvquant;index++)
        {
            loc = scan_info[index].optloc;
            if (loc < minloc)
            {
                minloc = loc;
            }
            if (loc > maxloc)
            {
                maxloc = loc;
            }
        }
        midloc = 0.5*(minloc + maxloc);

        /* Find the slice most close to the center of the prescribed region, MRIge45995 */
        minimum = MAXFLOAT;
        for (index=0;index<opslquant*opvquant;index++)
        {
            loc = scan_info[index].optloc;
            if (fabs(loc-midloc) < minimum)
            {
                minimum = fabs(loc-midloc);
                PSslice_num  = _PSslice_num.fixedflag ?  ((void)(index), PSslice_num) : index;
            }
        }
    } /* End of code moved up from PSpredownload section below */

    /* Comment from /vobs/scan/MrScan/SrxControl/SrxGeos.m on setting opcoax */
    /* slightly modified */

    /* This next section determines the value of the opcoax CV  */
    /* The rules are as follows:  */
    /*   */
    /* coaxial      N   Y   Y  */
    /* offcenter    -   N   Y  */
    /* ======================  */
    /* opcoax       0   1   2  */
    /*  */
    /* The decision of NOT coaxial is determined by the following three  */
    /* conditions: (graphic rx imaging option selected) AND (oblique   */
    /* prescription) AND ( (more than one group has been prescribed) OR (Number
     * of radial slices > 1 ) ).  */
    /*  */
    /* The decision of offcenter is made based on whether or not   */
    /* all of the slices have 0 offset in their phase and frequency  */
    /* directions.  If even one is not 0, then the prescription is  */
    /* said to be offcenter.  */

    /* Use the below in the PSD Code if the HDMR2 changes for MRIhc08321
     * need to be overridden. RBA for MRIhc08321.
     */
    
    
    PS1cvinit();
    CFLcvinit();
    CFHcvinit();
    RCVNcvinit();

    /* initialize field strength and PS variables */ /* vmx 05/02/95 YO */
    PSfield_strength  = _PSfield_strength.fixedflag ?   ((void)((int)cffield), PSfield_strength) : (int)cffield;
    if(PSfield_strength <= B0_5000)
    {
        PScs_sat  = _PScs_sat.fixedflag ?  ((void)(1), PScs_sat) : 1;
        PSmt  = _PSmt.fixedflag ?  ((void)(0), PSmt) : 0;
    }
    else
    {
        if (aspir_flag || (PSD_ON == exist(opspecir)))
        {   /* turn OFF ASPIR/SPECIAL during CFH */
            PScs_sat  = _PScs_sat.fixedflag ?  ((void)(0), PScs_sat) : 0;
        } else {
            PScs_sat  = _PScs_sat.fixedflag ?  ((void)(1), PScs_sat) : 1;
        }

        if (use_spsp_fatsat)
        {   /* turn OFF SPSP FATSAT during CFH */
            PScs_sat  = _PScs_sat.fixedflag ?  ((void)(0), PScs_sat) : 0;
        } 
        PSmt  = _PSmt.fixedflag ?  ((void)(1), PSmt) : 1;
    }

    pimrs[0] = _pimrsaps1.fixedflag ? (_temp786_pimrsaps1=pimrsaps1,&_temp786_pimrsaps1) : &pimrsaps1;
    pimrs[1] = _pimrsaps2.fixedflag ? (_temp787_pimrsaps2=pimrsaps2,&_temp787_pimrsaps2) : &pimrsaps2;
    pimrs[2] = _pimrsaps3.fixedflag ? (_temp788_pimrsaps3=pimrsaps3,&_temp788_pimrsaps3) : &pimrsaps3;
    pimrs[3] = _pimrsaps4.fixedflag ? (_temp789_pimrsaps4=pimrsaps4,&_temp789_pimrsaps4) : &pimrsaps4;
    pimrs[4] = _pimrsaps5.fixedflag ? (_temp790_pimrsaps5=pimrsaps5,&_temp790_pimrsaps5) : &pimrsaps5;
    pimrs[5] = _pimrsaps6.fixedflag ? (_temp791_pimrsaps6=pimrsaps6,&_temp791_pimrsaps6) : &pimrsaps6;
    pimrs[6] = _pimrsaps7.fixedflag ? (_temp792_pimrsaps7=pimrsaps7,&_temp792_pimrsaps7) : &pimrsaps7;
    pimrs[7] = _pimrsaps8.fixedflag ? (_temp793_pimrsaps8=pimrsaps8,&_temp793_pimrsaps8) : &pimrsaps8;
    pimrs[8] = _pimrsaps9.fixedflag ? (_temp794_pimrsaps9=pimrsaps9,&_temp794_pimrsaps9) : &pimrsaps9;
    pimrs[9] = _pimrsaps10.fixedflag ? (_temp795_pimrsaps10=pimrsaps10,&_temp795_pimrsaps10) : &pimrsaps10;
    pimrs[10] = _pimrsaps11.fixedflag ? (_temp796_pimrsaps11=pimrsaps11,&_temp796_pimrsaps11) : &pimrsaps11;
    pimrs[11] = _pimrsaps12.fixedflag ? (_temp797_pimrsaps12=pimrsaps12,&_temp797_pimrsaps12) : &pimrsaps12;
    pimrs[12] = _pimrsaps13.fixedflag ? (_temp798_pimrsaps13=pimrsaps13,&_temp798_pimrsaps13) : &pimrsaps13;
    pimrs[13] = _pimrsaps14.fixedflag ? (_temp799_pimrsaps14=pimrsaps14,&_temp799_pimrsaps14) : &pimrsaps14;
    pimrs[14] = _pimrsaps15.fixedflag ? (_temp800_pimrsaps15=pimrsaps15,&_temp800_pimrsaps15) : &pimrsaps15;

    
    /* MRIhc15304: we will keep asfov as cv and fill it with the value
     * from coil. Some application (Spectro related) need to decide the
     * asfov based on the application (overriding the value decided by
     * coil). */ 
    asfov  = _asfov.fixedflag ?  ((void)(coilInfo[0].autoshimFov), asfov) : coilInfo[0].autoshimFov;

    /* 
     * Set the wait time for sethubindeximm.  A 100 ms delay is
     * sufficent to apply the settings on the driver module.  On systems
     * with an RRF receiver, a longer delay (250 ms) is needed for the
     * new receiver channel map to be loaded into the DRF. 
     */
    if( cfcoilswitchmethod & COIL_SWITCH_RSP_SETHUBINDEXIMM )
    {
        if( CFG_VAL_RECEIVER_RRF == cfreceivertype )
        {
            csw_wait_sethubindeximm   = _csw_wait_sethubindeximm.fixedflag ?  ((void)(250000), csw_wait_sethubindeximm) : 250000;
        }
        else
        {
            csw_wait_sethubindeximm   = _csw_wait_sethubindeximm.fixedflag ?  ((void)(100000), csw_wait_sethubindeximm) : 100000;
        }
    }

    return SUCCESS;

}   /* end PScvinit() */


/*
 *  FTGcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGcvinit( void )
{
    a_rf1ftg     = _a_rf1ftg.fixedflag ?  ((void)(0.5), a_rf1ftg) : 0.5;
    a_rf2ftg     = _a_rf2ftg.fixedflag ?  ((void)(1.0), a_rf2ftg) : 1.0;
    a_rf3ftg     = _a_rf3ftg.fixedflag ?  ((void)(1.0), a_rf3ftg) : 1.0;
    pw_rf1ftg    = _pw_rf1ftg.fixedflag ?  ((void)((int)rfpulse[RF1_FTG_SLOT].nom_pw), pw_rf1ftg) : (int)rfpulse[RF1_FTG_SLOT].nom_pw;
    pw_rf2ftg    = _pw_rf2ftg.fixedflag ?  ((void)((int)rfpulse[RF2_FTG_SLOT].nom_pw), pw_rf2ftg) : (int)rfpulse[RF2_FTG_SLOT].nom_pw;
    pw_rf3ftg    = _pw_rf3ftg.fixedflag ?  ((void)((int)rfpulse[RF3_FTG_SLOT].nom_pw), pw_rf3ftg) : (int)rfpulse[RF3_FTG_SLOT].nom_pw;
    cyc_rf1ftg   = _cyc_rf1ftg.fixedflag ?  ((void)(1), cyc_rf1ftg) : 1;
    res_rf1ftg   = _res_rf1ftg.fixedflag ?  ((void)(800), res_rf1ftg) : 800;
    cyc_rf2ftg   = _cyc_rf2ftg.fixedflag ?  ((void)(1), cyc_rf2ftg) : 1;
    res_rf2ftg   = _res_rf2ftg.fixedflag ?  ((void)(800), res_rf2ftg) : 800;
    cyc_rf3ftg   = _cyc_rf3ftg.fixedflag ?  ((void)(1), cyc_rf3ftg) : 1;
    res_rf3ftg   = _res_rf3ftg.fixedflag ?  ((void)(800), res_rf3ftg) : 800;
    flip_rf1ftg  = _flip_rf1ftg.fixedflag ?   ((void)(90.0), flip_rf1ftg) : 90.0;
    flip_rf2ftg  = _flip_rf2ftg.fixedflag ?  ((void)(180.0), flip_rf2ftg) : 180.0;
    flip_rf3ftg  = _flip_rf3ftg.fixedflag ?  ((void)(180.0), flip_rf3ftg) : 180.0;

    return SUCCESS;
} /* end FTGcvinit() */


/*
 *  XTGcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGcvinit( void )
{    
    double coil_maxb1, fermi_b1; /* HCSDM00157626 */
    a_rf1xtg     = _a_rf1xtg.fixedflag ?  ((void)(0.5), a_rf1xtg) : 0.5;
    a_rf2xtg     = _a_rf2xtg.fixedflag ?  ((void)(1.0), a_rf2xtg) : 1.0;
    pw_rf1xtg    = _pw_rf1xtg.fixedflag ?  ((void)((int)rfpulse[RF1_XTG_SLOT].nom_pw), pw_rf1xtg) : (int)rfpulse[RF1_XTG_SLOT].nom_pw;
    pw_rf2xtg    = _pw_rf2xtg.fixedflag ?  ((void)((int)rfpulse[RF2_XTG_SLOT].nom_pw), pw_rf2xtg) : (int)rfpulse[RF2_XTG_SLOT].nom_pw;
    cyc_rf1xtg   = _cyc_rf1xtg.fixedflag ?  ((void)(1), cyc_rf1xtg) : 1;
    res_rf1xtg   = _res_rf1xtg.fixedflag ?  ((void)(800), res_rf1xtg) : 800;
    cyc_rf2xtg   = _cyc_rf2xtg.fixedflag ?  ((void)(1), cyc_rf2xtg) : 1;
    res_rf2xtg   = _res_rf2xtg.fixedflag ?  ((void)(800), res_rf2xtg) : 800;
    flip_rf1xtg  = _flip_rf1xtg.fixedflag ?   ((void)(90.0), flip_rf1xtg) : 90.0;
    flip_rf2xtg  = _flip_rf2xtg.fixedflag ?  ((void)(180.0), flip_rf2xtg) : 180.0;

    a_rf3xtg  = _a_rf3xtg.fixedflag ?  ((void)(-1.0), a_rf3xtg) : -1.0; 
    a_rf4xtg  = _a_rf4xtg.fixedflag ?  ((void)(1.0), a_rf4xtg) : 1.0;
    res_rf3xtg  = _res_rf3xtg.fixedflag ?  ((void)(RES_FERMI_BLS), res_rf3xtg) : RES_FERMI_BLS;
    res_rf4xtg  = _res_rf4xtg.fixedflag ?  ((void)(res_rf3xtg), res_rf4xtg) : res_rf3xtg;
    pw_rf3xtg    = _pw_rf3xtg.fixedflag ?  ((void)(pw_bsrf), pw_rf3xtg) : pw_bsrf;
    pw_rf4xtg    = _pw_rf4xtg.fixedflag ?  ((void)(pw_rf3xtg), pw_rf4xtg) : pw_rf3xtg;
    
    flip_rf3xtg  = _flip_rf3xtg.fixedflag ?  ((void)((FA_FERMI_BLS*pw_rf3xtg)/SAR_FERMI_BLS_NOM_PW), flip_rf3xtg) : (FA_FERMI_BLS*pw_rf3xtg)/SAR_FERMI_BLS_NOM_PW;  /* scale flip to keep its maxB1 constant */
    /* 630 degree flip, 4ms pw: max B1 = 0.071 */

    /* HCSDM00157626: scale rf3xtg and rf4xtg flip angle if coil B1 limit
       would otherwise force pulses to stretch */
    coil_maxb1 = txCoilInfo[getTxIndex(coilInfo[0])].maxB1Peak;
    fermi_b1 = 100*FA_FERMI_BLS/NOM_FA_RFMT*SAR_MAXB1_FERMI_BLS;

    if(fermi_b1 > coil_maxb1)
    {
        flip_rf3xtg  = _flip_rf3xtg.fixedflag ?  ((void)((float)((int)(flip_rf3xtg*coil_maxb1/fermi_b1))), flip_rf3xtg) : (float)((int)(flip_rf3xtg*coil_maxb1/fermi_b1));
    }

    flip_rf4xtg  = _flip_rf4xtg.fixedflag ?  ((void)(flip_rf3xtg), flip_rf4xtg) : flip_rf3xtg;       
    
    rfpulse[RF3_XTG_SLOT].num = 1;  /* New TG */
    rfpulse[RF3_XTG_SLOT].activity = rfpulse[RF1_XTG_SLOT].activity;
    rfpulse[RF4_XTG_SLOT].num = 1;  /* New TG */
    rfpulse[RF4_XTG_SLOT].activity = rfpulse[RF1_XTG_SLOT].activity;    
        
    xtgtr  = _xtgtr.fixedflag ?  ((void)(200000), xtgtr) : 200000;
    
    xtg_dda  = _xtg_dda.fixedflag ?  ((void)(2), xtg_dda) : 2;
    XTGacq1  = _XTGacq1.fixedflag ?  ((void)(PSD_ON), XTGacq1) : PSD_ON;
        
    return SUCCESS;
} /* end XTGcvinit() */

/*
 *  AScvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
AScvinit( void )
{
    INT asplane;
    INT ascell;

    td0as  = _td0as.fixedflag ?  ((void)(GRAD_UPDATE_TIME), td0as) : GRAD_UPDATE_TIME;

    /* Create a pseudo scan_info table for obloptimize to work with.
       The rotation matrices for the planes are what is important. */
    for( asplane = 0; asplane < 3; asplane++ )
    {
        for( ascell = 0; ascell < 9; ascell++ )
        {
            asscan_info[asplane].oprot[ascell] = 0.0;
        }
    }

    /* Axial */
    asscan_info[0].oprot[0] = asscan_info[0].oprot[4] = asscan_info[0].oprot[8]
        = 1.0;
    /* Sagittal */
    asscan_info[1].oprot[2] = asscan_info[1].oprot[4] = asscan_info[1].oprot[6]
        = 1.0;
    /* Coronal */
    asscan_info[2].oprot[1] = asscan_info[2].oprot[5] = asscan_info[2].oprot[6]
        = 1.0;
  
    as_newgeo  = _as_newgeo.fixedflag ?  ((void)(1), as_newgeo) : 1;
    if (FAILURE==obloptimize(&asloggrd, &phygrd, asscan_info, 3, PSD_OBL,
                             0, PSD_OBL_RESTRICT, asobl_debug, _as_newgeo.fixedflag ? (_temp801_as_newgeo=as_newgeo,&_temp801_as_newgeo) : &as_newgeo,
                             cfsrmode))
    {
        epic_error(use_ermes, "%s failed in AScvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    /* derate SR for quiet PSC */ 
    sr_derate(&asloggrd, PSassr_derate_factor);

    /* X Killer CVs */
    if (FAILURE==amppwgrad(asx_killer_area, asloggrd.tx_xz, 0.0, 0.0, asloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkas.fixedflag ? (_temp802_a_gxkas=a_gxkas,&_temp802_a_gxkas) : &a_gxkas, _pw_gxkasa.fixedflag ? (_temp803_pw_gxkasa=pw_gxkasa,&_temp803_pw_gxkasa) : &pw_gxkasa,
                           _pw_gxkas.fixedflag ? (_temp804_pw_gxkas=pw_gxkas,&_temp804_pw_gxkas) : &pw_gxkas, _pw_gxkasd.fixedflag ? (_temp805_pw_gxkasd=pw_gxkasd,&_temp805_pw_gxkasd) : &pw_gxkasd ))
    {
        epic_error(use_ermes, "%s failed in AScvinit.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkas"); 
        return FAILURE;
    }

    /* Z Killer CVs */
    if (FAILURE==amppwgrad(asz_killer_area, asloggrd.tz_xz, 0.0, 0.0, asloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkas.fixedflag ? (_temp806_a_gzkas=a_gzkas,&_temp806_a_gzkas) : &a_gzkas, _pw_gzkasa.fixedflag ? (_temp807_pw_gzkasa=pw_gzkasa,&_temp807_pw_gzkasa) : &pw_gzkasa,
                           _pw_gzkas.fixedflag ? (_temp808_pw_gzkas=pw_gzkas,&_temp808_pw_gzkas) : &pw_gzkas, _pw_gzkasd.fixedflag ? (_temp809_pw_gzkasd=pw_gzkasd,&_temp809_pw_gzkasd) : &pw_gzkasd ))
    {
        epic_error(use_ermes, "%s failed in AScvinit.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkas"); 
        return FAILURE;
    }

    /* rf1 cvs  */
    a_rf1as  = _a_rf1as.fixedflag ?  ((void)(1.0), a_rf1as) : 1.0;
    pw_rf1as  = _pw_rf1as.fixedflag ?  ((void)(rfpulse[RF1_AUTOSHIM].nom_pw), pw_rf1as) : rfpulse[RF1_AUTOSHIM].nom_pw;
    gscale_rf1as  = _gscale_rf1as.fixedflag ?  ((void)(.90909), gscale_rf1as) : .90909;
    cyc_rf1as  = _cyc_rf1as.fixedflag ?  ((void)(1), cyc_rf1as) : 1;
    res_rf1as  = _res_rf1as.fixedflag ?  ((void)(0), res_rf1as) : 0; /* initialized to zero for system safety check in cveval */

    /* gzrf1 cvs */
    pw_gzrf1as  = _pw_gzrf1as.fixedflag ?  ((void)(pw_rf1as), pw_gzrf1as) : pw_rf1as;
    flip_rf1as  = _flip_rf1as.fixedflag ?  ((void)(asflip), flip_rf1as) : asflip;

    /*******************/
    /* Starting point  */
    /*******************/
    tleadas   = _tleadas.fixedflag ?    ((void)(RUP_GRD(24)), tleadas) : RUP_GRD(24);
    bw_rf1as  = _bw_rf1as.fixedflag ?      ((void)(4*cyc_rf1as/((float)pw_rf1as/(float)1000000)), bw_rf1as) : 4*cyc_rf1as/((float)pw_rf1as/(float)1000000);
    t_exaas   = _t_exaas.fixedflag ?     ((void)(pw_gzrf1asa+pw_rf1as/2), t_exaas) : pw_gzrf1asa+pw_rf1as/2;

    return SUCCESS;
} /* end AScvinit() */


/*
 *  AScveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
AScveval( void )
{
    /* REDFLAG : Making the same as 1.0T and 1.5T (3T/4T) */
    if ((fastprescan == 1) &&
        ((cffield == B0_10000) || (cffield == B0_15000) ||
         (cffield == B0_30000) || (cffield == B0_40000)))
    {
        as_dda  = _as_dda.fixedflag ?  ((void)(0), as_dda) : 0;
        echo1bwas  = _echo1bwas.fixedflag ?  ((void)(62.5), echo1bwas) : 62.5;
        asbaseline  = _asbaseline.fixedflag ?  ((void)(0), asbaseline) : 0;
        asxres  = _asxres.fixedflag ?  ((void)(128), asxres) : 128;
        asyres  = _asyres.fixedflag ?   ((void)(64), asyres) : 64;
        /* asres=128 and asyres=64 for all T fields */
    }
    else
    {
        as_dda  = _as_dda.fixedflag ?  ((void)(4), as_dda) : 4;
        echo1bwas  = _echo1bwas.fixedflag ?  ((void)(15.625), echo1bwas) : 15.625;
        asxres  = _asxres.fixedflag ?  ((void)(256), asxres) : 256;
        asyres  = _asyres.fixedflag ?  ((void)(128), asyres) : 128;
        asbaseline  = _asbaseline.fixedflag ?  ((void)(8), asbaseline) : 8;
        te_as  = _te_as.fixedflag ?  ((void)(9000), te_as) : 9000;
        if (cffield == B0_15000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(25000), tr_as) : 25000;
        }
        else if (cffield == B0_10000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(30000), tr_as) : 30000;
        }
        else if (cffield == B0_2000) /* profile 05/22/95 NM */
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(40000), tr_as) : 40000; /* Profile 09/29/95 NM */
        }
        else if (cffield == B0_3500) /* MFO,Hino, Feb/02/00 MM */
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(40000), tr_as) : 40000;
        }
        else if (cffield == B0_5000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(35000), tr_as) : 35000;
        }
        else if (cffield == B0_40000)
        {
            /* REDFLAG : Using same value as 1.5T. */
            tr_as  = _tr_as.fixedflag ?  ((void)(25000), tr_as) : 25000;
            DEBUG_4_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
        }
        else if (cffield == B0_30000)
        {
            /* REDFLAG : Using same value as 1.5T. */
            tr_as  = _tr_as.fixedflag ?  ((void)(25000), tr_as) : 25000;
            DEBUG_3_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
        }
        else if (cffield == B0_7000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(32000), tr_as) : 32000;
            DEBUG_0_7(SD_PSD_SUPPORT,__FILE__,__LINE__);
        }
        else 
        {
            SDL_PrintFStrengthWarning(SD_PSD_SUPPORT,cffield,__FILE__,__LINE__);
        }
    }

    /* MRIge21914 - moved deltf to @cv */

    /* Call the SDL function to compute fat-water separation. */
    deltf  = _deltf.fixedflag ?    ((void)(SDL_GetChemicalShift(cffield)), deltf) : SDL_GetChemicalShift(cffield);
    /* In phase delta TE will be used in MFO. Hino, Feb/02/00 MM */

    /* dixon time shift.  put it on grad boundary. */
    dix_timeas  = _dix_timeas.fixedflag ?   ((void)(RUP_GRD((int)(1000000/deltf))), dix_timeas) : RUP_GRD((int)(1000000/deltf));
    pw_sdixon2  = _pw_sdixon2.fixedflag ?    ((void)(GRAD_UPDATE_TIME+dix_timeas), pw_sdixon2) : GRAD_UPDATE_TIME+dix_timeas;

    /********************************************************/
    /*   Z Board                                            */
    /*   Slice Selection                                    */
    /********************************************************/
    if (FAILURE==ampslice(_a_gzrf1as.fixedflag ? (_temp810_a_gzrf1as=a_gzrf1as,&_temp810_a_gzrf1as) : &a_gzrf1as, bw_rf1as, asslthick, gscale_rf1as, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1as.");

        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gzrf1asa.fixedflag ? (_temp811_pw_gzrf1asa=pw_gzrf1asa,&_temp811_pw_gzrf1asa) : &pw_gzrf1asa, a_gzrf1as, asloggrd.tz_xyz, asloggrd.zrt, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1asa.");
        return FAILURE;
    }
    pw_gzrf1asd  = _pw_gzrf1asd.fixedflag ?  ((void)(pw_gzrf1asa), pw_gzrf1asd) : pw_gzrf1asa;

    /******************************************/
    /*   Calc area needed for z rephaser      */
    /******************************************/
    area_gz1as  = _area_gz1as.fixedflag ?     ((void)((off90as+pw_rf1as/2.0+pw_gzrf1asd/2.0)*a_gzrf1as), area_gz1as) : (off90as+pw_rf1as/2.0+pw_gzrf1asd/2.0)*a_gzrf1as;

    /* availible time for rephaser */
    avail_pwgz1as  = _avail_pwgz1as.fixedflag ?  ((void)(1000000), avail_pwgz1as) : 1000000;

    if ( FAILURE==amppwgz1(_a_gz1as.fixedflag ? (_temp812_a_gz1as=a_gz1as,&_temp812_a_gz1as) : &a_gz1as, _pw_gz1as.fixedflag ? (_temp813_pw_gz1as=pw_gz1as,&_temp813_pw_gz1as) : &pw_gz1as, _pw_gz1asa.fixedflag ? (_temp814_pw_gz1asa=pw_gz1asa,&_temp814_pw_gz1asa) : &pw_gz1asa, _pw_gz1asd.fixedflag ? (_temp815_pw_gz1asd=pw_gz1asd,&_temp815_pw_gz1asd) : &pw_gz1asd,
                           area_gz1as, avail_pwgz1as, MIN_PLATEAU_TIME,
                           asloggrd.zrt, asloggrd.tz_xyz) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1as.");
        return FAILURE;
    }

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1as_filt, echo1bwas, asxres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1as_filt");

        return FAILURE;
    }

    if ( FAILURE==ampfov(_a_gxwas.fixedflag ? (_temp816_a_gxwas=a_gxwas,&_temp816_a_gxwas) : &a_gxwas, echo1as_filt.bw, asfov) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwas.");
        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gxwasa.fixedflag ? (_temp817_pw_gxwasa=pw_gxwasa,&_temp817_pw_gxwasa) : &pw_gxwasa, a_gxwas, asloggrd.tx_xyz, asloggrd.xrt, TYPDEF)) 
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwasa.");
        return FAILURE;
    }

    pw_gxwasd  = _pw_gxwasd.fixedflag ?  ((void)(pw_gxwasa), pw_gxwasd) : pw_gxwasa;
    pw_gxwas  = _pw_gxwas.fixedflag ?  ((void)(echo1as_filt.tdaq), pw_gxwas) : echo1as_filt.tdaq;

    avail_pwgx1as  = _avail_pwgx1as.fixedflag ?  ((void)(1000000), avail_pwgx1as) : 1000000;

    area_readrampas  = _area_readrampas.fixedflag ?  ((void)(0.5*pw_gxwasa*a_gxwas), area_readrampas) : 0.5*pw_gxwasa*a_gxwas;
    area_gxwas  = _area_gxwas.fixedflag ?  ((void)(pw_gxwas*a_gxwas), area_gxwas) : pw_gxwas*a_gxwas;

    if ( FAILURE==amppwgx1(_a_gx1as.fixedflag ? (_temp818_a_gx1as=a_gx1as,&_temp818_a_gx1as) : &a_gx1as, _pw_gx1as.fixedflag ? (_temp819_pw_gx1as=pw_gx1as,&_temp819_pw_gx1as) : &pw_gx1as, _pw_gx1asa.fixedflag ? (_temp820_pw_gx1asa=pw_gx1asa,&_temp820_pw_gx1asa) : &pw_gx1asa, _pw_gx1asd.fixedflag ? (_temp821_pw_gx1asd=pw_gx1asd,&_temp821_pw_gx1asd) : &pw_gx1asd,
                           (int)TYPGRAD, area_gxwas, area_readrampas,
                           avail_pwgx1as, 1.0, MIN_PLATEAU_TIME,
                           asloggrd.xrt, asloggrd.tx_xyz) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1as.");
        return FAILURE;
    }

    /***************************************************************/
    /*   Y Board - Dephaser and Killer                             */
    /*                                                             */
    /*   Calculate Y Phase encode amp and pw.                      */
    /*                                                             */
    /***************************************************************/

    /* find min and max time for gy1as */
    avail_pwgy1as  = _avail_pwgy1as.fixedflag ?  ((void)(1000000), avail_pwgy1as) : 1000000;

    /* Scale the waveform amps for the phase encodes 
     * so each phase instruction jump is an integer step */
    if ( FAILURE==endview((int)(asyres), _endview_iampas.fixedflag ? (_temp822_endview_iampas=endview_iampas,&_temp822_endview_iampas) : &endview_iampas) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "endview:autoshim");
        return FAILURE;
    } 
  
    endview_scaleas  = _endview_scaleas.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iampas), endview_scaleas) : (float)max_pg_iamp/(float)endview_iampas;

    if ( FAILURE==amppwtpe(_a_gy1asa.fixedflag ? (_temp823_a_gy1asa=a_gy1asa,&_temp823_a_gy1asa) : &a_gy1asa, _a_gy1asb.fixedflag ? (_temp824_a_gy1asb=a_gy1asb,&_temp824_a_gy1asb) : &a_gy1asb, _pw_gy1as.fixedflag ? (_temp825_pw_gy1as=pw_gy1as,&_temp825_pw_gy1as) : &pw_gy1as, _pw_gy1asa.fixedflag ? (_temp826_pw_gy1asa=pw_gy1asa,&_temp826_pw_gy1asa) : &pw_gy1asa, _pw_gy1asd.fixedflag ? (_temp827_pw_gy1asd=pw_gy1asd,&_temp827_pw_gy1asd) : &pw_gy1asd,
                           asloggrd.ty_xyz/endview_scaleas,asloggrd.yrt,
                           (0.5 * (FLOAT)(asyres-1))/(asfov * 0.1) * 1.0e6/ GAM) ) 
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:autoshim");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1ras  = _a_gy1ras.fixedflag ?  ((void)(a_gy1as), a_gy1ras) : a_gy1as;
    a_gy1rasa  = _a_gy1rasa.fixedflag ?  ((void)(a_gy1asa), a_gy1rasa) : a_gy1asa;
    a_gy1rasb  = _a_gy1rasb.fixedflag ?  ((void)(a_gy1asb), a_gy1rasb) : a_gy1asb;
    pw_gy1ras  = _pw_gy1ras.fixedflag ?  ((void)(pw_gy1as), pw_gy1ras) : pw_gy1as;
    pw_gy1rasa  = _pw_gy1rasa.fixedflag ?  ((void)(pw_gy1asa), pw_gy1rasa) : pw_gy1asa;
    pw_gy1rasd  = _pw_gy1rasd.fixedflag ?  ((void)(pw_gy1asd), pw_gy1rasd) : pw_gy1asd;

    if(1==fastprescan) 
    {

        te_as  = _te_as.fixedflag ?           
                                  
                               ((void)(RUP_GRD(pw_rf1as/2+off90as+pw_gzrf1asd+pw_gz1asa+pw_gz1as+pw_gz1asd+pw_gy1asa+pw_gy1as+pw_gy1asd+pw_gx1asa+pw_gx1as+pw_gx1asd+pw_gxwasa+pw_gxwas/2)), te_as) : RUP_GRD(pw_rf1as/2+off90as+pw_gzrf1asd+pw_gz1asa+pw_gz1as+pw_gz1asd+pw_gy1asa+pw_gy1as+pw_gy1asd+pw_gx1asa+pw_gx1as+pw_gx1asd+pw_gxwasa+pw_gxwas/2);

        tr_as  = _tr_as.fixedflag ?           
                                  
                             ((void)(RUP_GRD(te_as+dix_timeas+pw_gzrf1as/2+pw_gzrf1asa+td0as+tleadas-rfupa+pw_gxwas/2+pw_gxwasd+pw_gzkasa+pw_gzkas+pw_gzkasd+1000)), tr_as) : RUP_GRD(te_as+dix_timeas+pw_gzrf1as/2+pw_gzrf1asa+td0as+tleadas-rfupa+pw_gxwas/2+pw_gxwasd+pw_gzkasa+pw_gzkas+pw_gzkasd+1000);
    }

    return SUCCESS;
}   /* end AScveval() */


/*
 *  PS1cveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1cveval( FLOAT *opthickPS )
{
    INT bw_rf1mps1, bw_rf2mps1;    /* band widths of rf pulses */
    FLOAT area_pulse;
    FLOAT area_readrampmps1;
    FLOAT area_gxwmps1;
    FLOAT av_temp_float = 0;
    int ps1_xrt;
    float ps1_tx;
    float ps1_tx_xz;
    float ps1_tz_xz;

    /* check for breast L/R coil */
    if( (strstr(coilInfo[0].coilName, "R_BREAST") != NULL) ||
        (strstr(coilInfo[0].coilName, "L_BREAST") != NULL) ||
        (strstr(coilInfo[0].coilName, "BreastL") != NULL) ||
        (strstr(coilInfo[0].coilName, "BreastR") != NULL) ||
        (strstr(coilInfo[0].coilName, "RtBreast") != NULL) ||
        (strstr(coilInfo[0].coilName, "LtBreast") != NULL) ||
        (strstr(coilInfo[0].coilName, "breast L") != NULL) ||
        (strstr(coilInfo[0].coilName, "breast R") != NULL) ||
        (strstr(coilInfo[0].coilName, "BrstL") != NULL) ||
        (strstr(coilInfo[0].coilName, "BrstR") != NULL) ||
        (strstr(coilInfo[0].coilName, "BREASTPA R") != NULL) ||
        (strstr(coilInfo[0].coilName, "BREASTPA L") != NULL) )
    {
        ps1_rxcoil  = _ps1_rxcoil.fixedflag ?  ((void)(PSD_ON), ps1_rxcoil) : PSD_ON;  /* Flag for R or L breast coil for TG */
    }
    else
    {
        ps1_rxcoil  = _ps1_rxcoil.fixedflag ?  ((void)(PSD_OFF), ps1_rxcoil) : PSD_OFF;
    }

    ps1_xrt = (TGspf ? ps1loggrd.yrt : ps1loggrd.xrt);
    ps1_tx = (TGspf ? ps1loggrd.ty : ps1loggrd.tx);
    ps1_tx_xz = (TGspf ? ps1loggrd.ty_yz : ps1loggrd.tx_xz);
    ps1_tz_xz = (TGspf ? ps1loggrd.tz_yz : ps1loggrd.tz_xz);

    /* Z slice select for 90 pulse */
    pw_gzrf1mps1  = _pw_gzrf1mps1.fixedflag ?  ((void)(pw_rf1mps1), pw_gzrf1mps1) : pw_rf1mps1;
    bw_rf1mps1 = rfpulse[RF1_APS1_SLOT].nom_bw*rfpulse[RF1_APS1_SLOT].nom_pw/(float)pw_rf1mps1;

    /* MRIge30641 */
    /* Need check on sl thk.  Otherwise causes dwnld failures w/0.8 G/cm. */
    /* Assumes that gzrf1 gives the worst case min sl thk of all psc pulses. */ 
    if (FAILURE==ampslice(&av_temp_float, bw_rf1mps1, ps1loggrd.tz, gscale_rf1mps1, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice");
        return FAILURE;
    }

    av_temp_float = ceil(av_temp_float*10.0)/10.0;
    if (av_temp_float > *opthickPS)
    {
        *opthickPS = av_temp_float;
    }

    if (0 == getAps1Mod()) {
        cvoverride(thickPS_mod, *opthickPS, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        float fov = FMax(2, getAps1ModSlThick(), av_temp_float);
        cvoverride(thickPS_mod, fov, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if (FAILURE==ampslice(_a_gzrf1mps1.fixedflag ? (_temp828_a_gzrf1mps1=a_gzrf1mps1,&_temp828_a_gzrf1mps1) : &a_gzrf1mps1, bw_rf1mps1,thickPS_mod,gscale_rf1mps1,TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1mps1.");
        return FAILURE;
    }
    /* end aps1_mod changes (GE) */

    /* slice selection ramp */
    if (optramp(_pw_gzrf1mps1a.fixedflag ? (_temp829_pw_gzrf1mps1a=pw_gzrf1mps1a,&_temp829_pw_gzrf1mps1a) : &pw_gzrf1mps1a, a_gzrf1mps1, ps1loggrd.tz, ps1loggrd.zrt,
                TYPDEF)==FAILURE) /* vmx 5/9/95 YI */ 
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1mps1a.");
        return FAILURE;
    }
    pw_gzrf1mps1d  = _pw_gzrf1mps1d.fixedflag ?  ((void)(pw_gzrf1mps1a), pw_gzrf1mps1d) : pw_gzrf1mps1a;

    /* Z gradient refocus */
    /* available time not calculated, defaulted to 10ms */
    area_pulse = a_gzrf1mps1*(pw_gzrf1mps1/2 + PSoff90 + pw_gzrf1mps1d/2);
    if (amppwgz1(_a_gz1mps1.fixedflag ? (_temp830_a_gz1mps1=a_gz1mps1,&_temp830_a_gz1mps1) : &a_gz1mps1,_pw_gz1mps1.fixedflag ? (_temp831_pw_gz1mps1=pw_gz1mps1,&_temp831_pw_gz1mps1) : &pw_gz1mps1,_pw_gz1mps1a.fixedflag ? (_temp832_pw_gz1mps1a=pw_gz1mps1a,&_temp832_pw_gz1mps1a) : &pw_gz1mps1a,_pw_gz1mps1d.fixedflag ? (_temp833_pw_gz1mps1d=pw_gz1mps1d,&_temp833_pw_gz1mps1d) : &pw_gz1mps1d,area_pulse,
                 (int)(1000000),MIN_PLATEAU_TIME,ps1loggrd.zrt,ps1_tz_xz) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1mps1.");
        return FAILURE;
    }

    /* Z gradient crushers for 180 pulse */
    /* Left crusher. Denoted by the "l" after the "2"  in "gzrf2lmps1" */
    if (amppwgrad(ps_crusher_area, ps1_tz_xz, 0.0, 0.0, ps1loggrd.zrt,
                  MIN_PLATEAU_TIME, _a_gzrf2lmps1.fixedflag ? (_temp834_a_gzrf2lmps1=a_gzrf2lmps1,&_temp834_a_gzrf2lmps1) : &a_gzrf2lmps1, _pw_gzrf2lmps1a.fixedflag ? (_temp835_pw_gzrf2lmps1a=pw_gzrf2lmps1a,&_temp835_pw_gzrf2lmps1a) : &pw_gzrf2lmps1a,
                  _pw_gzrf2lmps1.fixedflag ? (_temp836_pw_gzrf2lmps1=pw_gzrf2lmps1,&_temp836_pw_gzrf2lmps1) : &pw_gzrf2lmps1, _pw_gzrf2lmps1d.fixedflag ? (_temp837_pw_gzrf2lmps1d=pw_gzrf2lmps1d,&_temp837_pw_gzrf2lmps1d) : &pw_gzrf2lmps1d) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gzrf2lmps1"); 
        return FAILURE;
    }
  
    /* Right crusher. Denoted by the "r" after the "2" in "gzrf2rmps1"*/
    /* This is identical to left crusher */
    pw_gzrf2rmps1  = _pw_gzrf2rmps1.fixedflag ?  ((void)(pw_gzrf2lmps1), pw_gzrf2rmps1) : pw_gzrf2lmps1;
    a_gzrf2rmps1  = _a_gzrf2rmps1.fixedflag ?   ((void)(a_gzrf2lmps1), a_gzrf2rmps1) : a_gzrf2lmps1;

    /* right crusher ramps */
    pw_gzrf2rmps1a  = _pw_gzrf2rmps1a.fixedflag ?  ((void)(pw_gzrf2lmps1a), pw_gzrf2rmps1a) : pw_gzrf2lmps1a;
    pw_gzrf2rmps1d  = _pw_gzrf2rmps1d.fixedflag ?  ((void)(pw_gzrf2lmps1d), pw_gzrf2rmps1d) : pw_gzrf2lmps1d;

    /* Z slice select for 180 pulse */
    pw_gzrf2mps1  = _pw_gzrf2mps1.fixedflag ?  ((void)(pw_rf2mps1), pw_gzrf2mps1) : pw_rf2mps1;
    bw_rf2mps1 = rfpulse[RF2_APS1_SLOT].nom_bw*rfpulse[RF2_APS1_SLOT].nom_pw/(float)pw_rf2mps1;

    /* begin aps1_mod changes (GE) */
    if (FAILURE==ampslice(_a_gzrf2mps1.fixedflag ? (_temp838_a_gzrf2mps1=a_gzrf2mps1,&_temp838_a_gzrf2mps1) : &a_gzrf2mps1, bw_rf2mps1, thickPS_mod, gscale_rf2mps1, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf2mps1.");
        return FAILURE;
    }
    /* end aps1_mod changes (GE) */

    /* match ramps so gradient can be bridged in pulsegen */
    pw_gzrf2mps1a  = _pw_gzrf2mps1a.fixedflag ?  ((void)(pw_gzrf2lmps1d), pw_gzrf2mps1a) : pw_gzrf2lmps1d;
    pw_gzrf2mps1d  = _pw_gzrf2mps1d.fixedflag ?  ((void)(pw_gzrf2rmps1a), pw_gzrf2mps1d) : pw_gzrf2rmps1a;

    /* readout gradient */

    /* begin aps1_mod changes (GE) */
    if( (1 == getAps1Mod()) && (PSD_ON == ps1_rxcoil) )
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(getAps1ModFov()), mpsfov) : getAps1ModFov();
    }
    else
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(cfsystemmaxfov), mpsfov) : cfsystemmaxfov;
    }

    if (FAILURE==calcfilter( &echo1mps1_filt, 15.625, 256, OVERWRITE_NONE))
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1mps1_filt");
        return FAILURE;
    }

    /* MRIge30642 */
    /* Need check on fov.  Otherwise causes dwnld failures w/0.8 G/cm. */ 
    if (ampfov(&av_temp_float, echo1mps1_filt.bw, ps1_tx) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov");
        return FAILURE;
    }

    av_temp_float = ceil(av_temp_float/ 10.0) * 10.0;
    if( av_temp_float > mpsfov )
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(av_temp_float), mpsfov) : av_temp_float;
    }

    if (ampfov(_a_gxwmps1.fixedflag ? (_temp839_a_gxwmps1=a_gxwmps1,&_temp839_a_gxwmps1) : &a_gxwmps1, echo1mps1_filt.bw, mpsfov) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwmps1.");
        return FAILURE;
    }

    /* attack and decay ramps */
    if (optramp(_pw_gxwmps1a.fixedflag ? (_temp840_pw_gxwmps1a=pw_gxwmps1a,&_temp840_pw_gxwmps1a) : &pw_gxwmps1a, a_gxwmps1, ps1_tx, ps1_xrt,
                TYPDEF)==FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxwmps1a.");
        return FAILURE;
    }
  
    pw_gxwmps1d  = _pw_gxwmps1d.fixedflag ?  ((void)(pw_gxwmps1a), pw_gxwmps1d) : pw_gxwmps1a;

    pw_gxwmps1  = _pw_gxwmps1.fixedflag ?  ((void)(echo1mps1_filt.tdaq), pw_gxwmps1) : echo1mps1_filt.tdaq;
  
    /* dephaser */
    area_gxwmps1 = a_gxwmps1*(pw_gxwmps1);
    area_readrampmps1 = 0.5*pw_gxwmps1a*a_gxwmps1;

    if (amppwgx1(_a_gx1mps1.fixedflag ? (_temp841_a_gx1mps1=a_gx1mps1,&_temp841_a_gx1mps1) : &a_gx1mps1, _pw_gx1mps1.fixedflag ? (_temp842_pw_gx1mps1=pw_gx1mps1,&_temp842_pw_gx1mps1) : &pw_gx1mps1, _pw_gx1mps1a.fixedflag ? (_temp843_pw_gx1mps1a=pw_gx1mps1a,&_temp843_pw_gx1mps1a) : &pw_gx1mps1a ,_pw_gx1mps1d.fixedflag ? (_temp844_pw_gx1mps1d=pw_gx1mps1d,&_temp844_pw_gx1mps1d) : &pw_gx1mps1d, TYPSPIN,
                 area_gxwmps1, (float)area_readrampmps1, 
                 (int)1000000, 1.0, MIN_PLATEAU_TIME, ps1_xrt, ps1_tx_xz) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1mps1.");
        return FAILURE;
    }

    /* Y gradient is not used in MPS1 */

    return SUCCESS;
}

/*
 *  CFLcveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLcveval( FLOAT opthickPS )
{
    LONG bw_rf1cfl;
    FLOAT area_gz1cfl;

    cflloggrd = loggrd; /* same as imaging loggrd */
    /* derate SR for quiet PSC */ 
    sr_derate(&cflloggrd, PSsr_derate_factor);

    if ((fastprescan == 1) &&
        ((cffield == B0_10000) || (cffield == B0_15000) || 
         (cffield == B0_30000) || (cffield == B0_40000)))
    {
        cfl_dda  = _cfl_dda.fixedflag ?  ((void)(2), cfl_dda) : 2;      /* BJM MRIge80347: Changed from 0 -> 2 for MGD, coil switch problem */
        cfl_nex  = _cfl_nex.fixedflag ?  ((void)(1), cfl_nex) : 1;
    }
    else
    {
        cfl_dda  = _cfl_dda.fixedflag ?  ((void)(4), cfl_dda) : 4;
        cfl_nex  = _cfl_nex.fixedflag ?  ((void)(2), cfl_nex) : 2;
    }

    if(cffield == B0_2000) 
    {
        echo1bwcfl  = _echo1bwcfl.fixedflag ?  ((void)(10.41666), echo1bwcfl) : 10.41666;
    } 
    else if(cffield == B0_15000)
    {
        /* MRIhc54366: accommodate B0 drift using larger receive bandwidth 
           with matched spectral resolution */
        echo1bwcfl  = _echo1bwcfl.fixedflag ?  ((void)(7.8125), echo1bwcfl) : 7.8125;         
        CFLxres  = _CFLxres.fixedflag ?  ((void)(1024), CFLxres) : 1024;
    }
    else
    {
        echo1bwcfl  = _echo1bwcfl.fixedflag ?  ((void)(15.625), echo1bwcfl) : 15.625;         
        CFLxres  = _CFLxres.fixedflag ?  ((void)(1024), CFLxres) : 1024;
    }

    /* MRIhc54366: changed hard coded number of output points to CFLxres */
    if ( FAILURE==calcfilter( &echo1cfl, echo1bwcfl, CFLxres, OVERWRITE_NONE) )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1cfl_filt");
        return FAILURE;
    }

    /* MRIhc54366: dynamic CFL excitation pulse selection: */
    if(cyc_rf1cfl == 2)
    {
        rfpulse[RF1_CFL_SLOT].abswidth = SAR_ABS_SINC2;
        rfpulse[RF1_CFL_SLOT].effwidth = SAR_PSINC2;
        rfpulse[RF1_CFL_SLOT].area = SAR_ASINC2;
        rfpulse[RF1_CFL_SLOT].dtycyc = SAR_DTYCYC_SINC2;
        rfpulse[RF1_CFL_SLOT].maxpw = SAR_MAXPW_SINC2;
        rfpulse[RF1_CFL_SLOT].max_b1 = SAR_MAXB1_SINC2_90;
        rfpulse[RF1_CFL_SLOT].max_int_b1_sq = SAR_MAX_INT_B1_SQ_SINC2_90;
        rfpulse[RF1_CFL_SLOT].max_rms_b1 = SAR_MAX_RMS_B1_SINC2_90;
        rfpulse[RF1_CFL_SLOT].nom_bw = 2500;
    }
    else
    {
        rfpulse[RF1_CFL_SLOT].abswidth = SAR_ABS_SINC1;
        rfpulse[RF1_CFL_SLOT].effwidth = SAR_PSINC1;
        rfpulse[RF1_CFL_SLOT].area = SAR_ASINC1;
        rfpulse[RF1_CFL_SLOT].dtycyc = SAR_DTYCYC_SINC1;
        rfpulse[RF1_CFL_SLOT].maxpw = SAR_MAXPW_SINC1;
        rfpulse[RF1_CFL_SLOT].max_b1 = MAX_B1_SINC1_90;
        rfpulse[RF1_CFL_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
        rfpulse[RF1_CFL_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
        rfpulse[RF1_CFL_SLOT].nom_bw = 1250;
    }
    /* MRIhc54366: END pulse selection. */

    /* CFL acq duration needed for attenuator setting */
    cfl_tdaq = echo1cfl.tdaq;

    pw_gzrf1cfl  = _pw_gzrf1cfl.fixedflag ?  ((void)(pw_rf1cfl), pw_gzrf1cfl) : pw_rf1cfl;
    bw_rf1cfl = rfpulse[RF1_CFL_SLOT].nom_bw*rfpulse[RF1_CFL_SLOT].nom_pw/(float)pw_rf1cfl;

    /* MRIhc54366: new lower limit */
    opthickPS = (exist(opslthick) < 5.0) ? 5.0 : exist(opslthick);

    if ( FAILURE==ampslice(_a_gzrf1cfl.fixedflag ? (_temp845_a_gzrf1cfl=a_gzrf1cfl,&_temp845_a_gzrf1cfl) : &a_gzrf1cfl, bw_rf1cfl, opthickPS, gscale_rf1cfl, TYPDEF) ) 
    {
        epic_error(use_ermes, "%s failed for gzrf1cfl.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "ampslice");
        return FAILURE;
    }

    if ( FAILURE==optramp(_pw_gzrf1cfla.fixedflag ? (_temp846_pw_gzrf1cfla=pw_gzrf1cfla,&_temp846_pw_gzrf1cfla) : &pw_gzrf1cfla, a_gzrf1cfl, cflloggrd.tz, cflloggrd.zrt, TYPDEF) )  
    {
        epic_error(use_ermes, "%s failed for gzrf1cfl.", 
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp");
        return FAILURE;
    }

    pw_gzrf1cfld  = _pw_gzrf1cfld.fixedflag ?  ((void)(pw_gzrf1cfla), pw_gzrf1cfld) : pw_gzrf1cfla;

    /* Find Params for refocusing pulse */
    area_gz1cfl =  a_gzrf1cfl *0.5* ( pw_gzrf1cfl + pw_gzrf1cfld);
    if ( FAILURE==amppwgz1(_a_gz1cfl.fixedflag ? (_temp847_a_gz1cfl=a_gz1cfl,&_temp847_a_gz1cfl) : &a_gz1cfl, _pw_gz1cfl.fixedflag ? (_temp848_pw_gz1cfl=pw_gz1cfl,&_temp848_pw_gz1cfl) : &pw_gz1cfl, _pw_gz1cfla.fixedflag ? (_temp849_pw_gz1cfla=pw_gz1cfla,&_temp849_pw_gz1cfla) : &pw_gz1cfla, _pw_gz1cfld.fixedflag ? (_temp850_pw_gz1cfld=pw_gz1cfld,&_temp850_pw_gz1cfld) : &pw_gz1cfld, 
                           area_gz1cfl, (INT)1000000, MIN_PLATEAU_TIME,
                           cflloggrd.zrt, cflloggrd.tz) ) 
    {
        epic_error(use_ermes, "%s failed in cfl.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1cfl");
        return FAILURE;
    }

    /* Find Params for killer pulse */
    area_gykcfl  = _area_gykcfl.fixedflag ?  ((void)(amp_killer*pw_killer), area_gykcfl) : amp_killer*pw_killer;
    if ( FAILURE==amppwgrad(area_gykcfl, cflloggrd.ty, 0.0, 0.0, cflloggrd.yrt,
                            MIN_PLATEAU_TIME, _a_gykcfl.fixedflag ? (_temp851_a_gykcfl=a_gykcfl,&_temp851_a_gykcfl) : &a_gykcfl, _pw_gykcfla.fixedflag ? (_temp852_pw_gykcfla=pw_gykcfla,&_temp852_pw_gykcfla) : &pw_gykcfla,
                            _pw_gykcfl.fixedflag ? (_temp853_pw_gykcfl=pw_gykcfl,&_temp853_pw_gykcfl) : &pw_gykcfl, _pw_gykcfld.fixedflag ? (_temp854_pw_gykcfld=pw_gykcfld,&_temp854_pw_gykcfld) : &pw_gykcfld) ) 
    {
        epic_error(use_ermes, "%s failed in cfl.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykcfl");
        return FAILURE;
    }

    return SUCCESS;
}


/*
 *  RCVNcveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNcveval( void )
{
    rcvnloggrd = loggrd; /* same as imaging loggrd */
    /* derate SR for quiet PSC */ 
    sr_derate(&rcvnloggrd, PSsr_derate_factor);

    /* MRIhc47602/MRIhc47515/GEHmr03545 : Killer gradient before Receiver noise sequence */

    if ( FAILURE==amppwgrad( area_gxkrcvn, rcvnloggrd.tx_xyz, 0.0, 0.0, rcvnloggrd.xrt,
                             MIN_PLATEAU_TIME, _a_gxkrcvn.fixedflag ? (_temp855_a_gxkrcvn=a_gxkrcvn,&_temp855_a_gxkrcvn) : &a_gxkrcvn, _pw_gxkrcvna.fixedflag ? (_temp856_pw_gxkrcvna=pw_gxkrcvna,&_temp856_pw_gxkrcvna) : &pw_gxkrcvna,
                             _pw_gxkrcvn.fixedflag ? (_temp857_pw_gxkrcvn=pw_gxkrcvn,&_temp857_pw_gxkrcvn) : &pw_gxkrcvn, _pw_gxkrcvnd.fixedflag ? (_temp858_pw_gxkrcvnd=pw_gxkrcvnd,&_temp858_pw_gxkrcvnd) : &pw_gxkrcvnd ) )
    {
        epic_error(use_ermes, "Support routine %s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gxkrcvn");
        return FAILURE;
    }

    if ( FAILURE==amppwgrad( area_gykrcvn, rcvnloggrd.ty_xyz, 0.0, 0.0, rcvnloggrd.yrt,
                             MIN_PLATEAU_TIME, _a_gykrcvn.fixedflag ? (_temp859_a_gykrcvn=a_gykrcvn,&_temp859_a_gykrcvn) : &a_gykrcvn, _pw_gykrcvna.fixedflag ? (_temp860_pw_gykrcvna=pw_gykrcvna,&_temp860_pw_gykrcvna) : &pw_gykrcvna,
                             _pw_gykrcvn.fixedflag ? (_temp861_pw_gykrcvn=pw_gykrcvn,&_temp861_pw_gykrcvn) : &pw_gykrcvn, _pw_gykrcvnd.fixedflag ? (_temp862_pw_gykrcvnd=pw_gykrcvnd,&_temp862_pw_gykrcvnd) : &pw_gykrcvnd ) )
    {
        epic_error(use_ermes, "Support routine %s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykrcvn");
        return FAILURE;
    }

    if ( FAILURE==amppwgrad( area_gzkrcvn, rcvnloggrd.tz_xyz, 0.0, 0.0, rcvnloggrd.zrt,
                             MIN_PLATEAU_TIME, _a_gzkrcvn.fixedflag ? (_temp863_a_gzkrcvn=a_gzkrcvn,&_temp863_a_gzkrcvn) : &a_gzkrcvn, _pw_gzkrcvna.fixedflag ? (_temp864_pw_gzkrcvna=pw_gzkrcvna,&_temp864_pw_gzkrcvna) : &pw_gzkrcvna,
                             _pw_gzkrcvn.fixedflag ? (_temp865_pw_gzkrcvn=pw_gzkrcvn,&_temp865_pw_gzkrcvn) : &pw_gzkrcvn, _pw_gzkrcvnd.fixedflag ? (_temp866_pw_gzkrcvnd=pw_gzkrcvnd,&_temp866_pw_gzkrcvnd) : &pw_gzkrcvnd ) )
    {
        epic_error(use_ermes, "Support routine %s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gzkrcvn");
        return FAILURE;
    }

    if ( rcvn_flag == 1 )
    {
        pre_rcvn_tr  = _pre_rcvn_tr.fixedflag ?    ((void)(IMax(2,20000,RUP_GRD(pw_gxkrcvna+pw_gxkrcvn+pw_gxkrcvnd+1000))), pre_rcvn_tr) : IMax(2,20000,RUP_GRD(pw_gxkrcvna+pw_gxkrcvn+pw_gxkrcvnd+1000));
    }
    else if(rcvn_flag == 2)  /* extra delay before rcvn */
    {
        pre_rcvn_tr  = _pre_rcvn_tr.fixedflag ?  ((void)(1000000), pre_rcvn_tr) : 1000000;
    }

    if (existcv(oprbw))
    {
        echo1bwrcvn  = _echo1bwrcvn.fixedflag ?  ((void)(exist(oprbw)), echo1bwrcvn) : exist(oprbw);
    }

    echo1bwrcvn  = _echo1bwrcvn.fixedflag ?     ((void)(FMax(2,echo1bwrcvn,(float)RCVN_MIN_BW)), echo1bwrcvn) : FMax(2,echo1bwrcvn,(float)RCVN_MIN_BW);

    echo1bwrcvn  = _echo1bwrcvn.fixedflag ?     ((void)(FMin(2,echo1bwrcvn,(float)RCVN_MAX_BW)), echo1bwrcvn) : FMin(2,echo1bwrcvn,(float)RCVN_MAX_BW);

    if ( FAILURE==calcfilter( &echo1rcvn, echo1bwrcvn, rcvn_xres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1rcvn");
        return FAILURE;
    }

    /* RCVN acq duration needed for attenuator setting */
    rcvn_tdaq = echo1rcvn.tdaq;

    /* Add 20ms dead time to prevent runtime errors */
    rcvn_tr  = _rcvn_tr.fixedflag ?       ((void)(IMax(2,rcvn_tdaq+20000,(int)RCVN_MIN_TR)), rcvn_tr) : IMax(2,rcvn_tdaq+20000,(int)RCVN_MIN_TR);

    /* To make sure RCVN loops enough to acquire 4K points */
    rcvn_loops  = _rcvn_loops.fixedflag ?       ((void)(IMax(2,2*(int)(4096/rcvn_xres),1)), rcvn_loops) : IMax(2,2*(int)(4096/rcvn_xres),1);

    return SUCCESS;
}


/*
 *  CFHfilter
 *  
 *  Type: Private Function
 *  
 *  Description: Separate function for CFH for inclusion in 
 *               in Spectroscopy volume localized CFH
 *  
 */
STATUS
CFHfilter( void )
{
    /* MRIhc08595: Replaced cfh filter output points, hard coded 256, with echo1ptcfh CV. */
    echo1ptcfh  = _echo1ptcfh.fixedflag ?  ((void)(256), echo1ptcfh) : 256;

    if(cffield <= B0_5000) 
    {
        echo1bwcfh  = _echo1bwcfh.fixedflag ?  ((void)(0.25), echo1bwcfh) : 0.25;
    }
    else if (cffield >= B0_30000) 
    {
        echo1bwcfh  = _echo1bwcfh.fixedflag ?  ((void)(1.0), echo1bwcfh) : 1.0;
    }
    else 
    {
        echo1bwcfh  = _echo1bwcfh.fixedflag ?  ((void)(0.50), echo1bwcfh) : 0.50;
    }

    if ( FAILURE==calcfilter( &echo1cfh, echo1bwcfh, echo1ptcfh, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1cfh_filt");
        return FAILURE;
    }

    cfh_tdaq = echo1cfh.tdaq;

    return SUCCESS;
}

/*
 *  CFHcveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHcveval( FLOAT opthickPS )
{
    INT bw_rf0cfh;
    INT bw_rf1cfh;

    GRAD_PULSE psd_cfhrightcrush;
    GRAD_PULSE psd_cfhleftcrush;

    FLOAT area_gz1cfh;
    a_gyrf3cfh  = _a_gyrf3cfh.fixedflag ?  ((void)(0.0), a_gyrf3cfh) : 0.0;/*For MRIhc11621 */
    /* For presscfh MRIhc08321 */
    if( presscfh == PRESSCFH_SLICE && PSfield_strength > B0_5000 && 
        cfh_newmode && exist(oppscvquant)>= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SLICE, PSD_FIX_ON, PSD_EXIST_ON);
        presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(opthickPS), presscfh_slthick) : opthickPS;
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(0.8), presscfh_fov_ratio) : 0.8;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(0.8), presscfh_pfov_ratio) : 0.8;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(0.5), presscfh_slab_ratio) : 0.5;
    } 
    else if(presscfh == PRESSCFH_SLAB && PSfield_strength > B0_5000 &&
            cfh_newmode && exist(oppscvquant)>= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SLAB, PSD_FIX_ON, PSD_EXIST_ON);
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(0.8), presscfh_fov_ratio) : 0.8;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(0.8), presscfh_pfov_ratio) : 0.8;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(0.75), presscfh_slab_ratio) : 0.75;
    }
    else if( presscfh == PRESSCFH_SHIMVOL && PSfield_strength > B0_5000 &&
             cfh_newmode && exist(oppscvquant) >= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON); 
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(0.5), presscfh_fov_ratio) : 0.5;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(0.5), presscfh_pfov_ratio) : 0.5;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(0.5), presscfh_slab_ratio) : 0.5;
    }
    else
    { 
        cvoverride(presscfh_ctrl, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON); 
    }
    
    if(presscfh_debug) 
    {
        printf("\n CFHcveval : presscfh = %d,presscfh_ctrl = %d,presscfh_override = %d\n",presscfh,presscfh_ctrl,presscfh_override);
        fflush(stdout);
    }

    /* REDFLAG : Making the same as 1.0T and 1.5T (3T/4T) */
    if ((fastprescan == 1) &&
        ((cffield == B0_10000) || (cffield == B0_15000) || 
         (cffield == B0_30000) || (cffield == B0_40000)))
    {
        cfh_dda  = _cfh_dda.fixedflag ?  ((void)(0), cfh_dda) : 0;
        cfh_nex  = _cfh_nex.fixedflag ?  ((void)(1), cfh_nex) : 1;
    }
    else
    {
        cfh_dda  = _cfh_dda.fixedflag ?  ((void)(4), cfh_dda) : 4;
        cfh_nex  = _cfh_nex.fixedflag ?  ((void)(2), cfh_nex) : 2;
    }

    if(cffield == B0_15000) 
    {
        cfh_ti  = _cfh_ti.fixedflag ?  ((void)(CFHTI_1HT), cfh_ti) : CFHTI_1HT;
        eff_cfh_te  = _eff_cfh_te.fixedflag ?  ((void)(CFHTE_1HT), eff_cfh_te) : CFHTE_1HT;
    }
    else if(cffield >= B0_30000) 
    {
        cfh_ti  = _cfh_ti.fixedflag ?  ((void)(CFHTI_3T), cfh_ti) : CFHTI_3T;
        eff_cfh_te  = _eff_cfh_te.fixedflag ?  ((void)(CFHTE_3T), eff_cfh_te) : CFHTE_3T;
    }

    CFHfilter();

    /* Initialize some grad structures 
       so we can use the psdsupport routine amppwlcrsh */
    psd_cfhleftcrush.attack = _pw_gzrf2lcfha.fixedflag ? (_temp867_pw_gzrf2lcfha=pw_gzrf2lcfha,&_temp867_pw_gzrf2lcfha) : &pw_gzrf2lcfha;
    psd_cfhleftcrush.decay = _pw_gzrf2lcfhd.fixedflag ? (_temp868_pw_gzrf2lcfhd=pw_gzrf2lcfhd,&_temp868_pw_gzrf2lcfhd) : &pw_gzrf2lcfhd;
    psd_cfhleftcrush.pw = _pw_gzrf2lcfh.fixedflag ? (_temp869_pw_gzrf2lcfh=pw_gzrf2lcfh,&_temp869_pw_gzrf2lcfh) : &pw_gzrf2lcfh;
    psd_cfhleftcrush.amp = _a_gzrf2lcfh.fixedflag ? (_temp870_a_gzrf2lcfh=a_gzrf2lcfh,&_temp870_a_gzrf2lcfh) : &a_gzrf2lcfh;
 
    psd_cfhrightcrush.attack = _pw_gzrf2rcfha.fixedflag ? (_temp871_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp871_pw_gzrf2rcfha) : &pw_gzrf2rcfha;
    psd_cfhrightcrush.decay = _pw_gzrf2rcfhd.fixedflag ? (_temp872_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp872_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd;
    psd_cfhrightcrush.pw = _pw_gzrf2rcfh.fixedflag ? (_temp873_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp873_pw_gzrf2rcfh) : &pw_gzrf2rcfh;
    psd_cfhrightcrush.amp = _a_gzrf2rcfh.fixedflag ? (_temp874_a_gzrf2rcfh=a_gzrf2rcfh,&_temp874_a_gzrf2rcfh) : &a_gzrf2rcfh;

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        psd_cfhrightcrush.attack = _pw_gzrf3rcfha.fixedflag ? (_temp875_pw_gzrf3rcfha=pw_gzrf3rcfha,&_temp875_pw_gzrf3rcfha) : &pw_gzrf3rcfha;
        psd_cfhrightcrush.decay = _pw_gzrf3rcfhd.fixedflag ? (_temp876_pw_gzrf3rcfhd=pw_gzrf3rcfhd,&_temp876_pw_gzrf3rcfhd) : &pw_gzrf3rcfhd;
        psd_cfhrightcrush.pw = _pw_gzrf3rcfh.fixedflag ? (_temp877_pw_gzrf3rcfh=pw_gzrf3rcfh,&_temp877_pw_gzrf3rcfh) : &pw_gzrf3rcfh;
        psd_cfhrightcrush.amp = _a_gzrf3rcfh.fixedflag ? (_temp878_a_gzrf3rcfh=a_gzrf3rcfh,&_temp878_a_gzrf3rcfh) : &a_gzrf3rcfh;
    }

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp879_pw_rf1cfh=pw_rf1cfh,&_temp879_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp880_a_rf1cfh=a_rf1cfh,&_temp880_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp881_flip_rf1cfh=flip_rf1cfh,&_temp881_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp882_res_rf1cfh=res_rf1cfh,&_temp882_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp883_wg_rf1cfh=wg_rf1cfh,&_temp883_wg_rf1cfh) : &wg_rf1cfh, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp884_pw_rf2cfh=pw_rf2cfh,&_temp884_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp885_a_rf2cfh=a_rf2cfh,&_temp885_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp886_flip_rf2cfh=flip_rf2cfh,&_temp886_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp887_res_rf2cfh=res_rf2cfh,&_temp887_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp888_wg_rf2cfh=wg_rf2cfh,&_temp888_wg_rf2cfh) : &wg_rf2cfh, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp889_pw_rf3cfh=pw_rf3cfh,&_temp889_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp890_a_rf3cfh=a_rf3cfh,&_temp890_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp891_flip_rf3cfh=flip_rf3cfh,&_temp891_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp892_res_rf3cfh=res_rf3cfh,&_temp892_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp893_wg_rf3cfh=wg_rf3cfh,&_temp893_wg_rf3cfh) : &wg_rf3cfh, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(1), a_rf0cfh) : 1;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5464), a_rf1cfh) : 0.5464;
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(0.5464), a_rf2cfh) : 0.5464;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(0.5464), a_rf3cfh) : 0.5464; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(60), flip_rf1cfh) : 60;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(60), flip_rf2cfh) : 60;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(60), flip_rf3cfh) : 60; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(3), cyc_rf1cfh) : 3;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(3), cyc_rf2cfh) : 3;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(3), cyc_rf3cfh) : 3; 
    }
    else
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp894_pw_rf1cfh=pw_rf1cfh,&_temp894_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp895_a_rf1cfh=a_rf1cfh,&_temp895_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp896_flip_rf1cfh=flip_rf1cfh,&_temp896_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp897_res_rf1cfh=res_rf1cfh,&_temp897_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp898_wg_rf1cfh=wg_rf1cfh,&_temp898_wg_rf1cfh) : &wg_rf1cfh, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp899_pw_rf2cfh=pw_rf2cfh,&_temp899_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp900_a_rf2cfh=a_rf2cfh,&_temp900_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp901_flip_rf2cfh=flip_rf2cfh,&_temp901_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp902_res_rf2cfh=res_rf2cfh,&_temp902_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp903_wg_rf2cfh=wg_rf2cfh,&_temp903_wg_rf2cfh) : &wg_rf2cfh, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp904_pw_rf3cfh=pw_rf3cfh,&_temp904_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp905_a_rf3cfh=a_rf3cfh,&_temp905_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp906_flip_rf3cfh=flip_rf3cfh,&_temp906_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp907_res_rf3cfh=res_rf3cfh,&_temp907_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp908_wg_rf3cfh=wg_rf3cfh,&_temp908_wg_rf3cfh) : &wg_rf3cfh, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(0.61), a_rf0cfh) : 0.61;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5), a_rf1cfh) : 0.5;
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(1.0), a_rf2cfh) : 1.0;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(1.0), a_rf3cfh) : 1.0; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(90), flip_rf1cfh) : 90;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(180), flip_rf2cfh) : 180;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(180), flip_rf3cfh) : 180; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(1), cyc_rf1cfh) : 1;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(1), cyc_rf2cfh) : 1;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(1), cyc_rf3cfh) : 1; 

    }

    if( presscfh_ctrl == PRESSCFH_SLICE || presscfh_ctrl == PRESSCFH_SLAB ) 
    {
        /* it is assumed: 
         * (a) cubicle local shim volume 
         */

        FLOAT av;
        FLOAT dxv, dyv, dzv, dxs, dys, dzs, dxs0, dys0, dzs0; 
        FLOAT Dz, al2, al, dxl, dyl, dzl;
        FLOAT rs[9], rv[9], rstrv[9];
        INT ii, vidx;
       
        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
        {
            av = (psc_info[vidx].oppsclenx)/2.0;
            dxv = psc_info[vidx].oppscrloc;
            dyv = psc_info[vidx].oppscphasoff;
            dzv = psc_info[vidx].oppsctloc;

            dxs = scan_info[PSslice_num].oprloc;
            dys = scan_info[PSslice_num].opphasoff;
            dzs = scan_info[PSslice_num].optloc;

            for( ii = 0; ii < 9; ii++ )
            {
                rs[ii] = scan_info[PSslice_num].oprot[ii];
                rv[ii] = psc_info[vidx].oppscrot[ii];
            }

            for( ii = 0; ii < 9; ii++ )
            {
                int ir, ic;
                ir = ii/ 3;
                ic = ii % 3;
                rstrv[ii] = rs[3*0+ir]*rv[3*0+ic] 
                    + rs[3*1+ir]*rv[3*1+ic] 
                    + rs[3*2+ir]*rv[3*2+ic]; 
            }

            if( presscfh_debug )
            {
                printf("rot for shim volume %d\n", vidx);
                printf("%8.2f %8.2f %8.2f\n", rv[0], rv[3], rv[6]);
                printf("%8.2f %8.2f %8.2f\n", rv[1], rv[4], rv[7]);
                printf("%8.2f %8.2f %8.2f\n", rv[2], rv[5], rv[8]);
                printf("rot for slice\n");
                printf("%8.2f %8.2f %8.2f\n", rs[0], rs[3], rs[6]);
                printf("%8.2f %8.2f %8.2f\n", rs[1], rs[4], rs[7]);
                printf("%8.2f %8.2f %8.2f\n", rs[2], rs[5], rs[8]);
            }

            dxs0 = rstrv[0]*dxv + rstrv[1]*dyv + rstrv[2]*dzv;
            dys0 = rstrv[3]*dxv + rstrv[4]*dyv + rstrv[5]*dzv;
            dzs0 = rstrv[6]*dxv + rstrv[7]*dyv + rstrv[8]*dzv;

            if( presscfh == PRESSCFH_SLICE ) 
            {
                presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(opthickPS), presscfh_slthick) : opthickPS;
                if( abs(dzs0 - dzs) >= av ) 
                {
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(1), presscfh_outrange) : 1;
                } else {
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(0), presscfh_outrange) : 0;
                }
            } 
            else 
            {   /* presscfh == PRESSCFH_SLAB */
                FLOAT dzss, dzse, dzs0s, dzs0e;
                FLOAT dz1, dz2;
                dzss = scan_info[0].optloc;
                dzse = scan_info[opslquant*opvquant-1].optloc;
                dzs0s = dzs0 - av/2;
                dzs0e = dzs0 + av/2;

                /* find dz1 and dz2 */
                if( dzs0e - dzs0s < 0 ) 
                {
                    FLOAT temp;
                    temp = dzs0e;
                    dzs0e = dzs0s;
                    dzs0s = temp;
                }
                if( dzse - dzss < 0 ) 
                {
                    FLOAT temp;
                    temp = dzse;
                    dzse = dzss;
                    dzss = temp;
                }

                dz1 = dzs0s;
                dz2 = dzs0e;

                if( dzss > dz1 ) 
                { 
                    dz1 = dzss;
                }
                if( dzse < dz2 ) 
                {
                    dz2 = dzse;
                }

                if( dzss >= dz2 || dzse <= dz1 ) 
                {
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(1), presscfh_outrange) : 1;
                }
                else
                {
                    dzs = dz1 + (dz2-dz1)/2;   
                    presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(presscfh_slab_ratio*(dz2-dz1)), presscfh_slthick) : presscfh_slab_ratio*(dz2-dz1);
                    if( presscfh_slthick < opthickPS ) 
                    {
                        presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(opthickPS), presscfh_slthick) : opthickPS;
                    }
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(0), presscfh_outrange) : 0;
                }         
            }

            if( presscfh_outrange == 0 ) 
            {
                Dz = dzs0 - dzs;
                al2 = av*av - Dz*Dz;
                if( al2 > 0 ) 
                {
                    al = sqrt(al2);
                } else {
                    al = 0;
                }
            }

            if( al >= presscfh_minfov_ratio*av ) 
            {
                dxl = dxs0;
                dyl = dys0;
                dzl = dzs;

                presscfh_fov  = _presscfh_fov.fixedflag ?  ((void)(presscfh_fov_ratio*al*2.0), presscfh_fov) : presscfh_fov_ratio*al*2.0;
                presscfh_pfov  = _presscfh_pfov.fixedflag ?  ((void)(presscfh_pfov_ratio*al*2.0), presscfh_pfov) : presscfh_pfov_ratio*al*2.0;

                presscfh_info[vidx].oppsctloc = dzl;
                presscfh_info[vidx].oppscrloc = dxl;
                presscfh_info[vidx].oppscphasoff = dyl;
                for( ii = 0; ii < 9; ii++ ) 
                {
                    presscfh_info[vidx].oppscrot[ii] = scan_info[PSslice_num].oprot[ii]; 
                }
                presscfh_info[vidx].oppsclenx = (INT)(presscfh_fov_ratio*al*2.0);
                presscfh_info[vidx].oppscleny = (INT)(presscfh_pfov_ratio*al*2.0);
                presscfh_info[vidx].oppsclenz = (INT)presscfh_slthick;
            } 
            else 
            {
                presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(1), presscfh_outrange) : 1;
            }

            if( presscfh_debug ) 
            {
                printf("av, dxv, dyv, dzv: %8.2f, %8.2f, %8.2f, %8.2f\n", av, dxv, dyv, dzv);    
                printf("dxs, dys, dzs: %8.2f, %8.2f, %8.2f\n", dxs, dys, dzs);    
                printf("al, dxl, dyl, dzl: %8.2f, %8.2f, %8.2f, %8.2f\n", al, dxl, dyl, dzl);    
                printf("presscfh_slthick: %8.2f\n", presscfh_slthick);    
                printf("outrange: %d\n", presscfh_outrange);    
            }

            if( presscfh_outrange == 1 ) 
            {
                cvoverride(presscfh_ctrl, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON); 
                if(presscfh_debug) 
                {
                    printf("\nCFHcveval : THIS TURNS OUT TO BE PRESSCFH_NONE,but was initially %d\n",presscfh);
                    fflush(stdout);
                }
                break;
            }
        }
    } 

    if (presscfh_ctrl == PRESSCFH_SHIMVOL ) 
    {
        INT vidx = 0;
        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
        {
            presscfh_fov  = _presscfh_fov.fixedflag ?    ((void)(presscfh_fov_ratio*psc_info[vidx].oppsclenx), presscfh_fov) : presscfh_fov_ratio*psc_info[vidx].oppsclenx;
            presscfh_pfov  = _presscfh_pfov.fixedflag ?    ((void)(presscfh_pfov_ratio*psc_info[vidx].oppscleny), presscfh_pfov) : presscfh_pfov_ratio*psc_info[vidx].oppscleny;
            presscfh_slthick  = _presscfh_slthick.fixedflag ?    ((void)(presscfh_slab_ratio*psc_info[vidx].oppsclenz), presscfh_slthick) : presscfh_slab_ratio*psc_info[vidx].oppsclenz;

            presscfh_info[vidx].oppsclenx = (INT)(presscfh_fov);
            presscfh_info[vidx].oppscleny = (INT)(presscfh_pfov);
            presscfh_info[vidx].oppsclenz = (INT)(presscfh_slthick);

            if( presscfh_debug ) 
            {
                printf(": SHIM VOLUME %d presscfh=2; presscfh_fov=%8.2f\n", vidx, presscfh_fov);
                fflush(stdout);
            }
        }
    }

    if( presscfh_ctrl != PRESSCFH_NONE ) 
    {
        INT vidx = 0;
        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
        {
            if( presscfh_fov < presscfh_info[vidx].oppsclenx )
            {
                presscfh_fov  = _presscfh_fov.fixedflag ?  ((void)(presscfh_info[vidx].oppsclenx), presscfh_fov) : presscfh_info[vidx].oppsclenx;
            }
            if( presscfh_pfov < presscfh_info[vidx].oppscleny )
            {
                presscfh_pfov  = _presscfh_pfov.fixedflag ?  ((void)(presscfh_info[vidx].oppscleny), presscfh_pfov) : presscfh_info[vidx].oppscleny;
            }
            if( presscfh_slthick < presscfh_info[vidx].oppsclenz )
            {
                presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(presscfh_info[vidx].oppsclenz), presscfh_slthick) : presscfh_info[vidx].oppsclenz;
            }
        }

        presscfh_ir_slthick  = _presscfh_ir_slthick.fixedflag ?  ((void)(presscfh_slthick), presscfh_ir_slthick) : presscfh_slthick;

        rfpulse[RF3_CFH_SLOT].num = 1;
        rfpulse[RF3_CFH_SLOT].activity = PSD_CFH_ON;

    } else {
        rfpulse[RF3_CFH_SLOT].num = 0;
        rfpulse[RF3_CFH_SLOT].activity = PSD_PULSE_OFF;

    }

    /* If inversion recovery image mode, Calcs for the Inversion pulse */
    if (PSD_ON == PSir)
    {
        res_rf0cfh  = _res_rf0cfh.fixedflag ?  ((void)(RES_SH_ADIABATIC), res_rf0cfh) : RES_SH_ADIABATIC;  /* Adiabatic pulse */
        /* MRIge90312 -- use 1.5sec TR for IR cfh */
        cfh_tr  = _cfh_tr.fixedflag ?  ((void)(1500000), cfh_tr) : 1500000;
        gscale_rf0cfh  = _gscale_rf0cfh.fixedflag ?  ((void)(0.87), gscale_rf0cfh) : 0.87; /* Changed from .65 to .87 for adiabatic pulse */

        pw_gzrf0cfh    = _pw_gzrf0cfh.fixedflag ?  ((void)(pw_rf0cfh), pw_gzrf0cfh) : pw_rf0cfh;

        /* Y Killer CVs */ /* YMSmr09211  04/26/2006 YI */
        if(amppwgrad(cfhir_killer_area, cfhloggrd.ty_yz, 0.0, 0.0, cfhloggrd.yrt,
                     MIN_PLATEAU_TIME, _a_gyrf0kcfh.fixedflag ? (_temp909_a_gyrf0kcfh=a_gyrf0kcfh,&_temp909_a_gyrf0kcfh) : &a_gyrf0kcfh, _pw_gyrf0kcfha.fixedflag ? (_temp910_pw_gyrf0kcfha=pw_gyrf0kcfha,&_temp910_pw_gyrf0kcfha) : &pw_gyrf0kcfha, _pw_gyrf0kcfh.fixedflag ? (_temp911_pw_gyrf0kcfh=pw_gyrf0kcfh,&_temp911_pw_gyrf0kcfh) : &pw_gyrf0kcfh, _pw_gyrf0kcfhd.fixedflag ? (_temp912_pw_gyrf0kcfhd=pw_gyrf0kcfhd,&_temp912_pw_gyrf0kcfhd) : &pw_gyrf0kcfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "amppwgrad:gyrf0kcfh"); 
            return FAILURE;
        }

        rfpulse[RF0_CFH_SLOT].num = 1;
        rfpulse[RF0_CFH_SLOT].activity = PSD_CFH_ON;
        bw_rf0cfh = 5.12*cyc_rf0cfh/((FLOAT)pw_rf0cfh/(FLOAT)1000000); /* adiabatic pulse */
 
        if(ampslice(_a_gzrf0cfh.fixedflag ? (_temp913_a_gzrf0cfh=a_gzrf0cfh,&_temp913_a_gzrf0cfh) : &a_gzrf0cfh, bw_rf0cfh, ((presscfh_ctrl == PRESSCFH_NONE) ? opthickPS : presscfh_ir_slthick),
                    gscale_rf0cfh, TYPDEF) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed for gzrf0cfh.",EM_PSD_SUPPORT_FAILURE, 
                       EE_ARGS(1), STRING_ARG, "ampslice");
            return FAILURE;
        }
        /* Non Selective IR */
        if( (presscfh_ctrl != PRESSCFH_NONE) && presscfh_ir_noselect ) 
        {
            a_gzrf0cfh  = _a_gzrf0cfh.fixedflag ?  ((void)(0), a_gzrf0cfh) : 0;
        }
        /* YMSmr09211  04/26/2006 YI */
        if(optramp(_pw_gzrf0cfha.fixedflag ? (_temp914_pw_gzrf0cfha=pw_gzrf0cfha,&_temp914_pw_gzrf0cfha) : &pw_gzrf0cfha,a_gzrf0cfh, cfhloggrd.tz, cfhloggrd.zrt, TYPDEF)==FAILURE) 
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "optramp for gzrf0cfha.");
            return FAILURE;
        }
        pw_gzrf0cfhd  = _pw_gzrf0cfhd.fixedflag ?  ((void)(pw_gzrf0cfha), pw_gzrf0cfhd) : pw_gzrf0cfha;
    } else {
        cfh_tr  = _cfh_tr.fixedflag ?  ((void)(398000), cfh_tr) : 398000;
        rfpulse[RF0_CFH_SLOT].num = 0;
        rfpulse[RF0_CFH_SLOT].activity = PSD_PULSE_OFF;
    }

    /* Calculations for the 90 pulse */
    pw_gzrf1cfh  = _pw_gzrf1cfh.fixedflag ?  ((void)(pw_rf1cfh), pw_gzrf1cfh) : pw_rf1cfh;
    bw_rf1cfh = rfpulse[RF1_CFH_SLOT].nom_bw*rfpulse[RF1_CFH_SLOT].nom_pw/(float)pw_rf1cfh;
       
    if (ampslice(_a_gzrf1cfh.fixedflag ? (_temp915_a_gzrf1cfh=a_gzrf1cfh,&_temp915_a_gzrf1cfh) : &a_gzrf1cfh, bw_rf1cfh, ( (presscfh_ctrl == PRESSCFH_NONE) ? opthickPS : presscfh_slthick),
                 gscale_rf1cfh, TYPDEF) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed for gzrf1cfh.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice");
        return FAILURE;
    }

    /* YMSmr09211  04/26/2006 YI */
    if (optramp(_pw_gzrf1cfha.fixedflag ? (_temp916_pw_gzrf1cfha=pw_gzrf1cfha,&_temp916_pw_gzrf1cfha) : &pw_gzrf1cfha, a_gzrf1cfh, cfhloggrd.tz, cfhloggrd.zrt, TYPDEF) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed for gzrf1cfh.", 
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp");
        return FAILURE;
    }

    pw_gzrf1cfhd  = _pw_gzrf1cfhd.fixedflag ?  ((void)(pw_gzrf1cfha), pw_gzrf1cfhd) : pw_gzrf1cfha;

    /* Calculations for the 180 pulse */
    /* Have to rely on the PSD to keep these up to date - can't tell from
       here whether or not the PSD is a mempoid. */
    pw_gxrf2cfh  = _pw_gxrf2cfh.fixedflag ?  ((void)(pw_rf2cfh), pw_gxrf2cfh) : pw_rf2cfh;
    pw_gyrf2cfh  = _pw_gyrf2cfh.fixedflag ?  ((void)(pw_rf2cfh), pw_gyrf2cfh) : pw_rf2cfh;
    pw_gyrf3cfh  = _pw_gyrf3cfh.fixedflag ?  ((void)(pw_rf3cfh), pw_gyrf3cfh) : pw_rf3cfh; /* for presscfh */

    /* Find amplitudes for the FOV selective traps */
    if (opcoax==1) 
    {
        /* If coaxial through isocenter */
        cfh_fov  = _cfh_fov.fixedflag ?    ((void)(FMin(2,40.0,opfov/10.0)), cfh_fov) : FMin(2,40.0,opfov/10.0);
    } else {
        /* Otherwise open it up */
        cfh_fov  = _cfh_fov.fixedflag ?  ((void)(40.0), cfh_fov) : 40.0;
    }

    if(cfh_newmode) 
    {   /*override with new mode*/
        float cfh_new_fov = opspf ? (opphasefov*opfov/10.0) : (opfov/10.0);

        cfh_fov  = _cfh_fov.fixedflag ?    ((void)(FMin(2,40.0,cfh_new_fov)), cfh_fov) : FMin(2,40.0,cfh_new_fov);
        /* For non-coaxials (multi angle), center cfh_rf2freq and up the
           excitation region to 40 cm to cover lots of ground */
        cfh_fov  = _cfh_fov.fixedflag ?        ((void)((opcoax==0)?40.0:FMax(2,(float)FOV_MIN,cfh_fov)), cfh_fov) : (opcoax==0)?40.0:FMax(2,(float)FOV_MIN,cfh_fov);
    }

    if( presscfh_ctrl != PRESSCFH_NONE ) 
    {
        /* X FOV Selective */ /* YMSmr09211  04/26/2006 YI */
        a_gxrf2cfh  = _a_gxrf2cfh.fixedflag ?  ((void)(4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*presscfh_fov/10.0)), a_gxrf2cfh) : 4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*presscfh_fov/10.0);
        if (optramp(_pw_gxrf2cfha.fixedflag ? (_temp917_pw_gxrf2cfha=pw_gxrf2cfha,&_temp917_pw_gxrf2cfha) : &pw_gxrf2cfha, a_gxrf2cfh, cfhloggrd.tx, cfhloggrd.xrt, TYPDEF) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed for gxrf2cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "optramp for gxrf2cfh"); 
            return FAILURE;
        }
        pw_gxrf2cfha  = _pw_gxrf2cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha)), pw_gxrf2cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha);
        pw_gxrf2cfhd  = _pw_gxrf2cfhd.fixedflag ?  ((void)(pw_gxrf2cfha), pw_gxrf2cfhd) : pw_gxrf2cfha;
        target_cfh_crusher  = _target_cfh_crusher.fixedflag ?  ((void)(cfhloggrd.tz_xz), target_cfh_crusher) : cfhloggrd.tz_xz; /* YMSmr09211  04/26/2006 YI */

        /* Y FOV Selective */ /* YMSmr09211  04/26/2006 YI */
        a_gyrf3cfh  = _a_gyrf3cfh.fixedflag ?  ((void)(4*cyc_rf3cfh/(GAM*(float)pw_rf3cfh/(float)(1000000)*presscfh_pfov/10.0)), a_gyrf3cfh) : 4*cyc_rf3cfh/(GAM*(float)pw_rf3cfh/(float)(1000000)*presscfh_pfov/10.0);
        if (optramp(_pw_gyrf3cfha.fixedflag ? (_temp918_pw_gyrf3cfha=pw_gyrf3cfha,&_temp918_pw_gyrf3cfha) : &pw_gyrf3cfha, a_gyrf3cfh, cfhloggrd.ty, cfhloggrd.yrt, TYPDEF) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed for gyrf3cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "optramp for gyrf3cfh");
            return FAILURE;
        }
        pw_gyrf3cfha  = _pw_gyrf3cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf3cfha)), pw_gyrf3cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf3cfha);
        pw_gyrf3cfhd  = _pw_gyrf3cfhd.fixedflag ?  ((void)(pw_gyrf3cfha), pw_gyrf3cfhd) : pw_gyrf3cfha;
        target_cfh_crusher2  = _target_cfh_crusher2.fixedflag ?  ((void)(cfhloggrd.tz_yz), target_cfh_crusher2) : cfhloggrd.tz_yz; /* YMSmr09211  04/26/2006 YI */

        if( cfh_steam_flag != PSD_ON )
        {
            /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf2rcfh.fixedflag ? (_temp919_a_gzrf2rcfh=a_gzrf2rcfh,&_temp919_a_gzrf2rcfh) : &a_gzrf2rcfh, _pw_gzrf2rcfha.fixedflag ? (_temp920_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp920_pw_gzrf2rcfha) : &pw_gzrf2rcfha,
                          _pw_gzrf2rcfh.fixedflag ? (_temp921_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp921_pw_gzrf2rcfh) : &pw_gzrf2rcfh, _pw_gzrf2rcfhd.fixedflag ? (_temp922_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp922_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf2rcfh"); 
                return FAILURE;
            }
            pw_gzrf2lcfha  = _pw_gzrf2lcfha.fixedflag ?  ((void)(pw_gzrf2rcfha), pw_gzrf2lcfha) : pw_gzrf2rcfha;
            pw_gzrf2lcfhd  = _pw_gzrf2lcfhd.fixedflag ?  ((void)(pw_gzrf2rcfhd), pw_gzrf2lcfhd) : pw_gzrf2rcfhd;
        }
        else
        {
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3rcfh.fixedflag ? (_temp923_a_gzrf3rcfh=a_gzrf3rcfh,&_temp923_a_gzrf3rcfh) : &a_gzrf3rcfh, _pw_gzrf3rcfha.fixedflag ? (_temp924_pw_gzrf3rcfha=pw_gzrf3rcfha,&_temp924_pw_gzrf3rcfha) : &pw_gzrf3rcfha,
                          _pw_gzrf3rcfh.fixedflag ? (_temp925_pw_gzrf3rcfh=pw_gzrf3rcfh,&_temp925_pw_gzrf3rcfh) : &pw_gzrf3rcfh, _pw_gzrf3rcfhd.fixedflag ? (_temp926_pw_gzrf3rcfhd=pw_gzrf3rcfhd,&_temp926_pw_gzrf3rcfhd) : &pw_gzrf3rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3rcfh"); 
                return FAILURE;
            }
            pw_gzrf2lcfha  = _pw_gzrf2lcfha.fixedflag ?  ((void)(pw_gzrf3rcfha), pw_gzrf2lcfha) : pw_gzrf3rcfha;
            pw_gzrf2lcfhd  = _pw_gzrf2lcfhd.fixedflag ?  ((void)(pw_gzrf3rcfhd), pw_gzrf2lcfhd) : pw_gzrf3rcfhd;
        }

        if( cfh_steam_flag != PSD_ON )
        {
            /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3rcfh.fixedflag ? (_temp927_a_gzrf3rcfh=a_gzrf3rcfh,&_temp927_a_gzrf3rcfh) : &a_gzrf3rcfh, _pw_gzrf3rcfha.fixedflag ? (_temp928_pw_gzrf3rcfha=pw_gzrf3rcfha,&_temp928_pw_gzrf3rcfha) : &pw_gzrf3rcfha,
                          _pw_gzrf3rcfh.fixedflag ? (_temp929_pw_gzrf3rcfh=pw_gzrf3rcfh,&_temp929_pw_gzrf3rcfh) : &pw_gzrf3rcfh, _pw_gzrf3rcfhd.fixedflag ? (_temp930_pw_gzrf3rcfhd=pw_gzrf3rcfhd,&_temp930_pw_gzrf3rcfhd) : &pw_gzrf3rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3rcfh"); 
                return FAILURE;
            }

            /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3lcfh.fixedflag ? (_temp931_a_gzrf3lcfh=a_gzrf3lcfh,&_temp931_a_gzrf3lcfh) : &a_gzrf3lcfh, _pw_gzrf3lcfha.fixedflag ? (_temp932_pw_gzrf3lcfha=pw_gzrf3lcfha,&_temp932_pw_gzrf3lcfha) : &pw_gzrf3lcfha,
                          _pw_gzrf3lcfh.fixedflag ? (_temp933_pw_gzrf3lcfh=pw_gzrf3lcfh,&_temp933_pw_gzrf3lcfh) : &pw_gzrf3lcfh, _pw_gzrf3lcfhd.fixedflag ? (_temp934_pw_gzrf3lcfhd=pw_gzrf3lcfhd,&_temp934_pw_gzrf3lcfhd) : &pw_gzrf3lcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3lrcfhd"); 
                return FAILURE;
            }
        }
        else
        {
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf2rcfh.fixedflag ? (_temp935_a_gzrf2rcfh=a_gzrf2rcfh,&_temp935_a_gzrf2rcfh) : &a_gzrf2rcfh, _pw_gzrf2rcfha.fixedflag ? (_temp936_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp936_pw_gzrf2rcfha) : &pw_gzrf2rcfha,
                          _pw_gzrf2rcfh.fixedflag ? (_temp937_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp937_pw_gzrf2rcfh) : &pw_gzrf2rcfh, _pw_gzrf2rcfhd.fixedflag ? (_temp938_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp938_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf2rcfh"); 
                return FAILURE;
            }

            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3lcfh.fixedflag ? (_temp939_a_gzrf3lcfh=a_gzrf3lcfh,&_temp939_a_gzrf3lcfh) : &a_gzrf3lcfh, _pw_gzrf3lcfha.fixedflag ? (_temp940_pw_gzrf3lcfha=pw_gzrf3lcfha,&_temp940_pw_gzrf3lcfha) : &pw_gzrf3lcfha,
                          _pw_gzrf3lcfh.fixedflag ? (_temp941_pw_gzrf3lcfh=pw_gzrf3lcfh,&_temp941_pw_gzrf3lcfh) : &pw_gzrf3lcfh, _pw_gzrf3lcfhd.fixedflag ? (_temp942_pw_gzrf3lcfhd=pw_gzrf3lcfhd,&_temp942_pw_gzrf3lcfhd) : &pw_gzrf3lcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3lrcfhd"); 
                return FAILURE;
            }
        }
    } else {
        if (opspf == 0) 
        {
            /* X FOV Selective */ /* YMSmr09211  04/26/2006 YI */
            a_gxrf2cfh  = _a_gxrf2cfh.fixedflag ?  ((void)(4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov)), a_gxrf2cfh) : 4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov);
            if (optramp(_pw_gxrf2cfha.fixedflag ? (_temp943_pw_gxrf2cfha=pw_gxrf2cfha,&_temp943_pw_gxrf2cfha) : &pw_gxrf2cfha, a_gxrf2cfh, cfhloggrd.tx, cfhloggrd.xrt, TYPDEF) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed for gxrf2cfh.", 
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "optramp for gxrf2cfh");
                return FAILURE;
            }
            pw_gxrf2cfha  = _pw_gxrf2cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha)), pw_gxrf2cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha);
            pw_gxrf2cfhd  = _pw_gxrf2cfhd.fixedflag ?  ((void)(pw_gxrf2cfha), pw_gxrf2cfhd) : pw_gxrf2cfha;
            target_cfh_crusher  = _target_cfh_crusher.fixedflag ?  ((void)(cfhloggrd.tz_xz), target_cfh_crusher) : cfhloggrd.tz_xz; /* YMSmr09211  04/26/2006 YI */
        } 
        else 
        {
            /* Y FOV Selective */ /* YMSmr09211  04/26/2006 YI */
            a_gyrf2cfh  = _a_gyrf2cfh.fixedflag ?  ((void)(4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov)), a_gyrf2cfh) : 4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov);
            if (optramp(_pw_gyrf2cfha.fixedflag ? (_temp944_pw_gyrf2cfha=pw_gyrf2cfha,&_temp944_pw_gyrf2cfha) : &pw_gyrf2cfha, a_gyrf2cfh, cfhloggrd.ty, cfhloggrd.yrt, TYPDEF) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed for gyrf2cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "optramp for gyrf2cfh");
                return FAILURE;
            }
            pw_gyrf2cfha  = _pw_gyrf2cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf2cfha)), pw_gyrf2cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf2cfha);
            pw_gyrf2cfhd  = _pw_gyrf2cfhd.fixedflag ?  ((void)(pw_gyrf2cfha), pw_gyrf2cfhd) : pw_gyrf2cfha;
            target_cfh_crusher  = _target_cfh_crusher.fixedflag ?  ((void)(cfhloggrd.tz_yz), target_cfh_crusher) : cfhloggrd.tz_yz; /* YMSmr09211  04/26/2006 YI */
        }

        /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
        if (amppwgrad(cfh_crusher_area, target_cfh_crusher, 0.0, 0.0, cfhloggrd.zrt,
                      MIN_PLATEAU_TIME, _a_gzrf2rcfh.fixedflag ? (_temp945_a_gzrf2rcfh=a_gzrf2rcfh,&_temp945_a_gzrf2rcfh) : &a_gzrf2rcfh, _pw_gzrf2rcfha.fixedflag ? (_temp946_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp946_pw_gzrf2rcfha) : &pw_gzrf2rcfha,
                      _pw_gzrf2rcfh.fixedflag ? (_temp947_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp947_pw_gzrf2rcfh) : &pw_gzrf2rcfh, _pw_gzrf2rcfhd.fixedflag ? (_temp948_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp948_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "amppwgrad:gzrf2rcfh"); 
            return FAILURE;
        }

        pw_gzrf2lcfha  = _pw_gzrf2lcfha.fixedflag ?  ((void)(pw_gzrf2rcfha), pw_gzrf2lcfha) : pw_gzrf2rcfha;
        pw_gzrf2lcfhd  = _pw_gzrf2lcfhd.fixedflag ?  ((void)(pw_gzrf2rcfhd), pw_gzrf2lcfhd) : pw_gzrf2rcfhd;
    }

    area_gz1cfh = (PSoff90 + pw_rf1cfh/2.0 + pw_gzrf1cfhd/2.0)*a_gzrf1cfh;
    /* YMSmr09211  04/26/2006 YI */
    if (amppwlcrsh(&psd_cfhleftcrush, &psd_cfhrightcrush,
                   area_gz1cfh, (float)0, cfhloggrd.tz_xz, 
                   MIN_PLATEAU_TIME, cfhloggrd.zrt, _dummy_pw.fixedflag ? (_temp949_dummy_pw=dummy_pw,&_temp949_dummy_pw) : &dummy_pw) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed in cfh.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwlcrsh for gzrf2lcfh");
        return FAILURE;
    }

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        FLOAT area_g1 = (pw_gxrf2cfh + pw_gxrf2cfha)*a_gxrf2cfh/2.0; 
        if (amppwgrad(area_g1, cfhloggrd.tx, 0.0, 0.0, cfhloggrd.xrt,
                      MIN_PLATEAU_TIME, _a_gx1cfh.fixedflag ? (_temp950_a_gx1cfh=a_gx1cfh,&_temp950_a_gx1cfh) : &a_gx1cfh, _pw_gx1cfha.fixedflag ? (_temp951_pw_gx1cfha=pw_gx1cfha,&_temp951_pw_gx1cfha) : &pw_gx1cfha,
                      _pw_gx1cfh.fixedflag ? (_temp952_pw_gx1cfh=pw_gx1cfh,&_temp952_pw_gx1cfh) : &pw_gx1cfh, _pw_gx1cfhd.fixedflag ? (_temp953_pw_gx1cfhd=pw_gx1cfhd,&_temp953_pw_gx1cfhd) : &pw_gx1cfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "amppwgrad:gx1cfh"); 
            return FAILURE;
        }

        area_g1 = (pw_gyrf3cfh + pw_gyrf3cfhd)*a_gyrf3cfh/2.0; 
        if (amppwgrad(area_g1, cfhloggrd.ty, 0.0, 0.0, cfhloggrd.yrt,
                      MIN_PLATEAU_TIME, _a_gy1cfh.fixedflag ? (_temp954_a_gy1cfh=a_gy1cfh,&_temp954_a_gy1cfh) : &a_gy1cfh, _pw_gy1cfha.fixedflag ? (_temp955_pw_gy1cfha=pw_gy1cfha,&_temp955_pw_gy1cfha) : &pw_gy1cfha,
                      _pw_gy1cfh.fixedflag ? (_temp956_pw_gy1cfh=pw_gy1cfh,&_temp956_pw_gy1cfh) : &pw_gy1cfh, _pw_gy1cfhd.fixedflag ? (_temp957_pw_gy1cfhd=pw_gy1cfhd,&_temp957_pw_gy1cfhd) : &pw_gy1cfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "amppwgrad:gy1cfh"); 
            return FAILURE;
        }
    }

    /* Find Params for killer pulse */ /* YMSmr09211  04/26/2006 YI */
    area_gykcfh  = _area_gykcfh.fixedflag ?  ((void)(amp_killer*pw_killer), area_gykcfh) : amp_killer*pw_killer;
    if (amppwgrad(area_gykcfh, cfhloggrd.ty, 0.0, 0.0, cfhloggrd.yrt,
                  MIN_PLATEAU_TIME, _a_gykcfh.fixedflag ? (_temp958_a_gykcfh=a_gykcfh,&_temp958_a_gykcfh) : &a_gykcfh, _pw_gykcfha.fixedflag ? (_temp959_pw_gykcfha=pw_gykcfha,&_temp959_pw_gykcfha) : &pw_gykcfha,
                  _pw_gykcfh.fixedflag ? (_temp960_pw_gykcfh=pw_gykcfh,&_temp960_pw_gykcfh) : &pw_gykcfh, _pw_gykcfhd.fixedflag ? (_temp961_pw_gykcfhd=pw_gykcfhd,&_temp961_pw_gykcfhd) : &pw_gykcfhd) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed in cfh.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykcfh");
        return FAILURE;
    }

    return SUCCESS;
}

/*
 *  PScveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PScveval( void )
{
    STATUS ps_status;
    FLOAT opthickPS;
    INT i,j; /* YMSmr09211  04/26/2006 YI */
    INT num_cfhlocs;

    /*********************************************************************
     * Generic SECTION
     *********************************************************************/
   
    /* Set the modes for presscfh */
    set_presscfh_mode();

    /* YMSmr09211  04/26/2006 YI */
    if( presscfh_ctrl == PRESSCFH_SHIMVOL )
    {
        num_cfhlocs = exist(oppscvquant);
        for (i=0; i< num_cfhlocs; i++)
        {
            for (j=0; j<9; j++)
            {
                cfh_info[i].oprot[j] = psc_info[i].oppscrot[j];
            }
        }
    }
    else
    {
        num_cfhlocs = IMax(2, 1, exist(oppscvquant));
        for (i=0; i< num_cfhlocs; i++)
        {
            for (j=0; j<9; j++)
            {
                cfh_info[i].oprot[j] = scan_info[PSslice_num].oprot[j];
            }
        }
    }

    cfh_newgeo  = _cfh_newgeo.fixedflag ?  ((void)(1), cfh_newgeo) : 1;
    if (obloptimize(&cfhloggrd, &phygrd, cfh_info, num_cfhlocs,
                    PSD_OBL, 0, obl_method, cfhobl_debug, _cfh_newgeo.fixedflag ? (_temp962_cfh_newgeo=cfh_newgeo,&_temp962_cfh_newgeo) : &cfh_newgeo, cfsrmode)==FAILURE)
    {
        epic_error(use_ermes,"obloptimize failed in PScveval()",
                   EM_PSD_FUNCTION_FAILURE,2,STRING_ARG,"obloptimize",STRING_ARG,"PScveval()");
        return FAILURE; 

    }

    /* derate SR for quiet PSC */ 
    sr_derate(&cfhloggrd, PSsr_derate_factor);

    if (opimode == PSD_3D)  
    {
        opthickPS = 10.0;
    } 
    else 
    {
        /* vmx 12/07/94 YI */
        if( (cfcoilshld == 1) && (pigradcoil == 1) )
        {
            opthickPS = (exist(opslthick) < 3.5) ? 3.5 : exist(opslthick);
        }
        else
        {
            opthickPS = (exist(opslthick) < 3.0) ? 3.0 : exist(opslthick);
        }
        /* end vmx */
    }

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = PS1cveval( &opthickPS )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "PS1cveval");
        return ps_status;
    }

    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFLcveval( opthickPS )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFLcveval");
        return ps_status;
    }

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = RCVNcveval( )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "RCVNcveval");
        return ps_status;
    }

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFHcveval( opthickPS )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFHcveval");
        return ps_status;
    }

    /***********************************************************************
     * Programmable Prescan SECTION
     ***********************************************************************/

    /* Check for valid Optprescan entry points */
    if(pimrsapsflg) {
        int ipi;
        char strmrs[16] = "pimrsaps1";

        for (ipi = 0; ipi < PSC_MAX_CONTROL_ARRAY; ipi++) 
        {
            switch(*pimrs[ipi]) 
            {
            case MRSAPS_OFF: case MRSAPS_CFL: case MRSAPS_TG:
            case MRSAPS_CFH: case MRSAPS_TR: case MRSAPS_FSEPS:
            case MRSAPS_APA: case MRSAPS_AWS: case MRSAPS_AVS:
            case MRSAPS_AS: case MRSAPS_FTG: case MRSAPS_RCVN:
            case MRSAPS_XTG:
                break;
            default:
                sprintf(strmrs, "pimrsaps%d", ipi + 1);
                epic_error(use_ermes, "%s is out of range.",
                           EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1),
                           STRING_ARG, strmrs);
                return FAILURE;
            }
        }
    } /* end pimrsapsflg check */

    return SUCCESS;
}   /* end PScveval() */


/*
 *  FTGcveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGcveval( void )
{
    INT bw_rf1ftg;
    INT bw_rf2ftg;
    INT bw_rf3ftg;
    FLOAT area_g1ftg;
    FLOAT area_g2ftg;
    FLOAT area_g2bftg;
    FLOAT area_g3ftg;
    FLOAT area_postgxw1ftg;
    FLOAT area_gxw1ftg;
    FLOAT area_gx1ftg;
    FLOAT area_gx2ftg;
    INT PosReadoutWindow;  /* Readout window location            */
    int ftg_xrt;
    float ftg_tx;
    float ftg_tx_xz;
    float ftg_tz_xz;
    float ftg_tx_xyz;
    int FTGtau1check1, FTGtau1check2, FTGtau1check3,
        FTGtau1check4, FTGtau1check5, FTGtau1check6, temp_FTGtau1;

    /* HCSDM00161809: for calculation of minimum FTGtau1 */
    FTGtau1  = _FTGtau1.fixedflag ?    ((void)(8192), FTGtau1) : 8192;
    FTGtau1check1   = FTGtau1;
    FTGtau1check2   = FTGtau1;
    FTGtau1check3   = FTGtau1;
    FTGtau1check4   = FTGtau1;
    FTGtau1check5   = FTGtau1;
    FTGtau1check6   = FTGtau1;
    temp_FTGtau1    = FTGtau1;
    
    ftg_xrt = (TGspf ? ps1loggrd.yrt : ps1loggrd.xrt);
    ftg_tx = (TGspf ? ps1loggrd.ty : ps1loggrd.tx);
    ftg_tx_xz = (TGspf ? ps1loggrd.ty_yz : ps1loggrd.tx_xz);
    ftg_tz_xz = (TGspf ? ps1loggrd.tz_yz : ps1loggrd.tz_xz);
    ftg_tx_xyz = (TGspf ? ps1loggrd.ty_xyz : ps1loggrd.tx_xyz);

    FTGfov  = _FTGfov.fixedflag ?  ((void)(cfsystemmaxfov), FTGfov) : cfsystemmaxfov;

    FTGopslthickz1  = _FTGopslthickz1.fixedflag ?  ((void)(4*FTGslthk), FTGopslthickz1) : 4*FTGslthk;
    FTGopslthickz2  = _FTGopslthickz2.fixedflag ?  ((void)(4*FTGslthk), FTGopslthickz2) : 4*FTGslthk;
    FTGopslthickz3  = _FTGopslthickz3.fixedflag ?  ((void)(FTGslthk), FTGopslthickz3) : FTGslthk;
    gscale_rf1ftg   = _gscale_rf1ftg.fixedflag ?  ((void)(0.90909), gscale_rf1ftg) : 0.90909;
    gscale_rf2ftg   = _gscale_rf2ftg.fixedflag ?  ((void)(gscale_rf1ftg), gscale_rf2ftg) : gscale_rf1ftg;
    gscale_rf3ftg   = _gscale_rf3ftg.fixedflag ?  ((void)(gscale_rf1ftg), gscale_rf3ftg) : gscale_rf1ftg;
    pw_gzrf1ftg  = _pw_gzrf1ftg.fixedflag ?  ((void)(pw_rf1ftg), pw_gzrf1ftg) : pw_rf1ftg;
    pw_gzrf2ftg  = _pw_gzrf2ftg.fixedflag ?  ((void)(pw_rf2ftg), pw_gzrf2ftg) : pw_rf2ftg;
    pw_gzrf3ftg  = _pw_gzrf3ftg.fixedflag ?  ((void)(pw_rf3ftg), pw_gzrf3ftg) : pw_rf3ftg;

    /* 12/07/94 YI temporary change to avoid internal error with Vectra SGC coil */
    if( cfgradcoil == GCOIL_VECTRA )
    {
        FTGopslthickz3  = _FTGopslthickz3.fixedflag ?  ((void)(7), FTGopslthickz3) : 7;
    }
    
    bw_rf1ftg = 4 * cyc_rf1ftg/ ((FLOAT)pw_rf1ftg/ (FLOAT)1000000);

    if( !existcv(FTGtau2) )
    {
        FTGtau2  = _FTGtau2.fixedflag ?  ((void)(exist(FTGtau1)*exist(FTGau)), FTGtau2) : exist(FTGtau1)*exist(FTGau);
    }

    if( ampslice(_a_gzrf1ftg.fixedflag ? (_temp963_a_gzrf1ftg=a_gzrf1ftg,&_temp963_a_gzrf1ftg) : &a_gzrf1ftg, bw_rf1ftg, FTGopslthickz1, gscale_rf1ftg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1ftg.");
        return FAILURE;
    }
    
    bw_rf2ftg = 4 * cyc_rf2ftg/ ((FLOAT)pw_rf2ftg/ (FLOAT)1000000);
 
    if( ampslice(_a_gzrf2ftg.fixedflag ? (_temp964_a_gzrf2ftg=a_gzrf2ftg,&_temp964_a_gzrf2ftg) : &a_gzrf2ftg, bw_rf2ftg, FTGopslthickz2, gscale_rf2ftg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf2ftg.");
        return FAILURE;
    }
    
 
    bw_rf3ftg = 4 * cyc_rf3ftg/ ((FLOAT)pw_rf3ftg/ (FLOAT)1000000);
 
    if( ampslice(_a_gzrf3ftg.fixedflag ? (_temp965_a_gzrf3ftg=a_gzrf3ftg,&_temp965_a_gzrf3ftg) : &a_gzrf3ftg, bw_rf3ftg, FTGopslthickz3, gscale_rf3ftg, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf3ftg.");
        return FAILURE;
    }
    if( optramp(_pw_gzrf1ftga.fixedflag ? (_temp966_pw_gzrf1ftga=pw_gzrf1ftga,&_temp966_pw_gzrf1ftga) : &pw_gzrf1ftga, a_gzrf1ftg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1ftga.");
        return FAILURE;
    }    
    
    pw_gzrf1ftgd  = _pw_gzrf1ftgd.fixedflag ?  ((void)(pw_gzrf1ftga), pw_gzrf1ftgd) : pw_gzrf1ftga;

    if (optramp(_pw_gzrf2ftga.fixedflag ? (_temp967_pw_gzrf2ftga=pw_gzrf2ftga,&_temp967_pw_gzrf2ftga) : &pw_gzrf2ftga, a_gzrf2ftg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf2ftga.");
        return FAILURE;
    }    
    
    pw_gzrf2ftgd  = _pw_gzrf2ftgd.fixedflag ?  ((void)(pw_gzrf2ftga), pw_gzrf2ftgd) : pw_gzrf2ftga;
 
 
    /* Find Params for first zgrad refocusing pulse */
    area_g1ftg = ( a_gzrf1ftg *.5* ( pw_gzrf1ftg + pw_gzrf1ftgd)
                   + a_gzrf2ftg *.5 * (pw_gzrf2ftga + pw_gzrf2ftg) );
    if( amppwgz1(_a_gz1ftg.fixedflag ? (_temp968_a_gz1ftg=a_gz1ftg,&_temp968_a_gz1ftg) : &a_gz1ftg, _pw_gz1ftg.fixedflag ? (_temp969_pw_gz1ftg=pw_gz1ftg,&_temp969_pw_gz1ftg) : &pw_gz1ftg, _pw_gz1ftga.fixedflag ? (_temp970_pw_gz1ftga=pw_gz1ftga,&_temp970_pw_gz1ftga) : &pw_gz1ftga, _pw_gz1ftgd.fixedflag ? (_temp971_pw_gz1ftgd=pw_gz1ftgd,&_temp971_pw_gz1ftgd) : &pw_gz1ftgd,
                 area_g1ftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ps1loggrd.tz) == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1ftg.");
        return FAILURE;
    }
    

    /* Find Params for refocusing pulse gz2ftg */
    area_g2ftg =  a_gzrf2ftg *.5* ( pw_gzrf2ftg + pw_gzrf2ftgd);
    if( amppwgz1(_a_gz2ftg.fixedflag ? (_temp972_a_gz2ftg=a_gz2ftg,&_temp972_a_gz2ftg) : &a_gz2ftg, _pw_gz2ftg.fixedflag ? (_temp973_pw_gz2ftg=pw_gz2ftg,&_temp973_pw_gz2ftg) : &pw_gz2ftg, _pw_gz2ftga.fixedflag ? (_temp974_pw_gz2ftga=pw_gz2ftga,&_temp974_pw_gz2ftga) : &pw_gz2ftga, _pw_gz2ftgd.fixedflag ? (_temp975_pw_gz2ftgd=pw_gz2ftgd,&_temp975_pw_gz2ftgd) : &pw_gz2ftgd,
                 area_g2ftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ftg_tz_xz) == FAILURE ) {
	epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz2ftg.");
	return FAILURE;
    }
 
    /* Find Params for refocusing pulse gz2btg */

    /* MRIge56170  AF  10/13/99 */
    if( optramp(_pw_gzrf3ftga.fixedflag ? (_temp976_pw_gzrf3ftga=pw_gzrf3ftga,&_temp976_pw_gzrf3ftga) : &pw_gzrf3ftga, a_gzrf3ftg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf3ftga.");
        return FAILURE;
    }

    area_g2bftg =  a_gzrf3ftg * .5 *(pw_gzrf3ftga + pw_gzrf3ftg);
    if( amppwgz1(_a_gz2bftg.fixedflag ? (_temp977_a_gz2bftg=a_gz2bftg,&_temp977_a_gz2bftg) : &a_gz2bftg, _pw_gz2bftg.fixedflag ? (_temp978_pw_gz2bftg=pw_gz2bftg,&_temp978_pw_gz2bftg) : &pw_gz2bftg, _pw_gz2bftga.fixedflag ? (_temp979_pw_gz2bftga=pw_gz2bftga,&_temp979_pw_gz2bftga) : &pw_gz2bftga, _pw_gz2bftgd.fixedflag ? (_temp980_pw_gz2bftgd=pw_gz2bftgd,&_temp980_pw_gz2bftgd) : &pw_gz2bftgd,
                 area_g2bftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ps1loggrd.tz) == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, ":amppwgz1 for gz2bftg.");
        return FAILURE;
    }
    
    pw_gzrf3ftgd  = _pw_gzrf3ftgd.fixedflag ?  ((void)(pw_gzrf3ftga), pw_gzrf3ftgd) : pw_gzrf3ftga;
 
    /* Find Params for refocusing pulse */
    area_g3ftg =  a_gzrf3ftg *.5* ( pw_gzrf3ftg + pw_gzrf3ftgd);
    if( amppwgz1(_a_gz3ftg.fixedflag ? (_temp981_a_gz3ftg=a_gz3ftg,&_temp981_a_gz3ftg) : &a_gz3ftg, _pw_gz3ftg.fixedflag ? (_temp982_pw_gz3ftg=pw_gz3ftg,&_temp982_pw_gz3ftg) : &pw_gz3ftg, _pw_gz3ftga.fixedflag ? (_temp983_pw_gz3ftga=pw_gz3ftga,&_temp983_pw_gz3ftga) : &pw_gz3ftga, _pw_gz3ftgd.fixedflag ? (_temp984_pw_gz3ftgd=pw_gz3ftgd,&_temp984_pw_gz3ftgd) : &pw_gz3ftgd,
                 area_g3ftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ftg_tz_xz) == FAILURE )
    {

        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz3ftg.");
        return FAILURE;
    }
    
    if( calcfilter( &echo1ftg_filt, FTGecho1bw, FTGxres, OVERWRITE_NONE)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"calcfilter for echo1ftg_filt");
        return FAILURE;
    }

    if( ampfov(_a_gxw1ftg.fixedflag ? (_temp985_a_gxw1ftg=a_gxw1ftg,&_temp985_a_gxw1ftg) : &a_gxw1ftg, echo1ftg_filt.bw, FTGfov) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxw1ftg.");
        return FAILURE;
 
    }
 
    pw_gxw1ftg  = _pw_gxw1ftg.fixedflag ?  ((void)(RUP_GRD((int)(echo1ftg_filt.tdaq)/4)), pw_gxw1ftg) : RUP_GRD((int)(echo1ftg_filt.tdaq)/4);

    area_gxw1ftg = 2.0*a_gxw1ftg*(float)(pw_gxw1ftg);
 
    if( amppwgx1(_a_gx1ftg.fixedflag ? (_temp986_a_gx1ftg=a_gx1ftg,&_temp986_a_gx1ftg) : &a_gx1ftg, _pw_gx1ftg.fixedflag ? (_temp987_pw_gx1ftg=pw_gx1ftg,&_temp987_pw_gx1ftg) : &pw_gx1ftg, _pw_gx1ftga.fixedflag ? (_temp988_pw_gx1ftga=pw_gx1ftga,&_temp988_pw_gx1ftga) : &pw_gx1ftga, _pw_gx1ftgd.fixedflag ? (_temp989_pw_gx1ftgd=pw_gx1ftgd,&_temp989_pw_gx1ftgd) : &pw_gx1ftgd,
                 TYPSPIN, area_gxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx_xz) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1ftg.");
        return FAILURE;
    }
    
    if( amppwgx1(_a_gx2test.fixedflag ? (_temp990_a_gx2test=a_gx2test,&_temp990_a_gx2test) : &a_gx2test, _pw_gx2test.fixedflag ? (_temp991_pw_gx2test=pw_gx2test,&_temp991_pw_gx2test) : &pw_gx2test, _pw_gx2testa.fixedflag ? (_temp992_pw_gx2testa=pw_gx2testa,&_temp992_pw_gx2testa) : &pw_gx2testa, _pw_gx2testd.fixedflag ? (_temp993_pw_gx2testd=pw_gx2testd,&_temp993_pw_gx2testd) : &pw_gx2testd,
                 TYPSPIN, area_gxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx_xz) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1ftg.");

        return FAILURE;
    }
    
 
    area_gxw1ftg = a_gxw1ftg*(float)(pw_gxw1ftg);
    if( amppwgx1(_a_gx1bftg.fixedflag ? (_temp994_a_gx1bftg=a_gx1bftg,&_temp994_a_gx1bftg) : &a_gx1bftg, _pw_gx1bftg.fixedflag ? (_temp995_pw_gx1bftg=pw_gx1bftg,&_temp995_pw_gx1bftg) : &pw_gx1bftg, _pw_gx1bftga.fixedflag ? (_temp996_pw_gx1bftga=pw_gx1bftga,&_temp996_pw_gx1bftga) : &pw_gx1bftga, _pw_gx1bftgd.fixedflag ? (_temp997_pw_gx1bftgd=pw_gx1bftgd,&_temp997_pw_gx1bftgd) : &pw_gx1bftgd,
                 TYPSPIN, area_gxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx_xyz) == FAILURE )
    {
        epic_error(use_ermes, "%s call failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1:gx1btg");
    }

    if( optramp(_pw_gxw1ftga.fixedflag ? (_temp998_pw_gxw1ftga=pw_gxw1ftga,&_temp998_pw_gxw1ftga) : &pw_gxw1ftga, a_gxw1ftg, ftg_tx,
                ftg_xrt, TYPDEF) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxw1ftga.");
        return FAILURE;
    }    
    
    pw_gxw1ftgd  = _pw_gxw1ftgd.fixedflag ?  ((void)(pw_gxw1ftga), pw_gxw1ftgd) : pw_gxw1ftga;
 
    area_postgxw1ftg = ( 3.0 * a_gxw1ftg * (float)(pw_gxw1ftg)
                         - 0.5 * a_gxw1ftg * (pw_gxw1ftga + pw_gxw1ftgd) );
    if( amppwgx1(_a_postgxw1ftg.fixedflag ? (_temp999_a_postgxw1ftg=a_postgxw1ftg,&_temp999_a_postgxw1ftg) : &a_postgxw1ftg, _pw_postgxw1ftg.fixedflag ? (_temp1000_pw_postgxw1ftg=pw_postgxw1ftg,&_temp1000_pw_postgxw1ftg) : &pw_postgxw1ftg, _pw_postgxw1ftga.fixedflag ? (_temp1001_pw_postgxw1ftga=pw_postgxw1ftga,&_temp1001_pw_postgxw1ftga) : &pw_postgxw1ftga,
                 _pw_postgxw1ftgd.fixedflag ? (_temp1002_pw_postgxw1ftgd=pw_postgxw1ftgd,&_temp1002_pw_postgxw1ftgd) : &pw_postgxw1ftgd, TYPSPIN, area_postgxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for postgxw1ftg.");
        return FAILURE;
    }
    
    if( ampfov(_a_gxw2ftg.fixedflag ? (_temp1003_a_gxw2ftg=a_gxw2ftg,&_temp1003_a_gxw2ftg) : &a_gxw2ftg, echo1ftg_filt.bw, FTGfov) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxw2ftg.");
        return FAILURE;
    }
    
    pw_gxw2ftg  = _pw_gxw2ftg.fixedflag ?  ((void)(RUP_GRD((int)(4.0*(float)pw_gxw1ftg))), pw_gxw2ftg) : RUP_GRD((int)(4.0*(float)pw_gxw1ftg));
    if( optramp(_pw_gxw2ftga.fixedflag ? (_temp1004_pw_gxw2ftga=pw_gxw2ftga,&_temp1004_pw_gxw2ftga) : &pw_gxw2ftga, a_gxw2ftg, ftg_tx,
                ftg_xrt, TYPDEF) == FAILURE )
    { 
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxw2ftga.");
 
        return FAILURE;
    }
    
    pw_gxw2ftgd  = _pw_gxw2ftgd.fixedflag ?  ((void)(pw_gxw2ftga), pw_gxw2ftgd) : pw_gxw2ftga;
 
    /* We want S1 to refocus tau1 ms after rf3.  The gx2tg refocusing
       pulse accomplishes this.  gxw2tg pulse can't start before the
       end of the gz3tg refocussing pulse (why bother collecting
       corrupt data? ). */
    area_gx1ftg = a_gx1ftg * (0.5 * (float)(pw_gx1ftga + pw_gx1ftgd) + pw_gx1ftg);
 
    /* Starting readout window position relative to center of rf3 */
    PosReadoutWindow = ( pw_rf3ftg/2 + pw_gzrf3ftgd + pw_gz3ftga
                         + pw_gz3ftg + pw_gz3ftgd );
 
    pw_gxw2ftgleft  = _pw_gxw2ftgleft.fixedflag ?  ((void)(RUP_GRD(echo1ftg_filt.tdaq/8)), pw_gxw2ftgleft) : RUP_GRD(echo1ftg_filt.tdaq/8);   /* 1/8th of readout window to left of S1 */

    area_gx2ftg = area_gx1ftg - a_gxw2ftg * (float)(pw_gxw2ftga/ 2 + pw_gxw2ftgleft);
 
    if( amppwgrad(area_gx2ftg, ftg_tx_xz,
                  0.0, 0.0, ftg_xrt,
                  MIN_PLATEAU_TIME, _a_gx2ftg.fixedflag ? (_temp1005_a_gx2ftg=a_gx2ftg,&_temp1005_a_gx2ftg) : &a_gx2ftg, _pw_gx2ftga.fixedflag ? (_temp1006_pw_gx2ftga=pw_gx2ftga,&_temp1006_pw_gx2ftga) : &pw_gx2ftga,
                  _pw_gx2ftg.fixedflag ? (_temp1007_pw_gx2ftg=pw_gx2ftg,&_temp1007_pw_gx2ftg) : &pw_gx2ftg, _pw_gx2ftgd.fixedflag ? (_temp1008_pw_gx2ftgd=pw_gx2ftgd,&_temp1008_pw_gx2ftgd) : &pw_gx2ftgd) == FAILURE ) {
        epic_error(use_ermes, "%s failed in fasttg.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gx2ftg");
        return FAILURE;
    }
   
    if( (pw_rf3ftg/2+pw_gx2ftga+pw_gx2ftg+pw_gx2ftgd+pw_gxw2ftga+pw_gxw2ftgleft
         > FTGtau1) || (pw_rf3ftg/2+pw_gzrf3ftgd+pw_gz3ftga+pw_gz3ftg+pw_gz3ftgd+pw_gxw2ftga+pw_gxw2ftgleft > FTGtau1) )
    {
        /* return FAILURE; */
    }
    
    /* HCSDM00161809: calculate minimum FTGtau1 */
    FTGtau1check1 = RUP_GRD(pw_rf1ftg/2+pw_gx1ftga+pw_gx1ftg+pw_gx1ftgd+pw_rf2ftg/2);
    FTGtau1check2 = RUP_GRD(pw_rf1ftg/2+pw_gzrf1ftgd+pw_gz1ftga+pw_gz1ftg+pw_gz1ftgd+pw_gzrf2ftga+pw_rf2ftg/2);
    FTGtau1check3 = RUP_GRD(pw_rf2ftg/2+pw_gx1bftga+pw_gx1bftg+pw_gx1bftgd+pw_gxw1ftga+pw_gxw1ftg/2);
    FTGtau1check4 = RUP_GRD(pw_rf2ftg/2+pw_gzrf2ftgd+pw_gz2ftga+pw_gz2ftg+pw_gz2ftgd+pw_gxw1ftga+pw_gxw1ftg/2);
    FTGtau1check5 = RUP_GRD(pw_rf3ftg/2+pw_gx2ftga+pw_gx2ftg+pw_gx2ftgd+pw_gxw2ftga+pw_gxw2ftgleft);
    FTGtau1check6 = RUP_GRD(pw_rf3ftg/2+pw_gzrf3ftgd+pw_gz3ftga+pw_gz3ftg+pw_gz3ftgd+pw_gxw2ftga+pw_gxw2ftgleft);

    temp_FTGtau1 = IMax(7, FTGtau1, FTGtau1check1, FTGtau1check2, FTGtau1check3, FTGtau1check4, FTGtau1check5, FTGtau1check6);

    cvoverride(FTGtau1, temp_FTGtau1, PSD_FIX_OFF, PSD_EXIST_ON);

    if( !existcv(FTGtau2) )
    {
        FTGtau2  = _FTGtau2.fixedflag ?  ((void)(exist(FTGtau1)*exist(FTGau)), FTGtau2) : exist(FTGtau1)*exist(FTGau); 
    }

    flip_rf1ftg  = _flip_rf1ftg.fixedflag ?   ((void)(90.0), flip_rf1ftg) : 90.0;
    flip_rf2ftg  = _flip_rf2ftg.fixedflag ?  ((void)(180.0), flip_rf2ftg) : 180.0;
    flip_rf3ftg  = _flip_rf3ftg.fixedflag ?  ((void)(180.0), flip_rf3ftg) : 180.0;
    
    strcpy(entry_point_table[L_FTG].epname, "fasttg");
 
    return SUCCESS;
}   /* end FTGcveval() */


/*
 *  XTGcveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGcveval( void )
{
    INT bw_rf1xtg;
    INT bw_rf2xtg;
    FLOAT area_g1xtg;
    FLOAT area_gxw1xtg;
    INT ta_180, tb_180;
    FLOAT area_gxw1rampxtg;
    INT xtg_xrt, xtg_yrt;
    FLOAT xtg_tx;
    FLOAT xtg_tx_xz;
    FLOAT xtg_tz_xz;
    FLOAT xtg_tx_xyz, xtg_ty_xyz, xtg_tz_xyz;
    FLOAT xtg_temp_float;
    INT temp_max_pw;

    XTGfov  = _XTGfov.fixedflag ?    ((void)(FMin(2,480.0,cfsystemmaxfov)), XTGfov) : FMin(2,480.0,cfsystemmaxfov);

    if(0 == getAps1Mod())
    {
        XTGfov  = _XTGfov.fixedflag ?    ((void)(FMin(2,opfov,XTGfov)), XTGfov) : FMin(2,opfov,XTGfov);
        XTGfov  = _XTGfov.fixedflag ?    ((void)(FMax(2,XTGfov,50.0)), XTGfov) : FMax(2,XTGfov,50.0);
    }

    xtg_xrt = (TGspf ? ps1loggrd.yrt : ps1loggrd.xrt);
    xtg_yrt = (TGspf ? ps1loggrd.xrt : ps1loggrd.yrt);
    xtg_tx = (TGspf ? ps1loggrd.ty : ps1loggrd.tx);
    xtg_tx_xz = (TGspf ? ps1loggrd.ty_yz : ps1loggrd.tx_xz);
    xtg_tz_xz = (TGspf ? ps1loggrd.tz_yz : ps1loggrd.tz_xz);
    xtg_tz_xyz = ps1loggrd.tz_xyz;
    xtg_tx_xyz = (TGspf ? ps1loggrd.ty_xyz : ps1loggrd.tx_xyz);
    xtg_ty_xyz = (TGspf ? ps1loggrd.tx_xyz : ps1loggrd.ty_xyz);

    XTGopslthick  = _XTGopslthick.fixedflag ?  ((void)(10.0), XTGopslthick) : 10.0;

    gscale_rf1xtg   = _gscale_rf1xtg.fixedflag ?  ((void)(0.90909), gscale_rf1xtg) : 0.90909;
    gscale_rf2xtg   = _gscale_rf2xtg.fixedflag ?  ((void)(gscale_rf1xtg), gscale_rf2xtg) : gscale_rf1xtg;
    pw_gzrf1xtg  = _pw_gzrf1xtg.fixedflag ?  ((void)(pw_rf1xtg), pw_gzrf1xtg) : pw_rf1xtg;
    pw_gzrf2xtg  = _pw_gzrf2xtg.fixedflag ?  ((void)(pw_rf2xtg), pw_gzrf2xtg) : pw_rf2xtg;

    XTGecho1bw  = _XTGecho1bw.fixedflag ?  ((void)(15.625), XTGecho1bw) : 15.625;

    bw_rf1xtg = 4 * cyc_rf1xtg/ ((FLOAT)pw_rf1xtg/ (FLOAT)1000000);

    if( ampslice(_a_gzrf1xtg.fixedflag ? (_temp1009_a_gzrf1xtg=a_gzrf1xtg,&_temp1009_a_gzrf1xtg) : &a_gzrf1xtg, bw_rf1xtg, XTGopslthick, gscale_rf1xtg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1xtg.");
        return FAILURE;
    }

    bw_rf2xtg = 4 * cyc_rf2xtg/ ((FLOAT)pw_rf2xtg/ (FLOAT)1000000);

    if( ampslice(_a_gzrf2xtg.fixedflag ? (_temp1010_a_gzrf2xtg=a_gzrf2xtg,&_temp1010_a_gzrf2xtg) : &a_gzrf2xtg, bw_rf2xtg, XTGopslthick, gscale_rf2xtg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf2xtg.");
        return FAILURE;
    }

    if( optramp(_pw_gzrf1xtga.fixedflag ? (_temp1011_pw_gzrf1xtga=pw_gzrf1xtga,&_temp1011_pw_gzrf1xtga) : &pw_gzrf1xtga, a_gzrf1xtg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1xtga.");
        return FAILURE;
    }    

    pw_gzrf1xtgd  = _pw_gzrf1xtgd.fixedflag ?  ((void)(pw_gzrf1xtga), pw_gzrf1xtgd) : pw_gzrf1xtga;
    
    if (optramp(_pw_gzrf2xtga.fixedflag ? (_temp1012_pw_gzrf2xtga=pw_gzrf2xtga,&_temp1012_pw_gzrf2xtga) : &pw_gzrf2xtga, a_gzrf2xtg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf2xtga.");
        return FAILURE;
    }    

    pw_gzrf2xtgd  = _pw_gzrf2xtgd.fixedflag ?  ((void)(pw_gzrf2xtga), pw_gzrf2xtgd) : pw_gzrf2xtga;

    /* Z CRUSHER CVs */ 
    area_g1xtg = (PSoff90 + pw_gzrf1xtg/2.0 + pw_gzrf1xtgd/2.0)*a_gzrf1xtg;
    area_xtgzkiller  = _area_xtgzkiller.fixedflag ?  ((void)(amp_killer*pw_killer+area_g1xtg), area_xtgzkiller) : amp_killer*pw_killer+area_g1xtg;
    if (amppwgrad(area_xtgzkiller, xtg_tz_xyz, 0.0, 0.0, ps1loggrd.zrt,
                  MIN_PLATEAU_TIME, _a_gz2xtg.fixedflag ? (_temp1013_a_gz2xtg=a_gz2xtg,&_temp1013_a_gz2xtg) : &a_gz2xtg, _pw_gz2xtga.fixedflag ? (_temp1014_pw_gz2xtga=pw_gz2xtga,&_temp1014_pw_gz2xtga) : &pw_gz2xtga,
                  _pw_gz2xtg.fixedflag ? (_temp1015_pw_gz2xtg=pw_gz2xtg,&_temp1015_pw_gz2xtg) : &pw_gz2xtg, _pw_gz2xtgd.fixedflag ? (_temp1016_pw_gz2xtgd=pw_gz2xtgd,&_temp1016_pw_gz2xtgd) : &pw_gz2xtgd) == FAILURE) {
        epic_error(use_ermes, "%s failed in XTGcveval.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "amppwgrad: gz2xtg"); 
        return FAILURE;
    }

    if (amppwgrad((area_xtgzkiller-area_g1xtg), xtg_tz_xyz, 0.0, 0.0, ps1loggrd.zrt,
                  MIN_PLATEAU_TIME, _a_gz1xtg.fixedflag ? (_temp1017_a_gz1xtg=a_gz1xtg,&_temp1017_a_gz1xtg) : &a_gz1xtg, _pw_gz1xtga.fixedflag ? (_temp1018_pw_gz1xtga=pw_gz1xtga,&_temp1018_pw_gz1xtga) : &pw_gz1xtga,
                  _pw_gz1xtg.fixedflag ? (_temp1019_pw_gz1xtg=pw_gz1xtg,&_temp1019_pw_gz1xtg) : &pw_gz1xtg, _pw_gz1xtgd.fixedflag ? (_temp1020_pw_gz1xtgd=pw_gz1xtgd,&_temp1020_pw_gz1xtgd) : &pw_gz1xtgd) == FAILURE) {
        epic_error(use_ermes, "%s failed in XTGcveval.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "amppwgrad: gz1xtg"); 
        return FAILURE;
    }

    /* use 16kHz, 256 xres */
    if( calcfilter( &echo1xtg_filt, XTGecho1bw, XTGxres, OVERWRITE_NONE)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"calcfilter for echo1xtg_filt");
        return FAILURE;
    }
    
    if (ampfov(&xtg_temp_float, echo1xtg_filt.bw, xtg_tx) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "xtg ampfov");
        return FAILURE;
    }

    xtg_temp_float = ceil(xtg_temp_float/ 10.0) * 10.0;
    if( xtg_temp_float > XTGfov )
    {
        XTGfov  = _XTGfov.fixedflag ?  ((void)(xtg_temp_float), XTGfov) : xtg_temp_float;
    }

    if( ampfov(_a_gxw1xtg.fixedflag ? (_temp1021_a_gxw1xtg=a_gxw1xtg,&_temp1021_a_gxw1xtg) : &a_gxw1xtg, echo1xtg_filt.bw, XTGfov) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxw1xtg.");
        return FAILURE;        
    }

    if( optramp(_pw_gxw1xtga.fixedflag ? (_temp1022_pw_gxw1xtga=pw_gxw1xtga,&_temp1022_pw_gxw1xtga) : &pw_gxw1xtga, a_gxw1xtg, xtg_tx,
                xtg_xrt, TYPDEF) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxw1xtga.");
        return FAILURE;
    }    

    pw_gxw1xtgd  = _pw_gxw1xtgd.fixedflag ?  ((void)(pw_gxw1xtga), pw_gxw1xtgd) : pw_gxw1xtga;
    
    pw_gxw1xtg  = _pw_gxw1xtg.fixedflag ?  ((void)(RUP_GRD((int)(echo1xtg_filt.tdaq))), pw_gxw1xtg) : RUP_GRD((int)(echo1xtg_filt.tdaq));
    
    area_gxw1xtg = a_gxw1xtg*(float)(pw_gxw1xtg);
    area_gxw1rampxtg = 0.5*a_gxw1xtg*(float)(pw_gxw1xtga);
    
    if( amppwgx1(_a_gx1bxtg.fixedflag ? (_temp1023_a_gx1bxtg=a_gx1bxtg,&_temp1023_a_gx1bxtg) : &a_gx1bxtg, _pw_gx1bxtg.fixedflag ? (_temp1024_pw_gx1bxtg=pw_gx1bxtg,&_temp1024_pw_gx1bxtg) : &pw_gx1bxtg, _pw_gx1bxtga.fixedflag ? (_temp1025_pw_gx1bxtga=pw_gx1bxtga,&_temp1025_pw_gx1bxtga) : &pw_gx1bxtga, _pw_gx1bxtgd.fixedflag ? (_temp1026_pw_gx1bxtgd=pw_gx1bxtgd,&_temp1026_pw_gx1bxtgd) : &pw_gx1bxtgd,
                 TYPSPIN, area_gxw1xtg, area_gxw1rampxtg,
                 10000, 1.0, MIN_PLATEAU_TIME, xtg_xrt, xtg_tx_xyz) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1bxtg.");
        return FAILURE;
    }
    a_gx1bxtg  = _a_gx1bxtg.fixedflag ?  ((void)(-a_gx1bxtg), a_gx1bxtg) : -a_gx1bxtg;

    /* Find Params for killer pulse */
    area_xtgykiller  = _area_xtgykiller.fixedflag ?  ((void)(amp_killer*pw_killer), area_xtgykiller) : amp_killer*pw_killer;
    if (amppwgrad(area_xtgykiller, xtg_ty_xyz, 0.0, 0.0, xtg_yrt,
                  MIN_PLATEAU_TIME, _a_gykxtgl.fixedflag ? (_temp1027_a_gykxtgl=a_gykxtgl,&_temp1027_a_gykxtgl) : &a_gykxtgl, _pw_gykxtgla.fixedflag ? (_temp1028_pw_gykxtgla=pw_gykxtgla,&_temp1028_pw_gykxtgla) : &pw_gykxtgla,
                  _pw_gykxtgl.fixedflag ? (_temp1029_pw_gykxtgl=pw_gykxtgl,&_temp1029_pw_gykxtgl) : &pw_gykxtgl, _pw_gykxtgld.fixedflag ? (_temp1030_pw_gykxtgld=pw_gykxtgld,&_temp1030_pw_gykxtgld) : &pw_gykxtgld) == FAILURE) {
        epic_error(use_ermes, "%s failed in xtg.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykxtgl");
        return FAILURE;
    }
    
    if (amppwgrad(area_xtgykiller, xtg_ty_xyz, 0.0, 0.0, xtg_yrt,
                  MIN_PLATEAU_TIME, _a_gykxtgr.fixedflag ? (_temp1031_a_gykxtgr=a_gykxtgr,&_temp1031_a_gykxtgr) : &a_gykxtgr, _pw_gykxtgra.fixedflag ? (_temp1032_pw_gykxtgra=pw_gykxtgra,&_temp1032_pw_gykxtgra) : &pw_gykxtgra,
                  _pw_gykxtgr.fixedflag ? (_temp1033_pw_gykxtgr=pw_gykxtgr,&_temp1033_pw_gykxtgr) : &pw_gykxtgr, _pw_gykxtgrd.fixedflag ? (_temp1034_pw_gykxtgrd=pw_gykxtgrd,&_temp1034_pw_gykxtgrd) : &pw_gykxtgrd) == FAILURE) {
        epic_error(use_ermes, "%s failed in xtg.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykxtgr");
        return FAILURE;
    }
    flip_rf1xtg  = _flip_rf1xtg.fixedflag ?   ((void)(90.0), flip_rf1xtg) : 90.0;
    flip_rf2xtg  = _flip_rf2xtg.fixedflag ?  ((void)(180.0), flip_rf2xtg) : 180.0;
    
    temp_max_pw = IMax(2,pw_gzrf1xtgd, pw_gykxtgla+pw_gykxtgl+pw_gykxtgld);
    ta_180 = pw_gzrf1xtg/2+pw_gz1xtga+pw_gz1xtg+pw_gz1xtgd+temp_max_pw+pw_rf3xtg+rfupd+pw_gzrf2xtga+pw_gzrf2xtg/2;
    
    temp_max_pw = IMax(2,(pw_gx1bxtga+pw_gx1bxtg+pw_gx1bxtgd+pw_gxw1xtga), pw_gykxtgra+pw_gykxtgr+pw_gykxtgrd);
    tb_180 = pw_gzrf2xtg/2+pw_gzrf2xtgd+pw_gz2xtga+pw_gz2xtg+pw_gz2xtgd+temp_max_pw+pw_rf4xtg+rfupd+pw_gxw1xtg/2;
    XTGtau1  = _XTGtau1.fixedflag ?    ((void)(RUP_GRD(IMax(2,ta_180,tb_180))), XTGtau1) : RUP_GRD(IMax(2,ta_180,tb_180)); 
    
    strcpy(entry_point_table[L_XTG].epname, "expresstg");
    
    return SUCCESS;
}   /* end XTGcveval() */


/*
 *  RGcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
RGcvinit( void )
{
    return SUCCESS;
}


/*
 *  RGcveval
 *
 *  Type: Public Function
 *
 *  Description:
 *
 */
STATUS
RGcveval( void )
{
    if (PSD_ON == rgfeature_enable) 
    { 
        cvmod( opuser39, RG_CAL_MODE_MEASURED, RG_CAL_MODE_HIGH_FIXED, RG_CAL_MODE_HIGH_FIXED, 
               "Receiver Gain (0:Prescan Measured, 1:Predefined)", 0, "" );

        if ( (PSD_2D == exist(opimode)) &&
             ((PSD_SE == exist(oppseq)) || (PSD_IR == exist(oppseq))) &&
             (exist(opptsize) == 4) &&
             (exist(opslthick) <= 10) ) 
        {
            opuser39  = _opuser39.fixedflag ?  ((void)(_opuser39.defval), opuser39) : _opuser39.defval;
            activate_reserved_usercv(39);

            if( existcv(opuser39) && (exist(opuser39) != _opuser39.minval) &&
                (exist(opuser39) != _opuser39.maxval) )
            {
                epic_error(use_ermes, "%s must be 0 or 1", EM_PSD_CV_0_OR_1,
                           EE_ARGS(1), STRING_ARG, "UserCV39");

                return FAILURE;
            }

            oprgcalmode  = _oprgcalmode.fixedflag ?  ((void)(exist(opuser39)), oprgcalmode) : exist(opuser39);
        }
        else 
        {
            opuser39  = _opuser39.fixedflag ?  ((void)(0), opuser39) : 0;
            deactivate_reserved_usercv(39);

            oprgcalmode  = _oprgcalmode.fixedflag ?  ((void)(RG_CAL_MODE_MEASURED), oprgcalmode) : RG_CAL_MODE_MEASURED;
        }
    } 
    else 
    {
        opuser39  = _opuser39.fixedflag ?  ((void)(0), opuser39) : 0;
        deactivate_reserved_usercv(39);

        oprgcalmode  = _oprgcalmode.fixedflag ?  ((void)(RG_CAL_MODE_MEASURED), oprgcalmode) : RG_CAL_MODE_MEASURED;
    }

    return SUCCESS;
}   /* end RGcveval() */


/*
 *  PSfilter
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSfilter( void )
{
    if (setfilter( &echo1cfl,PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_cfl_fid  = _filter_cfl_fid.fixedflag ?  ((void)(echo1cfl.fslot), filter_cfl_fid) : echo1cfl.fslot;

    if (setfilter( &echo1rcvn,PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_rcvn_fid  = _filter_rcvn_fid.fixedflag ?  ((void)(echo1rcvn.fslot), filter_rcvn_fid) : echo1rcvn.fslot;

    if (setfilter(&echo1cfh, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_cfh_fid  = _filter_cfh_fid.fixedflag ?  ((void)(echo1cfh.fslot), filter_cfh_fid) : echo1cfh.fslot;


    if (setfilter(&echo1mps1_filt, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1mps1  = _filter_echo1mps1.fixedflag ?  ((void)(echo1mps1_filt.fslot), filter_echo1mps1) : echo1mps1_filt.fslot;

    if (setfilter(&echo1ftg_filt, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1ftg   = _filter_echo1ftg.fixedflag ?  ((void)(echo1ftg_filt.fslot), filter_echo1ftg) : echo1ftg_filt.fslot; /* 11/24/94 YI */
    filter_echo2ftg  = _filter_echo2ftg.fixedflag ?   ((void)(filter_echo1ftg), filter_echo2ftg) : filter_echo1ftg;

    if (setfilter(&echo1xtg_filt, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1xtg   = _filter_echo1xtg.fixedflag ?  ((void)(echo1xtg_filt.fslot), filter_echo1xtg) : echo1xtg_filt.fslot;

    if (setfilter(&echo1as_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1as  = _filter_echo1as.fixedflag ?  ((void)(echo1as_filt.fslot), filter_echo1as) : echo1as_filt.fslot;

    return SUCCESS;
}   /* end PSfilter() */


/*
 *  PS1predownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1predownload( void )
{
    /* Set xmtaddAPS1 according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtaddAPS1 is too big.
       Add in coilatten, too. */
    xmtaddAPS1  = _xmtaddAPS1.fixedflag ?    ((void)(-200*log10(maxB1[L_APS1]/maxB1Seq)+getCoilAtten()), xmtaddAPS1) : -200*log10(maxB1[L_APS1]/maxB1Seq)+getCoilAtten();
    if (xmtaddAPS1 > cfdbmax)
    {
        ps1scale  = _ps1scale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddAPS1)/200.0)), ps1scale) : (float)pow(10.0,(cfdbmax-xmtaddAPS1)/200.0);
        xmtaddAPS1  = _xmtaddAPS1.fixedflag ?  ((void)(cfdbmax), xmtaddAPS1) : cfdbmax;
    }
    else
    {
        ps1scale  = _ps1scale.fixedflag ?  ((void)(1.0), ps1scale) : 1.0;
    }
  
    if( (B0_30000 == cffield) && (PSD_XRMW_COIL == cfgcoiltype) )
    {
        /* MRIhc57081: Limit TG to coil peak B1 on MR750w */
        calcTGLimit(_tgcap.fixedflag ? (_temp1035_tgcap=tgcap,&_temp1035_tgcap) : &tgcap, _tgwindow.fixedflag ? (_temp1036_tgwindow=tgwindow,&_temp1036_tgwindow) : &tgwindow, maxB1Seq, txCoilInfo[getTxIndex(coilInfo[0])]);
    }
    else
    {
        /* Otherwise use defaults */
        tgcap  = _tgcap.fixedflag ?  ((void)(_tgcap.defval), tgcap) : _tgcap.defval;
        tgwindow  = _tgwindow.fixedflag ?  ((void)(_tgwindow.defval), tgwindow) : _tgwindow.defval;
    }

    if (setScale(L_APS1, RF_FREE, rfpulse, maxB1[L_APS1], 
                 ps1scale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "setScale ps1");
        return FAILURE;
    }

    ia_rf1mps1  = _ia_rf1mps1.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_APS1_SLOT].amp)), ia_rf1mps1) : max_pg_iamp*(*rfpulse[RF1_APS1_SLOT].amp);
    ia_rf2mps1  = _ia_rf2mps1.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF2_APS1_SLOT].amp)), ia_rf2mps1) : max_pg_iamp*(*rfpulse[RF2_APS1_SLOT].amp);

    entry_point_table[L_APS1].epxmtadd = (short) rint((double)xmtaddAPS1);
    /* APS1 & MPS1 */
    strcpy(entry_point_table[L_APS1].epname,"aps1");
    entry_point_table[L_APS1].epfilter=(n8)filter_echo1mps1;

    /* MRIge75651 */
    if( powermon( &entry_point_table[L_APS1],
                  L_APS1,
                  (int)RF_FREE,
                  rfpulse,
                  ps1_tr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon ps1");
        return FAILURE;
    }

    {
        double pmfsrf[NUM_POWERMON_PORT];
        double pmfspw[NUM_POWERMON_PORT];
        double pmfsdc[NUM_POWERMON_PORT];

        /* Check for multiple Tx coils. This routine is optimized only
         * for single Tx coil. */ 
        if (1 != getNumTxCoils(coilInfo, opncoils))
        {
            epic_error( use_ermes,
                        "%s does not support more than one transmit coil",
                        EM_PSD_MULTI_TX_NOT_SUPPORTED, EE_ARGS(1), STRING_ARG,
                        "Prescan");
            return FAILURE;
        }
 
        if( cfpwrmontyp >= PMTYP_UPM ) 
        {
            if( SUCCESS != getActivePowerMonPeakLimits( pmfsrf, pmfspw,
                                                        pmfsdc, (int)cffield))
            {
                epic_error( use_ermes, "Support routine %s failed.",
                            EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                            STRING_ARG, "getActivePowerMonPeakLimits" );
                return FAILURE;
            }
        }
        else
        {
            int i = 0;
            for( i = 0; i < NUM_POWERMON_PORT; ++i )
            {
                pmfsrf[i] = PMFULL;
                pmfspw[i] = PMFULL;
                pmfsdc[i] = PMFULL;
            }
        }

        /* for APS1, set amp values to full scale */
        /* Use the first Tx coil */
        switch(activePowerMonChannel(txCoilInfo[getTxIndex(coilInfo[0])]))
        {
            case PMCH_HEAD:
                entry_point_table[L_APS1].epamph = pmfsrf[PMCH_HEAD];
                break;
            case PMCH_BODY:
                entry_point_table[L_APS1].epampb = pmfsrf[PMCH_BODY];
                break;
            case PMCH_SPECTRO:
                entry_point_table[L_APS1].epamps = pmfsrf[PMCH_SPECTRO];
                break;
        }
    }

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1037_min_seqgrad=min_seqgrad,&_temp1037_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqmps1, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    /* If aps1_mod set to 1 and NOT breast R or L coil, use volRec coil to set TG */
    if ( (1 == getAps1Mod()) && (PSD_OFF == ps1_rxcoil) )
    {
        if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
        {
            UpdateEntryTabRecCoil(&entry_point_table[L_APS1], 0);
        }
    }

    /* copy APS1 to MPS1 */
    entry_point_table[L_MPS1] = entry_point_table[L_APS1];

    strcpy(entry_point_table[L_MPS1].epname, "mps1");

    /* This is usually equal to the scan entry point.
       Make sure it is continuous for manual prescan */
    entry_point_table[L_MPS1].eppmtable.pmContinuousUpdate = 1;
    entry_point_table[L_MPS2].eppmtable.pmContinuousUpdate = 1;

    return SUCCESS;
}

/*
 *  CFLpredownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLpredownload( void )
{
    /* Sample time for cfl */
    pitsp1 = echo1cfl.tdaq/echo1cfl.outputs;

    xmtaddCFL  = _xmtaddCFL.fixedflag ?    ((void)(-200*log10(maxB1[L_CFL]/maxB1Seq)+getCoilAtten()), xmtaddCFL) : -200*log10(maxB1[L_CFL]/maxB1Seq)+getCoilAtten();
    if (xmtaddCFL > cfdbmax)
    {
        cflscale  = _cflscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddCFL)/200.0)), cflscale) : (float)pow(10.0,(cfdbmax-xmtaddCFL)/200.0);
        xmtaddCFL  = _xmtaddCFL.fixedflag ?  ((void)(cfdbmax), xmtaddCFL) : cfdbmax;
    }
    else
    {
        cflscale  = _cflscale.fixedflag ?  ((void)(1.0), cflscale) : 1.0;
    }

    if (setScale(L_CFL, RF_FREE, rfpulse, maxB1[L_CFL], 
                 cflscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale cfl");
        return FAILURE;
    }

    ia_rf1cfl  = _ia_rf1cfl.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_CFL_SLOT].amp)), ia_rf1cfl) : max_pg_iamp*(*rfpulse[RF1_CFL_SLOT].amp);

    entry_point_table[L_CFL].epxmtadd = (short) rint((double)xmtaddCFL);

    entry_point_table[L_CFL].epprexres = (s16)CFLxres; /* MRIhc54366 */

    strcpy(entry_point_table[L_CFL].epname,"cfl");
    entry_point_table[L_CFL].epfilter=(n8)filter_cfl_fid;
    
    /* MRIge75651 */
    if( powermon( &entry_point_table[L_CFL],
                  L_CFL,
                  (int)RF_FREE,
                  rfpulse,
                  cfl_tr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon cfl");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1038_min_seqgrad=min_seqgrad,&_temp1038_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqcfl, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    return SUCCESS;
}

/*
 *  RCVNpredownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNpredownload( void )
{
    entry_point_table[L_RCVN] = entry_point_table[L_MPS2];

    xmtaddRCVN  = _xmtaddRCVN.fixedflag ?  ((void)(xmtaddCFL), xmtaddRCVN) : xmtaddCFL;
    entry_point_table[L_RCVN].epxmtadd = (short) rint((double)xmtaddRCVN);

    strcpy(entry_point_table[L_RCVN].epname,"rcvn");
    
    entry_point_table[L_RCVN].epfilter  = (n8)filter_rcvn_fid;
    entry_point_table[L_RCVN].epprexres = rcvn_xres;

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1039_min_seqgrad=min_seqgrad,&_temp1039_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqrcvn, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    return SUCCESS;
}

/*
 *  CFHpredownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHpredownload( void )
{
    /* Sample time for cfh */
    pitsp2 = echo1cfh.tdaq/echo1cfh.outputs;

    xmtaddCFH  = _xmtaddCFH.fixedflag ?    ((void)(-200*log10(maxB1[L_CFH]/maxB1Seq)+getCoilAtten()), xmtaddCFH) : -200*log10(maxB1[L_CFH]/maxB1Seq)+getCoilAtten();
    if (xmtaddCFH > cfdbmax)
    {
        cfhscale  = _cfhscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddCFH)/200.0)), cfhscale) : (float)pow(10.0,(cfdbmax-xmtaddCFH)/200.0);
        xmtaddCFH  = _xmtaddCFH.fixedflag ?  ((void)(cfdbmax), xmtaddCFH) : cfdbmax;
    }
    else
    {
        cfhscale  = _cfhscale.fixedflag ?  ((void)(1.0), cfhscale) : 1.0;
    }

    if (setScale(L_CFH, RF_FREE, rfpulse, maxB1[L_CFH], 
                 cfhscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale cfh");
        return FAILURE;
    }

    ia_rf1cfh  = _ia_rf1cfh.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_CFH_SLOT].amp)), ia_rf1cfh) : max_pg_iamp*(*rfpulse[RF1_CFH_SLOT].amp);
    ia_rf2cfh  = _ia_rf2cfh.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF2_CFH_SLOT].amp)), ia_rf2cfh) : max_pg_iamp*(*rfpulse[RF2_CFH_SLOT].amp);
#ifdef PSD_CFH_CHEMSAT
    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        ia_rfcssatcfh  = _ia_rfcssatcfh.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RFCSSAT_CFH_SLOT].amp)), ia_rfcssatcfh) : max_pg_iamp*(*rfpulse[RFCSSAT_CFH_SLOT].amp);
    }
#endif
    if (PSD_ON == PSir)
    {
        ia_rf0cfh  = _ia_rf0cfh.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF0_CFH_SLOT].amp)), ia_rf0cfh) : max_pg_iamp*(*rfpulse[RF0_CFH_SLOT].amp);
    }

    cfh_rf1freq  = _cfh_rf1freq.fixedflag ?       
    ((void)((GAM*a_gzrf1cfh*PStloc/(10*TARDIS_FREQ_RES))), cfh_rf1freq) : (GAM*a_gzrf1cfh*PStloc/(10*TARDIS_FREQ_RES));
    /* factor 10 is because rsptloc is in mm */

    if( ( (opcoax != 0) && cfh_newmode ) || (presscfh != PRESSCFH_NONE) ) {
        if( presscfh_ctrl == PRESSCFH_SLICE || presscfh_ctrl == PRESSCFH_SLAB ) {
	    cfh_rf2freq  = _cfh_rf2freq.fixedflag ?          ((void)(GAM*presscfh_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES)), cfh_rf2freq) : GAM*presscfh_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES);
            cfh_rf3freq  = _cfh_rf3freq.fixedflag ?           ((void)(GAM*presscfh_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES)), cfh_rf3freq) : GAM*presscfh_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES);
	} else if(presscfh_ctrl == PRESSCFH_SHIMVOL){
	    cfh_rf2freq  = _cfh_rf2freq.fixedflag ?          ((void)(GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES)), cfh_rf2freq) : GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES);
            cfh_rf3freq  = _cfh_rf3freq.fixedflag ?           ((void)(GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES)), cfh_rf3freq) : GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES);
            if((presscfh != presscfh_ctrl) && presscfh_debug) {
                printf("\n  presscfh %d changes to presscfh_ctrl %d \n",presscfh, presscfh_ctrl);
                fflush(stdout);
            }
        } else {
            cfh_rf2freq  = _cfh_rf2freq.fixedflag ?              
    ((void)((GAM*(opspf?PSphasoff*a_gyrf2cfh:PSrloc*a_gxrf2cfh)/(10*TARDIS_FREQ_RES))), cfh_rf2freq) : (GAM*(opspf?PSphasoff*a_gyrf2cfh:PSrloc*a_gxrf2cfh)/(10*TARDIS_FREQ_RES));
        /* factor 10 is because rloc/phasoff is in mm */
    }
    } else {
        /* For non-coaxials (multi angle), center cfh_rf2freq and up the
           excitation region to 40 cm to cover lots of ground 
        */
        cfh_rf2freq  = _cfh_rf2freq.fixedflag ?  ((void)(0), cfh_rf2freq) : 0;
    }

    entry_point_table[L_CFH].epxmtadd = (short) rint((double)xmtaddCFH);
    strcpy(entry_point_table[L_CFH].epname,"cfh");
    entry_point_table[L_CFH].epfilter=(n8)filter_cfh_fid;
    entry_point_table[L_CFH].epprexres = (s16)echo1ptcfh; /* MRIhc08633 */
    
    /* MRIge75651 */
    if( powermon( &entry_point_table[L_CFH],
                  L_CFH,
                  (int)RF_FREE,
                  rfpulse,
                  cfh_tr) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon cfh");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1040_min_seqgrad=min_seqgrad,&_temp1040_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqcfh, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    switch (getTxCoilType())
    /* Only 0.5/0.2T will use. */ /* vmx 07/27/95 YO */
    {
        case TX_COIL_LOCAL:
            cfh_ec_position  = _cfh_ec_position.fixedflag ?   ((void)((10.0/256.0)), cfh_ec_position) : (10.0/256.0);
            break;
        default:
            cfh_ec_position  = _cfh_ec_position.fixedflag ?   ((void)((16.0/256.0)), cfh_ec_position) : (16.0/256.0);
            break;
    }

    return SUCCESS;
}

/*
 *  PSpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSpredownload( void )
{
    STATUS ps_status;
    INT i;
    INT j;
    INT index, vidx;
    
    /* Check for multiple Tx coils. This routine is optimized only for
     * single Tx coil. */
    if (1 != getNumTxCoils(coilInfo, opncoils))
    {
        epic_error( use_ermes,
                    "%s does not support more than one transmit coil",
                    EM_PSD_MULTI_TX_NOT_SUPPORTED, EE_ARGS(1), STRING_ARG,
                    "prescan");
        return FAILURE;
    }
    
    /***********************************************************************
     * Generic SECTION
     ***********************************************************************/

    if(PSD_ON == exist(oprtcgate)) {
        phys_record_flag  = _phys_record_flag.fixedflag ?  ((void)(PSD_ON), phys_record_flag) : PSD_ON; /* flag for rt data recording */
    } else {
        phys_record_flag  = _phys_record_flag.fixedflag ?  ((void)(PSD_OFF), phys_record_flag) : PSD_OFF;
    }

    /* go through entry point table and set frequency offset based on receiver */
    for( i = 0; i < ENTRY_POINT_MAX; i++ )
    {
        PSfreq_offset[i] = cfreceiveroffsetfreq;
    }

    pw_omegarf0cfh  = _pw_omegarf0cfh.fixedflag ?  ((void)(pw_rf0cfh), pw_omegarf0cfh) : pw_rf0cfh; /* adiabatic pulse */

    PSslice_ind  = _PSslice_ind.fixedflag ?  ((void)(PSslice_num), PSslice_ind) : PSslice_num;  /* MRIge90312 -- for smart prescan */

    PStloc  = _PStloc.fixedflag ?  ((void)(scan_info[PSslice_num].optloc), PStloc) : scan_info[PSslice_num].optloc;
    PSrloc  = _PSrloc.fixedflag ?  ((void)(scan_info[PSslice_num].oprloc), PSrloc) : scan_info[PSslice_num].oprloc;
    PSphasoff  = _PSphasoff.fixedflag ?  ((void)(scan_info[PSslice_num].opphasoff), PSphasoff) : scan_info[PSslice_num].opphasoff;

    /* begin aps1_mod changes (GE) */
    if ( 1 == getAps1Mod() )
    {
        cvunlock(PStloc_mod);
        cvunlock(PSrloc_mod);
        PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(getAps1ModPsTloc()), PStloc_mod) : getAps1ModPsTloc();
        PSrloc_mod  = _PSrloc_mod.fixedflag ?  ((void)(getAps1ModPsRloc()), PSrloc_mod) : getAps1ModPsRloc();
    }
    else  /* use imaging locs */
    { 
        PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(PStloc), PStloc_mod) : PStloc;
        PSrloc_mod  = _PSrloc_mod.fixedflag ?      ((void)(opspf?PSphasoff:PSrloc), PSrloc_mod) : opspf?PSphasoff:PSrloc;    
    }
    /* end aps1_mod changes (GE) */

   /* Create rsp_psc_info table based on psc_info */
    for ( i=0; i < exist(oppscvquant); i ++) {
        rsp_psc_info[i].rsppsctloc = psc_info[i].oppsctloc;
        rsp_psc_info[i].rsppscrloc = psc_info[i].oppscrloc;
        rsp_psc_info[i].rsppscphasoff = psc_info[i].oppscphasoff;

        rsp_psc_info[i].rsppsclenx = psc_info[i].oppsclenx;
        rsp_psc_info[i].rsppscleny = psc_info[i].oppscleny;
        rsp_psc_info[i].rsppsclenz = psc_info[i].oppsclenz; 
    }

    /* Check the rotation matrix for rsp_psc_info */
    for (i=0; i< exist(oppscvquant); i++) {
        for (j=0; j<9; j++) {
            rsp_psc_info[i].rsppscrot[j] = hostToRspRotMat(psc_info[0].oppscrot[j]);
        }
    } 

    /* fill in the prescan rotation array for the prescan slice.
       PSrot is an ipgexport defined in epic.h  */

    /*
     * MRIge43971 BJM: loop over 2D PSrot array to be consistent with other
     *                 rotation matrices and since scalerotmats() expects a 2D
     *                 argument.
     */
    for (index = 0; index < 9; index++)
    {
        PSrot[0][index] = hostToRspRotMat(scan_info[PSslice_num].oprot[index]);
        PSrot_mod[0][index] = hostToRspRotMat(ps1scan_info[0].oprot[index]); 

        rsp_PSrot[0][index] = hostToRspRotMat(cfh_info[0].oprot[index]);

        /* set up rot for CFH */
        for( vidx = 0; vidx < oppscvquant; vidx++ )
        {
            rsp_PSrot[vidx][index] = hostToRspRotMat(cfh_info[vidx].oprot[index]);

        }
    }

    /* Scale Rot matrix for CFH */
    if(scalerotmats(rsp_PSrot, &cfhloggrd, &phygrd, IMax(2,1,exist(oppscvquant)), obl_debug) == FAILURE) /* YMSmr09211  04/26/2006 YI */
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }
    
    /* Scale Rot matrix for CFL */
    if(scalerotmats(PSrot, &loggrd, &phygrd, 1, obl_debug) == FAILURE)
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }

    /* Scale Rot matrix for ps1 & FTG */
    if(scalerotmats(PSrot_mod, &ps1loggrd, &phygrd, 1, obl_debug) == FAILURE) 
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }

    PStrigger  = _PStrigger.fixedflag ?  ((void)(TRIG_LINE), PStrigger) : TRIG_LINE;

    /* For Prescan: Inform 'Auto' Prescan about prescan parameters 	*/
    pitr = 2000000;	        /* 1st pass prescan TR 	*/
    pichop = 0;		/* No chop		*/

    /* find minimum rfamp te time based on duty cycle */
    min180te  = _min180te.fixedflag ?    
                                 
                                ((void)(RUP_GRD((int)((float)(pw_rf1mps1+cfrfminblank)/((TX_COIL_LOCAL==getTxCoilType())?cfrfmdch:cfrfmdcb)))*2), min180te) : RUP_GRD((int)((float)(pw_rf1mps1+cfrfminblank)/((TX_COIL_LOCAL==getTxCoilType())?cfrfmdch:cfrfmdcb)))*2;

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = PS1predownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "PS1predownload");
        return ps_status;
    }


    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFLpredownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFLpredownload");  /* MRIhc08595 */
        return ps_status;
    }

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFHpredownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFHpredownload");  /* MRIhc08595 */
        return ps_status;
    }

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = RCVNpredownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "RCVNpredownload");
        return ps_status;
    }

    /* xmtaddRef is used for calculating TG value to be stored in smart prescan DB wrt a
     * reference maxB1 used in TG entry point */
    xmtaddRef = -200*log10(cfmaxb1ref/100.0/maxB1Seq) + getCoilAtten();

    /* HCSDM00184619 : Tools PSD dont inline PSpreDwonload.
     * This should move to a routine which  psdIF can handle. */

    /* Copy coilInfo, volRecCoilInfo, txCoilInfo to target side */
    memcpy(coilInfo_tgt, coilInfo, sizeof(coilInfo));
    memcpy(volRecCoilInfo_tgt, volRecCoilInfo, sizeof(volRecCoilInfo));
    memcpy(txCoilInfo_tgt, txCoilInfo, sizeof(txCoilInfo));
    memcpy(cttEntry_tgt, cttEntry, sizeof(cttEntry)); 
    chksum_rampdir_tgt = chksum_rampdir;
    cframpdir_tgt = cframpdir;

    return SUCCESS;
}   /* end PSpredownload() */


/*
 *  FTGpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGpredownload( void )
{
    
    /* Set xmtaddFTG according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtaddFTG is too big.
       We are assuming that the pulse shapes used in CFH are the
       same as in scan. */
    xmtaddFTG  = _xmtaddFTG.fixedflag ?    ((void)(-200*log10(maxB1[L_FTG]/maxB1Seq)+getCoilAtten()), xmtaddFTG) : -200*log10(maxB1[L_FTG]/maxB1Seq)+getCoilAtten();
    if (xmtaddFTG > cfdbmax)
    {
        ftgscale  = _ftgscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddFTG)/200.0)), ftgscale) : (float)pow(10.0,(cfdbmax-xmtaddFTG)/200.0);
        xmtaddFTG  = _xmtaddFTG.fixedflag ?  ((void)(cfdbmax), xmtaddFTG) : cfdbmax;
    }
    else
    {
        ftgscale  = _ftgscale.fixedflag ?  ((void)(1.0), ftgscale) : 1.0;
    }

    if (setScale(L_FTG,RF_FREE,rfpulse,maxB1[L_FTG],ftgscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale ftg");
        return FAILURE;
    }
    
    /* Set the amplitude scale factors. */
    ia_rf1ftg  = _ia_rf1ftg.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_FTG_SLOT].amp)), ia_rf1ftg) : max_pg_iamp*(*rfpulse[RF1_FTG_SLOT].amp);
    ia_rf2ftg  = _ia_rf2ftg.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF2_FTG_SLOT].amp)), ia_rf2ftg) : max_pg_iamp*(*rfpulse[RF2_FTG_SLOT].amp);
    ia_rf3ftg  = _ia_rf3ftg.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF3_FTG_SLOT].amp)), ia_rf3ftg) : max_pg_iamp*(*rfpulse[RF3_FTG_SLOT].amp);
    
    entry_point_table[L_FTG].epxmtadd = (short)rint((double)xmtaddFTG);

    /* MRIge75651 */
    if( powermon( &entry_point_table[L_FTG],
                  L_FTG,
                  (int)RF_FREE,
                  rfpulse,
                  (int)exist(ftgtr) ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon ftg");
        return FAILURE;
    }
    xmtadd  = _xmtadd.fixedflag ?  ((void)(xmtaddFTG), xmtadd) : xmtaddFTG;

    entry_point_table[L_FTG].epfilter = (n8)filter_echo1ftg; /* 11/24/94 YI */
    entry_point_table[L_FTG].epprexres = 256;
    
    FTGxmtadd  = _FTGxmtadd.fixedflag ?  ((void)(entry_point_table[L_APS1].epxmtadd-entry_point_table[L_FTG].epxmtadd), FTGxmtadd) : entry_point_table[L_APS1].epxmtadd-entry_point_table[L_FTG].epxmtadd;

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1041_min_seqgrad=min_seqgrad,&_temp1041_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqftg, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    /* Use volRec coil for FTG */
    if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
    {
        UpdateEntryTabRecCoil(&entry_point_table[L_FTG], 0);
    } 

    return SUCCESS;
}   /* end FTGpredownload() */


/*
 *  XTGpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGpredownload( void )
{
    
    /* Set xmtaddXTG according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtaddXTG is too big. */
    xmtaddXTG  = _xmtaddXTG.fixedflag ?    ((void)(-200*log10(maxB1[L_XTG]/maxB1Seq)+getCoilAtten()), xmtaddXTG) : -200*log10(maxB1[L_XTG]/maxB1Seq)+getCoilAtten();
    if (xmtaddXTG > cfdbmax)
    {
        xtgscale  = _xtgscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddXTG)/200.0)), xtgscale) : (float)pow(10.0,(cfdbmax-xmtaddXTG)/200.0);
        xmtaddXTG  = _xmtaddXTG.fixedflag ?  ((void)(cfdbmax), xmtaddXTG) : cfdbmax;
    }
    else
    {
        xtgscale  = _xtgscale.fixedflag ?  ((void)(1.0), xtgscale) : 1.0;
    }

    if (setScale(L_XTG,RF_FREE,rfpulse,maxB1[L_XTG],xtgscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale xtg");
        return FAILURE;
    }
    
    /* Set the amplitude scale factors. */
    ia_rf1xtg  = _ia_rf1xtg.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_XTG_SLOT].amp)), ia_rf1xtg) : max_pg_iamp*(*rfpulse[RF1_XTG_SLOT].amp);
    ia_rf2xtg  = _ia_rf2xtg.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF2_XTG_SLOT].amp)), ia_rf2xtg) : max_pg_iamp*(*rfpulse[RF2_XTG_SLOT].amp);
    ia_rf4xtg  = _ia_rf4xtg.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF4_XTG_SLOT].amp)), ia_rf4xtg) : max_pg_iamp*(*rfpulse[RF4_XTG_SLOT].amp);
    ia_rf3xtg  = _ia_rf3xtg.fixedflag ?  ((void)(-ia_rf4xtg), ia_rf3xtg) : -ia_rf4xtg;
    a_rf3xtg   = _a_rf3xtg.fixedflag ?  ((void)(-a_rf4xtg), a_rf3xtg) : -a_rf4xtg;
    
    entry_point_table[L_XTG].epxmtadd = (short)rint((double)xmtaddXTG);

    /* MRIge75651 */
    if( powermon( &entry_point_table[L_XTG],
                  L_XTG,
                  (int)RF_FREE,
                  rfpulse,
                  (int)exist(xtgtr) ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon xtg");
        return FAILURE;
    }
    xmtadd  = _xmtadd.fixedflag ?  ((void)(xmtaddXTG), xmtadd) : xmtaddXTG;

    entry_point_table[L_XTG].epfilter = (n8)filter_echo1xtg; /* 11/24/94 YI */
    entry_point_table[L_XTG].epprexres = 256;

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1042_min_seqgrad=min_seqgrad,&_temp1042_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqxtg, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    if(PSD_ON == xtg_volRecCoil)
    {
        /* Use volRec coil for XTG */
        if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
        {
            UpdateEntryTabRecCoil(&entry_point_table[L_XTG], 0);
        } 
    }

    return SUCCESS;
}   /* end XTGpredownload() */


/*
 *  ASpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASpredownload( void )
{
    FLOAT asscale;
 
    /******************************************************************/
    /* Set xmtaddas according to maximum B1 and rescale for powermon, */
    /* adding additional (audio) scaling if xmtaddas is too big.      */
    /* We are assuming that the pulse shapes used in CFH are the      */
    /* same as in scan.                                               */
    /******************************************************************/

    strcpy(entry_point_table[L_AUTOSHIM].epname, "autoshim");

    xmtaddas  = _xmtaddas.fixedflag ?    ((void)(-200*log10(maxB1[L_AUTOSHIM]/maxB1Seq)+getCoilAtten()), xmtaddas) : -200*log10(maxB1[L_AUTOSHIM]/maxB1Seq)+getCoilAtten();
    if (xmtaddas > cfdbmax) 
    {
        asscale = (float) pow(10.0, (cfdbmax - xmtaddas)/200.0);
        xmtaddas  = _xmtaddas.fixedflag ?  ((void)(cfdbmax), xmtaddas) : cfdbmax;
    } 
    else
    {
        asscale = 1.0;
    }

    if (setScale(L_AUTOSHIM, RF_FREE, rfpulse, maxB1[L_AUTOSHIM],
                 asscale) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale autoshim");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rf1as  = _ia_rf1as.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_AUTOSHIM].amp)), ia_rf1as) : max_pg_iamp*(*rfpulse[RF1_AUTOSHIM].amp);

    entry_point_table[L_AUTOSHIM].epxmtadd=(short)rint((double)xmtaddas);
    
    /* MRIge75651 */
    if( powermon( &entry_point_table[L_AUTOSHIM],
                  L_AUTOSHIM,
                  (int)RF_FREE,
                  rfpulse,
                  (int)tr_as ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon autoshim");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1043_min_seqgrad=min_seqgrad,&_temp1043_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqaushim, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    entry_point_table[L_AUTOSHIM].epfilter = (n8)filter_echo1as;
    entry_point_table[L_AUTOSHIM].epprexres = asxres;
    
    /* Use volRec coil for autoshim */
    if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
    {
        UpdateEntryTabRecCoil(&entry_point_table[L_AUTOSHIM], 0);
    } 

    pidoshim = PSD_OFF;  /* MRIge92917 - initialize to OFF */
    if( pimrsapsflg == PSD_ON || exist(opepi) == PSD_ON 
        || exist(opspiral) == PSD_ON || oppseq == PSD_SSFP
        || exist(opvrg) == PSD_ON )
    {
        pidoshim = PSD_ON;
    }  /* Auto Shim is required for MRS, EPI, Spiral, VERSE and fiesta */

    if( exist(opfat) || exist(opfatcl)
        || exist(opspecir) || exist(opwater) )
    {
        pidoshim = PSD_ON;
    }  /* Auto Shim is required for Chem Sat scans */

    return SUCCESS;
}   /* end ASpredownload() */

/* CoilSwitchGetTR (MRIhc15304)
 * 
 * Description:
 *   This function returns the TR for the coilSwitch SSP sequence based on
 *   the setRcvPortFlag as passed to CoilSwitchSetCoil.
 *
 *  Parameters:
 *  (I: for input parameters, O: for output parameters)
 *  (O) return: TR in usec
 *  (I) setRcvPortFlag - flag to indicate that setrcvportimm will be
 *        executed when switching coils.  See CoilSwitchSetCoil
 */
int
CoilSwitchGetTR(const int setRcvPortFlag)
{
    int wait_rspimm = 0;
    
    /* When asynchronous RSP function calls are needed, the wait time is
     * extended to accomodate the worst case RSP time */
    if( COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod )
    {
        wait_rspimm = csw_wait_sethubindeximm;
    }

    if( setRcvPortFlag )
    {
        wait_rspimm = IMax(2, wait_rspimm, csw_wait_setrcvportimm);
    }

    return csw_tr + wait_rspimm;
}


/**************************************************************************/
/**************************************************************************/
#ifndef sys_psdiopt_h
#define sys_psdiopt_h
#include "psdiopt.h"
#endif
#ifndef _SYSCHECK_
#define _SYSCHECK_
STATUS syscheck(INT *p_syscheck_limit, int *p_status_flag)
{
    /* Variables to hold the minseq  values. These are local to syscheck*/
    INT syscheck_min_seqgrad = 0;
    INT syscheck_min_seqrfamp = 0; 

    /* Flag to turn on or off syscheck logging */
    int syschecklog_on = 0;

    /* The file pointer to enable or disable RF check with the help of a file*/
    FILE *fp_rfon;
    FILE *fp_syschecklog_on;

    int iopt_num=0;/* Imaging option Num*/

    char im_opt_name[128];/* Imaging option String*/
    char logValues[1024];

    INT seq_entry_index = 0;

    char path[128] = "/usr/g/service/log/";
    char filename[64] = "psd_syscheck_error.log";
    char macro_name[32];
    float tolerance_percentage = 0.0;
    const int TOLERANCE_LIMIT = 5;
    int syscheck_limit = 0;
    float syscheck_limit_tolerance = 0.0;
    int debug_syscheck;
    debug_syscheck = (getenv("DEBUG_SYSCHECK")!='\0');

if(debug_syscheck){
        printf(" Calling minseq from macro\n");
        fflush(stdout);
        }
    strcpy(macro_name,"SYSCHECK_MINSEQ_PGOH");
    if (FAILURE == minseq(&syscheck_min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, seq_entry_index, tsamp,
                                avail_image_time,
                                use_ermes, seg_debug ) )
             {
        log_error(path,filename,1,"%s %d %d  %d","Minseq failed in syscheck",__FILE__,__LINE__,EM_PSD_SUPPORT_FAILURE);
        if(debug_syscheck){
            printf(" Minseq failed in syscheck \n");
            fflush(stdout);
        }
        *p_status_flag=1;
    }
    else
    {
        if(debug_syscheck){
            printf("minseq completed successfully with values\n syscheck_min_seqgrad : %d\n",syscheck_min_seqgrad);
            fflush(stdout);
        }
    }
    /****** To include Rf calculation based on the choice made ****/

    fp_rfon = fopen("/usr/g/bin/.RFCHECKON","r");
    if(fp_rfon !=NULL)
    {
       if(debug_syscheck){
           printf("Calling minseqrfamp from macro\n");
           fflush(stdout);
       }
       if(minseqrfamp(&syscheck_min_seqrfamp,(int)RF_FREE,rfpulse,L_SCAN) == FAILURE)
         {
             log_error(path,filename,1,"%s \n file:%s line:%d Error no:%d","Minseqrfamp failed in syscheck",__FILE__,__LINE__,EM_PSD_SUPPORT_FAILURE);
             if(debug_syscheck){
                 printf(" Minseqrfamp failed in syscheck\n");
                 fflush(stdout);
             }
             *p_status_flag= 1;
         }
         else
         {
            if(debug_syscheck){
                printf("Completed minseqrfamp successfully with syscheck_min_seqrfamp %d\n",syscheck_min_seqrfamp);
                fflush(stdout);
            }
        }
    }

    /** to check for the environment variable whether logging has to be done or not ***/

    fp_syschecklog_on = fopen("/usr/g/bin/.SYSCHECKLOGON","r");
    syschecklog_on =((getenv("SYSCHECKLOGON")!='\0') || (fp_syschecklog_on!=NULL));
    /*** if RF check is on include the min_seqrfamp for syscheck_safety_limit and for comparison with optr ***/

        if(fp_rfon !=NULL)
        {
            if(debug_syscheck){
                printf("\nRF included");
                fflush(stdout);
            }
            syscheck_limit = IMax(2,syscheck_min_seqgrad,syscheck_min_seqrfamp);
        }
        else
        {
           if(debug_syscheck){
               printf("\nRf calculation not included");
               fflush(stdout);
           }
           syscheck_limit = syscheck_min_seqgrad;
        }
        /*** Calculate the tolerance percentage to allow a maximum of 5% tolerance before comparision***/
        tolerance_percentage = 1-(TOLERANCE_LIMIT * 0.01);
        if(psd_tol_value!=0){
            if((((oppseq == PSD_GE) || (oppseq == PSD_SPGR) || (oppseq == PSD_TOF) || (oppseq == PSD_TOFSP) || (oppseq == PSD_SSFP)) &&
                (opfast == PSD_ON) && (opimode == PSD_3D) && ((opirprep == PSD_ON) || ((opgirmode == PSD_GIRMANUAL) && (opnumgir > 0)))) ||
               (((oppseq == PSD_GE) || (oppseq == PSD_SPGR)) && (opimode == PSD_2D) && (oprealtime == PSD_ON) && (opfast == PSD_ON))){
                if(debug_syscheck){
                    printf("Special case for syscheck considered");
                    printf(" VALUE OF PSD_TOL_VALUE = %d",psd_tol_value);
                    fflush(stdout);
                }
            }
            else{
                if(debug_syscheck){
                    printf("Not allowing a tolerance.Not a  special cases");
                }
                cvoverride(psd_tol_value,0,PSD_FIX_ON,PSD_EXIST_ON);
           }
        }
        syscheck_limit_tolerance = (syscheck_limit * tolerance_percentage) - psd_tol_value;
        *p_syscheck_limit = (int)(syscheck_limit_tolerance);
        /*** Compare the optr with the minseq values if found less than max of minseq values,log an error ***/
        /*** MRIhc37381: Bypass the optr check for Phase Contrast to avoid the download failure ***/
        /*** MRIhc42193: remove the code added by MRIhc37381, enable syscheck for Phase Contrast ***/
        if( (exist(optr)) < (*p_syscheck_limit) || (optr) < (*p_syscheck_limit ) )
        {
            log_error(path,filename,1,"%s \nfile:%s line:%d","ERROR : PSD SAFETY CHECK ERROR!!! ILLEGAL OPTR DETECTED IN SYSCHECK!!!",__FILE__,__LINE__);
            *p_status_flag = 2;
            if(debug_syscheck){
                printf("Illegal optr  value found %d\n",exist(optr));
                fflush(stdout);
            }
        }
        else
        {
            /**** Log a positive message for no error case *****/
            log_error(path,filename,1,"%s", "SAFETY CHECK RAN SUCCESSFULLY!OPTR VALUES FOUND SAFE!");
            *p_status_flag = 0;
        }
        if(((*p_status_flag ==0) && (syschecklog_on)) || (*p_status_flag ==2))
        {
            sprintf(logValues,"\noptr : %d\ntmin : %d\t\ttmin_total : %d\nmin_seqgrad : %d\tsyscheck_min_seqgrad : %d\nsyscheck_safety_limit : %d",exist(optr),tmin,tmin_total,min_seqgrad,syscheck_min_seqgrad,*p_syscheck_limit);
            log_error(path,filename,0,"%s %s","Values found:",logValues);
            if(fp_rfon!=NULL)
            {
                sprintf(logValues,"min_seqrfamp : %d\t syscheck_min_seqrfamp : %d\n",min_seqrfamp,syscheck_min_seqrfamp);
                log_error(path,filename,0,"%s",logValues);
            }
        }
            /************** Log the PSD name & IOPT selected *****/
            log_error(path,filename,0,"%s %s ","PSD:",psd_name);
            for(iopt_num = 0;iopt_num < PSD_NUM_IOPTS; iopt_num++){
                if(is_iopt_selected(iopt_num)){
                return_iopt_name(iopt_num,im_opt_name);
                log_error(path,filename,0,"%s %s","Imaging Option :",im_opt_name);
            }
        }

    log_error(path,filename,0,"%s",macro_name);
    if((*p_status_flag) != 0)
    {
        return FAILURE;
    }
    else
    {
        return SUCCESS;
    }
}
#endif
/***************************************************************/

/*********************************************************************
 *                       EPI.E PULSEGEN SECTION                      *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/

/* MRIge55206 - change memory allocation if in SIM for multi-dim array support */
#ifdef SIM
#include <stdlib.h>
#define AllocMem malloc
#else
#define AllocMem AllocNode
#endif
                                          

/* BJM: SE Ref Scan */
STATUS setreadpolarity_ref( void );

/* Declaration of new function for ref scan */

int tot_etl; /* internref */
                                           
long rsprot_orig[DATA_ACQ_MAX][9]; /* rotation matrix for SAT */
extern PSD_EXIT_ARG psdexitarg;
short *acq_ptr;               /* first slice in a pass */
int   *ctlend_tab;            /* table of cardiac deadtimes */
short *slc_in_acq;            /* number of slices in each pass */
/* Frequency/Phase offsets */
int   *rf1_freq;
int   *theta_freq;
int   *rf2_freq;
int   ***recv_freq;
int   ***recv_phase;
double ***recv_phase_angle;
int   **rf_phase_spgr;
WF_PULSE **echotrainxtr;
WF_PULSE **echotrainrba;
int *echotrainramp;
int *echotrainramp1;
int *echotrainramp2;
short **echotrainrampamp;
short **echotrainrampamp1;
short **echotrainrampamp2;

WF_PULSE_ADDR rtb0echoxtr;

/* The following arrays are indexed by intleave: */
int *gy1f;      /* amplitude of gy1f pulse */
int *gymn;      /* amplitude of y gradient moment nulling pulses */
int *view1st;   /* 1st view to acquire */
int *viewskip;  /* number of views to skip */
int *tf;        /* time factor shift */
int *rfpol;     /* rf polarity */
int *blippol;   /* blip gradient polarity */
int *gradpol;   /* readout gradient polarity */
float *b0ditherval;/* B0 dither value, per slice basis */
float *delayval;   /* delay values, per slice basis */
int *gldelaycval;  /* per slice gldelayc valuse */
float *gldelayfval; /* per slice gldelayf values */
int defaultdelay = 0; /* default delay */
int mintf;         /* most negative tfon value, for echo train positioning */
int sp_satindex, cs_satindex;  /* index for multiple calls to spsat
                                  and chemsat routines */
int rcvrunblankpos;

/*jwg bb for reading external waveform*/
char rf1froot[80]; 
char rf1_datfile[80]; 
/*jwg end*/

WF_PULSE gx1a = INITPULSE;
WF_PULSE gx1 = INITPULSE;
WF_PULSE gx1d = INITPULSE;

WF_PULSE rho_killer = INITPULSE;

WF_PULSE rs_omega_attack = INITPULSE;
WF_PULSE rs_omega_decay = INITPULSE;
WF_PULSE omega_flat = INITPULSE;

/* Define some more MRE variables */
WF_PULSE touch_gx_meg = INITPULSE;
WF_PULSE touch_gy_meg = INITPULSE;
WF_PULSE touch_gz_meg = INITPULSE;

long scan_deadtime;          /* deadtime in scan entry point */
long *scan_deadtime_correct; /* deadtime for each slice after correction*/ 
long prescan_trigger;        /* save the prescan slice's trigger */
long rsptrigger_temp[1];     /* temp trigger array for pass packets 
                                sequences and other misc */
/* Original scan info */
RSP_INFO orig_rsp_info[DATA_ACQ_MAX];
long origrot[DATA_ACQ_MAX][9];
WF_INSTR_HDR *instrtemp;

/* Frequency offsets */
int *rf0_freq;
int *rf0_pha;
long ir_deadtime;     /* dead time for IR pulses */


/* BJM: SE Ref Scan */    

/* 90 Degree Pulse + Gradient */
WF_PULSE gzrf1refa = INITPULSE;
WF_PULSE gzrf1ref  = INITPULSE;
WF_PULSE gzrf1refd = INITPULSE;
WF_PULSE rf1ref = INITPULSE;
WF_PULSE thetarf1ref  = INITPULSE;

/* 180 Degree Pulse Pulse Slice-Select */
WF_PULSE gzrf2refa = INITPULSE;
WF_PULSE gzrf2ref  = INITPULSE;
WF_PULSE gzrf2refd = INITPULSE;
WF_PULSE rf2ref = INITPULSE;
WF_PULSE rf2se1b4_ref = INITPULSE;

/* Crushers Left (l1) and Right (r1) */
WF_PULSE gzrf2refl1a = INITPULSE;
WF_PULSE gzrf2refl1 = INITPULSE;
WF_PULSE gzrf2refl1d = INITPULSE;

WF_PULSE gzrf2refr1a = INITPULSE;
WF_PULSE gzrf2refr1 = INITPULSE;
WF_PULSE gzrf2refr1d = INITPULSE;

/* Ky Prephaser Pulse */
WF_PULSE refgy1a = INITPULSE;
WF_PULSE refgy1 = INITPULSE;
WF_PULSE refgy1d = INITPULSE;

/* Kx Prephaser Pulse */
WF_PULSE refgx1a = INITPULSE;
WF_PULSE refgx1 = INITPULSE;
WF_PULSE refgx1d = INITPULSE;

/* Killer Pulse on X */
WF_PULSE refgxka = INITPULSE;
WF_PULSE refgxk = INITPULSE;
WF_PULSE refgxkd = INITPULSE;

/* Killer Pulse on Y */
WF_PULSE refgyka = INITPULSE;
WF_PULSE refgyk = INITPULSE;
WF_PULSE refgykd = INITPULSE;

/* Killer Pulse on Z */
WF_PULSE refgzka = INITPULSE;
WF_PULSE refgzk = INITPULSE;
WF_PULSE refgzkd = INITPULSE;

WF_PULSE wgxref = INITPULSE;

WF_PULSE wgyref = INITPULSE;

WF_PULSE wgzref = INITPULSE;

WF_PULSE wsspref = INITPULSE;

WF_PULSE sspdelayref = INITPULSE;

WF_PULSE omegadelayref = INITPULSE;

WF_PULSE womegaref = INITPULSE;

WF_PULSE e1entnsref = INITPULSE;
short e1entnsref_pack[4] = {0,SSPOC+DREG,SSPD+DCBL,SSPDS};

WF_PULSE e1distnsref = INITPULSE;
short e1distnsref_pack[4] = {0,SSPOC+DREG,SSPD,SSPDS};

WF_PULSE sspshiftref = INITPULSE;
WF_PULSE ssp_pass_delayref = INITPULSE;


WF_PULSE rho_killerref = INITPULSE;

WF_PULSE rs_omega_attackref = INITPULSE;
WF_PULSE rs_omega_decayref = INITPULSE;
WF_PULSE omega_flatref = INITPULSE;

WF_PULSE_ADDR rf2ssp_end;

WF_PULSE **echotrainxtr_ref;
WF_PULSE **echotrainrba_ref;


/***************************** setreadpolarity *************************/
STATUS setreadpolarity_ref( void )
{
    int polarity;

    if (iref_etl%2 == 1) {
        polarity = -1;
    }
    else {
        polarity = 1;
    }

    tia_gx1  = _tia_gx1.fixedflag ?  ((void)(polarity*gradpol[ileave]*ia_gx1), tia_gx1) : polarity*gradpol[ileave]*ia_gx1;  /* temporary x dephaser amp */
    tia_gxw  = _tia_gxw.fixedflag ?  ((void)(polarity*gradpol[ileave]*ia_gxw), tia_gxw) : polarity*gradpol[ileave]*ia_gxw;  /* temporary x readout amp  */
    tia_gxk  = _tia_gxk.fixedflag ?  ((void)(polarity*gradpol[ileave]*ia_gxk), tia_gxk) : polarity*gradpol[ileave]*ia_gxk;  /* temporary x killer amp   */
    setiamp(tia_gx1, &refgx1a, 0);        /* x dephaser attack */
    setiamp(tia_gx1, &refgx1, 0);         /* x dephaser middle */
    setiamp(tia_gx1, &refgx1d, 0);        /* x dephaser decay  */
    setiamp(tia_gxw, &refgxw, 0);

    /* Ramps are handled with opposite sign because of the way they
       are defined in the EP_TRAIN_NAME macro.  Please refer to epic.h
       for more details. */

    for (echo=1; echo < tot_etl; echo++) {
        if ((echo % 2) == 1) {  /* Even echo within interleave */ 
            setiamp(-tia_gxw, &refgxwa, echo-1); /* waveforms go neg to pos in ep_train */
            setiamp(-tia_gxw, &refgxwd, echo-1);
            setiamp(-tia_gxw, &refgxw, echo);    /* const   */
        } else {                    /* Odd echo within interleave */
            setiamp(tia_gxw, &refgxwa, echo-1); /* waveforms go neg to pos in ep_train */
            setiamp(tia_gxw, &refgxwd, echo-1);
            setiamp(tia_gxw, &refgxw, echo);     /* flattop   */
        }
    }


    if ((tot_etl % 2) == 1) {

        setiamp(-tia_gxw,&refgxwde, 0);  /* decay,end */

        if (eosxkiller == 1) {
            setiamp(-tia_gxk,&refgxka, 0);   /* killer attack */
            setiamp(-tia_gxk,&refgxk, 0);    /* killer flattop */
            setiamp(-tia_gxk,&refgxkd, 0);   /* killer decay  */
        }

    } else {

        setiamp(tia_gxw,&refgxwde, 0);   /* decay,end */

        if (eosxkiller == 1) {
            setiamp(tia_gxk,&refgxka, 0);    /* killer attack */
            setiamp(tia_gxk,&refgxk, 0);     /* killer flattop */
            setiamp(tia_gxk,&refgxkd, 0);    /* killer decay  */
        }
    }

    return SUCCESS;

} /* end setreadpolarity_ref() */


/**** END of refScan.e File ****/

void
#ifdef __STDC__ 
dummyssi( void )
#else /* !__STDC__ */
    dummyssi() 
#endif /* __STDC__ */
{
    return;
}

/* Added for Inversion.e */
STATUS
#ifdef __STDC__
setupphases ( INT *phase,
              INT *freq,
              INT slice,
              FLOAT rel_phase,
              INT time_delay )
#else /* !__STDC__ */
    setupphases( phase, freq, slice, rel_phase, time_delay )
    INT *phase;                /* output phase offsets */
    INT *freq;                 /* precomputed frequency offsets */
    INT slice;                 /* slice number */
    FLOAT rel_phase;           /* in cycles */
    INT time_delay;            /* in micro seconds */
#endif /* __STDC__ */
{
    double ftime_delay;           /* floating point time delay in seconds */
    double temp_freq;             /* frequency offset */
    float tmpphase;
    int   intphase;
    int   sign;
    
    ftime_delay = ((double)time_delay)/((double)(1000000));
    
    /* Convert tardis int to frequency */
    temp_freq = ((double)(freq[slice]))*TARDIS_FREQ_RES;
    
    /* Determine phase change in radians */
    tmpphase = (rel_phase - ( temp_freq * ftime_delay ))*2.0*PI;
    
    tmpphase/= (float)PI;    /* unwrap this phase bits */
    if (tmpphase < 0) {
        sign = -1;
        tmpphase *= -1;
    } else {
        sign = 1;
    }

    if ( ((int)floor((double)tmpphase) % 2) == 1) {
        sign *= -1;
        intphase = sign * (long)((1.0-(tmpphase - (float)floor((double)tmpphase)) ) * ((double)FSI));
    } else {
        intphase = sign * (long)((tmpphase - (float)floor((double)tmpphase)) * ((double)FSI));
    }

    phase[slice] = intphase;
    
    return SUCCESS;   
} /* end setupphases */


void
#ifdef __STDC__ 
ssisat( void )
#else /* !__STDC__ */
    ssisat()
#endif /* __STDC__ */
{
#ifdef IPG
    int next_slice;

    next_slice = sp_sat_index;
    sp_update_rot_matrix( &rsprot_orig[next_slice][0], sat_rot_matrices,
                          sat_rot_ex_num, sat_rot_df_num );
#endif /* IPG */
    return;
}


/***************************** setreadpolarity *************************/
STATUS
#ifdef __STDC__ 
setreadpolarity( void )
#else /* !__STDC__ */
    setreadpolarity()
#endif /* __STDC__ */
{

    int polarity;

    if (iref_etl%2 == 1) {
        polarity = -1;
    }
    else {
        polarity = 1;
    } 

    tia_gx1  = _tia_gx1.fixedflag ?  ((void)(polarity*gradpol[ileave]*ia_gx1), tia_gx1) : polarity*gradpol[ileave]*ia_gx1;  /* temporary x dephaser amp */
    tia_gxw  = _tia_gxw.fixedflag ?  ((void)(polarity*gradpol[ileave]*ia_gxw), tia_gxw) : polarity*gradpol[ileave]*ia_gxw;  /* temporary x readout amp  */
    tia_gxk  = _tia_gxk.fixedflag ?  ((void)(polarity*gradpol[ileave]*ia_gxk), tia_gxk) : polarity*gradpol[ileave]*ia_gxk;  /* temporary x killer amp   */

    setiamp(tia_gx1, &gx1a, 0);        /* x dephaser attack */
    setiamp(tia_gx1, &gx1, 0);         /* x dephaser middle */
    setiamp(tia_gx1, &gx1d, 0);        /* x dephaser decay  */
    setiamp(tia_gxw, &gxw, 0);

    /* Ramps are handled with opposite sign because of the way they
       are defined in the EP_TRAIN macro.  Please refer to epic.h
       for more details. */
    
    for (echo=1; echo < tot_etl; echo++) {
        if ((echo % 2) == 1) {  /* Even echo within interleave */ 
            setiamp(-tia_gxw, &gxwa, echo-1); /* waveforms go neg to pos in ep_train */
            setiamp(-tia_gxw, &gxwd, echo-1);
            setiamp(-tia_gxw, &gxw, echo);    /* const   */
        } else {                    /* Odd echo within interleave */
            setiamp(tia_gxw, &gxwa, echo-1); /* waveforms go neg to pos in ep_train */
            setiamp(tia_gxw, &gxwd, echo-1);
            setiamp(tia_gxw, &gxw, echo);     /* flattop   */
        }
    }
  
    
    if ((tot_etl % 2) == 1) {

        setiamp(-tia_gxw,&gxwde, 0);  /* decay,end */

	if (eosxkiller == 1) {
            setiamp(-tia_gxk,&gxka, 0);   /* killer attack */
            setiamp(-tia_gxk,&gxk, 0);    /* killer flattop */
            setiamp(-tia_gxk,&gxkd, 0);   /* killer decay  */
	}

    } else {

        setiamp(tia_gxw,&gxwde, 0);   /* decay,end */

	if (eosxkiller == 1) {
            setiamp(tia_gxk,&gxka, 0);    /* killer attack */
            setiamp(tia_gxk,&gxk, 0);     /* killer flattop */
            setiamp(tia_gxk,&gxkd, 0);    /* killer decay  */
	}
    }
    
    return SUCCESS;
}

STATUS
pulsegen( void )
{
    EXTERN_FILENAME ext_filename; /* filename holder for externals */
    int Rf2Location[NECHO_MAX]; /* time locations of Rf2 */
    short slmod_acqs;           /* slices%acqs */
    int tempx, tempy, tempz;
    int i;
#ifdef IPG
    int temps;
#ifdef SIM
    int j;
#endif /* SIM */
#endif /* IPG */
    int temp1, temp2;
    int echoloop;
    int psd_icnt,psd_jcnt;
    int psd_seqtime;      /* sequence time */
    int pg_tsp = 0;
    int stddab;           /* 1 = use standard dab, 0 = use hsdab */
    short *wave_space;
    short *temp_wave_space; /* temporary waveform space for rf scaling */
    short temp_res;         /* temporary resolution */
    int wave_ptr;           /* hardware wave pointer */
    float temp_gmnamp;  /* temporary amplitudes for y gmn calc */
    float tempa, tempb;
    int lpfval = -1;
    LONG pulsePos;
    float betax;

    tot_etl = etl + iref_etl; /* internref */
    
  /*jwg more additions for BB*/
 if((acquire_type == SPECPSD_SLAVE_H1)|| (acquire_type == SPECPSD_SLAVE_MNS))
   {	
	 requestTransceiver( psd_board_type, SLAVE_EXCITER, ALL_RECEIVERS);
   }
 else
   {
	 requestTransceiver( psd_board_type, MASTER_EXCITER, ALL_RECEIVERS);
   }    
        
    /* Set HPC timer set to 10 seconds (5 sec. per count) */
    setwatchdogrsp(watchdogcount); /* First give pulsegen a little extra time */
    sspinit(psd_board_type);
    

#ifdef IPG
    /*
     * Execute this code only on the Tgt side
     */

#ifdef SIM

    /* Set rotation matrices for Simulation */
    simulationInit( rsprot[0] );

    /* Saved unscaled version of rotation matrices */
    for ( i = 0 ; i < (opslquant * opphases) ; i++ ) {

        if (obl_debug == PSD_ON){
            printf( "Slice %d\n", i );
        }

        for ( j = 0 ; j < 9 ; j++ ) {

            rsprot_unscaled[i][j] = rsprot[i][j];

            if (obl_debug == PSD_ON) {
                printf( "rsprot_unscaled[%d] = %ld\n", j, rsprot_unscaled[i][j] );
            }
        }
    }
#endif /* SIM */
#endif /* IPG */

    /* Initialize psdexitarg */
    psdexitarg.abcode = 0;
    strcpy(psdexitarg.text_arg, "pulsegen");
    view = slice = excitation  = 0;
 
    { /* Start of code inlined from vmx.e VMXpg */
        if( system_type == 1 )
        {
            rfupa = cv_rfupa;
        }
    } /* End of code inlined from vmx.e VMXpg */


    
  /*jwg have to fix this or download will fail*/
  ia_gxwas  = _ia_gxwas.fixedflag ?  ((void)(0), ia_gxwas) : 0;
       
    debugstate = debugipg;
  
    /* Allocate memory for various arrays.
     * An extra 2 locations are saved in case the user wants to do
     * some tricks. */
    acq_ptr = (short *)AllocNode((acqs*pass_reps + 2)*sizeof(short));
    ctlend_tab = (int *)AllocNode((opphases*opslquant + 2)*sizeof(int));
    slc_in_acq = (short *)AllocNode((acqs*pass_reps + 2)*sizeof(short));
    rf1_freq = (int *)AllocNode((opslquant + 2)*sizeof(int));
    theta_freq = (int *)AllocNode((opslquant + 2)*sizeof(int));
    rf2_freq = (int *)AllocNode((opslquant + 2)*sizeof(int));
    
    /* MRIge55206 */
    /* BJM - change to malloc() in SIM since AllocNode doesn't handle */
    /*       multi-dimensional arrays very well */
    recv_freq = (int ***)AllocMem(opslquant*sizeof(int **));
    for (psd_icnt = 0; psd_icnt < opslquant; psd_icnt++) {
	recv_freq[psd_icnt] = (int **)AllocMem(intleaves*sizeof(int *));
	for (psd_jcnt = 0; psd_jcnt < intleaves; psd_jcnt++)
            recv_freq[psd_icnt][psd_jcnt] = (int *)AllocMem(tot_etl*sizeof(int));
    }
    
    recv_phase = (int ***)AllocMem(opslquant*sizeof(int **));
    for (psd_icnt = 0; psd_icnt < opslquant; psd_icnt++) {
	recv_phase[psd_icnt] = (int **)AllocMem(intleaves*sizeof(int *));
	for (psd_jcnt = 0; psd_jcnt < intleaves; psd_jcnt++)
            recv_phase[psd_icnt][psd_jcnt] = (int *)AllocMem(tot_etl*sizeof(int));
    }
    
    recv_phase_angle = (double ***)AllocMem(opslquant*sizeof(double **));
    for (psd_icnt = 0; psd_icnt < opslquant; psd_icnt++) {
	recv_phase_angle[psd_icnt] = (double **)AllocMem(intleaves*sizeof(double *));
	for (psd_jcnt = 0; psd_jcnt < intleaves; psd_jcnt++)
            recv_phase_angle[psd_icnt][psd_jcnt] =
		(double *)AllocMem(tot_etl*sizeof(double));
    }
    
    rf_phase_spgr = (int **)AllocMem(opslquant*sizeof(int *));
    for (psd_icnt = 0; psd_icnt < opslquant; psd_icnt++) {
	rf_phase_spgr[psd_icnt] = (int *)AllocMem(intleaves*sizeof(int));
    }
    
    echotrainxtr = (WF_PULSE **)AllocNode(tot_etl*sizeof(WF_PULSE *));
    echotrainrba = (WF_PULSE **)AllocNode(tot_etl*sizeof(WF_PULSE *));
    echotrainramp = (int *)AllocNode(tot_etl*sizeof(int));
    echotrainramp1 = (int *)AllocNode(tot_etl*sizeof(int));
    echotrainramp2 = (int *)AllocNode(tot_etl*sizeof(int));
    echotrainrampamp = (short **)AllocNode(tot_etl*sizeof(short*));
    echotrainrampamp1 = (short **)AllocNode(tot_etl*sizeof(short*));
    echotrainrampamp2 = (short **)AllocNode(tot_etl*sizeof(short*));

    gy1f = (int *)AllocNode((intleaves+1)*sizeof(int));
    gymn = (int *)AllocNode((intleaves+1)*sizeof(int));
    view1st = (int *)AllocNode((intleaves+1)*sizeof(int));
    viewskip = (int *)AllocNode((intleaves+1)*sizeof(int));
    tf = (int *)AllocNode((intleaves+1)*sizeof(int));
    rfpol = (int *)AllocNode((intleaves+1)*sizeof(int));
    gradpol = (int *)AllocNode((intleaves+1)*sizeof(int));
    blippol = (int *)AllocNode((intleaves+1)*sizeof(int));
    b0ditherval = (float *)AllocNode((opslquant+1)*sizeof(float));
    delayval = (float *)AllocNode((opslquant+1)*sizeof(float));
    gldelaycval = (int *)AllocNode((opslquant+1)*sizeof(int));
    gldelayfval = (float *)AllocNode((opslquant+1)*sizeof(float));
    
#ifdef ERMES_DEBUG
    debugileave  = _debugileave.fixedflag ?  ((void)(1), debugileave) : 1;
#endif

    switch (ky_dir) {
    case PSD_TOP_DOWN:
	readpolar  = _readpolar.fixedflag ?  ((void)(1), readpolar) : 1;
	break;
    case PSD_BOTTOM_UP:
    case PSD_CENTER_OUT:
    default:
	if (etl % 2 == 1)  /* odd */
            readpolar  = _readpolar.fixedflag ?  ((void)(1), readpolar) : 1;
	else               /* even */
            readpolar  = _readpolar.fixedflag ?  ((void)(-1), readpolar) : -1;  
	break;
    }

    /*
     * Set gradpol array for readout gradient amplitudes.
     */
    /* BJM: MRIge60610 - added num_overscan */ 
    /* internref: added iref_etl. Note etl does not count iref_etl */
    /* MRIge92386 */

    if (FAILURE == ileaveinit( fullk_nframes, ky_dir,
                               intleaves, ep_alt, readpolar, blippolar, debugileave, ia_rf1,
                               ia_gyb, pepolar, etl, seq_data, delt, tfon, fract_ky,
                               ky_offset, num_overscan, endview_iamp, esp, tsp, rhfrsize,
                               a_gxw, rhrcxres, slquant1, lpfval, iref_etl, gy1f, view1st,
                               viewskip, tf, rfpol, gradpol, blippol, &mintf ))
    {
        return FAILURE;
    }

    for (ileave = 0; ileave < intleaves; ileave++){
        if (ygmn_type == CALC_GMN1) {
            tempa = a_gy1a * (float)gy1f[ileave]/ (float)endview_iamp;
            tempb = a_gy1b * (float)gy1f[ileave]/ (float)endview_iamp;
            
            amppwygmn( gyb_tot_0thmoment, gyb_tot_1stmoment, pw_gy1a, pw_gy1,
                       pw_gy1d, tempa, tempb, loggrd.ty_xyz, (float)loggrd.yrt,
                       1, _pw_gymn1a.fixedflag ? (_temp1044_pw_gymn1a=pw_gymn1a,&_temp1044_pw_gymn1a) : &pw_gymn1a, _pw_gymn1.fixedflag ? (_temp1045_pw_gymn1=pw_gymn1,&_temp1045_pw_gymn1) : &pw_gymn1, _pw_gymn1d.fixedflag ? (_temp1046_pw_gymn1d=pw_gymn1d,&_temp1046_pw_gymn1d) : &pw_gymn1d, &temp_gmnamp );
            
            gymn[ileave] = (int)((float)ia_gymn1 * a_gymn1/ temp_gmnamp);
            
            if (debugileave == 1) {
                printf( "gymn[%d] = %d, temp_gmnamp = %f\n",
                        ileave,gymn[ileave],temp_gmnamp );
            }
        } else {
            gymn[ileave] = 0;
        }
    }
    

#ifdef IPG
    /*
     * Execute this code only on the Tgt side
     */
    rdx = dx;
    rdy = dy;
    rdz = dz;
    
    dlyx = gldelayx;
    dlyy = gldelayy;
    dlyz = gldelayz;
    
    b0Dither_ifile( b0ditherval, ditheron, rdx, rdy, rdz, a_gxw, esp,
                    opslquant, debugdither, rsprot_unscaled, 
                    ccinx, cciny, ccinz, esp_in, fesp_in,
                    &g0, &num_elements, &file_exist );
    
    /* Account for rotation in delays.  Since each slice can have a different */
    /* rot mat, each slice is given its own delay */
    calcdelay( delayval, delayon, dlyx, dlyy, dlyz,
               &defaultdelay, opslquant,opgradmode, debugdelay, rsprot_unscaled ); 

#ifdef UNDEF
    calcdelayfile(delayval, delayon, dlyx, dlyy, dlyz,
                  &defaultdelay, opslquant, debugdelay, rsprot_unscaled, 
                  delay_buffer);    
#endif

    /* Set up slice dependent delays for SSP */
    for (slice = 0; slice < opslquant; slice++) {
        
        /* Adjust by daq window (e.g. ramp sampling) */
        delayval[slice] += dacq_adjust;
        
        /* Cast to nearest micro-second */
        if (delayval[slice] < 0.0)
            gldelaycval[slice] = (int)(delayval[slice] - 0.5);
        else
            gldelaycval[slice] = (int)(delayval[slice] + 0.5);
    }
    
    /* SPGR Stuff - not currently used */
    if (oppseq == PSD_SPGR)
	spgr_flag  = _spgr_flag.fixedflag ?  ((void)(1), spgr_flag) : 1;
    else
	spgr_flag  = _spgr_flag.fixedflag ?  ((void)(0), spgr_flag) : 0;
    
    for (slice = 0; slice < opslquant; slice++) {
        for (ileave = 0; ileave < intleaves; ileave++)
            rf_phase_spgr[slice][ileave] = 0;  /* call spgr function in future */
        
    }
#endif

    
       
  {
    pulsename(&x_td0,"x_td0");
    createconst(&x_td0,(WF_PROCESSOR)wg_x_td0,pw_x_td0,(short)0); 
    createinstr( &x_td0,(long)(tlead),pw_x_td0,0);
  }

       
  {
    pulsename(&y_td0,"y_td0");
    createconst(&y_td0,(WF_PROCESSOR)wg_y_td0,pw_y_td0,(short)0); 
    createinstr( &y_td0,(long)(tlead),pw_y_td0,0);
  }

       
  {
    pulsename(&z_td0,"z_td0");
    createconst(&z_td0,(WF_PROCESSOR)wg_z_td0,pw_z_td0,(short)0); 
    createinstr( &z_td0,(long)(tlead),pw_z_td0,0);
  }

       
  {
    pulsename(&rho_td0,"rho_td0");
    createconst(&rho_td0,(WF_PROCESSOR)wg_rho_td0,pw_rho_td0,(short)0); 
    createinstr( &rho_td0,(long)(tlead),pw_rho_td0,0);
  }

       
  {
    pulsename(&theta_td0,"theta_td0");
    createconst(&theta_td0,(WF_PROCESSOR)wg_theta_td0,pw_theta_td0,(short)0); 
    createinstr( &theta_td0,(long)(tlead),pw_theta_td0,0);
  }
 /* YMSmr07445 */
       
  {
    pulsename(&omega_td0,"omega_td0");
    createconst(&omega_td0,(WF_PROCESSOR)wg_omega_td0,pw_omega_td0,(short)0); 
    createinstr( &omega_td0,(long)(tlead),pw_omega_td0,0);
  }

       
  {
    pulsename(&ssp_td0,"ssp_td0");
    createconst(&ssp_td0,(WF_PROCESSOR)wg_ssp_td0,pw_ssp_td0,(short)0); 
    createinstr( &ssp_td0,(long)(tleadssp),pw_ssp_td0,0);
  }

    
    { /* Start of code inlined from Inversion.e InversionPG */
        int i;
        int j;

        if (ir_on == PSD_ON || flair_on == PSD_ON)
        {
/* MRIhc13638 - Substituting sh3t2 for shNvrg5b when 3T field is selected. */
            if (silver_hoult == PSD_ON) 
            {
				if (ir3t_flag == 0 )
				{
                	strcpy(pulse_rho,"shNvrg5b.rho");
				}
				else
				{
                	strcpy(pulse_rho,"sh3t2.rho");
				}
            }
            else
                strcpy(pulse_rho,"rfinvI0.rho");

            for (i=0; i<irslquant; i++) 
            {
                if((flair_on == PSD_ON) || ((opfast == PSD_ON) && (oppseq == PSD_SE)) ||
                   ((opfast == PSD_ON) && ( (oppseq == PSD_IR) || (opirprep == PSD_ON)) ) || (opepi == PSD_ON))       
                    pos_ref  = _pos_ref.fixedflag ?  ((void)(RUP_GRD(ir_start+i*irinterval)), pos_ref) : RUP_GRD(ir_start+i*irinterval);
                else
                    pos_ref  = _pos_ref.fixedflag ?  ((void)(RUP_GRD(pos_start_rf0+pw_gzrf0a)), pos_ref) : RUP_GRD(pos_start_rf0+pw_gzrf0a);

                /* JAH/BJM/HD: Replace SLICESELZEXT_INV() with
                   SLICESELZEXT2STR() to provide automatic pulse
                   stretching for the inversion pulse. */
                   
                                       
                                       
                                      
    {
        short *orig_wave_space, *full_wave_space;

        /* Check for RF waveform generator */
        RFEnvelopeWaveformGeneratorCheck("rf0", 
                                         (WF_PROCESSOR)wg_rf0);

        /* First create the pulses */
        pulsename(&gzrf0a, "gzrf0a");
        pulsename(&gzrf0, "gzrf0");
        pulsename(&gzrf0d, "gzrf0d");
        pulsename(&rf0, "rf0");

        /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;
        createramp( &gzrf0a, ZGRAD, pw_gzrf0a, (short)0,
	            MAX_PG_WAMP,
                    (short)(maxGradRes*(pw_gzrf0a/GRAD_UPDATE_TIME)),
                    pg_beta );
        createinstr( &gzrf0a,
                     (LONG)(pos_ref - pw_gzrf0a),
		     pw_gzrf0a, ia_gzrf0 );
        if( 0 == PLAY_GFILE )
        {
            /***************************************************************** 
	     Now create the waveform & perform required system safety checks
	     create a temporary buffer to modify gradient data using
             createreserve. Here the values of cyc_rf and alpha_rf are
             irrelevant. Stretch the waveform and copy stretched data into
             permanent waveform memory. It is important to to have temp buffer
             have new resolution size waveform memory.
            ******************************************************************/
	    if( PSD_ON == rfpulseInfo[RF0_SLOT].change )
	    {
	        createreserve( &gzrf0, ZGRAD,
                               rfpulseInfo[RF0_SLOT].newres/2 );
	        /************************************************************* 
	         * Change pulse type to external createreserve zero fills
                 * resolution number of points in waveform memory for use.
	         ************************************************************/
	        gzrf0.type = TYPEXTERNAL;
	        createinstr( &gzrf0, (LONG)(pos_ref),
		             pw_gzrf0, ia_gzrf0 );
	        /* Scale the pulse, and then move to the reserved memory */
	        orig_wave_space = (short *)AllocNode( res_gzrf0 * sizeof(short) );
	        uextwave( orig_wave_space, res_gzrf0, NULL );
	        full_wave_space = (short *)AllocNode( rfpulseInfo[RF0_SLOT].newres/2 * sizeof(short) );
	        stretchpulse( (int)res_gzrf0,
                              (int)rfpulseInfo[RF0_SLOT].newres/2,
                              orig_wave_space, full_wave_space );
	        res_gzrf0  = _res_gzrf0.fixedflag ?  ((void)(rfpulseInfo[RF0_SLOT].newres/2), res_gzrf0) : rfpulseInfo[RF0_SLOT].newres/2;
	        /* Copy over original pulse data */
	        movewaveimm( full_wave_space, &gzrf0, (int)0,
                             res_gzrf0, TOHARDWARE );
	        FreeNode( full_wave_space );
	        FreeNode( orig_wave_space );
	    }
	    else
            {
                createextwave( &gzrf0, ZGRAD, 
                               res_gzrf0, NULL );
                createinstr( &gzrf0, (LONG)(pos_ref),
                             pw_gzrf0, ia_gzrf0 );
	    }
        }
        else
        {
            createconst( &gzrf0, ZGRAD, pw_rf0,
                         MAX_PG_WAMP );
            createinstr( &gzrf0, (LONG)(pos_ref),
                         pw_gzrf0, ia_gzrf0 );
        }
        /* Decay ramp */
        createramp( &gzrf0d, ZGRAD, pw_gzrf0d, MAX_PG_WAMP,
	            (short)0,
                    (short)(maxGradRes*(pw_gzrf0d/GRAD_UPDATE_TIME)),
                    pg_beta );
        createinstr( &gzrf0d,
                     (LONG)(pos_ref+pw_gzrf0),
                     pw_gzrf0d, ia_gzrf0 );
    
        /******************************************************************* 
        ** Now create the rf pulse & perform required system safety checks
        ** create a temporary buffer to modify rfpulse data using createsinc.
        ** Here the values of cyc_rf and alpha_rf are irrelevant. Stretch the
        ** pulse and copy stretched data into permanent waveform memory.
        ** It is important to to have temp buffer have new resolution size
        ** waveform memory.
        ********************************************************************/
/* MRIhc06555 HH March 2005 - Ifdef this code to TGT */

#if defined(IPG_TGT) || defined(MGD_TGT)

        if( PSD_ON == rfpulseInfo[RF0_SLOT].change )
        {
            /* Make sure we have a value for createsinc */
            cyc_rf0  = _cyc_rf0.fixedflag ?  ((void)(1.0), cyc_rf0) : 1.0;
	    createsinc( &rf0, (WF_PROCESSOR)wg_rf0,
                        rfpulseInfo[RF0_SLOT].newres,
                        MAX_PG_WAMP, cyc_rf0, alpha_rf0 );
            createinstr( &rf0, (LONG)(pos_ref) + psd_rf_wait,
                         pw_rf0, ia_rf0 );
            linkpulses( 4, &rf0, &gzrf0, &gzrf0a,
                        &gzrf0d );
            addrfbits( &rf0, off_rf0,
                       (LONG)(pos_ref) + psd_rf_wait,
                       pw_rf0 );

            /* Create some RHO waveform space, scale the pulse, and then move
             * the local memory to the reserved RHO memory, and set
             * pulsepointers to new stretched pulse
             */
            orig_wave_space = (short *)AllocNode( res_rf0 * sizeof(short) );
            uextwave( orig_wave_space, res_rf0, pulse_rho );
            full_wave_space = (short *)AllocNode( rfpulseInfo[RF0_SLOT].newres * sizeof(short) );
            stretchpulse( (int)res_rf0,
                          rfpulseInfo[RF0_SLOT].newres,
                          orig_wave_space, full_wave_space );

            movewaveimm( full_wave_space, &rf0, (int)0,
                        rfpulseInfo[RF0_SLOT].newres, TOHARDWARE );
            FreeNode( full_wave_space );
            FreeNode( orig_wave_space );
        }
        else
        {
            /* No rf scaling required. Use createextwave to read pulse 
             * and move to HW 
             */
            createextwave( &rf0, (WF_PROCESSOR)wg_rf0,
                           res_rf0, pulse_rho );
            createinstr( &rf0, (LONG)(pos_ref) + psd_rf_wait,
                         pw_rf0, ia_rf0 );
            linkpulses( 4, &rf0, &gzrf0, &gzrf0a,
                        &gzrf0d );
            addrfbits( &rf0, off_rf0,
                       (LONG)(pos_ref) + psd_rf_wait, pw_rf0 );
        }
#endif
    }


                if (silver_hoult == PSD_ON) 
				{
                    /* JAH/BJM/HD: Replace EXTWAVE() with EXTWAVE2() to
                       provide automatic pulse stretching for the inversion pulse. */

/* HH      02/10/06     MRIhc13638 - Substituting sh3t2 for shNvrg5b when 3T field is selected. */

        		/* Added an if loop for cffield <= 1.5T and set fileloc_omegarf0 directly*/
        		/* This makes the file_name argument in EXTWAVE2 macro irrelevant */

					if (ir3t_flag == 0 )
           				strcpy(fileloc_omegarf0, "shNvrg5b.pha");
        			else
           				strcpy(fileloc_omegarf0, "sh3t2.pha");
                        
                                
  {

    short *stretched_wave_space;  /* temporary waveform space */
    short *wave_space;            /* temporary waveform space for
                                     stretched RF pulse */
    INT old_res;                  /* temp holder for old pulse resolution */
    INT new_res;                  /* temp holder for new pulse resolution */

    if ( (wg_omegarf0 != TYPRHO1)  && (wg_omegarf0 != TYPRHO2) &&
         (wg_omegarf0 != TYPTHETA) && (wg_omegarf0 != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    old_res =  res_omegarf0;
    new_res =  rfpulseInfo[rfslot_omegarf0].newres;

    n_omegarf0  = _n_omegarf0.fixedflag ?  ((void)(1), n_omegarf0) : n_omegarf0+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( omegarf0.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&omegarf0,"omegarf0");
        
        /* Scale waveform if needed */
        if( rfpulseInfo[rfslot_omegarf0].change==PSD_ON ) {

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&omegarf0, (WF_PROCESSOR)wg_omegarf0, new_res);

            /* Allocate memory for original RF pulse */
            wave_space = (short *)AllocNode(old_res*sizeof(short));
            /* Read RF pulse from file and store to wave_space */
            uextwave(wave_space, old_res, fileloc_omegarf0);

            /* Allocate memory for stretched RF pulse */
            stretched_wave_space = (short *)AllocNode(new_res*sizeof(short));
            
            stretchpulse(old_res, new_res, wave_space, stretched_wave_space);
            
            /* Move stretched pulse immediately into reserved memory */
            movewaveimm(stretched_wave_space, &omegarf0,
                        (int)0, new_res, TOHARDWARE);
            
             /* Free memory allocated for original RF pulse */
            FreeNode(wave_space);
            /* Free memory allocated for stretched RF pulse */
            FreeNode(stretched_wave_space);
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_omegarf0  = _res_omegarf0.fixedflag ?  ((void)(new_res), res_omegarf0) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&omegarf0,(WF_PROCESSOR)wg_omegarf0,
                          old_res,fileloc_omegarf0);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &omegarf0,(LONG)(pos_ref) + psd_rf_wait, 
                 pw_omegarf0,ia_omegarf0);
    

    /*** Add RF Bits ***/
    addrfbits(&omegarf0,off_omegarf0,(LONG)(pos_ref) + psd_rf_wait,
              pw_omegarf0);
    

    /*** Reset Resolution ***/
    res_omegarf0  = _res_omegarf0.fixedflag ?  ((void)(old_res), res_omegarf0) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */

  }

                }

                j = i + irslquant*ir_index; 

 /* HH      01/13/06     MRIhc13008 Fix - Use pend(gzrf0)+psd_rf_wait instead of pend(rf0) */
 /* Remove psd_rf_wait here - since it is only needed for RF axis */

                  
                          
                           

  trapezoid((WF_PROCESSOR)wg_gyk0, "gyk0", &gyk0, &gyk0a,
                        &gyk0d, pw_gyk0, pw_gyk0a, pw_gyk0d,
                        ia_gyk0, 0, 0, 0, 0, RUP_GRD(pend(&gzrf0,"gzrf0",j)+pw_gyk0a+((rfupd>>2)<<2))-pw_gyk0a, TRAP_ALL,
                        &loggrd);

            }
        }

        if (flair_on == PSD_ON) 
        {
              
  {
    pulsename(&seqinv,"seqinv");
    createseq(&seqinv,invseqlen, off_seqinv);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqinv );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqinv = %d\n", idx_seqinv );
#endif
  }

            getperiod(&ir_deadtime,&seqinv,0);

            /* Assert the ESSP flag on the sync packet byte seq length */
            attenflagon(&seqinv, 0);
        }
    } /* End of code inlined from Inversion.e InversionPG */


    /* Spatial Sat *******************************************************/
    sp_satindex = 0;
    SpSatPG(vrgsat,sp_satstart, &sp_satindex, sp_satcard_loc);
    
    /* Chem Sat **********************************************************/
    cs_satindex = 0;
    if (cs_sat) ChemSatPG(cs_satstart, &cs_satindex);
  
    /* spsp 90 RF slice select pulse *******************************************/
    
    /*jwg bb for debugging*/
    fprintf(stderr,"rf pulse is %s \n", ssrffile);
    fprintf(stderr,"gradient file is %s \n", ssgzfile);
    if (thetaflag == 1) fprintf(stderr,"theta file is %s \n", ssthetafile);
    temp_res = res_rf1;
    if (rfpulseInfo[RF1_SLOT].change == PSD_ON)  /* set to new resolution */
	res_rf1  = _res_rf1.fixedflag ?  ((void)(rfpulseInfo[RF1_SLOT].newres), res_rf1) : rfpulseInfo[RF1_SLOT].newres;
    
    /* set rfunblank_bits[2] so that addrfbits in sliceselz does not
       unblank the receiver - see EpicConf.c for defaults. Will unblank
       the receiver later - MRIge28778 */
    
    rfunblank_bits[0][2] = SSPD;
    rfunblank_bits[1][2] = SSPD;
    
          
                          
                          
                            
  {
      /* Check for RF waveform generator */
      RFEnvelopeWaveformGeneratorCheck("rf1", 
                                       (WF_PROCESSOR)wg_rf1);

      /* Select proper filename */
      grad_zrf1=  ssgzfile;
      rf_rf1 =  ssrffile;
      theta_rf1 = ssgzfile;

      /* Now create the pulses */
      pulsename(&gzrf1a,"gzrf1a");
      pulsename(&gzrf1,"gzrf1");
      pulsename(&gzrf1d,"gzrf1d");
      pulsename(&rf1,"rf1");
      pulsename(&thetarf1, "thetarf1");

      /*  Now create the slice select trapezoid */
      pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;

      if ( gztype == PLAY_GFILE) {

#if defined(IPG_TGT) || defined(MGD_TGT)
          /* Use external gradient file for now */
          createextwave( &gzrf1, ZGRAD, res_gzrf1,
                         grad_zrf1 );

          createinstr( &gzrf1, (long)pos_start+pw_gzrf1a,
                       pw_gzrf1, ia_gzrf1 );

#elif defined(HOST_TGT)
          /* Create train of trapezoids on the Host side */
          int i;
          int polarity = 1;
       
          pulsepos  = _pulsepos.fixedflag ?  ((void)(pos_start+pw_gzrf1a), pulsepos) : pos_start+pw_gzrf1a; 
       
          for(i = 1; i <= num_rf1lobe; i++) {
              polarity *= -1;

              trapezoid( ZGRAD,"gzrf1", &gzrf1, 
                         &gzrf1a, &gzrf1d,
                         pw_constant, pw_ss_rampz, pw_ss_rampz, 
                         (polarity*(ia_gzrf1)),
                         (polarity*(ia_gzrf1)),
                         (polarity*(ia_gzrf1)), 0, 0, 
                         pulsepos, TRAP_ALL, &loggrd );

              pulsepos  = _pulsepos.fixedflag ?      ((void)(pw_constant+2*pw_ss_rampz), pulsepos) : pulsepos+pw_constant+2*pw_ss_rampz;
          }
#endif

      } else {

          /* Create simple trapezoid for chem sat + rf */
          createramp( &gzrf1a,ZGRAD,pw_gzrf1a,
                      (short)0, max_pg_wamp,
                      (short)(maxGradRes *
                              (pw_gzrf1a/ GRAD_UPDATE_TIME)),
                      pg_beta );

          createinstr( &gzrf1a,
                       (long)(pos_start+pw_gzrf1a - pw_gzrf1a),
                       pw_gzrf1a, ia_gzrf1 );

          createconst( &gzrf1, ZGRAD, pw_rf1, max_pg_wamp );
          createinstr( &gzrf1, (long)pos_start+pw_gzrf1a,
                       pw_gzrf1, ia_gzrf1 );

          createramp( &gzrf1d, ZGRAD, pw_gzrf1d,
                      max_pg_wamp, (short)0,
                      (short)(maxGradRes *
                              (pw_gzrf1d/ GRAD_UPDATE_TIME)),
                      pg_beta );
          createinstr( &gzrf1d,
                       (long)(pos_start+pw_gzrf1a + pw_gzrf1),
                       pw_gzrf1d, ia_gzrf1 );

      }

      /* Now create the rf pulse */
      if ( rftype == PLAY_RFFILE) {
          createextwave( &rf1, (WF_PROCESSOR)wg_rf1, res_rf1,
                         rf_rf1);
      } else {
          createsinc( &rf1, (WF_PROCESSOR)wg_rf1, res_rf1,
                      max_pg_wamp,cyc_rf1, alpha_rf1 );
      }

      createinstr( &rf1,(long)pos_start+pw_gzrf1a + psd_rf_wait +
                   ss_rf_wait,  pw_rf1,ia_rf1);

      addrfbits( &rf1, off_rf1, (long)pos_start+pw_gzrf1a +
                 psd_rf_wait + ss_rf_wait, pw_rf1 );

      /* Now create the theta pulse */
      if ( thetatype == PLAY_THETA) {
          /*jwg force theta pulse on OMEGA*/
          /*createextwave( &theta$[slsel_name], (wg_$[slsel_name]==TYPRHO1)?TYPOMEGA:TYPTHETA,
                         res_theta$[slsel_name], theta_$[slsel_name] );	  */
          createextwave( &thetarf1, wg_omegarf1,
                         res_thetarf1, theta_rf1 );

          createinstr( &thetarf1, (long)pos_start+pw_gzrf1a + psd_rf_wait +
                       ss_rf_wait, pw_thetarf1,
                       ia_thetarf1 );

          addrfbits( &thetarf1, off_thetarf1,
                     (long)pos_start+pw_gzrf1a + psd_rf_wait + ss_rf_wait,
                     pw_thetarf1 );
      }
      if ( gztype == PLAY_GFILE) {
          #if defined(IPG_TGT) || defined(MGD_TGT)
          linkpulses( 3,
                      &rf1, &gzrf1, &thetarf1);
          #endif
      } else {
          linkpulses( 4,
                      &rf1, &gzrf1,
                      &gzrf1a, &gzrf1d);
      }
  }
 
		       
    if(thetaflag == 1) 
        {
		strcpy(fileloc_phaserf1,ssthetafile);
		/*jwg bb replace first argument THETA with wg_phaserf1*/
       		       
			   
  {
    pulsename(&phaserf1,"phaserf1");
    createextwave(&phaserf1,(WF_PROCESSOR)wg_phaserf1,
                  res_phaserf1,fileloc_phaserf1);
    if ((wg_phaserf1==TYPRHO1)||(wg_phaserf1==TYPRHO2) ||
	(wg_phaserf1==TYPTHETA)||(wg_phaserf1==TYPOMEGA))
      {
	createinstr( &phaserf1,(long)(pos_start+pw_gzrf1a) + psd_rf_wait, 
		    pw_phaserf1,ia_phaserf1);
	addrfbits(&phaserf1,off_phaserf1,(long)(pos_start+pw_gzrf1a) + psd_rf_wait,
		  pw_phaserf1);
      }
    else
      {
	createinstr( &phaserf1,(long)(pos_start+pw_gzrf1a), 
		    pw_phaserf1,ia_phaserf1);
      }
  }
		       
	}
    
    /* reset the bit */
    rfunblank_bits[0][2] = SSPD + RUBL;
    rfunblank_bits[1][2] = SSPD + RUBL;
    
    if (rfpulseInfo[RF1_SLOT].change == PSD_ON)  /* change back for ext. file */
	res_rf1  = _res_rf1.fixedflag ?  ((void)(temp_res), res_rf1) : temp_res;
   
    /* 180 RF refocusing pulse ********************************************/
    if (oppseq == PSD_SE) {
#ifndef RT
	Rf2Location[0] = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso  + opte/2
                                       - pw_rf2/2) - psd_rf_wait);  /* Find start loc of 180s */
#else
        Rf2Location[0] = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso  + opte/2
                                       - pw_rf2/2) + 1000*ase_offset - psd_rf_wait);  /* Find start loc of 180s */
#endif
        
        /* MRIge58235: moved uextwave to here so the file read from disk is always read with orig. res_rf2 */
	strcpy(ext_filename, "rfse1b4.rho");
        
	/* Create some RHO waveform space, read in the 
	   se1b4 spin echo 180 to local memory, and then move
	   the local memory to the reserved RHO memory.
        */
	temp_wave_space = (short *)AllocNode(res_rf2*sizeof(short));
	uextwave(temp_wave_space, res_rf2, ext_filename);
        
        {
            /* MRIge58235: save orig. res_rf2 for scaling */
            short orig_res;
            
            orig_res = res_rf2;
            if (rfpulseInfo[RF2_SLOT].change==PSD_ON)
                res_rf2  = _res_rf2.fixedflag ?  ((void)(rfpulseInfo[RF2_SLOT].newres), res_rf2) : rfpulseInfo[RF2_SLOT].newres;     /* Set to new resolution */
            
            /* set rfunblank_bits[2] so that addrfbits in sliceselz does not
               unblank the receiver - see EpicConf.c for defaults. Will unblank
               the receiver later - MRIge28778 */
            rfunblank_bits[0][2] = SSPD;
            rfunblank_bits[1][2] = SSPD;
            
            /*  180 slice sel pulse  */
              
                          
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2", 
                                     (WF_PROCESSOR)wg_rf2);

    /* First create the pulses */
    pulsename(&gzrf2a,"gzrf2a");
    pulsename(&gzrf2,"gzrf2");
    pulsename(&gzrf2d,"gzrf2d");
    pulsename(&rf2,"rf2");
    
    /*  Now create the slice select trapezoid */
    pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;
    createramp(&gzrf2a,ZGRAD,pw_gzrf2a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2a,(long)(Rf2Location[0]-pw_gzrf2a),
                pw_gzrf2a,ia_gzrf2);
    createconst(&gzrf2,ZGRAD,pw_gzrf2,MAX_PG_WAMP);
    createinstr( &gzrf2,(long)(Rf2Location[0]),
                pw_gzrf2,ia_gzrf2);
    createramp(&gzrf2d,ZGRAD,pw_gzrf2d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrf2d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrf2d,(long)(Rf2Location[0]+pw_gzrf2),
                pw_gzrf2d,ia_gzrf2);
    
    /* Now create the rf pulse */
    createsinc(&rf2,(WF_PROCESSOR)wg_rf2,res_rf2,
	       MAX_PG_WAMP,cyc_rf2, alpha_rf2);
    createinstr( &rf2,(long)(Rf2Location[0]) + psd_rf_wait,
		pw_rf2,ia_rf2);
    linkpulses(4,&rf2,&gzrf2,&gzrf2a,
	       &gzrf2d);
    addrfbits(&rf2,off_rf2,(long)(Rf2Location[0]) + psd_rf_wait, 
	      pw_rf2);
  }

            
            /* reset the bit */
            rfunblank_bits[0][2] = SSPD + RUBL;
            rfunblank_bits[1][2] = SSPD + RUBL;
            
            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF2_SLOT].change==PSD_ON) {
                wave_space = (short *)AllocNode(rfpulseInfo[RF2_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)orig_res, (int)rfpulseInfo[RF2_SLOT].newres,
                             temp_wave_space,wave_space);
                FreeNode(temp_wave_space);
            } else {
                wave_space = temp_wave_space;
            }

            /* Assign temporary board memory and move immediately into permanent
               memory */
            res_rf2se1b4  = _res_rf2se1b4.fixedflag ?  ((void)(res_rf2), res_rf2se1b4) : res_rf2;
              
  {
    pulsename(&rf2se1b4,"rf2se1b4");
    createreserve(&rf2se1b4,(WF_PROCESSOR)wg_rf2se1b4,
		  res_rf2se1b4);
  }

            movewaveimm(wave_space, &rf2se1b4, (int)0, res_rf2, TOHARDWARE);
            FreeNode(wave_space);
            
            /* MRIge58235: reset res_rf2 after scaling */
            res_rf2  = _res_rf2.fixedflag ?  ((void)(orig_res), res_rf2) : orig_res;
        }
        
	if (innerVol == PSD_ON) {
                 

  trapezoid((WF_PROCESSOR)wg_gyrf2iv, "gyrf2iv", &gyrf2iv, &gyrf2iva,
                        &gyrf2ivd, pw_gyrf2iv, pw_gyrf2iva, pw_gyrf2ivd,
                        ia_gyrf2iv, 0, 0, 0, 0, Rf2Location[0]-pw_gyrf2iva, TRAP_ALL,
                        &loggrd);

            ia_gzrf2  = _ia_gzrf2.fixedflag ?  ((void)(0), ia_gzrf2) : 0;
	}
	
	setphase((float)(PI/-2.0), &rf2, 0);  /* Apply 90 phase shift to  180 */
        
	attenflagon(&rf1, 0);                 /* Assert ESSP flag on rf1 pulse */
	
	attenflagon(&rf2, 0);                 /* Assert ESSP flag on 1st rf2 */
        
        
	/* Z crushers (echo 1) ***********************************************/
	 
                     
                  

  trapezoid((WF_PROCESSOR)wg_gzrf2l1, "gzrf2l1", &gzrf2l1, &gzrf2l1a,
                        &gzrf2l1d, pw_gzrf2l1, pw_gzrf2l1a, pw_gzrf2l1d,
                        ia_gzrf2l1, 0, 0, 0, 0, pbeg(&gzrf2,"gzrf2",0)-(pw_gzrf2l1+pw_gzrf2l1d)-pw_gzrf2l1a, TRAP_ALL,
                        &loggrd);

	
	     

  trapezoid((WF_PROCESSOR)wg_gzrf2r1, "gzrf2r1", &gzrf2r1, &gzrf2r1a,
                        &gzrf2r1d, pw_gzrf2r1, pw_gzrf2r1a, pw_gzrf2r1d,
                        ia_gzrf2r1, 0, 0, 0, 0, pend(&gzrf2,"gzrf2d",0)-pw_gzrf2r1a, TRAP_ALL,
                        &loggrd);

        
    } 
    
    /***********************************************************************/
    /* X EPI readout train                                                 */
    /***********************************************************************/
    
    /* For now assume a simple retiling. */
    if (fract_ky == PSD_FRACT_KY) {

        if ( ky_dir == PSD_BOTTOM_UP ) {
            echoOffset  = num_overscan/intleaves + iref_etl;
        } else {
            /* with fract_ky = ON and TOP down, echoffset is yes/2 */       
	    /* MRIge92386 */
            echoOffset  = fullk_nframes/intleaves/2 + iref_etl;
        }       

    } else {
	if (ky_dir == PSD_TOP_DOWN || ky_dir == PSD_BOTTOM_UP)
	    /* MRIge92386 */
            echoOffset  = fullk_nframes/intleaves/2 + iref_etl;
	else
            echoOffset  = 0;
    }
    
    /* BJM: pkt_delay is included to account for any delay between */
    /* sending the RBA and the first sample acquired (hardware delay) */
    if (vrgfsamp == PSD_ON) {
        dacq_offset  = _dacq_offset.fixedflag ?      
              
                          ((void)(pkt_delay+pw_gxwad-(int)(fbhw*((float)pw_gyb/2.0+(float)pw_gybd)+0.5)), dacq_offset) : pkt_delay+pw_gxwad-(int)(fbhw*((float)pw_gyb/2.0+(float)pw_gybd)+0.5);

        if(dacq_offset < 0) dacq_offset  = _dacq_offset.fixedflag ?  ((void)(0), dacq_offset) : 0;

    } else {
        dacq_offset  = _dacq_offset.fixedflag ?  ((void)(pkt_delay), dacq_offset) : pkt_delay;
    }
    
    /* MRIge58023 & 58033 need to RUP_GRD entire expression */
    if (intleaves == fullk_nframes) {
	tempx = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso + opte - pw_gxw/2 - pw_gxwl - ky_offset*esp/intleaves));
    } else {
	tempx = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso + opte - echoOffset * esp - ky_offset*esp/intleaves - pw_iref_gxwait));
    }
    
    tempy = tempx + gydelay;
    tempz = tempx;
    tempx += gxdelay;
    
    /* Set up for EP_TRAIN */
    stddab = (hsdab==PSD_ON ? 0:1);
    pg_tsp =0;
    /* internref: use tot_etl instead of etl; added iref_etl */
    /*jwg bb this is where EPI readout starts!*/
    if(sake_flag == 0) sake_max_blip  = _sake_max_blip.fixedflag ?  ((void)(1), sake_max_blip) : 1;
    fprintf(stderr,"Before EP_TRAIN, pw_gyb and a_gyb are %d and %f \n",pw_gyb,a_gyb);
      
              
             
             
             
             
             
               
             
             
             
             
             
    {
        int psd_gxwcnt;
        int psd_pulsepos;
        int psd_eparity;
        long psd_epxtroff;
        long psd_epdaboff;
        float psd_etbetax;
        float psd_etbetay;
        char psd_epstring[EPSTRING_LENGTH];

        psd_pulsepos = RUP_GRD((LONG)tempx+pw_gxwad);           
	if( iref_etl == 0 ){
           pw_iref_gxwait  = _pw_iref_gxwait.fixedflag ?  ((void)(0), pw_iref_gxwait) : 0;
        } 
        /* allocate on 1st pass only  */
        if ( 0 == 0 ) {
            echotrain = (WF_PULSE *)AllocNode((tot_etl + 3) * sizeof(WF_PULSE));
        }
 
        pulsename(&gxcla, "gxcla");
        pulsename(&gxcl, "gxcl");
        pulsename(&gxcld, "gxcld");
 
        pulsename(&gxwa, "gxwa");
        pulsename(&gxw, "gxw");
        pulsename(&gxwd, "gxwd");
        pulsename(&gxwde, "gxwde");
 
        pulsename(&gxgap, "gxgap");
 
        pulsename(&gyba, "gyba");
        pulsename(&gyb, "gyb");
        pulsename(&gybd, "gybd");
 
        pulsename(&gxcra, "gxcra");
        pulsename(&gxcr, "gxcr");
        pulsename(&gxcrd, "gxcrd");
 
        getbeta(&psd_etbetax, XGRAD, &epiloggrd);
        getbeta(&psd_etbetay, YGRAD, &epiloggrd);
 
        if (pw_gxcla >= GRAD_UPDATE_TIME) {
            createramp(&gxcla, XGRAD, pw_gxcla, (short)0,
                       (short)ia_gxcl, (short)(maxGradRes*(pw_gxcla/
                                                           GRAD_UPDATE_TIME)), psd_etbetax);
            createinstr(&gxcla, (long)psd_pulsepos,
                        pw_gxcla, max_pg_iamp);
            psd_pulsepos += pw_gxcla;
        }
    
        if (pw_gxcl >= GRAD_UPDATE_TIME) {
            createconst(&gxcl, XGRAD, pw_gxcl, max_pg_wamp);
            createinstr(&gxcl, (long)psd_pulsepos,
                        pw_gxcl, ia_gxcl);
            psd_pulsepos += pw_gxcl;
        }
    
        if (pw_gxcld >= GRAD_UPDATE_TIME) {
            createramp(&gxcld, XGRAD, pw_gxcld, (short)ia_gxcl,
                       (short)ia_gxw, (short)(maxGradRes*(pw_gxcld/
                                                          GRAD_UPDATE_TIME)), psd_etbetax);
            createinstr(&gxcld, (long)psd_pulsepos,
                        pw_gxcld, max_pg_iamp);
            psd_pulsepos += pw_gxcld;
        }
    
        createconst(&gxw, XGRAD, pw_gxwl+pw_gxw+pw_gxwr, max_pg_wamp);
        createinstr(&gxw, (long)psd_pulsepos,
                    pw_gxwl+pw_gxw+pw_gxwr, ia_gxw);
        psd_pulsepos += pw_gxwl;
    
        sprintf(psd_epstring, "echo%04d", 0);
        pulsename(&(echotrain[0]), psd_epstring);
    
        if (dab_offset == 0)
            psd_epdaboff = 0;
        else
            psd_epdaboff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + dab_offset);            
        if (xtr_offset == 0)
            psd_epxtroff = 0;
        else
            psd_epxtroff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + xtr_offset);            
    
        epiacqq(&(echotrain[0]),                
                (long)(psd_pulsepos + psd_grd_wait-dacq_offset),
                psd_epdaboff, psd_epxtroff,
                (long)scanslot, 
                (TYPDAB_PACKETS)DABNORM,
                (long)fast_rec,
                (long)stddab);
    
        psd_pulsepos += pw_gxw + pw_gxwr;      
    
        psd_eparity = 1;
        for (psd_gxwcnt = 2; psd_gxwcnt <= tot_etl; psd_gxwcnt++) {
            psd_eparity *= -1;
	 if( psd_gxwcnt - 1 > iref_etl ){  
	    createramp(&gyba, YGRAD, pw_gyba, 0, max_pg_wamp,
                       (short)((maxGradRes*pw_gyba)/GRAD_UPDATE_TIME), psd_etbetay);
            createinstr(&gyba, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 -
                                      (pw_gyba + pw_gyb/2)), pw_gyba, ia_gyb);
        
            if (pw_gyb >= GRAD_UPDATE_TIME) {
                createconst(&gyb, YGRAD, pw_gyb, max_pg_wamp);
                createinstr(&gyb, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 -
                                         pw_gyb/2), pw_gyb, ia_gyb);
            }
        
            createramp(&gybd, YGRAD, pw_gybd, max_pg_wamp, 0,
                       (short)((maxGradRes*pw_gybd)/GRAD_UPDATE_TIME), psd_etbetay);
            createinstr(&gybd, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 +
                                      pw_gyb/2), pw_gybd, ia_gyb);
        
            linkpulses(3,&gyb,&gyba,&gybd);
           }
	   createramp(&gxwd, XGRAD, pw_gxwad, -max_pg_wamp, 0,
                      (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME),
                      psd_etbetax);
           createinstr(&gxwd, (long)psd_pulsepos, pw_gxwad, psd_eparity* ia_gxw);
           psd_pulsepos += pw_gxwad;

           if( pw_gxgap == 0 ){
               if( (pw_iref_gxwait != 0) && (psd_gxwcnt == iref_etl) ){ 
                   createconst(&gxgap, XGRAD, pw_iref_gxwait, 0);
                   createinstr(&gxgap, (long)psd_pulsepos, pw_iref_gxwait, 0);
                   psd_pulsepos += pw_iref_gxwait;
               }
           }else{ 
               int gapgap;
               if( (pw_iref_gxwait == 0) || (psd_gxwcnt != iref_etl) ){
                      gapgap = pw_gxgap;
               }else{
                      gapgap = pw_gxgap+pw_iref_gxwait;
               }
               createconst(&gxgap, XGRAD, gapgap, 0);
               createinstr(&gxgap, (long)psd_pulsepos, gapgap, 0);
               psd_pulsepos += gapgap;
           }

           createramp(&gxwa, XGRAD, pw_gxwad, 0, max_pg_wamp,
                      (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), psd_etbetax);
           createinstr(&gxwa, (long)psd_pulsepos, pw_gxwad, psd_eparity* ia_gxw);
           psd_pulsepos += pw_gxwad;
	                     
            createconst(&gxw, XGRAD, pw_gxwl+pw_gxw+pw_gxwr, max_pg_wamp);
            createinstr(&gxw, (long)psd_pulsepos,
                        pw_gxwl+pw_gxw+pw_gxwr, psd_eparity*ia_gxw);
            psd_pulsepos += pw_gxwl;
        
            sprintf(psd_epstring, "echo%04d", psd_gxwcnt-1 + 0);
            pulsename(&(echotrain[psd_gxwcnt-1+0]), psd_epstring);
        
            if (dab_offset == 0)                                           
                psd_epdaboff = 0;
            else
                psd_epdaboff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + dab_offset);
        
            if (xtr_offset == 0)
                psd_epxtroff = 0;
            else
                psd_epxtroff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + xtr_offset);
            
	    epiacqq(&(echotrain[psd_gxwcnt-1+0]),                
                    (long)(psd_pulsepos + psd_grd_wait-dacq_offset),
                    psd_epdaboff, psd_epxtroff,
                    (long)scanslot, 
                    (TYPDAB_PACKETS)DABNORM,
                    (long)fast_rec,
                    (long)stddab);
        
            psd_pulsepos += pw_gxw + pw_gxwr;      
        }     
        if ((tot_etl % 2) == 1) {    /* views per shot is odd */          
            if (pw_gxcra >= GRAD_UPDATE_TIME) {
                createramp(&gxcra, XGRAD, pw_gxcra, (short)ia_gxw,
                           (short)ia_gxcr, (short)(maxGradRes*(pw_gxcra/
                           GRAD_UPDATE_TIME)), psd_etbetax);
                createinstr(&gxcra, (long)(psd_pulsepos), pw_gxcra, max_pg_iamp);
                psd_pulsepos += pw_gxcra;
            }
        } else { /* views per shot is even */
            /* single transition ramp into crusher */                  
            if ((ia_gxw == ia_gxcr) && (pw_gxwad == pw_gxcra)) {
                createramp(&gxwd, XGRAD, 2*pw_gxwad, -max_pg_wamp, max_pg_wamp,
                           (short)(maxGradRes*(2*pw_gxwad)/GRAD_UPDATE_TIME),
                           psd_etbetax);
                createinstr(&gxwd, (long)psd_pulsepos, 2*pw_gxwad, ia_gxw);
                psd_pulsepos += 2*pw_gxwad;
            } else {    /* two separate ramps, decay ramp needs new waveform */
                createramp(&gxwde, XGRAD, pw_gxwad, -max_pg_wamp, 0,              
                           (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), psd_etbetax);
                createinstr(&gxwde, (long)psd_pulsepos, pw_gxwad, ia_gxw);
                psd_pulsepos += pw_gxwad;

                if (pw_gxcra >= GRAD_UPDATE_TIME) {
                    createramp(&gxcra, XGRAD, pw_gxcra, (short)0,
                               (short)ia_gxcr, (short)(maxGradRes*(pw_gxcra/
                                GRAD_UPDATE_TIME)),psd_etbetax);
                    createinstr(&gxcra, (long)(psd_pulsepos),pw_gxcra, max_pg_iamp);
                    psd_pulsepos += pw_gxcra;
                }
            }   
        }        
        if (pw_gxcr >= GRAD_UPDATE_TIME) {
            createconst(&gxcr, XGRAD, pw_gxcr, max_pg_wamp);
            createinstr(&gxcr, (long)psd_pulsepos,pw_gxcr, ia_gxcr);
            psd_pulsepos += pw_gxcr;
        }

        if (pw_gxcrd >= GRAD_UPDATE_TIME) {
            createramp(&gxcrd, XGRAD, pw_gxcrd, (short)ia_gxcr,
                       (short)0, (short)(maxGradRes*(pw_gxcrd/
                        GRAD_UPDATE_TIME)), psd_etbetax);                             
            createinstr(&gxcrd, (long)psd_pulsepos,pw_gxcrd, max_pg_iamp);
            psd_pulsepos += pw_gxcrd;
        }
    }

    fprintf(stderr,"After EP_TRAIN, pw_gyb and a_gyb are %d and %f \n",pw_gyb,a_gyb);	     

    /*jwg bb run amppwgrad so that we can generate 'worst-case scenario' blip scheme*/
    /*if(sake_flag > 0)
    {
    	amppwgrad(area_gyb * (int)sake_max_blip, 5.0, 0.0, 0.0, loggrd.yrt, MIN_PLATEAU_TIME, &a_gyb, &pw_gyba, &pw_gyb, &pw_gybd);
    }
    */

    /* unblank receiver rcvr_ub_off us prior to first xtr/dab/rba packet */
    getssppulse(&(echotrainxtr[0]), &(echotrain[0]), "xtr", 0);
    rcvrunblankpos = echotrainxtr[0]->inst_hdr_tail->start;
    rcvrunblankpos += rcvr_ub_off;
     
  {
    rec_unblank_pack[0] = SSPDS+RDC;
    rec_unblank_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rec_unblank_pack[2] = SSPD+RUBL;
    rec_unblank_pack[3] = SSPDS;

    pulsename(&rec_unblank,"rec_unblank");
    createbits(&rec_unblank,TYPSSP,4,rec_unblank_pack);
    createinstr( &rec_unblank,(long)(rcvrunblankpos),4,ia_rec_unblank);
  }


    if (tot_etl % 2 == 1) {
	getbeta(&betax, XGRAD, &epiloggrd);
	pulsePos = pend(&gxw, "gxw", tot_etl-1);
	createramp(&gxwde, XGRAD, pw_gxwad, -max_pg_wamp, 0,
                   (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), betax);
	createinstr(&gxwde, pulsePos, pw_gxwad, -ia_gxw);
	pulsePos += pw_gxwad;
    }
    
    /***********************************************************************/
    /* X dephaser                                                          */
    /***********************************************************************/
    
    if (gx1pos == PSD_POST_180)
	temp1 = RUP_GRD((int)(pbeg(&gxw,"gxw",0) - (pw_gxwad + pw_gx1a +
						    pw_gx1 + pw_gx1d)));
    else
	temp1 = RUP_GRD((int)(pendall(&gzrf1, gzrf1.ninsts-1) + pw_gx1a +
                              pw_wgx + rfupd));
    
    pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.xbeta), pg_beta) : loggrd.xbeta;
    
    pulsename(&gx1a,"gx1a");
    createramp(&gx1a,XGRAD,pw_gx1a,(short)0,
               max_pg_wamp,(short)(maxGradRes*(pw_gx1a/
                                               GRAD_UPDATE_TIME)),
               pg_beta);
    createinstr(&gx1a, (LONG)temp1, pw_gx1a, ia_gx1);
    
    if (pw_gx1 >= GRAD_UPDATE_TIME) {
	pulsename(&gx1,"gx1");
	createconst(&gx1,XGRAD,pw_gx1,max_pg_wamp);
	createinstr( &gx1,(LONG)(LONG)temp1+pw_gx1a,
                     pw_gx1,ia_gx1);
    }
    
    pulsename(&gx1d, "gx1d");
    if (single_ramp_gx1d == PSD_ON) {   /* Single ramp for gx1 decay into gxw
                                           attack */
        createramp(&gx1d, XGRAD, pw_gxwad, max_pg_wamp, -max_pg_wamp,
                   (short)(maxGradRes*(2*pw_gxwad/GRAD_UPDATE_TIME)), pg_beta);
        createinstr(&gx1d, (LONG)(temp1+pw_gx1a+pw_gx1), 2*pw_gxwad, ia_gx1);
    } else {                     /* decay ramp for gx1 */
        createramp(&gx1d,XGRAD,pw_gx1d,max_pg_wamp,
                   (short)0,(short)(maxGradRes*(pw_gx1d/GRAD_UPDATE_TIME)),
                   pg_beta);
	createinstr( &gx1d,(LONG)((LONG)temp1+pw_gx1a+pw_gx1),
                     pw_gx1d,ia_gx1);
        
	pulsename(&gxwa, "gxwa");  /* attack ramp for epi train */
	createramp(&gxwa, XGRAD, pw_gxwad, (short)0, max_pg_wamp,
                   (short)(maxGradRes*(pw_gxwad/GRAD_UPDATE_TIME)), pg_beta);
        if ( tot_etl%2 == 0 && ky_dir != PSD_TOP_DOWN )
            createinstr(&gxwa, (LONG)tempx, pw_gxwad, -ia_gxw);
        else
            createinstr(&gxwa, (LONG)tempx, pw_gxwad, ia_gxw);
    }
    
    /* Set readout polarity to gradpol[ileave] value */
    ileave = 0;
    setreadpolarity();
    
    if(rtb0_flag)
    {
        temp2 = pendall(&rf1, 0) + IMax(2, pw_gz1_tot, rfupd + 4   + rtb0_minintervalb4acq)+rtb0_acq_delay;
            
  {
    pulsename(&rtb0echo,"rtb0echo");
    acqq(&rtb0echo, (long)(temp2),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_rtb0echo,
        (TYPDAB_PACKETS)DABNORM);
  }

        attenflagon( &(rtb0echo), 0 );

        getssppulse(&(rtb0echoxtr), &(rtb0echo), "xtr", 0);
        rcvrunblankpos = rtb0echoxtr->inst_hdr_tail->start;
        rcvrunblankpos += rcvr_ub_off;
         
  {
    rec_unblank2_pack[0] = SSPDS+RDC;
    rec_unblank2_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rec_unblank2_pack[2] = SSPD+RUBL;
    rec_unblank2_pack[3] = SSPDS;

    pulsename(&rec_unblank2,"rec_unblank2");
    createbits(&rec_unblank2,TYPSSP,4,rec_unblank2_pack);
    createinstr( &rec_unblank2,(long)(rcvrunblankpos),4,ia_rec_unblank2);
  }


        temp2 += esp;
    }
    else
    {
        /* Hyperscan DAB packet */
        temp2 = pendall(&rf1, 0) + rfupd + 4  ;  /* 4us for unblank receiver */
    }

     
{
    pulsename(&hyperdab,"hyperdab");

        createhsdab(&hyperdab, (long)(temp2));
  }

    
    /* If we don't reset frequency and phase on each view, then it is best
       to use a single packet at the beginning of the frame - one that doesn't
       shift with interleave.  This is because we want the constant part of Ahn
       correction to see continuous phase evolution across the views. */
    
    if (oppseq == PSD_SE) {
	temp2 = pendall(&rf2, 0) + rfupd + 4  ;  /* 4us for unblank receiver */
    } else {
	temp2 = pendall(&rf1, 0) + rfupd + 4  ;  /* 4us for unblank receiver */
    }
   
    /* Y prephaser ************************************************************/
    if (gy1pos == PSD_POST_180) {
	temp1 = pbeg(&gxw, "gxw", iref_etl) - pw_gxwad - pw_gy1_tot; /* internref */
        if(no_gy1_ol_gxw && iref_etl > 0) {
            temp1 -= esp;
        }
	temp1 = RDN_GRD(temp1);
    } else {
	temp1 = RDN_GRD(pend(&rf1,"rf1",0) + rfupd);
    }
    
        
    trapezoid((WF_PROCESSOR)wg_gy1,"gy1",
              &gy1,&gy1a,&gy1d,
              pw_gy1,pw_gy1a,pw_gy1d,
              ia_gy1,ia_gy1wa,ia_gy1wb,
              0,0,temp1,TRAP_ALL_SLOPED,
                          &loggrd);

    
    if (ygmn_type == CALC_GMN1) {
	temp1 = pbeg(&gy1a, "gy1a", 0) - pw_gymn2 - pw_gymn2d;
	     

  trapezoid((WF_PROCESSOR)wg_gymn2, "gymn2", &gymn2, &gymn2a,
                        &gymn2d, pw_gymn2, pw_gymn2a, pw_gymn2d,
                        ia_gymn2, 0, 0, 0, 0, temp1-pw_gymn2a, TRAP_ALL,
                        &loggrd);
 
	temp1 = pbeg(&gy1a, "gy1a", 0) - pw_gymn2_tot - pw_gymn1 - pw_gymn1d;
	     

  trapezoid((WF_PROCESSOR)wg_gymn1, "gymn1", &gymn1, &gymn1a,
                        &gymn1d, pw_gymn1, pw_gymn1a, pw_gymn1d,
                        ia_gymn1, 0, 0, 0, 0, temp1-pw_gymn1a, TRAP_ALL,
                        &loggrd);
 
    }
    
    /* Z prephaser ************************************************************/
    if (oppseq != PSD_SE || zgmn_type == CALC_GMN1) {
        if(ss_rf1 == PSD_ON)
        {
#if defined(IPG_TGT) || defined(MGD_TGT)
	   temp1 = RDN_GRD(pend(&gzrf1, "gzrf1", gzrf1.ninsts-1) + pw_gz1a);
#elif defined(HOST_TGT)
           temp1 = RDN_GRD(pend(&gzrf1d, "gzrf1d", gzrf1.ninsts-1) + pw_gz1a);
#endif
        }
        else
        {
	    temp1 = RDN_GRD(pendall(&gzrf1d, gzrf1.ninsts-1) + pw_gz1a);	
        }       

	/*jwg bb change start time of rephaser to decay ramp if needed*/
	if( opuser20 == 0) /*using default fat/water spsp rf*/
	{ 
	temp1 = RDN_GRD(pendall(&gzrf1, gzrf1.ninsts-1) + pw_gz1a); 
	} 
	else 
	{
	if ((int)opuser20 == 1)  /*only move to end of decay ramp if using a sinc, which is case 1*/
	{
	temp1 = RDN_GRD(pendall(&gzrf1d, gzrf1.ninsts-1) + pw_gz1a);			
	} 
	else /*using c13 spsp rf, no decay ramp */
	{ 
	temp1 = RDN_GRD(pendall(&gzrf1, gzrf1.ninsts-1) + pw_gz1a); 
	}
	}	
	
	/*fprintf(stderr,"rephaser starts at %d",temp1);*/
	      

  trapezoid((WF_PROCESSOR)wg_gz1, "gz1", &gz1, &gz1a,
                        &gz1d, pw_gz1, pw_gz1a, pw_gz1d,
                        ia_gz1, 0, 0, 0, 0, temp1-pw_gz1a, TRAP_ALL,
                        &loggrd);

	
	if (zgmn_type == CALC_GMN1) {
            temp1 += (pw_gz1 + pw_gz1d + pw_gzmna);
                  

  trapezoid((WF_PROCESSOR)wg_gzmn, "gzmn", &gzmn, &gzmna,
                        &gzmnd, pw_gzmn, pw_gzmna, pw_gzmnd,
                        ia_gzmn, 0, 0, 0, 0, temp1-pw_gzmna, TRAP_ALL,
                        &loggrd);
 
	}
    }
    
    /* Added for Inversion.e */
      
  {
    pulsename(&rf2se1,"rf2se1");
    createreserve(&rf2se1,(WF_PROCESSOR)wg_rf2se1,
		  res_rf2se1);
  }

    
    /* X killer pulse *********************************************************/
    if (eosxkiller == PSD_ON) {
	tempx = RUP_GRD(pend(&gxwde,"gxwde",0) + gkdelay + pw_gxka);
	     

  trapezoid((WF_PROCESSOR)wg_gxk, "gxk", &gxk, &gxka,
                        &gxkd, pw_gxk, pw_gxka, pw_gxkd,
                        ia_gxk, 0, 0, 0, 0, tempx-pw_gxka, TRAP_ALL,
                        &loggrd);

    }
    
    /* Y killer pulse *****************************************************/
    if (eosykiller == PSD_ON) {
	tempy = RUP_GRD(pend(&gxwde,"gxwde",0) + gkdelay + pw_gyka);
	     

  trapezoid((WF_PROCESSOR)wg_gyk, "gyk", &gyk, &gyka,
                        &gykd, pw_gyk, pw_gyka, pw_gykd,
                        ia_gyk, 0, 0, 0, 0, tempy-pw_gyka, TRAP_ALL,
                        &loggrd);

    }
    
    /* Z killer pulse *****************************************************/
    if (eoszkiller == PSD_ON) {
	tempz = RUP_GRD(pend(&gxwde,"gxwde",0) + gkdelay + pw_gzka);
	     

  trapezoid((WF_PROCESSOR)wg_gzk, "gzk", &gzk, &gzka,
                        &gzkd, pw_gzk, pw_gzka, pw_gzkd,
                        ia_gzk, 0, 0, 0, 0, tempz-pw_gzka, TRAP_ALL,
                        &loggrd);

    }

    /* Add MRE waveforms */
/* Start inline from touch.e TouchPg */
/* Put the motion-encoding gradients and trigger pulses into the sequence */
if( touch_flag )
{
    int pos_enc, pos_enc0, pos_enc0_2;
    short dab6on[4];
    short dab6off[4];
    int i;

    dab6on[0] = SSPDS + EDC;
    dab6on[1] = SSPOC + DREG;
    dab6on[2] = SSPD + DABOUT6; /* SSPD+2*DSCP */
    dab6on[3] = SSPDS + 0x8000;
    dab6off[0] = SSPDS + EDC;
    dab6off[1] = SSPOC + DREG;
    dab6off[2] = SSPD;
    dab6off[3] = SSPDS + 0x8000;

    /* ***************************************************************
     Encoding gradients
     *****************************************************************/
    /* pos_enc will be the start of the motion-encoding gradients */
    if( oppseq == PSD_SE )
    {
        if( meg_mode == 0 )
        { /* left-side-only MEGs */
            if( opfcomp )
            {
                pos_enc0 = pend(&gzmnd, "gzmnd", 0); /* if flow comp. is on, MEG's start after GZMN . . . */
            }
            else
            {
                pos_enc0 = pendall(&gzrf1, gzrf1.ninsts - 1); /* otherwise they start after RF1 */
            }
        }
        else
        {
            pos_enc0 = RUP_GRD(pbeg(&gzrf2, "gzrf2", 0) + pw_gzrf2/ 2 - rf2_time/ 2 - touch_time); /* if there will be MEG's on both sides of RF2, position them in a symmetric and synchronized fashion */
        }
    }
    else
    {
        pos_enc0 = ((opfcomp) ? pend(&gzmnd, "gzmnd", 0) : pend(&gz1d, "gz1d", 0)); /* for GRE EPI, put the MEG's after GZ1, or GZMN if flow comp. is on */
    }
    pos_enc0 = RUP_GRD(pos_enc0);
    pos_enc = pos_enc0;
    if( touch_fcomp == 1 )
    {
        if( touch_gnum )
        {
            AddEncodeFcomp(pos_enc, 0);
            AddEncodeDown(pos_enc + touch_lobe_meg, 0);
            pos_enc += touch_period_meg;
            for( i = 1; i < touch_gnum; i++ )
            {
                AddEncodeUp(pos_enc, 0);
                AddEncodeDown(pos_enc + touch_lobe_meg, 0);
                pos_enc += touch_period_meg;
            }
            AddEncodeFcomp(pos_enc, 0);
        }
    }
    else if( touch_fcomp == 2 )
    {
        if( touch_gnum )
        {
            AddEncodeFcomp(pos_enc, 0);
            AddEncodeDown(pos_enc + touch_lobe_meg/ 2, 0);
            pos_enc += 3 * touch_lobe_meg/ 2;
            for( i = 1; i < touch_gnum; i++ )
            {
                AddEncodeUp(pos_enc, 0);
                AddEncodeDown(pos_enc + touch_lobe_meg, 0);
                pos_enc += touch_period_meg;
            }
            AddEncodeFcomp(pos_enc, 0);
        }
    }
    else
    {
        if( touch_gnum > 0 )
        {
            for( i = 0; i < ceil(touch_gnum); i++ )
            {
                AddEncodeUp(pos_enc, 0);
                if( ((int)touch_gnum) == ceil(touch_gnum) )
                { /* if full MEG, always add down MEG */
                    AddEncodeDown(pos_enc + touch_lobe_meg, 0);
                }
                else
                { /* if half MEG, don't add last down MEG */
                    if( i < (ceil(touch_gnum) - 1) )
                    {
                        AddEncodeDown(pos_enc + touch_lobe_meg, 0);
                    }
                }
                pos_enc += touch_period_meg;
            }
        }
    }

    /* 2nd set of MEGs after the refocusing pulse */
    if( meg_mode >= 1 )
    {
        pos_enc0_2 = RUP_GRD(pos_enc0 + touch_time + rf2_time);
        pos_enc = pos_enc0_2;

        if( touch_fcomp == 1 )
        {
            if( touch_gnum )
            {
                AddEncodeFcomp(pos_enc, 1);
                AddEncodeDown(pos_enc + touch_lobe_meg, 1);
                pos_enc += touch_period_meg;
                for( i = 1; i < touch_gnum; i++ )
                {
                    AddEncodeUp(pos_enc, 1);
                    AddEncodeDown(pos_enc + touch_lobe_meg, 1);
                    pos_enc += touch_period_meg;
                }
                AddEncodeFcomp(pos_enc, 1);
            }
        }
        else if( touch_fcomp == 2 )
        {
            if( touch_gnum )
            {
                AddEncodeFcomp(pos_enc, 1);
                AddEncodeDown(pos_enc + touch_lobe_meg/ 2, 1);
                pos_enc += 3 * touch_lobe_meg/ 2;
                for( i = 1; i < touch_gnum; i++ )
                {
                    AddEncodeUp(pos_enc, 1);
                    AddEncodeDown(pos_enc + touch_lobe_meg, 1);
                    pos_enc += touch_period_meg;
                }
                AddEncodeFcomp(pos_enc, 1);
            }
        }
        else
        {
            if( touch_gnum > 0 )
            {
                for( i = 0; i < ceil(touch_gnum); i++ )
                {
                    AddEncodeUp(pos_enc, 1);
                    if( ((int)touch_gnum) == ceil(touch_gnum) )
                    { /* if full MEG, always add down MEG */
                        AddEncodeDown(pos_enc + touch_lobe_meg, 1);
                    }
                    else
                    { /* if half MEG, don't add last down MEG */
                        if( i < (ceil(touch_gnum) - 1) )
                        {
                            AddEncodeDown(pos_enc + touch_lobe_meg, 1);
                        }
                    }
                    pos_enc += touch_period_meg;
                }
            }
        }
    }

    /* ********************
     Sync Pulses
     *******************/
    int pos_sync = touch_pos_sync;

    /* if overlapping trigger pulses with the MEG's, start the trigger pulses after RF1, otherwise put them at the beginning of the sequence */
    pos_sync = pendallssp(&hyperdab, 0) + (multi_phases - 1.) * touch_delta + cont_drive_ssp_delay;

    while( pos_sync < 40   )
        pos_sync += act_tr + time_ssi;
    for( i = 0; i < multi_phases; i++ )
    {
           
  {
    pulsename(&sync_on_2,"sync_on_2");
    createbits(&sync_on_2,TYPSSP,sizeof(dab6on)/2,dab6on);
    createinstr( &sync_on_2,(long)(pos_sync),
		4,ia_sync_on_2);
  }

           
  {
    pulsename(&sync_off_2,"sync_off_2");
    createbits(&sync_off_2,TYPSSP,sizeof(dab6off)/2,dab6off);
    createinstr( &sync_off_2,(long)(pos_sync+touch_sync_pw-4),
		4,ia_sync_off_2);
  }

        pos_sync -= touch_delta;
    }
    getwave(&wave_trigon, &sync_on_2);
    getwave(&wave_trigoff, &sync_off_2);
}
/* End inline from touch.e TouchPg */


    /* RHO killer? pulse ***********************************************/
    /* This pulse is specific to MGD.  It forces the RHO sequencer to  */
    /* EOS after all other RF sequencers (omega & theta) as a temp fix */
    /* for a sequencer buffer glitch.                                  */

    if (eosrhokiller == PSD_ON) {

        int pw_rho_killer = 2;
        int ia_rho_killer = 0;

	tempz = RUP_GRD(pend(&gxwde,"gxwde",0) + gkdelay + pw_gzka);
        pulsename(&rho_killer,"rho_killer");
        createconst(&rho_killer,RHO,pw_rho_killer,MAX_PG_WAMP);
        createinstr( &rho_killer,(long)(tempz),
                     pw_rho_killer,ia_rho_killer);
    }
   
#ifdef IPG
    /*
     * Execute this code only on the Tgt side
     */
    /* Major "Wait" Pulses ************************************************/
    if (gy1pos == PSD_POST_180)
        tempy = pbeg(&gy1a, "gy1a", 0) - pw_wgy;
    else
        tempy = pbeg(&gyba, "gyba", 0) - pw_wgy;
    
    if (ygmn_type == CALC_GMN1)
        tempy = pbeg(&gymn1a, "gymn1a", 0) - pw_wgy;
    
    if (gx1pos == PSD_POST_180)
        tempx = pbeg(&gx1a, "gx1a", 0) - pw_wgx;
    else
        tempx = pbeg(&gxwa, "gxwa", 0) - pw_wgx;
    
    /* TFON sliding data acq. window wait intervals */
        
  {
    pulsename(&wgx,"wgx");
    createconst(&wgx,(WF_PROCESSOR)wg_wgx,pw_wgx,(short)0); 
    createinstr( &wgx,(long)(tempx),pw_wgx,0);
  }

        
  {
    pulsename(&wgy,"wgy");
    createconst(&wgy,(WF_PROCESSOR)wg_wgy,pw_wgy,(short)0); 
    createinstr( &wgy,(long)(tempy),pw_wgy,0);
  }

    
    if (oppseq == PSD_SE) {
	tempz = pendall(&gzrf2r1, 0);
    } else {
	if (zgmn_type == CALC_GMN1) {
            tempz = pendall(&gzmnd, 0);
        } else {
            tempz = pendall(&gz1d, 0); /*jwg bb i think there may be a problem here, come back to*/
        }
    }
 
    /* For MR-Touch, match with wgx by using tempx instead of tempz */
           
  {
    pulsename(&wgz,"wgz");
    createconst(&wgz,(WF_PROCESSOR)wg_wgz,pw_wgz,(short)0); 
    createinstr( &wgz,(long)(touch_flag?tempx:tempz),pw_wgz,0);
  }


    if (oppseq == PSD_SE) {
        temps = pendall(&rf2, 0) + rfupd + 4  ;
    } else {
        temps = pendall(&rf1, 0) + rfupd + 4   + (int)HSDAB_length;
    }

       
  {
    pulsename(&wssp,"wssp");
    createconst(&wssp,(WF_PROCESSOR)wg_wssp,pw_wssp,(short)0); 
    createinstr( &wssp,(long)(temps),pw_wssp,0);
  }

    
    pw_sspdelay  = _pw_sspdelay.fixedflag ?      ((void)(defaultdelay+1), pw_sspdelay) : defaultdelay+1;	/* 1us is the min time for ssp,
					   per L. Ploetz. YPD */
         
  {
    pulsename(&sspdelay,"sspdelay");
    createconst(&sspdelay,(WF_PROCESSOR)wg_sspdelay,pw_sspdelay,(short)0); 
    createinstr( &sspdelay,(long)(temps+pw_wssp),pw_sspdelay,0);
  }

    
    pw_omegadelay  = _pw_omegadelay.fixedflag ?    ((void)(RUP_RF(defaultdelay+2)), pw_omegadelay) : RUP_RF(defaultdelay+2); /* 2us is the min time for omega,
                                                 per L. Ploetz. YPD */
        
  {
    pulsename(&omegadelay,"omegadelay");
    createconst(&omegadelay,(WF_PROCESSOR)wg_omegadelay,pw_omegadelay,(short)0); 
    createinstr( &omegadelay,(long)(RUP_GRD(temps)),pw_omegadelay,0);
  }

    
       
  {
    pulsename(&womega,"womega");
    createconst(&womega,(WF_PROCESSOR)wg_womega,pw_womega,(short)0); 
    createinstr( &womega,(long)(RUP_GRD(temps)+pw_omegadelay),pw_womega,0);
  }

    
    /* pulse names for Omega Freq Mod pulses */ 
    pulsename(&rs_omega_attack, "rs_omega_attack");
    pulsename(&rs_omega_decay, "rs_omega_decay");
    pulsename(&omega_flat, "omega_flat");

    /* internref: use tot_etl instead of etl */
    for (echoloop = 0; echoloop < tot_etl; echoloop++ ) {
        getssppulse(&(echotrainrba[echoloop]), &(echotrain[echoloop]), "rba", 0);

        {   /* local scope */

            int time_offset = 0;
            pulsepos  = _pulsepos.fixedflag ?   ((void)(pendallssp(echotrainrba[echoloop],0)), pulsepos) : pendallssp(echotrainrba[echoloop],0); 
            time_offset = pw_gxwad - dacq_offset;  
 
            /* TURN TNS ON at the first etl and OFF at the last etl so that */
            /* the xtr and TNS do not overlap. */
            if ( echoloop == 0) 
  {
    e1entns_pack[0] = SSPDS+EDC;
    pulsename(&e1entns,"e1entns");
    createbits(&e1entns,TYPSSP,4,e1entns_pack);
    createinstr( &e1entns,(LONG)(pulsepos),4,0);
  }

            if ( echoloop == tot_etl-1)   
  {
    e1distns_pack[0] = SSPDS+EDC;
    pulsename(&e1distns,"e1distns");
    createbits(&e1distns,TYPSSP,4,e1distns_pack);
    createinstr( &e1distns,(LONG)(pulsepos+(int)(tsp*(float)rhfrsize)),4,0);
  }


            if (vrgfsamp) {
	        /*jwg bb change first variable from OMEGA to wg_omegaro1 so we can broadband this sucker*/
                trapezoid( wg_omegaro1,"omega", &omega_flat, 
                           &rs_omega_attack, &rs_omega_decay,
                           pw_gxwl+pw_gxw+pw_gxwr,  pw_gxwad, pw_gxwad, 
                           ia_omega,ia_omega,ia_omega, 0, 0, 
                           RUP_RF(pulsepos-time_offset+start_pulse), TRAP_ALL, &loggrd);    
            } else {
                
                /* BJM: to offset frequency, play constant on omega */
		/* jwg bb and we'll do the same thing down here, in case we're not ramp sampling*/
                createconst(&omega_flat, wg_omegaro1, pw_gxw, max_pg_wamp);
                createinstr(&omega_flat, RUP_RF(pulsepos+start_pulse), pw_gxw, ia_omega);
            }

        }
    }
    
    /* 4us for the e1distns pack */
    temps = pendallssp(&echotrain[tot_etl-1], 0) + (int)(tsp*(float)rhfrsize)+ 4; 
    
     
  {
  pulsename(&atten,"atten");
  createatten(&atten, (long)(temps));
}



    /* spring for sspdelay */
         
  {
    pulsename(&sspshift,"sspshift");
    createconst(&sspshift,(WF_PROCESSOR)wg_sspshift,pw_sspshift,(short)0); 
    createinstr( &sspshift,(long)(temps+7  ),pw_sspshift,0);
  }

    
    temps = pendallssp(&sspshift, 0);
   
    for (i=0; i<num_passdelay; i++) { 
           
  {
    pulsename(&ssp_pass_delay,"ssp_pass_delay");
    createconst(&ssp_pass_delay,(WF_PROCESSOR)wg_ssp_pass_delay,pw_ssp_pass_delay,(short)0); 
    createinstr( &ssp_pass_delay,(long)(temps),pw_ssp_pass_delay,0);
  }

        temps = pendallssp(&ssp_pass_delay, i);
    }
    
    
     
  {
    pulsename(&pass_pulse,"pass_pulse");
    createpass(&pass_pulse,(long)(temps));
  }


    /*jwg bb testing out different delays here to try and fix the shifts in PE direction*/    
    temps = pendallssp(&pass_pulse, 0);
      
  {
    pulsename(&jwg_delay,"jwg_delay");
    createconst(&jwg_delay,(WF_PROCESSOR)wg_jwg_delay,pw_jwg_delay,(short)0); 
    createinstr( &jwg_delay,(long)(temps),pw_jwg_delay,0);
  }

    /*jwg bb end*/

    if (touch_flag) {
        /* Add WAIT pulse to SSP to sync trigger pulses with MEG */
           
  {
    pulsename(&touch_wssp,"touch_wssp");
    createconst(&touch_wssp,(WF_PROCESSOR)wg_touch_wssp,pw_touch_wssp,(short)0); 
    createinstr( &touch_wssp,(long)(pendallssp(&pass_pulse,0)),pw_touch_wssp,0);
  }

    }

#endif /* IPG */
    
    /* Actual deadtimes for cardiac scans will be rewritten later */
    if(opcgate==PSD_ON)
	    psd_seqtime = RUP_GRD(tmin);
    else
    {
        if(tr_corr_mode == 0) psd_seqtime = RUP_GRD(act_tr/slquant1 - time_ssi);
        else psd_seqtime = RDN_GRD(act_tr/slquant1 - time_ssi);
    }
    
    
  {
    pulsename(&seqcore,"seqcore");
    createseq(&seqcore,psd_seqtime, off_seqcore);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcore );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcore = %d\n", idx_seqcore );
#endif
  }

    
    getperiod(&scan_deadtime, &seqcore, 0);

    if(opcgate == PSD_OFF)
    {
        int num;
        /* To make sure repetition time is exactly equal to act_tr */
        scan_deadtime_correct = (long *)AllocNode((slquant1 + 2)*sizeof(long));
        switch(tr_corr_mode)
        {
            case 0:
                for(i=0; i<slquant1; i++)
                {
                     scan_deadtime_correct[i] = scan_deadtime;
                }
            break;

            case 1:
                num = (act_tr - (psd_seqtime+time_ssi)*slquant1)/GRAD_UPDATE_TIME;
                for(i=0; i<slquant1; i++)
                {
                    if(i<num) scan_deadtime_correct[i] = scan_deadtime+GRAD_UPDATE_TIME;
                    else scan_deadtime_correct[i] = scan_deadtime;
                }
            break;

            case 2:
                for(i=0; i<slquant1-1; i++)
                {
                    scan_deadtime_correct[i] = scan_deadtime;
                }
                scan_deadtime_correct[slquant1-1] = scan_deadtime + act_tr - (psd_seqtime+time_ssi)*slquant1; 
            break;
        }
    }

    /* BJM: SE Ref Scan */

if(se_ref == PSD_ON) {

    /* BJM: reuse all the pulse parameters of the imaging sequence */
    /* spsp 90 RF slice select pulse *******************************************/
    temp_res = res_rf1;
    if (rfpulseInfo[RF1_SLOT].change == PSD_ON)  /* set to new resolution */
        res_rf1  = _res_rf1.fixedflag ?  ((void)(rfpulseInfo[RF1_SLOT].newres), res_rf1) : rfpulseInfo[RF1_SLOT].newres;
    
    /* set rfunblank_bits[2] so that addrfbits in sliceselz does not
       unblank the receiver - see EpicConf.c for defaults. Will unblank
       the receiver later - MRIge28778 */
    
    rfunblank_bits[0][2] = SSPD;
    rfunblank_bits[1][2] = SSPD;

    {
      /* Now create the pulses */
      pulsename(&gzrf1refa,"gzrf1refa");
      pulsename(&gzrf1ref,"gzrf1ref");
      pulsename(&gzrf1refd,"gzrf1refd");
      pulsename(&rf1ref,"rf1ref");
      pulsename(&thetarf1ref, "thetarf1ref");

      /*  Now create the slice select trapezoid */
      pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;

      if ( gztype == PLAY_GFILE) {

#if defined(IPG_TGT) || defined(MGD_TGT)
          /* Use external gradient file for now */
          createextwave( &gzrf1ref, ZGRAD, res_gzrf1,
                         grad_zrf1);

          createinstr( &gzrf1ref, (long)pos_start+pw_gzrf1a,
                       pw_gzrf1, ia_gzrf1 );

#elif defined(HOST_TGT)
          /* Create train of trapezoids on the Host side */
          int i;
          int polarity = 1;
       
          pulsepos  = _pulsepos.fixedflag ?  ((void)(pos_start+pw_gzrf1a), pulsepos) : pos_start+pw_gzrf1a; 
       
          for(i = 1; i <= num_rf1lobe; i++) {
              polarity *= -1;

              trapezoid( ZGRAD,"gzrf1ref", &gzrf1ref, 
                         &gzrf1refa, &gzrf1refd,
                         pw_constant, pw_ss_rampz, pw_ss_rampz, 
                         (polarity*(ia_gzrf1)),
                         (polarity*(ia_gzrf1)),
                         (polarity*(ia_gzrf1)), 0, 0, 
                         pulsepos, TRAP_ALL, &loggrd );

              pulsepos  = _pulsepos.fixedflag ?      ((void)(pw_constant+2*pw_ss_rampz), pulsepos) : pulsepos+pw_constant+2*pw_ss_rampz;
          }
#endif

      } else {

          /* Create simple trapezoid for chem sat + rf */
          createramp( &gzrf1refa,ZGRAD,pw_gzrf1a,
                      (short)0, max_pg_wamp,
                      (short)(maxGradRes *
                              (pw_gzrf1a/ GRAD_UPDATE_TIME)),
                      pg_beta );

          createinstr( &gzrf1refa,
                       (long)(pos_start+pw_gzrf1a - pw_gzrf1a),
                       pw_gzrf1a, ia_gzrf1 );

          createconst( &gzrf1ref, ZGRAD, pw_rf1, max_pg_wamp );
          createinstr( &gzrf1ref, (long)pos_start+pw_gzrf1a,
                       pw_gzrf1, ia_gzrf1 );

          createramp( &gzrf1refd, ZGRAD, pw_gzrf1d,
                      max_pg_wamp, (short)0,
                      (short)(maxGradRes *
                              (pw_gzrf1d/ GRAD_UPDATE_TIME)),
                      pg_beta );
          createinstr( &gzrf1refd,
                       (long)(pos_start+pw_gzrf1a + pw_gzrf1),
                       pw_gzrf1d, ia_gzrf1 );

      }

      /* Now create the rf pulse */
      if ( rftype == PLAY_RFFILE) {
          createextwave( &rf1ref,TYPRHO1, res_rf1,
                         rf_rf1);
      } else {
          createsinc( &rf1ref,TYPRHO1, res_rf1,
                      max_pg_wamp,cyc_rf1, alpha_rf1 );
      }

      createinstr( &rf1ref,(long)pos_start+pw_gzrf1a + psd_rf_wait +
                   ss_rf_wait,  pw_rf1,ia_rf1);

      addrfbits( &rf1ref, off_rf1, (long)pos_start+pw_gzrf1a +
                 psd_rf_wait + ss_rf_wait, pw_rf1 );

      /* Now create the theta pulse */
      if ( thetatype == PLAY_THETA) {
          createextwave( &thetarf1ref, TYPOMEGA,
                         res_thetarf1, theta_rf1);

          createinstr( &thetarf1ref, (long)pos_start+pw_gzrf1a + psd_rf_wait +
                       ss_rf_wait, pw_thetarf1,
                       ia_thetarf1);

          addrfbits( &thetarf1ref, off_thetarf1,
                     (long)pos_start+pw_gzrf1a + psd_rf_wait + ss_rf_wait,
                     pw_thetarf1 );
      }
#if defined(IPG_TGT) || defined(MGD_TGT)
      if ( gztype == PLAY_GFILE) {
          linkpulses( 3,
                      &rf1ref, &gzrf1ref, &thetarf1ref);
      } else {
          linkpulses( 4,
                      &rf1ref, &gzrf1ref,
                      &gzrf1refa, &gzrf1refd);
      }
#endif
  }
    
    /* reset the bit */
    rfunblank_bits[0][2] = SSPD + RUBL;
    rfunblank_bits[1][2] = SSPD + RUBL;
    
    if (rfpulseInfo[RF1_SLOT].change == PSD_ON)  /* change back for ext. file */
        res_rf1  = _res_rf1.fixedflag ?  ((void)(temp_res), res_rf1) : temp_res;
    
    /* 180 RF refocusing pulse ********************************************/
    Rf2Location[0] = RUP_GRD((int)(pend(&rf1ref,"rf1ref",0) - rfExIso  + refScanTe/2
                                       - pw_rf2/2) - psd_rf_wait);  /* Find start loc of 180s */
        
        /* MRIge58235: moved uextwave to here so the file read from disk is always read with orig. res_rf2 */
    strcpy(ext_filename, "rfse1b4.rho");
        
    /* Create some RHO waveform space, read in the 
       se1b4 spin echo 180 to local memory, and then move
       the local memory to the reserved RHO memory.
     */
    temp_wave_space = (short *)AllocNode(res_rf2*sizeof(short));
    uextwave(temp_wave_space, res_rf2, ext_filename);
        
    {
        /* MRIge58235: save orig. res_rf2ref for scaling */
        short orig_res;
            
        orig_res = res_rf2;
        if (rfpulseInfo[RF2_SLOT].change==PSD_ON)
            res_rf2  = _res_rf2.fixedflag ?  ((void)(rfpulseInfo[RF2_SLOT].newres), res_rf2) : rfpulseInfo[RF2_SLOT].newres;     /* Set to new resolution */
            
        /* set rfunblank_bits[2] so that addrfbits in sliceselz does not
           unblank the receiver - see EpicConf.c for defaults. Will unblank
           the receiver later - MRIge28778 */
        rfunblank_bits[0][2] = SSPD;
        rfunblank_bits[1][2] = SSPD;

        /*  180 slice sel pulse  */
        {
            /* First create the pulses */
            pulsename(&gzrf2refa,"gzrf2refa");
            pulsename(&gzrf2ref,"gzrf2ref");
            pulsename(&gzrf2refd,"gzrf2refd");
            pulsename(&rf2ref,"rf2ref");

            /*  Now create the slice select trapezoid */
            pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;
            createramp(&gzrf2refa,ZGRAD,pw_gzrf2a,(short)0,
                       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2a/
                                                       GRAD_UPDATE_TIME)),pg_beta);
            createinstr( &gzrf2refa,(long)(Rf2Location[0]-pw_gzrf2a),
                         pw_gzrf2a,ia_gzrf2);
            createconst(&gzrf2ref,ZGRAD,pw_gzrf2,MAX_PG_WAMP);
            createinstr( &gzrf2ref,(long)(Rf2Location[0]),
                         pw_gzrf2,ia_gzrf2);
            createramp(&gzrf2refd,ZGRAD,pw_gzrf2d,MAX_PG_WAMP,
                       (short)0,(short)(maxGradRes*(pw_gzrf2d/GRAD_UPDATE_TIME)),
                       pg_beta);
            createinstr( &gzrf2refd,(long)(Rf2Location[0]+pw_gzrf2),
                         pw_gzrf2d,ia_gzrf2);

            /* Now create the rf pulse */
            createsinc(&rf2ref,TYPRHO1,res_rf2,
                       MAX_PG_WAMP,cyc_rf2, alpha_rf2);
            createinstr( &rf2ref,(long)(Rf2Location[0]) + psd_rf_wait,
                         pw_rf2,ia_rf2);
            linkpulses(4,&rf2ref,&gzrf2ref,&gzrf2refa,
                       &gzrf2refd);
            addrfbits(&rf2ref,off_rf2,(long)(Rf2Location[0]) + psd_rf_wait, 
                      pw_rf2);
        }

        /* reset the bit */
        rfunblank_bits[0][2] = SSPD + RUBL;
        rfunblank_bits[1][2] = SSPD + RUBL;

        /* Stretch rf pw if needed */
        if (rfpulseInfo[RF2_SLOT].change==PSD_ON) {
            wave_space = (short *)AllocNode(rfpulseInfo[RF2_SLOT].newres*
                                            sizeof(short));
            stretchpulse((int)orig_res, (int)rfpulseInfo[RF2_SLOT].newres,
                         temp_wave_space,wave_space);
            FreeNode(temp_wave_space);
        } else {
            wave_space = temp_wave_space;
        }

        /* Assign temporary board memory and move immediately into permanent
           memory */
        res_rf2se1b4  = _res_rf2se1b4.fixedflag ?  ((void)(res_rf2), res_rf2se1b4) : res_rf2;
        pulsename(&rf2se1b4_ref,"rf2se1b4_ref");
        createreserve(&rf2se1b4_ref,RHO, res_rf2se1b4);
        movewaveimm(wave_space, &rf2se1b4_ref, (int)0, res_rf2, TOHARDWARE);
        FreeNode(wave_space);

        /* MRIge58235: reset res_rf2 after scaling */
        res_rf2  = _res_rf2.fixedflag ?  ((void)(orig_res), res_rf2) : orig_res;
    }

    setphase((float)(PI/-2.0), &rf2ref, 0);  /* Apply 90 phase shift to  180 */

    attenflagon(&rf1ref, 0);                 /* Assert ESSP flag on rf1 pulse */

    attenflagon(&rf2ref, 0);                 /* Assert ESSP flag on 1st rf2 */

    /* Z crushers (echo 1) ***********************************************/
    trapezoid(ZGRADB, "gzrf2refl1", &gzrf2refl1, &gzrf2refl1a,
              &gzrf2refl1d, pw_gzrf2l1, pw_gzrf2l1a, pw_gzrf2l1d,
              ia_gzrf2l1, 0, 0, 0, 0, pbeg(&gzrf2ref,"gzrf2ref",0)-(pw_gzrf2l1+pw_gzrf2l1d)-pw_gzrf2l1a, TRAP_ALL,
              &loggrd);

    trapezoid(ZGRADB, "gzrf2refr1", &gzrf2refr1, &gzrf2refr1a,
              &gzrf2refr1d, pw_gzrf2r1, pw_gzrf2r1a, pw_gzrf2r1d,
              ia_gzrf2r1, 0, 0, 0, 0, pend(&gzrf2ref,"gzrf2refd",0)-pw_gzrf2r1a, TRAP_ALL,
              &loggrd);

    /* unblank receiver rcvr_ub_off us prior to first xtr/dab/rba packet */
    /* BJM: move DAB packet after RF for less upfront deadtime */
    getssppulse(&rf2ssp_end, &rf2ref, "ubr", 0);
    rcvrunblankpos = pendallssp(rf2ssp_end, 0);
     
  {
    rec_unblankref_pack[0] = SSPDS+RDC;
    rec_unblankref_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rec_unblankref_pack[2] = SSPD+RUBL;
    rec_unblankref_pack[3] = SSPDS;

    pulsename(&rec_unblankref,"rec_unblankref");
    createbits(&rec_unblankref,TYPSSP,4,rec_unblankref_pack);
    createinstr( &rec_unblankref,(long)(rcvrunblankpos),4,ia_rec_unblankref);
  }


    /***********************************************************************/
    /* X EPI readout train                                                 */
    /***********************************************************************/

    /* These arrays are used to hold the addresses of the data acq pulses.. */
    echotrainxtr_ref = (WF_PULSE **)AllocNode(tot_etl*sizeof(WF_PULSE *));
    echotrainrba_ref = (WF_PULSE **)AllocNode(tot_etl*sizeof(WF_PULSE *));

    /* BJM: pkt_delay is included to account for any delay between */
    /* sending the RBA and the first sample acquired (hardware delay) */
    if (vrgfsamp == PSD_ON) {
        dacq_offset  = _dacq_offset.fixedflag ?      
              
                          ((void)(pkt_delay+pw_gxwad-(int)(fbhw*((float)pw_gyb/2.0+(float)pw_gybd)+0.5)), dacq_offset) : pkt_delay+pw_gxwad-(int)(fbhw*((float)pw_gyb/2.0+(float)pw_gybd)+0.5);
    } else {
        dacq_offset  = _dacq_offset.fixedflag ?  ((void)(pkt_delay), dacq_offset) : pkt_delay;
    }

    /* MRIge58023 & 58033 need to RUP_GRD entire expression */
    if (intleaves == opyres) {
        tempx = RUP_GRD((int)(pend(&rf1ref,"rf1ref",0) - rfExIso + refScanTe - pw_gxw/2 - pw_gxwl - ky_offset*esp/intleaves));
    } else {
        tempx = RUP_GRD((int)(pend(&rf1ref,"rf1ref",0) - rfExIso + refScanTe - echoOffset * esp - ky_offset*esp/intleaves + 1000));
    }

    tempy = tempx + gydelay;
    tempz = tempx;
    tempx += gxdelay;

    /* Set up for EP_TRAIN */
    stddab = (hsdab==PSD_ON ? 0:1);
    pg_tsp =0;

    
                    
                  
                  
                  
                  
                  
                  
                    
                  
                  
                  
                  
                  
    {
        int psd_gxwcnt;
        int psd_pulsepos;
        int psd_eparity;
        long psd_epxtroff;
        long psd_epdaboff;
        float psd_etbetax;
        float psd_etbetay;
        char psd_epstring[EPSTRING_LENGTH];

        psd_pulsepos = RUP_GRD(tempx+pw_gxwad);           
 
        if ( 0 == 0 ) {
            refechotrain = (WF_PULSE *)AllocNode((tot_etl + 3) * sizeof(WF_PULSE));
        }
 
        pulsename(&refgxcla, "refgxcla");
        pulsename(&refgxcl, "refgxcl");
        pulsename(&refgxcld, "refgxcld");
 
        pulsename(&refgxwa, "refgxwa");
        pulsename(&refgxw, "refgxw");
        pulsename(&refgxwd, "refgxwd");
        pulsename(&refgxwde, "refgxwde");
 
        pulsename(&refgxgap, "refgxgap");
 
        pulsename(&refgyba, "refgyba");
        pulsename(&refgyb, "refgyb");
        pulsename(&refgybd, "refgybd");
 
        pulsename(&refgxcra, "refgxcra");
        pulsename(&refgxcr, "refgxcr");
        pulsename(&refgxcrd, "refgxcrd");
 
        getbeta(&psd_etbetax, XGRAD, &epiloggrd);
        getbeta(&psd_etbetay, YGRAD, &epiloggrd);
 
        if (pw_gxcla >= GRAD_UPDATE_TIME) {
            createramp(&refgxcla, XGRAD, pw_gxcla, (short)0,
                       (short)ia_gxcl, (short)(maxGradRes*(pw_gxcla/
                       GRAD_UPDATE_TIME)), psd_etbetax);
            createinstr(&refgxcla, (long)psd_pulsepos,
                        pw_gxcla, max_pg_iamp);
            psd_pulsepos += pw_gxcla;
        }
    
        if (pw_gxcl >= GRAD_UPDATE_TIME) {
            createconst(&refgxcl, XGRAD, pw_gxcl, max_pg_wamp);
            createinstr(&refgxcl, (long)psd_pulsepos, pw_gxcl, ia_gxcl);
            psd_pulsepos += pw_gxcl;
        }
    
        if (pw_gxcld >= GRAD_UPDATE_TIME) {
            createramp(&refgxcld, XGRAD, pw_gxcld, (short)ia_gxcl,
                       (short)ia_gxw, (short)(maxGradRes*(pw_gxcld/
                       GRAD_UPDATE_TIME)), psd_etbetax);
            createinstr(&refgxcld, (long)psd_pulsepos,
                        pw_gxcld, max_pg_iamp);
            psd_pulsepos += pw_gxcld;
        }
    
        createconst(&refgxw, XGRAD, pw_gxwl+pw_gxw+pw_gxwr, max_pg_wamp);
        createinstr(&refgxw, (long)psd_pulsepos, pw_gxwl+pw_gxw+pw_gxwr, ia_gxw);
        psd_pulsepos += pw_gxwl;
    
        sprintf(psd_epstring, "echo%04d",0);
        pulsename(&(refechotrain[0]), psd_epstring);
    
        if (dab_offset == 0)
            psd_epdaboff = 0;
        else
            psd_epdaboff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + dab_offset);            
        if (xtr_offset == 0)
            psd_epxtroff = 0;
        else
            psd_epxtroff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + xtr_offset);            
    
        epiacqq(&(refechotrain[0]),                
                (long)(psd_pulsepos + psd_grd_wait-dacq_offset),
                psd_epdaboff, psd_epxtroff,
                (long)scanslot, 
                (TYPDAB_PACKETS)DABNORM,
                (long)fast_rec,
                (long)stddab);
    
        psd_pulsepos += pw_gxw + pw_gxwr;      
    
        psd_eparity = 1;
        for (psd_gxwcnt = 2; psd_gxwcnt <= tot_etl; psd_gxwcnt++) {
            psd_eparity *= -1;
          if( psd_gxwcnt-1 > iref_etl ){ /* internref */ 
            createramp(&refgyba, YGRAD, pw_gyba, 0, max_pg_wamp,
                       (short)((maxGradRes*pw_gyba)/GRAD_UPDATE_TIME), psd_etbetay);
            createinstr(&refgyba, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 -
                        (pw_gyba + pw_gyb/2)), pw_gyba, ia_gyb);
        
            if (pw_gyb >= GRAD_UPDATE_TIME) {
                createconst(&refgyb, YGRAD, pw_gyb, max_pg_wamp);
                createinstr(&refgyb, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 -
                            pw_gyb/2), pw_gyb, ia_gyb);
            }
        
            createramp(&refgybd, YGRAD, pw_gybd, max_pg_wamp, 0,
                       (short)((maxGradRes*pw_gybd)/GRAD_UPDATE_TIME), psd_etbetay);
            createinstr(&refgybd, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 +
                        pw_gyb/2), pw_gybd, ia_gyb);
        
            linkpulses(3,&refgyb,&refgyba,&refgybd);
          } 

          createramp(&refgxwd, XGRAD, pw_gxwad, -max_pg_wamp, 0,
                           (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), psd_etbetax);
          createinstr(&refgxwd, (long)psd_pulsepos, pw_gxwad, psd_eparity*ia_gxw);
          psd_pulsepos += pw_gxwad;

          if( pw_gxgap == 0 ){
               if( (pw_iref_gxwait != 0) && (psd_gxwcnt == iref_etl) ){ 
                   createconst(&refgxgap, XGRAD, pw_iref_gxwait, 0);
                   createinstr(&refgxgap, (long)psd_pulsepos, pw_iref_gxwait, 0);
                   psd_pulsepos += pw_iref_gxwait;
               }
          }else{ 
               int gapgap;
               if( (pw_iref_gxwait == 0) || (psd_gxwcnt != iref_etl) ){
                   gapgap = pw_gxgap;
               }else{
                   gapgap = pw_gxgap+pw_iref_gxwait;
               }
               createconst(&refgxgap, XGRAD, gapgap, 0);
               createinstr(&refgxgap, (long)psd_pulsepos, gapgap, 0);
               psd_pulsepos += gapgap;
          }

          createramp(&refgxwa, XGRAD, pw_gxwad, 0, max_pg_wamp,
                     (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), psd_etbetax);
          createinstr(&refgxwa, (long)psd_pulsepos, pw_gxwad, psd_eparity*ia_gxw);
          psd_pulsepos += pw_gxwad;
        
            createconst(&refgxw, XGRAD, pw_gxwl+pw_gxw+pw_gxwr, max_pg_wamp);
            createinstr(&refgxw, (long)psd_pulsepos,
                        pw_gxwl+pw_gxw+pw_gxwr, psd_eparity*ia_gxw);
            psd_pulsepos += pw_gxwl;
        
            sprintf(psd_epstring, "echo%04d", psd_gxwcnt-1 + 0);
            pulsename(&(refechotrain[psd_gxwcnt-1+0]), psd_epstring);
        
            if (dab_offset == 0)                                           
                psd_epdaboff = 0;
            else
                psd_epdaboff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + dab_offset);
        
            if (xtr_offset == 0)
                psd_epxtroff = 0;
            else
                psd_epxtroff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + xtr_offset);
        
            epiacqq(&(refechotrain[psd_gxwcnt-1+0]),                
                    (long)(psd_pulsepos + psd_grd_wait-dacq_offset),
                    psd_epdaboff, psd_epxtroff,
                    (long)scanslot, 
                    (TYPDAB_PACKETS)DABNORM,
                    (long)fast_rec,
                    (long)stddab);
        
            psd_pulsepos += pw_gxw + pw_gxwr;      
        } 
    
        if ((tot_etl % 2) == 1) {    /* views per shot is odd */          
            if (pw_gxcra >= GRAD_UPDATE_TIME) {
                createramp(&refgxcra, XGRAD, pw_gxcra, (short)ia_gxw,
                           (short)ia_gxcr, (short)(maxGradRes*(pw_gxcra/
                           GRAD_UPDATE_TIME)), psd_etbetax);
                createinstr(&refgxcra, (long)(psd_pulsepos), pw_gxcra, max_pg_iamp);
                psd_pulsepos += pw_gxcra;
            }
        } else {                        /* views per shot is even */
            /* single transition ramp into crusher */                  
            if ((ia_gxw == ia_gxcr) && (pw_gxwad == pw_gxcra)) {
                createramp(&refgxwd, XGRAD, 2*pw_gxwad, -max_pg_wamp, max_pg_wamp,
                           (short)(maxGradRes*(2*pw_gxwad)/GRAD_UPDATE_TIME), psd_etbetax);
                createinstr(&refgxwd, (long)psd_pulsepos, 2*pw_gxwad, ia_gxw);
                psd_pulsepos += 2*pw_gxwad;
            } else {    /* two separate ramps, decay ramp needs new waveform */
                createramp(&refgxwde, XGRAD, pw_gxwad, -max_pg_wamp, 0,              
                           (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), psd_etbetax);
                createinstr(&refgxwde, (long)psd_pulsepos, pw_gxwad, ia_gxw);
                psd_pulsepos += pw_gxwad;

                if (pw_gxcra >= GRAD_UPDATE_TIME) {
                    createramp(&refgxcra, XGRAD, pw_gxcra, (short)0,
                               (short)ia_gxcr, (short)(maxGradRes*(pw_gxcra/
                               GRAD_UPDATE_TIME)), psd_etbetax);
                    createinstr(&refgxcra, (long)(psd_pulsepos), pw_gxcra, max_pg_iamp);
                    psd_pulsepos += pw_gxcra;
                }
            }   
        }        
     }
  

    if (tot_etl % 2 == 1) {
        getbeta(&betax, XGRAD, &epiloggrd);
        pulsePos = pend(&refgxw, "refgxw", tot_etl-1);
        createramp(&refgxwde, XGRAD, pw_gxwad, -max_pg_wamp, 0,
                   (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), betax);
        createinstr(&refgxwde, pulsePos, pw_gxwad, -ia_gxw);
        pulsePos += pw_gxwad;
    }

    /***********************************************************************/
    /* X dephaser                                                          */
    /***********************************************************************/
    temp1 = RUP_GRD((int)(pbeg(&refgxw,"refgxw",0) - (pw_gxwad + pw_gx1a +
                                                      pw_gx1 + pw_gx1d)));
    pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.xbeta), pg_beta) : loggrd.xbeta;
    
    /* Gx1ref Attack Pulse */
    pulsename(&refgx1a,"refgx1a");
    createramp(&refgx1a,XGRAD,pw_gx1a,(short)0,
               max_pg_wamp,(short)(maxGradRes*(pw_gx1a/GRAD_UPDATE_TIME)),
               pg_beta);
    createinstr(&refgx1a, (LONG)temp1, pw_gx1a, ia_gx1);
    
    /* Gx1ref Pulse */
    if (pw_gx1 >= GRAD_UPDATE_TIME) {
        pulsename(&refgx1,"refgx1");
        createconst(&refgx1,XGRAD,pw_gx1,max_pg_wamp);
        createinstr( &refgx1,(LONG)(LONG)temp1+pw_gx1a,
                     pw_gx1,ia_gx1);
    }

    /* Gx1ref Decay Pulse */
    pulsename(&refgx1d, "refgx1d");
    createramp(&refgx1d,XGRAD,pw_gx1d,max_pg_wamp,
               (short)0,(short)(maxGradRes*(pw_gx1d/GRAD_UPDATE_TIME)),
               pg_beta);
    createinstr( &refgx1d,(LONG)((LONG)temp1+pw_gx1a+pw_gx1),
                 pw_gx1d,ia_gx1);

    pulsename(&refgxwa, "refgxwa");  /* attack ramp for epi train */
    createramp(&refgxwa, XGRAD, pw_gxwad, (short)0, max_pg_wamp,
               (short)(maxGradRes*(pw_gxwad/GRAD_UPDATE_TIME)), pg_beta);
    if ( etl%2 == 0 && ky_dir != PSD_TOP_DOWN  )
        createinstr(&refgxwa, (LONG)tempx, pw_gxwad, -ia_gxw);
    else
        createinstr(&refgxwa, (LONG)tempx, pw_gxwad, ia_gxw);

    /* Set readout polarity to gradpol[ileave] value */
    ileave = 0;
    setreadpolarity_ref();

    /* Hyperscan DAB packet */
    temp2 = pendall(&rf1ref, 0) + rfupd + 4  ;  /* 4us for unblank receiver */
     
{
    pulsename(&hyperdabref,"hyperdabref");

        createhsdab(&hyperdabref, (long)(temp2));
  }


    /* If we don't reset frequency and phase on each view, then it is best
       to use a single packet at the beginning of the frame - one that doesn't
       shift with interleave.  This is because we want the constant part of Ahn
       correction to see continuous phase evolution across the views. */

    temp2 = pendall(&rf2ref, 0) + rfupd + 4  ;  /* 4us for unblank receiver */

    /* Y prephaser ************************************************************/
    temp1 = pbeg(&refgxw, "refgxw", iref_etl) - pw_gxwad - pw_gy1_tot;
    temp1 = RDN_GRD(temp1);

    /* Setup the Ky Prephaser for Ref Scan */
    trapezoid(YGRAD,"refgy1",
              &refgy1,&refgy1a,&refgy1d,
              pw_gy1,pw_gy1a,pw_gy1d,
              ia_gy1,ia_gy1wa,ia_gy1wb,
              0,0,temp1,TRAP_ALL_SLOPED, &loggrd);

    /* TRAPEZOID2(YGRAD, refgy1, temp1, TRAP_ALL_SLOPED,,,endview_scale, loggrd); */

    /* X killer pulse *********************************************************/
    if (eosxkiller == PSD_ON) {
        tempx = RUP_GRD(pend(&refgxwde,"refgxwde",0) + gkdelay + pw_gxka);

        trapezoid(XGRAD, "refgxk", &refgxk, &refgxka,
                  &refgxkd, pw_gxk, pw_gxka, pw_gxkd,
                  ia_gxk, 0, 0, 0, 0, tempx-pw_gxka, TRAP_ALL,
                  &loggrd);

        /* TRAPEZOID(XGRAD, refgxk, tempx, 0, TYPNDEF, loggrd); */
    }

    /* Y killer pulse *****************************************************/
    if (eosykiller == PSD_ON) {
        tempy = RUP_GRD(pend(&refgxwde,"refgxwde",0) + gkdelay + pw_gyka);

        trapezoid(YGRAD, "refgyk", &refgyk, &refgyka,
                  &refgykd, pw_gyk, pw_gyka, pw_gykd,
                  ia_gyk, 0, 0, 0, 0, tempy-pw_gyka, TRAP_ALL,
                  &loggrd);

        /* TRAPEZOID(YGRAD, refgyk, tempy, 0, TYPNDEF, loggrd); */
    }

    /* Z killer pulse *****************************************************/
    if (eoszkiller == PSD_ON) {
        tempz = RUP_GRD(pend(&refgxwde,"refgxwde",0) + gkdelay + pw_gzka);

        trapezoid(ZGRAD, "refgzk", &refgzk, &refgzka,
                  &refgzkd, pw_gzk, pw_gzka, pw_gzkd,
                  ia_gzk, 0, 0, 0, 0, tempz-pw_gzka, TRAP_ALL,
                  &loggrd);

        /* TRAPEZOID(ZGRAD, refgzk, tempz, 0, TYPNDEF, loggrd); */
    }

    /* RHO killer? pulse ***********************************************/
    /* This pulse is specific to MGD.  It forces the RHO sequencer to  */
    /* EOS after all other RF sequencers (omega & theta) as a temp fix */
    /* for a sequencer buffer glitch.                                  */

    if (eosrhokiller == PSD_ON) {

        int pw_rho_killer = 2;
        int ia_rho_killer = 0;

        tempz = RUP_GRD(pend(&refgxwde,"refgxwde",0) + gkdelay + pw_gzka);
        pulsename(&rho_killerref,"rho_killerref");
        createconst(&rho_killerref,RHO,pw_rho_killer,MAX_PG_WAMP);
        createinstr( &rho_killerref,(long)(tempz),
                     pw_rho_killer,ia_rho_killer);
    }

#ifdef IPG
    /*
     * Execute this code only on the Tgt side
     */
    /* Major "Wait" Pulses ************************************************/

    tempy = pbeg(&refgy1a, "refgy1a", 0) - pw_wgy;
    tempx = pbeg(&refgx1a, "refgx1a", 0) - pw_wgx;
    /* TFON sliding data acq. window wait intervals */

    /* WAIT Pulse on X */
    pulsename(&wgxref,"wgxref");
    createconst(&wgxref,XGRAD,pw_wgx,(short)0); 
    createinstr( &wgxref,(long)(tempx),pw_wgx,0);

    /* WAIT Pulse on Y */
    pulsename(&wgyref,"wgyref");
    createconst(&wgyref,YGRAD,pw_wgy,(short)0); 
    createinstr( &wgyref,(long)(tempy),pw_wgy,0);

    tempz = pendall(&gzrf2refr1, 0);    

    /* WAIT Pulse on Z */
    pulsename(&wgzref,"wgzref");
    createconst(&wgzref,ZGRAD,pw_wgz,(short)0); 
    createinstr( &wgzref,(long)(tempz),pw_wgz,0);

    temps = pendall(&rf2ref, 0) + rfupd + 4  ;

    /* WAIT on SSP */ 
    pulsename(&wsspref,"wsspref");
    createconst(&wsspref,SSP,pw_wssp,(short)0); 
    createinstr( &wsspref,(long)(temps),pw_wssp,0);
   
    /* 1us is the min time for ssp, per L. Ploetz. YPD */ 
    pw_sspdelay  = _pw_sspdelay.fixedflag ?      ((void)(defaultdelay+1), pw_sspdelay) : defaultdelay+1;
    
    /* WAIT for SSP Delay */ 
    pulsename(&sspdelayref,"sspdelayref");
    createconst(&sspdelayref,SSP,pw_sspdelay,(short)0); 
    createinstr( &sspdelayref,(long)(temps+pw_wssp),pw_sspdelay,0);
    
    pw_omegadelay  = _pw_omegadelay.fixedflag ?    ((void)(RUP_RF(defaultdelay+2)), pw_omegadelay) : RUP_RF(defaultdelay+2); /* 2us is the min time for omega,
                                                 per L. Ploetz. YPD */
    /* WAIT for Omega Delay */ 
    pulsename(&omegadelayref,"omegadelayref");
    createconst(&omegadelayref,OMEGA,pw_omegadelay,(short)0); 
    createinstr( &omegadelayref,(long)(RUP_GRD(temps)),pw_omegadelay,0);
    
    pulsename(&womegaref,"womegaref");
    createconst(&womegaref,OMEGA,pw_womega,(short)0); 
    createinstr( &womegaref,(long)(RUP_GRD(temps)+pw_omegadelay),pw_womega,0);

    /* pulse names for Omega Freq Mod pulses */ 
    pulsename(&rs_omega_attackref, "rs_omega_attackref");
    pulsename(&rs_omega_decayref, "rs_omega_decayref");
    pulsename(&omega_flatref, "omega_flatref");

    for (echoloop = 0; echoloop < tot_etl; echoloop++ ) {
        getssppulse(&(echotrainrba_ref[echoloop]), &(refechotrain[echoloop]), "rba", 0);

        {   /* local scope */

            int time_offset = 0;
            pulsepos  = _pulsepos.fixedflag ?   ((void)(pendallssp(echotrainrba_ref[echoloop],0)), pulsepos) : pendallssp(echotrainrba_ref[echoloop],0); 
            time_offset = pw_gxwad - dacq_offset;  
 
            /* TURN TNS ON at the first etl and OFF at the last etl so that */
            /* the xtr and TNS do not overlap. */
            if ( echoloop == 0)  {
                e1entnsref_pack[0] = SSPDS+EDC;
                pulsename(&e1entnsref,"e1entnsref");
                createbits(&e1entnsref,TYPSSP,4,e1entnsref_pack);
                createinstr( &e1entnsref,(LONG)(pulsepos),4,0);
            }

            if ( echoloop == tot_etl-1) {
                e1distnsref_pack[0] = SSPDS+EDC;
                pulsename(&e1distnsref,"e1distnsref");
                createbits(&e1distnsref,TYPSSP,4,e1distnsref_pack);
                createinstr( &e1distnsref,(LONG)(pulsepos+(int)(tsp*(float)rhfrsize)),4,0);
            }

            if (vrgfsamp) {
	        /*jwg bb change first variable from OMEGA to wg_omegaro1 so we can broadband this sucker*/	    
                trapezoid( wg_omegaro1,"omegaref", &omega_flatref, 
                           &rs_omega_attackref, &rs_omega_decayref,
                           pw_gxwl+pw_gxw+pw_gxwr,  pw_gxwad, pw_gxwad, 
                           ia_omega,ia_omega,ia_omega, 0, 0, 
                           RUP_RF(pulsepos-time_offset), TRAP_ALL, &loggrd);    
            } else {
                
                /* BJM: to offset frequency, play constant on omega */
		/* jwg bb and we'll do the same thing down here, in case we're not ramp sampling*/		
                createconst(&omega_flatref, wg_omegaro1, pw_gxwl+pw_gxw+pw_gxwr, 
                            max_pg_wamp);
                createinstr(&omega_flatref, RUP_RF(pulsepos),
                            pw_gxwl+pw_gxw+pw_gxwr, ia_omega);            
            }

        }
    }
    
    /* 4us for the e1distns pack */
    temps = pendallssp(&refechotrain[tot_etl-1], 0) + (int)(tsp*(float)rhfrsize)+ 4; 
    
    /* "Spring" for sspdelay - keeps TR constant for sliding read window */
    pulsename(&sspshiftref,"sspshiftref");
    createconst(&sspshiftref,SSP,pw_sspshift,(short)0); 
    createinstr( &sspshiftref,(long)(temps+7  ),pw_sspshift,0);

    temps = pendallssp(&sspshiftref, 0);
    pulsename(&ssp_pass_delayref,"ssp_pass_delayref");
    createconst(&ssp_pass_delayref,SSP,pw_ssp_pass_delay,(short)0); 
    createinstr( &ssp_pass_delayref,(long)(temps),pw_ssp_pass_delay,0);
    
    temps = pendallssp(&ssp_pass_delayref, 0);
    
     
  {
    pulsename(&pass_pulseref,"pass_pulseref");
    createpass(&pass_pulseref,(long)(temps));
  }

    
#endif /* IPG */
    
/* BJM: What if the number of spin-echo slices cannot fit into the GRE TR?? */
/* compensate here...*/

    {
        int tminSeRef = tmin;
        int actTrSe = act_tr;

        /* Determine of tmin calculated is ok */
        if(tmin < RUP_GRD(non_tetime + refScanTe)) {
           tminSeRef = RUP_GRD(non_tetime + refScanTe);

        } else {

           tminSeRef = tmin;
        }

        /* MRIge78651 - removed divide by zero condition */
        /* Will the slices requested fit work for a SE Ref? */
        if( act_tr < slquant1 * tminSeRef) {

          actTrSe = RUP_GRD(slquant1*tminSeRef) + 1000;

        } else {

          actTrSe = act_tr;

        }

        /* Actual deadtimes for cardiac scans will be rewritten later */
        if(opcgate==PSD_ON)
            psd_seqtime = RUP_GRD(tminSeRef);
        else
            psd_seqtime = RUP_GRD(actTrSe/slquant1 - time_ssi);
    }

      
  {
    pulsename(&seqrefcore,"seqrefcore");
    createseq(&seqrefcore,psd_seqtime, off_seqrefcore);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrefcore );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrefcore = %d\n", idx_seqrefcore );
#endif
  }


    /* Fill echotrain xtr and rba arrays with SSP pulse structures */
    for (echoloop = 0; echoloop < tot_etl; echoloop++ ) {
        getssppulse(&(echotrainxtr_ref[echoloop]), &(refechotrain[echoloop]), "xtr", 0);
        getssppulse(&(echotrainrba_ref[echoloop]), &(refechotrain[echoloop]), "rba", 0);
    }
    
} /* End if(se_ref == PSD_ON) */

/********* End of RefScan Pulsgen Section **************/


    /* PS **************************************************************/
/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                          PSpulsegen                               *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/
PSpulsegen();
FTGpulsegen();
XTGpulsegen();
ASpulsegen();

  
    if (SatRelaxers) /* Create Null sequence for Relaxers */
        SpSatCatRelaxPG(time_ssi);
    
    /* Baseline Acquisition *********************************************/
       
  {
    bline_unblank_pack[0] = SSPDS+RDC;
    bline_unblank_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    bline_unblank_pack[2] = SSPD+RUBL;
    bline_unblank_pack[3] = SSPDS;

    pulsename(&bline_unblank,"bline_unblank");
    createbits(&bline_unblank,TYPSSP,4,bline_unblank_pack);
    createinstr( &bline_unblank,(long)((LONG)(3000)),4,ia_bline_unblank);
  }

    
                     
                    
                    
                    
                    
                    
  {
    pulsename(&blineacq1,"blineacq1");
 
    epiacqq(&blineacq1, (long)((LONG)(5000)),(long)((LONG)0),
             (long)((LONG)0), (long)(filter_blineacq1),
             (TYPDAB_PACKETS)((TYPDAB_PACKETS)DABNORM), (long)((LONG)fast_rec),
                         (long)((LONG)stddab));
  }

    
    /* set up HyperScan Dab for Baseline */
    
{
    pulsename(&hyperdabbl,"hyperdabbl");

        createhsdab(&hyperdabbl, (long)(1000));
  }

    
      
  {
    pulsename(&seqblineacq,"seqblineacq");
    createseq(&seqblineacq,bl_acq_tr2, off_seqblineacq);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqblineacq );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqblineacq = %d\n", idx_seqblineacq );
#endif
  }


      
  {
    pulsename(&seqRTclock,"seqRTclock");
    createseq(&seqRTclock,RDN_GRD(time_ssi+4), off_seqRTclock);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqRTclock );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqRTclock = %d\n", idx_seqRTclock );
#endif
  }


    buildinstr();              /* load the sequencer memory */

    if (SatRelaxers) /* Use X and Z Grad offsets from off seqcore */
        SpSatCatRelaxOffsets(off_seqcore);
    
    { /* Start of code inlined from Inversion.e InversionPG1 */
        if(ir_sys_type == 1) rfupa = ir_rfupa; /* vmx 3/13/95 YI */

/* HH      01/13/06     MRIhc13008 Fix - Enclose the whole section with ifdef IPG */
#if defined(IPG_TGT) || defined(MGD_TGT) /* MRIhc13008 */
        if (ir_on == PSD_ON)
        {
            int newres;
            int i;

            newres = res_rf0;
            if(PSD_ON == rfpulseInfo[RF0_SLOT].change) {
                newres = rfpulseInfo[RF0_SLOT].newres;
            }

            setperiod((int)pw_rf0/newres, &rf0, 0);

            rf0_freq = (int *)AllocNode((opphases*opslquant + 2)*sizeof(int));
            rf0_pha = (int *)AllocNode((opphases*opslquant + 2)*sizeof(int));

            setupslices(rf0_freq, rsp_info, opslquant, a_gzrf0,
                        1.0, rhfreqscale*opfov, TYPTRANSMIT);

            for (i=0; i<opslquant; i++)
                setupphases(rf0_pha, rf0_freq, i, rf0_phase, 0);
        }
#endif
    } /* End of code inlined from Inversion.e InversionPG1 */


    if (PSD_ON == touch_flag)
    {
#ifdef IPG
        if((fp=fopen(".SKIP_MRE_DRIVER","r"))==NULL)
        {
            /* Make frequency slightly larger to ensure that the driver
             * completes prior TR */
            if ( FAILURE == setmrtouchdriver(touch_act_freq/0.99,
                                             touch_burst_count,
                                             touch_driver_amp) )
            {
                return FAILURE;
            }
        }
#endif
    }

    /*  ***********************************************************
        Initialization
        ********************************************************** */
  
    if (oppseq == PSD_SE) {   /* point to proper waveform */
        getwave(&wave_ptr, &rf2se1b4);
	setwave(wave_ptr, &rf2, 0);
    }
    
    rspdex = dex;
    rspech = 0;
    rspchp = CHOP_ALL;
    
    num_freqs = (int)opuser21; /*jwg bb*/
   /* for (i = 0; i < opfphases; i++)
    {
	vfa_flips_angle[i] = vfa_flips[i];
    }
    */
    
#ifdef IPG
    /*
     * Execute this code only on the Tgt side
     */
    /* Find frequency offsets */
    setupslices(rf1_freq, rsp_info, opslquant, a_gzrf1, 
                (float)1, (opfov*freq_scale), TYPTRANSMIT); 
    setupslices(theta_freq, rsp_info, opslquant, a_gzrf1/omega_scale,
                (float)1, (opfov*freq_scale), TYPTRANSMIT);
    
    if (oppseq == PSD_SE || se_ref == PSD_ON)
	setupslices(rf2_freq, rsp_info, opslquant, a_gzrf2,
                    (float)1, (opfov*freq_scale), TYPTRANSMIT);

    if (ipg_trigtest == 0) {
	/* Inform the Tgt of the trigger array to be used */
	/* Following code is just here to support Tgt oversize
	   board which only supports internal gating */
	for (slice=0; slice < opslquant*opphases; slice++)
            rsptrigger[slice] = (short)TRIG_INTERN;
	slice = 0;
    }
    
    settriggerarray((short)(opslquant*opphases),rsptrigger);
    
    /* Inform the Tgt of the rotation matrix array to be used.
       For everything but CFH and CFL the sat pulses are played
       out so load the sat rotation matrix. Otherwise
       the original slice rotation matrix is used. */

    /*jwg bb may need to change this to account for num_freq loop, if needed!*/
    SpSat_set_sat1_matrix(rsprot_orig, rsprot, opslquant*opphases,
                          sat_rot_matrices, sat_rot_ex_num, sat_rot_df_num,
                          sp_satcard_loc, 0);
    
    /* Inform the Tgt of the rotation matrix array to be used */
    setrotatearray( (short)(opslquant * opphases), rsprot[0] );
#endif /* IPG */

    sl_rcvcf = (int)((float)cfreceiveroffsetfreq/ TARDIS_FREQ_RES);
    
    /* Set up SlcInAcq and AcqPtr tables for multipass scans and
     * multi-repetition scans, including cardiac gating, interleaved,
     * and sequential multi-rep modes.
     * SlcInAcq array gives number of slices per array.
     * AcqPtr array gives index to the first slice in the 
     * multislice tables for each pass. */
    
    /* cardiac gated multi-slice, multi-phase, multi-rep */
    if (opcgate==PSD_ON) {
        rspcardiacinit((short)ophrep, (short)piclckcnt);
        sliceindex = acqs - 1; /* with cardiac gating, acqs is the no. of slices */
        for (pass = 0; pass < acqs; pass++)  {
            slc_in_acq[pass] = slquant1*opphases;
            if (pass == 0) {
                acq_ptr[pass] = 0;
            } else {
                acq_ptr[pass] = sliceindex;
                sliceindex = sliceindex - 1;
	    }
  	} /* repeat the table for multi-reps */
        for (pass_rep = 1; pass_rep < pass_reps; pass_rep++)  {
            for (pass = 0; pass < acqs; pass++)  {
                slc_in_acq[pass + pass_rep*acqs] = slc_in_acq[pass];
                acq_ptr[pass + pass_rep*acqs] = acq_ptr[pass];
	    }
	}
    } else {
        if ( mph_flag==PSD_OFF ) {  /* single-rep interleaved multi-slice */
            slmod_acqs = (opslquant*reps)%acqs;
            for (pass = 0; pass < acqs; pass++) {
                slc_in_acq[pass] = (opslquant*reps)/acqs;
                if (slmod_acqs > pass)
                    slc_in_acq[pass] = slc_in_acq[pass] + 1;
                acq_ptr[pass] = (int)(opslquant/acqs) *pass;
                if (slmod_acqs <= pass)
                    acq_ptr[pass] = acq_ptr[pass] + slmod_acqs;
                else
                    acq_ptr[pass] = acq_ptr[pass] + pass;
            }
        }
        if ( (mph_flag==PSD_ON) && (acqmode==1)) {  /* mph, sequential */
            for (pass=0; pass<acqs; pass++) {  /* for sequential, acqs=opslquant */
                slc_in_acq[pass] = reps;
                acq_ptr[pass] = pass;
            }
        }
        if ( (mph_flag==PSD_ON) && (acqmode==0) ) {  /* mph, interleaved, single pass */
            for (pass = 0; pass < acqs; pass++) {
                slc_in_acq[pass] = slquant1;
                acq_ptr[pass] = 0;
                slmod_acqs = (opslquant*reps)%acqs;
                for (pass = 0; pass < acqs; pass++) {
                    slc_in_acq[pass] = (opslquant*reps)/acqs;
                    if (slmod_acqs > pass)
                        slc_in_acq[pass] = slc_in_acq[pass] + 1;
                    acq_ptr[pass] = (int)(opslquant/acqs) *pass;
                    if (slmod_acqs <= pass)
                        acq_ptr[pass] = acq_ptr[pass] + slmod_acqs;
                    else
                        acq_ptr[pass] = acq_ptr[pass] + pass;
                }
            }
            for (pass_rep = 1; pass_rep < pass_reps; pass_rep++) { /* repeat the table for multi-reps */
                for (pass = 0; pass < acqs; pass++) {
                    slc_in_acq[pass + pass_rep*acqs] = slc_in_acq[pass];
                    acq_ptr[pass + pass_rep*acqs] = acq_ptr[pass];
                }
            }
        }
    }
    
    /* Save the trigger for the prescan slice. */
    prescan_trigger = rsptrigger[acq_ptr[pre_pass] + pre_slice];

    rsptrigger_temp[0] = TRIG_INTERN;
    
#ifdef IPG
    /*
     * Execute this code only on the Tgt side
     */
    /* Save copy of scan_info table */ 
    for(temp1=0; temp1<opslquant; temp1++) {
        orig_rsp_info[temp1].rsptloc = rsp_info[temp1].rsptloc;
        orig_rsp_info[temp1].rsprloc = rsp_info[temp1].rsprloc;
        orig_rsp_info[temp1].rspphasoff = rsp_info[temp1].rspphasoff;
        for (temp2=0; temp2<9; temp2++) {
            origrot[temp1][temp2] = rsprot[temp1][temp2];
        }
    }
    
    /* Fill echotrain xtr and rba arrays with SSP pulse structures */
    for (echoloop = 0; echoloop < tot_etl; echoloop++ ) {
        getssppulse(&(echotrainxtr[echoloop]), &(echotrain[echoloop]), "xtr", 0);
        getssppulse(&(echotrainrba[echoloop]), &(echotrain[echoloop]), "rba", 0);

        if(vrgfsamp) {
            /* Attack Ramp */
            instrtemp = (WF_INSTR_HDR *)GetPulseInstrNode(&rs_omega_attack,(int)echoloop);
            echotrainramp1[echoloop] = (int)instrtemp->wf_instr_ptr;
            echotrainrampamp1[echoloop] = (short*)(&(instrtemp->amplitude)); 

            /* Flattop */
            instrtemp = (WF_INSTR_HDR *)GetPulseInstrNode(&omega_flat,(int)echoloop);
            echotrainramp[echoloop] = (int)instrtemp->wf_instr_ptr;   
            echotrainrampamp[echoloop] = (short*)(&(instrtemp->amplitude)); 
 
            /* Decay Ramp */
            instrtemp = (WF_INSTR_HDR *)GetPulseInstrNode(&rs_omega_decay,(int)echoloop);
            echotrainramp2[echoloop] = (int)instrtemp->wf_instr_ptr;
            echotrainrampamp2[echoloop] = (short*)(&(instrtemp->amplitude)); 

        } else {
           
            /* Constant Freq Offset, no ramp samp */
            instrtemp = (WF_INSTR_HDR *)GetPulseInstrNode(&omega_flat,(int)echoloop);
            echotrainramp[echoloop] = (int)instrtemp->wf_instr_ptr; 
            echotrainrampamp[echoloop] = (short*)(&(instrtemp->amplitude)); 
            
        } /* end vrgfsamp */

    } /* end echoloop */
    
    hsdabmask = PSD_LOAD_HSDAB_ALL;
    scaleomega = 0;

    /* Initialize MRE RSP variables */
/* Start inline from touch.e TouchRspInit */
if( touch_flag )
{
    /* set scale factor for 2nd set of MEGs after 180 */
    if(meg_mode == 3)
    {
        meg2_amp = (int)pow(-1.0, M_half_periods + 1);
    }
    else if(meg_mode == 2)
    {
        meg2_amp = 1;
    }
    else if(meg_mode == 1)
    {
        meg2_amp = -1;
    }
    else
    {
        meg2_amp = 0;
    }

    /* ***************************************************************************************************** */
    /* put gradient amplitudes for each motion-encoding direction into arrays to be accessed during the scan */
    /* ***************************************************************************************************** */
    touchxuamp[0] = ia_gxtouchu;
    touchxuamp[1] = touch_gamp2 * ia_gxtouchu;
    touchxdamp[0] = ia_gxtouchd;
    touchxdamp[1] = touch_gamp2 * ia_gxtouchd;
    touchxfamp[0] = ia_gxtouchf;
    touchxfamp[1] = touch_gamp2 * ia_gxtouchf;
    touchyuamp[0] = ia_gytouchu;
    touchyuamp[1] = touch_gamp2 * ia_gytouchu;
    touchydamp[0] = ia_gytouchd;
    touchydamp[1] = touch_gamp2 * ia_gytouchd;
    touchyfamp[0] = ia_gytouchf;
    touchyfamp[1] = touch_gamp2 * ia_gytouchf;
    touchzuamp[0] = ia_gztouchu;
    touchzuamp[1] = touch_gamp2 * ia_gztouchu;
    touchzdamp[0] = ia_gztouchd;
    touchzdamp[1] = touch_gamp2 * ia_gztouchd;
    touchzfamp[0] = ia_gztouchf;
    touchzfamp[1] = touch_gamp2 * ia_gztouchf;
    /* MEGs after RF2 */
    touchxuamp2[0] = meg2_amp * ia_gxtouchu2;
    touchxuamp2[1] = meg2_amp * touch_gamp2 * ia_gxtouchu2;
    touchxdamp2[0] = meg2_amp * ia_gxtouchd2;
    touchxdamp2[1] = meg2_amp * touch_gamp2 * ia_gxtouchd2;
    touchxfamp2[0] = meg2_amp * ia_gxtouchf2;
    touchxfamp2[1] = meg2_amp * touch_gamp2 * ia_gxtouchf2;
    touchyuamp2[0] = meg2_amp * ia_gytouchu2;
    touchyuamp2[1] = meg2_amp * touch_gamp2 * ia_gytouchu2;
    touchydamp2[0] = meg2_amp * ia_gytouchd2;
    touchydamp2[1] = meg2_amp * touch_gamp2 * ia_gytouchd2;
    touchyfamp2[0] = meg2_amp * ia_gytouchf2;
    touchyfamp2[1] = meg2_amp * touch_gamp2 * ia_gytouchf2;
    touchzuamp2[0] = meg2_amp * ia_gztouchu2;
    touchzuamp2[1] = meg2_amp * touch_gamp2 * ia_gztouchu2;
    touchzdamp2[0] = meg2_amp * ia_gztouchd2;
    touchzdamp2[1] = meg2_amp * touch_gamp2 * ia_gztouchd2;
    touchzfamp2[0] = meg2_amp * ia_gztouchf2;
    touchzfamp2[1] = meg2_amp * touch_gamp2 * ia_gztouchf2;

    SetTouchAmp(0);
} /* ends if (touch_flag) { */
/* End inline from touch.e TouchRspInit */


#endif /* IPG */

    return SUCCESS;

} /* end pulsegen */

/* Add MRE RSP functions for manipulating the MEG */
/* Start inline from touch.e TouchEncodePg */
void AddEncodeUp( int pos,
                  int meg_set )
{
    if( meg_set == 1 )
    {
        if( touch_xdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gxtouchu2, "gxtouchu2", &gxtouchu2, &gxtouchu2a,
                        &gxtouchu2d, pw_gxtouchu2, pw_gxtouchu2a, pw_gxtouchu2d,
                        ia_gxtouchu2, 0, 0, 0, 0, pos+pw_gxtouchu2a-pw_gxtouchu2a, TRAP_ALL,
                        &loggrd);

        }
        if( touch_ydir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gytouchu2, "gytouchu2", &gytouchu2, &gytouchu2a,
                        &gytouchu2d, pw_gytouchu2, pw_gytouchu2a, pw_gytouchu2d,
                        ia_gytouchu2, 0, 0, 0, 0, pos+pw_gytouchu2a-pw_gytouchu2a, TRAP_ALL,
                        &loggrd);

        }
        if( touch_zdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gztouchu2, "gztouchu2", &gztouchu2, &gztouchu2a,
                        &gztouchu2d, pw_gztouchu2, pw_gztouchu2a, pw_gztouchu2d,
                        ia_gztouchu2, 0, 0, 0, 0, pos+pw_gztouchu2a-pw_gztouchu2a, TRAP_ALL,
                        &loggrd);

        }
    }
    else
    {
        if( touch_xdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gxtouchu, "gxtouchu", &gxtouchu, &gxtouchua,
                        &gxtouchud, pw_gxtouchu, pw_gxtouchua, pw_gxtouchud,
                        ia_gxtouchu, 0, 0, 0, 0, pos+pw_gxtouchua-pw_gxtouchua, TRAP_ALL,
                        &loggrd);

        }
        if( touch_ydir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gytouchu, "gytouchu", &gytouchu, &gytouchua,
                        &gytouchud, pw_gytouchu, pw_gytouchua, pw_gytouchud,
                        ia_gytouchu, 0, 0, 0, 0, pos+pw_gytouchua-pw_gytouchua, TRAP_ALL,
                        &loggrd);

        }
        if( touch_zdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gztouchu, "gztouchu", &gztouchu, &gztouchua,
                        &gztouchud, pw_gztouchu, pw_gztouchua, pw_gztouchud,
                        ia_gztouchu, 0, 0, 0, 0, pos+pw_gztouchua-pw_gztouchua, TRAP_ALL,
                        &loggrd);

        }
    }
}

void AddEncodeDown( int pos,
                    int meg_set )
{
    if( meg_set == 1 )
    {
        if( touch_xdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gxtouchd2, "gxtouchd2", &gxtouchd2, &gxtouchd2a,
                        &gxtouchd2d, pw_gxtouchd2, pw_gxtouchd2a, pw_gxtouchd2d,
                        ia_gxtouchd2, 0, 0, 0, 0, pos+pw_gxtouchd2a-pw_gxtouchd2a, TRAP_ALL,
                        &loggrd);

        }
        if( touch_ydir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gytouchd2, "gytouchd2", &gytouchd2, &gytouchd2a,
                        &gytouchd2d, pw_gytouchd2, pw_gytouchd2a, pw_gytouchd2d,
                        ia_gytouchd2, 0, 0, 0, 0, pos+pw_gytouchd2a-pw_gytouchd2a, TRAP_ALL,
                        &loggrd);

        }
        if( touch_zdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gztouchd2, "gztouchd2", &gztouchd2, &gztouchd2a,
                        &gztouchd2d, pw_gztouchd2, pw_gztouchd2a, pw_gztouchd2d,
                        ia_gztouchd2, 0, 0, 0, 0, pos+pw_gztouchd2a-pw_gztouchd2a, TRAP_ALL,
                        &loggrd);

        }
    }
    else
    {
        if( touch_xdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gxtouchd, "gxtouchd", &gxtouchd, &gxtouchda,
                        &gxtouchdd, pw_gxtouchd, pw_gxtouchda, pw_gxtouchdd,
                        ia_gxtouchd, 0, 0, 0, 0, pos+pw_gxtouchda-pw_gxtouchda, TRAP_ALL,
                        &loggrd);

        }
        if( touch_ydir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gytouchd, "gytouchd", &gytouchd, &gytouchda,
                        &gytouchdd, pw_gytouchd, pw_gytouchda, pw_gytouchdd,
                        ia_gytouchd, 0, 0, 0, 0, pos+pw_gytouchda-pw_gytouchda, TRAP_ALL,
                        &loggrd);

        }
        if( touch_zdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gztouchd, "gztouchd", &gztouchd, &gztouchda,
                        &gztouchdd, pw_gztouchd, pw_gztouchda, pw_gztouchdd,
                        ia_gztouchd, 0, 0, 0, 0, pos+pw_gztouchda-pw_gztouchda, TRAP_ALL,
                        &loggrd);

        }
    }
}

void AddEncodeFcomp( int pos,
                     int meg_set )
{
    if( meg_set == 1 )
    {
        if( touch_xdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gxtouchf2, "gxtouchf2", &gxtouchf2, &gxtouchf2a,
                        &gxtouchf2d, pw_gxtouchf2, pw_gxtouchf2a, pw_gxtouchf2d,
                        ia_gxtouchf2, 0, 0, 0, 0, pos+pw_gxtouchf2a-pw_gxtouchf2a, TRAP_ALL,
                        &loggrd);

        }
        if( touch_ydir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gytouchf2, "gytouchf2", &gytouchf2, &gytouchf2a,
                        &gytouchf2d, pw_gytouchf2, pw_gytouchf2a, pw_gytouchf2d,
                        ia_gytouchf2, 0, 0, 0, 0, pos+pw_gytouchf2a-pw_gytouchf2a, TRAP_ALL,
                        &loggrd);

        }
        if( touch_zdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gztouchf2, "gztouchf2", &gztouchf2, &gztouchf2a,
                        &gztouchf2d, pw_gztouchf2, pw_gztouchf2a, pw_gztouchf2d,
                        ia_gztouchf2, 0, 0, 0, 0, pos+pw_gztouchf2a-pw_gztouchf2a, TRAP_ALL,
                        &loggrd);

        }
    }
    else
    {
        if( touch_xdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gxtouchf, "gxtouchf", &gxtouchf, &gxtouchfa,
                        &gxtouchfd, pw_gxtouchf, pw_gxtouchfa, pw_gxtouchfd,
                        ia_gxtouchf, 0, 0, 0, 0, pos+pw_gxtouchfa-pw_gxtouchfa, TRAP_ALL,
                        &loggrd);

        }
        if( touch_ydir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gytouchf, "gytouchf", &gytouchf, &gytouchfa,
                        &gytouchfd, pw_gytouchf, pw_gytouchfa, pw_gytouchfd,
                        ia_gytouchf, 0, 0, 0, 0, pos+pw_gytouchfa-pw_gytouchfa, TRAP_ALL,
                        &loggrd);

        }
        if( touch_zdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gztouchf, "gztouchf", &gztouchf, &gztouchfa,
                        &gztouchfd, pw_gztouchf, pw_gztouchfa, pw_gztouchfd,
                        ia_gztouchf, 0, 0, 0, 0, pos+pw_gztouchfa-pw_gztouchfa, TRAP_ALL,
                        &loggrd);

        }
    }
}
/* End inline from touch.e TouchEncodePg */


#include <stdlib.h>

/* SPSP fat sat pulse*/
int *rfcssat_freq;
int *theta_cssat_freq;

/* SPSP fat sat pulse */
WF_PULSE gzrfcssat = INITPULSE;
WF_PULSE thetarfcssat = INITPULSE;


STATUS
ChemSatPG( INT chemsat_start,
           INT *cssat_index )
{
    CHAR rhoFile[256], phaFile[256];
    SHORT *rhoPulse, *phaPulse;
    SHORT *tempPulse;
    SHORT temp_res;

    int i;

    if(csat_sys_type == 1) rfupa = csat_rfupa; /* vmx 3/13/95 YI */
  
    /* Check to see if pw scaled during predownload. If TRUE then set resolution to
    ** scaled resolution.
    */
    temp_res = res_rfcssat;
    if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON)
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(rfpulseInfo[RFCSSAT_SLOT].newres), res_rfcssat) : rfpulseInfo[RFCSSAT_SLOT].newres;
    /*  Create skeleton chemsat pulse. */
      
  {
    pulsename(&rfcssat,"rfcssat");
    createreserve(&rfcssat,(WF_PROCESSOR)wg_rfcssat,
		  res_rfcssat);
  }


    addrfbits(&rfcssat, off_rfcssat, chemsat_start+psd_rf_wait, pw_rfcssat);

    createinstr(&rfcssat, chemsat_start+psd_rf_wait, pw_rfcssat, ia_rfcssat);

    /* Reset resolution to old resolution in case of external rf pulse */
    if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(temp_res), res_rfcssat) : temp_res;
    }

    switch (ChemSatPulse) {
   
    case SINC_PULSE:
    default:
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(rfpulseInfo[RFCSSAT_SLOT].newres), res_rfcssat) : rfpulseInfo[RFCSSAT_SLOT].newres;
        }
        rhoPulse = (short *)AllocNode(res_rfcssat*sizeof(short));
        usinc(rhoPulse, res_rfcssat, (short)max_pg_wamp, cyc_rfcssat, alpha_rfcssat);
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);
        break;

    /* SPSP fat sat pulse */
    case SPSP_FATSAT_PULSE:

        rfcssat_freq = (int *)AllocNode((opslquant + 2)*sizeof(int));
        theta_cssat_freq = (int *)AllocNode((opslquant + 2)*sizeof(int));

        for (i = 0; i < opslquant; i++)
        {
            if (spsp_fatsat_spatial_mode == 0)  /* normal mode*/
            {
                theta_cssat_freq[i] = GAM * (a_gzrfcssat/spsp_fatsat_omega_scale) * 
                                      (rsp_info[i].rsptloc + spsp_fatsat_spatial_offset)/ (10 * TARDIS_FREQ_RES);
            }
            else   /* fixed spatial sat region mode */
            {
                float center_slice_loc;
                if (opslquant%2 == 0)
                    center_slice_loc = (rsp_info[opslquant/2 - 1].rsptloc + rsp_info[opslquant/2].rsptloc)/2;
                else
                    center_slice_loc = rsp_info[(opslquant-1)/2].rsptloc;

                theta_cssat_freq[i] = GAM * (a_gzrfcssat/spsp_fatsat_omega_scale) * 
                                      (center_slice_loc + spsp_fatsat_spatial_offset)/ (10 * TARDIS_FREQ_RES);
            }
         }
         if (debug_spsp_fatsat)
         {
             FILE * debug_file_ptr;
             debug_file_ptr = fopen("/usr/g/service/log/dbgdata_theta_cssat_freq", "w");

             if (NULL != debug_file_ptr)
             {
                 fprintf(debug_file_ptr, "spsp_fatsat_spatial_mode = %d\tspsp_fatsat_spatial_offset = %f\n", 
                         spsp_fatsat_spatial_mode, spsp_fatsat_spatial_offset);
                 fprintf(debug_file_ptr, "a_gzrfcssat = %f\n", a_gzrfcssat);

                 for (i = 0; i<opslquant; i++)
                 {
                     fprintf(debug_file_ptr, "slice %d\tcssat freq = %d\n", i+1, theta_cssat_freq[i]);
                 }

                 fclose(debug_file_ptr);
             }
         }

        /* RHO */
        strcpy(rhoFile, ext_spsp_fatsat_rf_filename);
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
	        
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(rfpulseInfo[RFCSSAT_SLOT].newres), res_rfcssat) : rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        /* Gz */                
        pulsename(&gzrfcssat,"gzrfcssat");
        createextwave( &gzrfcssat, ZGRAD, res_gzrfcssat, ext_spsp_fatsat_gz_filename );
        createinstr( &gzrfcssat, chemsat_start, pw_gzrfcssat, ia_gzrfcssat );                               

        /* Frequency */
        pulsename(&thetarfcssat,"thetarfcssat");
        createextwave( &thetarfcssat, TYPOMEGA, res_thetarfcssat, ext_spsp_fatsat_gz_filename );
        createinstr( &thetarfcssat, (long)chemsat_start + psd_rf_wait, pw_thetarfcssat, ia_thetarfcssat );
        addrfbits( &thetarfcssat, 0, (long)chemsat_start + psd_rf_wait, pw_thetarfcssat );
        
        /* Link all 3 pulses */
        linkpulses( 3, &rfcssat, &gzrfcssat, &thetarfcssat);

        break;


    case CSM_PULSE:

        strcpy(rhoFile, "rfcsm.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
	        
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(rfpulseInfo[RFCSSAT_SLOT].newres), res_rfcssat) : rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        break;
      
    case CSMIN8_PULSE:

        strcpy(rhoFile, "rfcsmin8.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(rfpulseInfo[RFCSSAT_SLOT].newres), res_rfcssat) : rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }

        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        break;
      
    case CSMAX8_PULSE:

        strcpy(rhoFile, "rfcsmax8.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);

        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(rfpulseInfo[RFCSSAT_SLOT].newres), res_rfcssat) : rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else { 
            rhoPulse = tempPulse;
        }

        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        break;

    case CS3T_PULSE:				/*YH*/

        strcpy(rhoFile, "rfcs3t.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(rfpulseInfo[RFCSSAT_SLOT].newres), res_rfcssat) : rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);
        break;

    case CS_HS:	
    case CS_HS_20MS:
        if (ChemSatPulse == CS_HS_20MS)
        {
            strcpy(rhoFile, "hs.rho");
            strcpy(phaFile, "hs.pha");
        }
        else if (ChemSatPulse == CS_HS)
        {
            strcpy(rhoFile, "hs_40ms.rho");
            strcpy(phaFile, "hs_40ms.pha");
        }
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(rfpulseInfo[RFCSSAT_SLOT].newres), res_rfcssat) : rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        /* THETA pulse */
        {
              
  {
    pulsename(&omega_hs_rfcssat,"omega_hs_rfcssat");
    createreserve(&omega_hs_rfcssat,(WF_PROCESSOR)wg_omega_hs_rfcssat,
		  res_omega_hs_rfcssat);
  }


            addrfbits(&omega_hs_rfcssat, 0, chemsat_start+psd_rf_wait, pw_rfcssat);

            createinstr(&omega_hs_rfcssat, chemsat_start+psd_rf_wait, pw_rfcssat, ia_omega_hs_rfcssat);

            tempPulse =(short *)AllocNode(temp_res*sizeof(short));
            uextwave(tempPulse, temp_res, phaFile);
            if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
                phaPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
                stretchpulse((int)temp_res,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,phaPulse);
                FreeNode(tempPulse);
            } else {
                phaPulse = tempPulse;
            }
            movewaveimm(phaPulse, &omega_hs_rfcssat, 0, res_rfcssat, TOHARDWARE);
            FreeNode(phaPulse);
        }
        break;
    }
   
   if (PSD_ON == selectiveChemsat) 
   { 
             

  trapezoid((WF_PROCESSOR)wg_gzrfcs, "gzrfcs", &gzrfcs, &gzrfcsa,
                        &gzrfcsd, pw_gzrfcs, pw_gzrfcsa, pw_gzrfcsd,
                        ia_gzrfcs, 0, 0, 0, 0, chemsat_start-pw_gzrfcsa, TRAP_ALL,
                        &loggrd);
	
    }
   /*  Y board crusher for Chem Sat pulse  */
    /* MRIge62364 : karun Rounded up the postion for the pulses */

         
                                         

  trapezoid((WF_PROCESSOR)wg_gykcs, "gykcs", &gykcs, &gykcsa,
                        &gykcsd, pw_gykcs, pw_gykcsa, pw_gykcsd,
                        ia_gykcs, 0, 0, 0, 0, RUP_GRD(pendall(&rfcssat,*cssat_index)+pw_gykcsa-psd_rf_wait)-pw_gykcsa, TRAP_ALL,
                        &loggrd);
 
#ifdef CSXKILLER
    /*  X board crusher for Chem Sat pulse  */
         
                                         

  trapezoid((WF_PROCESSOR)wg_gxkcs, "gxkcs", &gxkcs, &gxkcsa,
                        &gxkcsd, pw_gxkcs, pw_gxkcsa, pw_gxkcsd,
                        ia_gxkcs, 0, 0, 0, 0, RUP_GRD(pendall(&rfcssat,*cssat_index)+pw_gxkcsa-psd_rf_wait)-pw_gxkcsa, TRAP_ALL,
                        &loggrd);

#endif
#ifdef CSZKILLER
    /*  Z board crusher for Chem Sat pulse  */
         
                                         

  trapezoid((WF_PROCESSOR)wg_gzkcs, "gzkcs", &gzkcs, &gzkcsa,
                        &gzkcsd, pw_gzkcs, pw_gzkcsa, pw_gzkcsd,
                        ia_gzkcs, 0, 0, 0, 0, RUP_GRD(pendall(&rfcssat,*cssat_index)+pw_gzrfcsd+pw_gzkcsa-psd_rf_wait)-pw_gzkcsa, TRAP_ALL,
                        &loggrd);


#endif
	
#ifdef PSD_CHEMSAT_SEQ
    if (*cssat_index == 0)
    {
          
  {
    pulsename(&seqcssat,"seqcssat");
    createseq(&seqcssat,RUP_GRD(cs_sattime+cs_satstart), off_seqcssat);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcssat );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcssat = %d\n", idx_seqcssat );
#endif
  }

        /* Assert the ESSP flag on the sync packet byte seq length */
        attenflagon(&seqcssat, 0);
    }
#endif
	
    /* Initialize for RSP */
    cstun = 0;
    amp_gykcs = ia_gykcs;
#ifdef CSXKILLER
    amp_gxkcs = ia_gxkcs;
#endif
#ifdef CSZKILLER
    amp_gzkcs = ia_gzkcs;
#endif
    csa = a_rfcssat * 1000;
    csf = off_rfcssat;
    *cssat_index += 1;

    /* Set the maximum of the csa corresponds to 360 degree */      
    max_csa = csa * CS_MAXFLIP/ flip_sat;  
	
    return SUCCESS;
} 
    
    
STATUS
SpSatPG( INT sat_type,
         INT start_time,
         INT *sat_index,
         INT cardiacsat_pos )
{
    SHORT *kernel_tab_rho = NULL; 
    SHORT *hadamard_tab_rho = NULL;
    SHORT *temp_wave_rho = NULL;
    SHORT *wave_space_rho = NULL;
    SHORT *kernel_tab_theta = NULL;
    SHORT *hadamard_tab_theta = NULL;
    SHORT *temp_wave_theta = NULL;
    EXTERN_FILENAME rho_file;
    EXTERN_FILENAME theta_file;  

    INT    skip_next_sat;
    long    ctrl_word;

    INT    sp_sattemp;
    FLOAT  separation; /* slice separation of hadamards in slice thickness */
    INT    sp_pos_killer;
    FLOAT  freqstep;
    INT  temp_sat_index;
  
    int rot_update_time;

    int ending;

    if(spsat_sys_type == 1) rfupa = spsat_rfupa; /* vmx 3/13/95 YI */

    sp_first_scan  = _sp_first_scan.fixedflag ?  ((void)(1), sp_first_scan) : 1;  /* First scan since download. This flag is used
                           to determine when rotation matrices need to
                           be copied over. This needs to be set even if
                           sat is off. */

    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return(SUCCESS);

    /* Change resolutions since SpSatPG can be called multiple times. i.e. sat1, sat2, sat3 
       conditions*/
    switch (sat_type)
    {
    case SINC_SAT:
	{
            res_rfse1  = _res_rfse1.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse1) : RES_NVRGSAT;
            res_rfse2  = _res_rfse2.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse2) : RES_NVRGSAT;
            res_rfse3  = _res_rfse3.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse3) : RES_NVRGSAT;
            res_rfse4  = _res_rfse4.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse4) : RES_NVRGSAT;
            res_rfse5  = _res_rfse5.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse5) : RES_NVRGSAT;
            res_rfse6  = _res_rfse6.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse6) : RES_NVRGSAT;
            res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsx1) : RES_NVRGSAT;
            res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsx2) : RES_NVRGSAT;
            res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsy1) : RES_NVRGSAT;
            res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsy2) : RES_NVRGSAT;
            res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsz1) : RES_NVRGSAT;
            res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsz2) : RES_NVRGSAT;
	    /* YMSmr09579 04-Oct-2006 HK */
            if (pw_rfse1==4800 ) res_rfse1  = _res_rfse1.fixedflag ?  ((void)(RES_SLRSAT), res_rfse1) : RES_SLRSAT;
            if (pw_rfse2==4800 ) res_rfse2  = _res_rfse2.fixedflag ?  ((void)(RES_SLRSAT), res_rfse2) : RES_SLRSAT;
            if (pw_rfse3==4800 ) res_rfse3  = _res_rfse3.fixedflag ?  ((void)(RES_SLRSAT), res_rfse3) : RES_SLRSAT;
            if (pw_rfse4==4800 ) res_rfse4  = _res_rfse4.fixedflag ?  ((void)(RES_SLRSAT), res_rfse4) : RES_SLRSAT;
            if (pw_rfse5==4800 ) res_rfse5  = _res_rfse5.fixedflag ?  ((void)(RES_SLRSAT), res_rfse5) : RES_SLRSAT;
            if (pw_rfse6==4800 ) res_rfse6  = _res_rfse6.fixedflag ?  ((void)(RES_SLRSAT), res_rfse6) : RES_SLRSAT;
            if (pw_rfsx1==4800 ) res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsx1) : RES_SLRSAT;
            if (pw_rfsx2==4800 ) res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsx2) : RES_SLRSAT;
            if (pw_rfsy1==4800 ) res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsy1) : RES_SLRSAT;
            if (pw_rfsy2==4800 ) res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsy2) : RES_SLRSAT;
            if (pw_rfsz1==4800 ) res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsz1) : RES_SLRSAT;
            if (pw_rfsz2==4800 ) res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsz2) : RES_SLRSAT;
            break;
	}
    case SLR_SAT:
	{
            res_rfse1  = _res_rfse1.fixedflag ?  ((void)(RES_SLRSAT), res_rfse1) : RES_SLRSAT;
            res_rfse2  = _res_rfse2.fixedflag ?  ((void)(RES_SLRSAT), res_rfse2) : RES_SLRSAT;
            res_rfse3  = _res_rfse3.fixedflag ?  ((void)(RES_SLRSAT), res_rfse3) : RES_SLRSAT;
            res_rfse4  = _res_rfse4.fixedflag ?  ((void)(RES_SLRSAT), res_rfse4) : RES_SLRSAT;
            res_rfse5  = _res_rfse5.fixedflag ?  ((void)(RES_SLRSAT), res_rfse5) : RES_SLRSAT;
            res_rfse6  = _res_rfse6.fixedflag ?  ((void)(RES_SLRSAT), res_rfse6) : RES_SLRSAT;
            res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsx1) : RES_SLRSAT;
            res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsx2) : RES_SLRSAT;
            res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsy1) : RES_SLRSAT;
            res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsy2) : RES_SLRSAT;
            res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsz1) : RES_SLRSAT;
            res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsz2) : RES_SLRSAT;
            break;
	}
    case SLR_CSAT:
        {
            res_rfse1  = _res_rfse1.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse1) : RES_SLRCSAT;
            res_rfse2  = _res_rfse2.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse2) : RES_SLRCSAT;
            res_rfse3  = _res_rfse3.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse3) : RES_SLRCSAT;
            res_rfse4  = _res_rfse4.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse4) : RES_SLRCSAT;
            res_rfse5  = _res_rfse5.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse5) : RES_SLRCSAT;
            res_rfse6  = _res_rfse6.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse6) : RES_SLRCSAT;
            res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsx1) : RES_SLRCSAT;
            res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsx2) : RES_SLRCSAT;
            res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsy1) : RES_SLRCSAT;
            res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsy2) : RES_SLRCSAT;
            res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsz1) : RES_SLRCSAT;
            res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsz2) : RES_SLRCSAT;
            break;
        }
    default:
	break;
    }

    sp_sattemp = start_time;

    /* In cardiac scan, there may not be enough time at the beginning
       of the scan for the sat pulses. In this case, the sats are moved
       to the end of the sequence. (i.e. cardiacsat_pos != 0 ) For this
       case an isi interrupt is added before the sats the prepare the
       first rotation matrix.

       If the sats are played at the beginning of a sequence, the first
       rotation matrix is loaded by the psd. 

       Note that the sat index is 0. Since only one sat sequence will
       use this extra SSP packet, the index is 0 not sat_index. */

    /* ************************************************************ *
     * MRIge50713 - change the index to sat_index instead of using  *
     * index 0 always.                                              *
     *                                                              *
     * This is necessary because in the new FSE phase correction,   *
     * two copies of SpSat instructions are generated. The first    *
     * is for fse pulse sequence (seqcore), the 2nd copy is for fse *
     * phase correction pulse sequence (seqfseps). If the index     *
     * remains always 0, the seqfseps will overwrite the seqcore.   *
     * ************************************************************ */
 
    if (cardiacsat_pos != 0)
    {

    	/*
          MRIge51141 - Use sat_index only for FAST sequences.
	*/

        if ( opfast==PSD_ON )	{
            temp_sat_index = *sat_index ;
	} else 	{
            temp_sat_index = 0;
	}

           
  {
    pulsename(&isi_cardiacsat,"isi_cardiacsat");
    createconst(&isi_cardiacsat,(WF_PROCESSOR)wg_isi_cardiacsat,pw_isi_cardiacsat,(short)0); 
    createinstr( &isi_cardiacsat,(long)(sp_sattemp),pw_isi_cardiacsat,0);
  }

        getctrl(&ctrl_word, &isi_cardiacsat, temp_sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT ;
        setctrl(ctrl_word, &isi_cardiacsat, temp_sat_index);
        sp_sattemp =  sp_sattemp + pw_isisat;

           
  {
    pulsename(&rot_update_cardiacsat,"rot_update_cardiacsat");
    createconst(&rot_update_cardiacsat,(WF_PROCESSOR)wg_rot_update_cardiacsat,pw_rot_update_cardiacsat,(short)0); 
    createinstr( &rot_update_cardiacsat,(long)(sp_sattemp),pw_rot_update_cardiacsat,0);
  }

        getctrl(&ctrl_word, &rot_update_cardiacsat, temp_sat_index);
        ctrl_word = ctrl_word |PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_cardiacsat, temp_sat_index);
        sp_sattemp =  sp_sattemp + pw_rotupdate;

    }
 
    /****************************************************************

            EXPLICIT SAT GRADIENTS

       1. Slice selection gradient
       2. Killer on y gradient
       3. If there are 2 sat bands that are parallel but do not have
          the same thickness, create a separate slice select & killer
          for the second band.
    ******************************************************************/

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_1) != 0)
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse1", 
                                     (WF_PROCESSOR)wg_rfse1);

    /* Modify resolution if scaling required */
    temp_res_rfse1  = _temp_res_rfse1.fixedflag ?  ((void)(res_rfse1), temp_res_rfse1) : res_rfse1;
    if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
       res_rfse1  = _res_rfse1.fixedflag ?  ((void)(rfpulseInfo[RFSE1_SLOT].newres), res_rfse1) : rfpulseInfo[RFSE1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse1a,"gzrfse1a");
    pulsename(&gzrfse1,"gzrfse1");
    pulsename(&gzrfse1d,"gzrfse1d");
    pulsename(&rfse1,"rfse1");

    /*  Now create the slice select trapezoid */
        pg_beta  = _pg_beta.fixedflag ?  ((void)(satloggrd.zbeta), pg_beta) : satloggrd.zbeta;
    createramp(&gzrfse1a,ZGRAD,pw_gzrfse1a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse1a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse1a,(LONG)(sp_sattemp+pw_gzrfse1a-pw_gzrfse1a),
                pw_gzrfse1a,ia_gzrfse1);
    createconst(&gzrfse1,ZGRAD,pw_gzrfse1,MAX_PG_WAMP);
    createinstr( &gzrfse1,(LONG)(sp_sattemp+pw_gzrfse1a),
                pw_gzrfse1,ia_gzrfse1);
    createramp(&gzrfse1d,ZGRAD,pw_gzrfse1d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse1d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse1d,(LONG)(sp_sattemp+pw_gzrfse1a+pw_gzrfse1),
                pw_gzrfse1d,ia_gzrfse1);

    /* Now create the rf pulse */
    createsinc(&rfse1,(WF_PROCESSOR)wg_rfse1,res_rfse1,
               MAX_PG_WAMP,cyc_rfse1, alpha_rfse1);

    createinstr( &rfse1,(LONG)(sp_sattemp+pw_gzrfse1a) + psd_rf_wait,
                pw_rfse1,ia_rfse1);
    linkpulses(4,&rfse1,&gzrfse1,&gzrfse1a,
               &gzrfse1d);
    addrfbits(&rfse1,off_rfse1,(LONG)(sp_sattemp+pw_gzrfse1a) + psd_rf_wait,
              pw_rfse1);



    pulsename(&rfse1Theta, "rfse1Theta");
    createreserve(&rfse1Theta, THETA, res_rfse1);
    addrfbits(&rfse1Theta, off_rfse1, (LONG)(sp_sattemp+pw_gzrfse1a) + psd_rf_wait , pw_rfse1);
    createinstr(&rfse1Theta, (LONG)(sp_sattemp+pw_gzrfse1a) + psd_rf_wait, pw_rfse1, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
       res_rfse1  = _res_rfse1.fixedflag ?  ((void)(temp_res_rfse1), res_rfse1) : temp_res_rfse1;
  }


        sp_sattemp = pend(&gzrfse1d, "gzrfse1d", *sat_index);

        ending = pendallssp(&rfse1, *sat_index);
 
           
  {
    pulsename(&isi_sate1,"isi_sate1");
    createconst(&isi_sate1,(WF_PROCESSOR)wg_isi_sate1,pw_isi_sate1,(short)0); 
    createinstr( &isi_sate1,(long)(ending),pw_isi_sate1,0);
  }

        getctrl(&ctrl_word, &isi_sate1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT ;
        setctrl(ctrl_word, &isi_sate1, *sat_index);

        rot_update_time = RUP_GRD(IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
           
  {
    pulsename(&rot_update_e1,"rot_update_e1");
    createconst(&rot_update_e1,(WF_PROCESSOR)wg_rot_update_e1,pw_rot_update_e1,(short)0); 
    createinstr( &rot_update_e1,(long)(rot_update_time),pw_rot_update_e1,0);
  }

        getctrl(&ctrl_word, &rot_update_e1, *sat_index);
        ctrl_word = ctrl_word |PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_e1, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse1a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse1, "gykse1", &gykse1, &gykse1a,
                        &gykse1d, pw_gykse1, pw_gykse1a, pw_gykse1d,
                        ia_gykse1, 0, 0, 0, 0, sp_pos_killer-pw_gykse1a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse1d, "gykse1d", *sat_index);

        if (area_gxkse1!=0.0)
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse1, "gxkse1", &gxkse1, &gxkse1a,
                        &gxkse1d, pw_gxkse1, pw_gxkse1a, pw_gxkse1d,
                        ia_gxkse1, 0, 0, 0, 0, sp_pos_killer-pw_gxkse1a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse1d, "gxkse1d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse1d, "gxkse1d", *sat_index);
        }
	  
             
  {
    pulsename(&isi_satek1,"isi_satek1");
    createconst(&isi_satek1,(WF_PROCESSOR)wg_isi_satek1,pw_isi_satek1,(short)0); 
    createinstr( &isi_satek1,(long)(sp_sattemp-isi_satdelay),pw_isi_satek1,0);
  }

        getctrl(&ctrl_word, &isi_satek1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT ;
        setctrl(ctrl_word, &isi_satek1, *sat_index);
	  
               
  {
    pulsename(&rot_update_ek1,"rot_update_ek1");
    createconst(&rot_update_ek1,(WF_PROCESSOR)wg_rot_update_ek1,pw_rot_update_ek1,(short)0); 
    createinstr( &rot_update_ek1,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek1,0);
  }

        getctrl(&ctrl_word, &rot_update_ek1, *sat_index);
        ctrl_word = ctrl_word |PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_ek1, *sat_index);

        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay + pw_isisat + pw_rotupdate + isi_extra;

        if ((opexsatparal & PSD_1_PARALLEL) != 0)
            skip_next_sat = 1;
    }

    if (((opexsatmask & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0))
    {
             
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse2", 
                                     (WF_PROCESSOR)wg_rfse2);

    /* Modify resolution if scaling required */
    temp_res_rfse2  = _temp_res_rfse2.fixedflag ?  ((void)(res_rfse2), temp_res_rfse2) : res_rfse2;
    if (rfpulseInfo[RFSE2_SLOT].change==PSD_ON)
       res_rfse2  = _res_rfse2.fixedflag ?  ((void)(rfpulseInfo[RFSE2_SLOT].newres), res_rfse2) : rfpulseInfo[RFSE2_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse2a,"gzrfse2a");
    pulsename(&gzrfse2,"gzrfse2");
    pulsename(&gzrfse2d,"gzrfse2d");
    pulsename(&rfse2,"rfse2");

    /*  Now create the slice select trapezoid */
        pg_beta  = _pg_beta.fixedflag ?  ((void)(satloggrd.zbeta), pg_beta) : satloggrd.zbeta;
    createramp(&gzrfse2a,ZGRAD,pw_gzrfse2a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse2a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse2a,(LONG)(sp_sattemp+pw_gzrfse2a-pw_gzrfse2a),
                pw_gzrfse2a,ia_gzrfse2);
    createconst(&gzrfse2,ZGRAD,pw_gzrfse2,MAX_PG_WAMP);
    createinstr( &gzrfse2,(LONG)(sp_sattemp+pw_gzrfse2a),
                pw_gzrfse2,ia_gzrfse2);
    createramp(&gzrfse2d,ZGRAD,pw_gzrfse2d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse2d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse2d,(LONG)(sp_sattemp+pw_gzrfse2a+pw_gzrfse2),
                pw_gzrfse2d,ia_gzrfse2);

    /* Now create the rf pulse */
    createsinc(&rfse2,(WF_PROCESSOR)wg_rfse2,res_rfse2,
               MAX_PG_WAMP,cyc_rfse2, alpha_rfse2);

    createinstr( &rfse2,(LONG)(sp_sattemp+pw_gzrfse2a) + psd_rf_wait,
                pw_rfse2,ia_rfse2);
    linkpulses(4,&rfse2,&gzrfse2,&gzrfse2a,
               &gzrfse2d);
    addrfbits(&rfse2,off_rfse2,(LONG)(sp_sattemp+pw_gzrfse2a) + psd_rf_wait,
              pw_rfse2);



    pulsename(&rfse2Theta, "rfse2Theta");
    createreserve(&rfse2Theta, THETA, res_rfse2);
    addrfbits(&rfse2Theta, off_rfse2, (LONG)(sp_sattemp+pw_gzrfse2a) + psd_rf_wait , pw_rfse2);
    createinstr(&rfse2Theta, (LONG)(sp_sattemp+pw_gzrfse2a) + psd_rf_wait, pw_rfse2, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE2_SLOT].change==PSD_ON)
       res_rfse2  = _res_rfse2.fixedflag ?  ((void)(temp_res_rfse2), res_rfse2) : temp_res_rfse2;
  }

        sp_sattemp = pend(&gzrfse2d, "gzrfse2d" , *sat_index);

        ending = pendallssp(&rfse2, *sat_index);

           
  {
    pulsename(&isi_sate2,"isi_sate2");
    createconst(&isi_sate2,(WF_PROCESSOR)wg_isi_sate2,pw_isi_sate2,(short)0); 
    createinstr( &isi_sate2,(long)(ending),pw_isi_sate2,0);
  }

        getctrl(&ctrl_word, &isi_sate2, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate2, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e2,"rot_update_e2");
    createconst(&rot_update_e2,(WF_PROCESSOR)wg_rot_update_e2,pw_rot_update_e2,(short)0); 
    createinstr( &rot_update_e2,(long)(rot_update_time),pw_rot_update_e2,0);
  }

        getctrl(&ctrl_word, &rot_update_e2, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_e2, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse2a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse2, "gykse2", &gykse2, &gykse2a,
                        &gykse2d, pw_gykse2, pw_gykse2a, pw_gykse2d,
                        ia_gykse2, 0, 0, 0, 0, sp_pos_killer-pw_gykse2a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse2d, "gykse2d", *sat_index);

        if (area_gxkse2!=0.0)
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse2, "gxkse2", &gxkse2, &gxkse2a,
                        &gxkse2d, pw_gxkse2, pw_gxkse2a, pw_gxkse2d,
                        ia_gxkse2, 0, 0, 0, 0, sp_pos_killer-pw_gxkse2a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse2d, "gxkse2d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse2d, "gxkse2d", *sat_index);
        }

             
  {
    pulsename(&isi_satek2,"isi_satek2");
    createconst(&isi_satek2,(WF_PROCESSOR)wg_isi_satek2,pw_isi_satek2,(short)0); 
    createinstr( &isi_satek2,(long)(sp_sattemp-isi_satdelay),pw_isi_satek2,0);
  }

        getctrl(&ctrl_word, &isi_satek2, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek2, *sat_index);

               
  {
    pulsename(&rot_update_ek2,"rot_update_ek2");
    createconst(&rot_update_ek2,(WF_PROCESSOR)wg_rot_update_ek2,pw_rot_update_ek2,(short)0); 
    createinstr( &rot_update_ek2,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek2,0);
  }

        getctrl(&ctrl_word, &rot_update_ek2, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_ek2, *sat_index);

        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat + pw_rotupdate + isi_extra;
    } 

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_3) != 0)
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse3", 
                                     (WF_PROCESSOR)wg_rfse3);

    /* Modify resolution if scaling required */
    temp_res_rfse3  = _temp_res_rfse3.fixedflag ?  ((void)(res_rfse3), temp_res_rfse3) : res_rfse3;
    if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
       res_rfse3  = _res_rfse3.fixedflag ?  ((void)(rfpulseInfo[RFSE3_SLOT].newres), res_rfse3) : rfpulseInfo[RFSE3_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse3a,"gzrfse3a");
    pulsename(&gzrfse3,"gzrfse3");
    pulsename(&gzrfse3d,"gzrfse3d");
    pulsename(&rfse3,"rfse3");

    /*  Now create the slice select trapezoid */
        pg_beta  = _pg_beta.fixedflag ?  ((void)(satloggrd.zbeta), pg_beta) : satloggrd.zbeta;
    createramp(&gzrfse3a,ZGRAD,pw_gzrfse3a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse3a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse3a,(LONG)(sp_sattemp+pw_gzrfse3a-pw_gzrfse3a),
                pw_gzrfse3a,ia_gzrfse3);
    createconst(&gzrfse3,ZGRAD,pw_gzrfse3,MAX_PG_WAMP);
    createinstr( &gzrfse3,(LONG)(sp_sattemp+pw_gzrfse3a),
                pw_gzrfse3,ia_gzrfse3);
    createramp(&gzrfse3d,ZGRAD,pw_gzrfse3d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse3d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse3d,(LONG)(sp_sattemp+pw_gzrfse3a+pw_gzrfse3),
                pw_gzrfse3d,ia_gzrfse3);

    /* Now create the rf pulse */
    createsinc(&rfse3,(WF_PROCESSOR)wg_rfse3,res_rfse3,
               MAX_PG_WAMP,cyc_rfse3, alpha_rfse3);

    createinstr( &rfse3,(LONG)(sp_sattemp+pw_gzrfse3a) + psd_rf_wait,
                pw_rfse3,ia_rfse3);
    linkpulses(4,&rfse3,&gzrfse3,&gzrfse3a,
               &gzrfse3d);
    addrfbits(&rfse3,off_rfse3,(LONG)(sp_sattemp+pw_gzrfse3a) + psd_rf_wait,
              pw_rfse3);



    pulsename(&rfse3Theta, "rfse3Theta");
    createreserve(&rfse3Theta, THETA, res_rfse3);
    addrfbits(&rfse3Theta, off_rfse3, (LONG)(sp_sattemp+pw_gzrfse3a) + psd_rf_wait , pw_rfse3);
    createinstr(&rfse3Theta, (LONG)(sp_sattemp+pw_gzrfse3a) + psd_rf_wait, pw_rfse3, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
       res_rfse3  = _res_rfse3.fixedflag ?  ((void)(temp_res_rfse3), res_rfse3) : temp_res_rfse3;
  }


        sp_sattemp = pend(&gzrfse3d, "gzrfse3d" , *sat_index);

        ending = pendallssp(&rfse3, *sat_index);

           
  {
    pulsename(&isi_sate3,"isi_sate3");
    createconst(&isi_sate3,(WF_PROCESSOR)wg_isi_sate3,pw_isi_sate3,(short)0); 
    createinstr( &isi_sate3,(long)(ending),pw_isi_sate3,0);
  }

        getctrl(&ctrl_word, &isi_sate3, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate3, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e3,"rot_update_e3");
    createconst(&rot_update_e3,(WF_PROCESSOR)wg_rot_update_e3,pw_rot_update_e3,(short)0); 
    createinstr( &rot_update_e3,(long)(rot_update_time),pw_rot_update_e3,0);
  }

        getctrl(&ctrl_word, &rot_update_e3, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_e3, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse3a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse3, "gykse3", &gykse3, &gykse3a,
                        &gykse3d, pw_gykse3, pw_gykse3a, pw_gykse3d,
                        ia_gykse3, 0, 0, 0, 0, sp_pos_killer-pw_gykse3a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse3d, "gykse3d", *sat_index);

        if (area_gxkse3!=0.0)
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse3, "gxkse3", &gxkse3, &gxkse3a,
                        &gxkse3d, pw_gxkse3, pw_gxkse3a, pw_gxkse3d,
                        ia_gxkse3, 0, 0, 0, 0, sp_pos_killer-pw_gxkse3a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse3d, "gxkse3d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse3d, "gxkse3d", *sat_index);
        }

              
  {
    pulsename(&isi_satek3,"isi_satek3");
    createconst(&isi_satek3,(WF_PROCESSOR)wg_isi_satek3,pw_isi_satek3,(short)0); 
    createinstr( &isi_satek3,(long)(sp_sattemp-isi_satdelay),pw_isi_satek3,0);
  }

        getctrl(&ctrl_word, &isi_satek3, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek3, *sat_index);

                
  {
    pulsename(&rot_update_ek3,"rot_update_ek3");
    createconst(&rot_update_ek3,(WF_PROCESSOR)wg_rot_update_ek3,pw_rot_update_ek3,(short)0); 
    createinstr( &rot_update_ek3,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek3,0);
  }

        getctrl(&ctrl_word, &rot_update_ek3, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_ek3, *sat_index);

        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat + pw_rotupdate + isi_extra;

        if ((opexsatparal &  PSD_2_PARALLEL) != 0)
            skip_next_sat = 1;
    }

    if (((opexsatmask & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0))
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse4", 
                                     (WF_PROCESSOR)wg_rfse4);

    /* Modify resolution if scaling required */
    temp_res_rfse4  = _temp_res_rfse4.fixedflag ?  ((void)(res_rfse4), temp_res_rfse4) : res_rfse4;
    if (rfpulseInfo[RFSE4_SLOT].change==PSD_ON)
       res_rfse4  = _res_rfse4.fixedflag ?  ((void)(rfpulseInfo[RFSE4_SLOT].newres), res_rfse4) : rfpulseInfo[RFSE4_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse4a,"gzrfse4a");
    pulsename(&gzrfse4,"gzrfse4");
    pulsename(&gzrfse4d,"gzrfse4d");
    pulsename(&rfse4,"rfse4");

    /*  Now create the slice select trapezoid */
        pg_beta  = _pg_beta.fixedflag ?  ((void)(satloggrd.zbeta), pg_beta) : satloggrd.zbeta;
    createramp(&gzrfse4a,ZGRAD,pw_gzrfse4a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse4a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse4a,(LONG)(sp_sattemp+pw_gzrfse4a-pw_gzrfse4a),
                pw_gzrfse4a,ia_gzrfse4);
    createconst(&gzrfse4,ZGRAD,pw_gzrfse4,MAX_PG_WAMP);
    createinstr( &gzrfse4,(LONG)(sp_sattemp+pw_gzrfse4a),
                pw_gzrfse4,ia_gzrfse4);
    createramp(&gzrfse4d,ZGRAD,pw_gzrfse4d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse4d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse4d,(LONG)(sp_sattemp+pw_gzrfse4a+pw_gzrfse4),
                pw_gzrfse4d,ia_gzrfse4);

    /* Now create the rf pulse */
    createsinc(&rfse4,(WF_PROCESSOR)wg_rfse4,res_rfse4,
               MAX_PG_WAMP,cyc_rfse4, alpha_rfse4);

    createinstr( &rfse4,(LONG)(sp_sattemp+pw_gzrfse4a) + psd_rf_wait,
                pw_rfse4,ia_rfse4);
    linkpulses(4,&rfse4,&gzrfse4,&gzrfse4a,
               &gzrfse4d);
    addrfbits(&rfse4,off_rfse4,(LONG)(sp_sattemp+pw_gzrfse4a) + psd_rf_wait,
              pw_rfse4);



    pulsename(&rfse4Theta, "rfse4Theta");
    createreserve(&rfse4Theta, THETA, res_rfse4);
    addrfbits(&rfse4Theta, off_rfse4, (LONG)(sp_sattemp+pw_gzrfse4a) + psd_rf_wait , pw_rfse4);
    createinstr(&rfse4Theta, (LONG)(sp_sattemp+pw_gzrfse4a) + psd_rf_wait, pw_rfse4, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE4_SLOT].change==PSD_ON)
       res_rfse4  = _res_rfse4.fixedflag ?  ((void)(temp_res_rfse4), res_rfse4) : temp_res_rfse4;
  }


        sp_sattemp = pend(&gzrfse4d, "gzrfse4d" , *sat_index);

        ending = pendallssp(&rfse4, *sat_index);
           
  {
    pulsename(&isi_sate4,"isi_sate4");
    createconst(&isi_sate4,(WF_PROCESSOR)wg_isi_sate4,pw_isi_sate4,(short)0); 
    createinstr( &isi_sate4,(long)(ending),pw_isi_sate4,0);
  }

        getctrl(&ctrl_word, &isi_sate4, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate4, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e4,"rot_update_e4");
    createconst(&rot_update_e4,(WF_PROCESSOR)wg_rot_update_e4,pw_rot_update_e4,(short)0); 
    createinstr( &rot_update_e4,(long)(rot_update_time),pw_rot_update_e4,0);
  }

        getctrl(&ctrl_word, &rot_update_e4, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_e4, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse4a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse4, "gykse4", &gykse4, &gykse4a,
                        &gykse4d, pw_gykse4, pw_gykse4a, pw_gykse4d,
                        ia_gykse4, 0, 0, 0, 0, sp_pos_killer-pw_gykse4a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse4d, "gykse4d", *sat_index);

        if (area_gxkse4!=0.0)
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse4, "gxkse4", &gxkse4, &gxkse4a,
                        &gxkse4d, pw_gxkse4, pw_gxkse4a, pw_gxkse4d,
                        ia_gxkse4, 0, 0, 0, 0, sp_pos_killer-pw_gxkse4a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse4d, "gxkse4d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse4d, "gxkse4d", *sat_index);
        }

              
  {
    pulsename(&isi_satek4,"isi_satek4");
    createconst(&isi_satek4,(WF_PROCESSOR)wg_isi_satek4,pw_isi_satek4,(short)0); 
    createinstr( &isi_satek4,(long)(sp_sattemp-isi_satdelay),pw_isi_satek4,0);
  }

        getctrl(&ctrl_word, &isi_satek4, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek4, *sat_index);

                
  {
    pulsename(&rot_update_ek4,"rot_update_ek4");
    createconst(&rot_update_ek4,(WF_PROCESSOR)wg_rot_update_ek4,pw_rot_update_ek4,(short)0); 
    createinstr( &rot_update_ek4,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek4,0);
  }

        getctrl(&ctrl_word, &rot_update_ek4, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_ek4, *sat_index);

        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat + pw_rotupdate + isi_extra;
    } 

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_5) != 0)
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse5", 
                                     (WF_PROCESSOR)wg_rfse5);

    /* Modify resolution if scaling required */
    temp_res_rfse5  = _temp_res_rfse5.fixedflag ?  ((void)(res_rfse5), temp_res_rfse5) : res_rfse5;
    if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
       res_rfse5  = _res_rfse5.fixedflag ?  ((void)(rfpulseInfo[RFSE5_SLOT].newres), res_rfse5) : rfpulseInfo[RFSE5_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse5a,"gzrfse5a");
    pulsename(&gzrfse5,"gzrfse5");
    pulsename(&gzrfse5d,"gzrfse5d");
    pulsename(&rfse5,"rfse5");

    /*  Now create the slice select trapezoid */
        pg_beta  = _pg_beta.fixedflag ?  ((void)(satloggrd.zbeta), pg_beta) : satloggrd.zbeta;
    createramp(&gzrfse5a,ZGRAD,pw_gzrfse5a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse5a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse5a,(LONG)(sp_sattemp+pw_gzrfse5a-pw_gzrfse5a),
                pw_gzrfse5a,ia_gzrfse5);
    createconst(&gzrfse5,ZGRAD,pw_gzrfse5,MAX_PG_WAMP);
    createinstr( &gzrfse5,(LONG)(sp_sattemp+pw_gzrfse5a),
                pw_gzrfse5,ia_gzrfse5);
    createramp(&gzrfse5d,ZGRAD,pw_gzrfse5d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse5d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse5d,(LONG)(sp_sattemp+pw_gzrfse5a+pw_gzrfse5),
                pw_gzrfse5d,ia_gzrfse5);

    /* Now create the rf pulse */
    createsinc(&rfse5,(WF_PROCESSOR)wg_rfse5,res_rfse5,
               MAX_PG_WAMP,cyc_rfse5, alpha_rfse5);

    createinstr( &rfse5,(LONG)(sp_sattemp+pw_gzrfse5a) + psd_rf_wait,
                pw_rfse5,ia_rfse5);
    linkpulses(4,&rfse5,&gzrfse5,&gzrfse5a,
               &gzrfse5d);
    addrfbits(&rfse5,off_rfse5,(LONG)(sp_sattemp+pw_gzrfse5a) + psd_rf_wait,
              pw_rfse5);



    pulsename(&rfse5Theta, "rfse5Theta");
    createreserve(&rfse5Theta, THETA, res_rfse5);
    addrfbits(&rfse5Theta, off_rfse5, (LONG)(sp_sattemp+pw_gzrfse5a) + psd_rf_wait , pw_rfse5);
    createinstr(&rfse5Theta, (LONG)(sp_sattemp+pw_gzrfse5a) + psd_rf_wait, pw_rfse5, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
       res_rfse5  = _res_rfse5.fixedflag ?  ((void)(temp_res_rfse5), res_rfse5) : temp_res_rfse5;
  }


        sp_sattemp = pend(&gzrfse5d, "gzrfse5d" , *sat_index);

        ending = pendallssp(&rfse5, *sat_index);
           
  {
    pulsename(&isi_sate5,"isi_sate5");
    createconst(&isi_sate5,(WF_PROCESSOR)wg_isi_sate5,pw_isi_sate5,(short)0); 
    createinstr( &isi_sate5,(long)(ending),pw_isi_sate5,0);
  }

        getctrl(&ctrl_word, &isi_sate5, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate5, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e5,"rot_update_e5");
    createconst(&rot_update_e5,(WF_PROCESSOR)wg_rot_update_e5,pw_rot_update_e5,(short)0); 
    createinstr( &rot_update_e5,(long)(rot_update_time),pw_rot_update_e5,0);
  }

        getctrl(&ctrl_word, &rot_update_e5, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_e5, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse5a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse5, "gykse5", &gykse5, &gykse5a,
                        &gykse5d, pw_gykse5, pw_gykse5a, pw_gykse5d,
                        ia_gykse5, 0, 0, 0, 0, sp_pos_killer-pw_gykse5a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse5d, "gykse5d", *sat_index);

        if (area_gxkse5!=0.0)
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse5, "gxkse5", &gxkse5, &gxkse5a,
                        &gxkse5d, pw_gxkse5, pw_gxkse5a, pw_gxkse5d,
                        ia_gxkse5, 0, 0, 0, 0, sp_pos_killer-pw_gxkse5a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse5d, "gxkse5d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse5d, "gxkse5d", *sat_index);
        }

              
  {
    pulsename(&isi_satek5,"isi_satek5");
    createconst(&isi_satek5,(WF_PROCESSOR)wg_isi_satek5,pw_isi_satek5,(short)0); 
    createinstr( &isi_satek5,(long)(sp_sattemp-isi_satdelay),pw_isi_satek5,0);
  }

        getctrl(&ctrl_word, &isi_satek5, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek5, *sat_index);

                
  {
    pulsename(&rot_update_ek5,"rot_update_ek5");
    createconst(&rot_update_ek5,(WF_PROCESSOR)wg_rot_update_ek5,pw_rot_update_ek5,(short)0); 
    createinstr( &rot_update_ek5,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek5,0);
  }

        getctrl(&ctrl_word, &rot_update_ek5, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_ek5, *sat_index);
          
        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat+pw_rotupdate + isi_extra;

        if ((opexsatparal & PSD_3_PARALLEL) != 0)
            skip_next_sat = 1;
    }

    if (((opexsatmask & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0))
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse6", 
                                     (WF_PROCESSOR)wg_rfse6);

    /* Modify resolution if scaling required */
    temp_res_rfse6  = _temp_res_rfse6.fixedflag ?  ((void)(res_rfse6), temp_res_rfse6) : res_rfse6;
    if (rfpulseInfo[RFSE6_SLOT].change==PSD_ON)
       res_rfse6  = _res_rfse6.fixedflag ?  ((void)(rfpulseInfo[RFSE6_SLOT].newres), res_rfse6) : rfpulseInfo[RFSE6_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse6a,"gzrfse6a");
    pulsename(&gzrfse6,"gzrfse6");
    pulsename(&gzrfse6d,"gzrfse6d");
    pulsename(&rfse6,"rfse6");

    /*  Now create the slice select trapezoid */
        pg_beta  = _pg_beta.fixedflag ?  ((void)(satloggrd.zbeta), pg_beta) : satloggrd.zbeta;
    createramp(&gzrfse6a,ZGRAD,pw_gzrfse6a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse6a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse6a,(LONG)(sp_sattemp+pw_gzrfse6a-pw_gzrfse6a),
                pw_gzrfse6a,ia_gzrfse6);
    createconst(&gzrfse6,ZGRAD,pw_gzrfse6,MAX_PG_WAMP);
    createinstr( &gzrfse6,(LONG)(sp_sattemp+pw_gzrfse6a),
                pw_gzrfse6,ia_gzrfse6);
    createramp(&gzrfse6d,ZGRAD,pw_gzrfse6d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse6d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse6d,(LONG)(sp_sattemp+pw_gzrfse6a+pw_gzrfse6),
                pw_gzrfse6d,ia_gzrfse6);

    /* Now create the rf pulse */
    createsinc(&rfse6,(WF_PROCESSOR)wg_rfse6,res_rfse6,
               MAX_PG_WAMP,cyc_rfse6, alpha_rfse6);

    createinstr( &rfse6,(LONG)(sp_sattemp+pw_gzrfse6a) + psd_rf_wait,
                pw_rfse6,ia_rfse6);
    linkpulses(4,&rfse6,&gzrfse6,&gzrfse6a,
               &gzrfse6d);
    addrfbits(&rfse6,off_rfse6,(LONG)(sp_sattemp+pw_gzrfse6a) + psd_rf_wait,
              pw_rfse6);



    pulsename(&rfse6Theta, "rfse6Theta");
    createreserve(&rfse6Theta, THETA, res_rfse6);
    addrfbits(&rfse6Theta, off_rfse6, (LONG)(sp_sattemp+pw_gzrfse6a) + psd_rf_wait , pw_rfse6);
    createinstr(&rfse6Theta, (LONG)(sp_sattemp+pw_gzrfse6a) + psd_rf_wait, pw_rfse6, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE6_SLOT].change==PSD_ON)
       res_rfse6  = _res_rfse6.fixedflag ?  ((void)(temp_res_rfse6), res_rfse6) : temp_res_rfse6;
  }


        sp_sattemp = pend(&gzrfse6d, "gzrfse6d" , *sat_index);

        ending = pendallssp(&rfse6, *sat_index);
           
  {
    pulsename(&isi_sate6,"isi_sate6");
    createconst(&isi_sate6,(WF_PROCESSOR)wg_isi_sate6,pw_isi_sate6,(short)0); 
    createinstr( &isi_sate6,(long)(ending),pw_isi_sate6,0);
  }

        getctrl(&ctrl_word, &isi_sate6, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate6, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e6,"rot_update_e6");
    createconst(&rot_update_e6,(WF_PROCESSOR)wg_rot_update_e6,pw_rot_update_e6,(short)0); 
    createinstr( &rot_update_e6,(long)(rot_update_time),pw_rot_update_e6,0);
  }

        getctrl(&ctrl_word, &rot_update_e6, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_e6, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse6a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse6, "gykse6", &gykse6, &gykse6a,
                        &gykse6d, pw_gykse6, pw_gykse6a, pw_gykse6d,
                        ia_gykse6, 0, 0, 0, 0, sp_pos_killer-pw_gykse6a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse6d, "gykse6d", *sat_index);

        if (area_gxkse6!=0.0)
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse6, "gxkse6", &gxkse6, &gxkse6a,
                        &gxkse6d, pw_gxkse6, pw_gxkse6a, pw_gxkse6d,
                        ia_gxkse6, 0, 0, 0, 0, sp_pos_killer-pw_gxkse6a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse6d, "gxkse6d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse6d, "gxkse6d", *sat_index);
        }

              
  {
    pulsename(&isi_satek6,"isi_satek6");
    createconst(&isi_satek6,(WF_PROCESSOR)wg_isi_satek6,pw_isi_satek6,(short)0); 
    createinstr( &isi_satek6,(long)(sp_sattemp-isi_satdelay),pw_isi_satek6,0);
  }

        getctrl(&ctrl_word, &isi_satek6, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek6, *sat_index);

                
  {
    pulsename(&rot_update_ek6,"rot_update_ek6");
    createconst(&rot_update_ek6,(WF_PROCESSOR)wg_rot_update_ek6,pw_rot_update_ek6,(short)0); 
    createinstr( &rot_update_ek6,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek6,0);
  }

        getctrl(&ctrl_word, &rot_update_ek6, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_ek6, *sat_index);
          
        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra;
    } 

    /* Slice select macro creates a since RF pulse. 
       A psd can use either sinc or SLR RF pulses. Parallel sat bands
       with the same thickness use a hadamard RF pulse. This one
       pulse replaces the 2 separate RF pulses. If the RF
       pulse is sinc, a hadamard sinc pulse is used. Likewise 
       if the SLR RF pulse is used, a hadamard SLR pulse is used. */

    /******************************************************************************
     ** This section has undergone significant restructuring to accomode rfpulse
     ** scaling following system safety requirements. The overall function is
     ** still similar. In the first case (SINC_SAT), the resolutions are changed
     ** if pulse scaling was performed. Interpolation is not required since the
     ** pulse is generated internally. For (SLR_SAT), the pulse is read into a work
     ** buffer (temp_wave), and copied over to the kernel file either in original
     ** size or increased size if scaling required. All scaling is performed before
     ** hadamard sat's are created. It is assumed that not all sat regions will have
     ** similar pulse resolutions, and scaling may or may not be required for each
     ** rfpulse SAT. The final rfpulse is then immediate moved (movewaveimm) onto
     ** the RHO board, and allocated memory freed.
     ******************************************************************************/
    
    switch (sat_type)
    {
    case SINC_SAT:
	
	/* Handle rf scaling */
	if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
            res_rfse1  = _res_rfse1.fixedflag ?  ((void)(rfpulseInfo[RFSE1_SLOT].newres), res_rfse1) : rfpulseInfo[RFSE1_SLOT].newres;
	if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
            res_rfse3  = _res_rfse3.fixedflag ?  ((void)(rfpulseInfo[RFSE3_SLOT].newres), res_rfse3) : rfpulseInfo[RFSE3_SLOT].newres;
	if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
            res_rfse5  = _res_rfse5.fixedflag ?  ((void)(rfpulseInfo[RFSE5_SLOT].newres), res_rfse5) : rfpulseInfo[RFSE5_SLOT].newres;
	
	if ((opexsatparal & PSD_1_PARALLEL) != 0)
        {
	    separation = 2 * satspace1/exsatthick1;
	    wave_space_rho = (SHORT *) AllocNode(res_rfse1*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfse1, max_pg_wamp, separation,
		      cyc_rfse1, alpha_rfse1);
	    movewaveimm(wave_space_rho, &rfse1, (INT)0, res_rfse1, 
			TOHARDWARE);
        }
	
	if ((opexsatparal & PSD_2_PARALLEL) != 0)
        {
	    separation = 2 * satspace3/exsatthick3;
	    wave_space_rho = (SHORT *) AllocNode(res_rfse3*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfse3, max_pg_wamp, separation,
		      cyc_rfse3, alpha_rfse3);
	    movewaveimm(wave_space_rho, &rfse3, (INT)0, res_rfse3, 
			TOHARDWARE);

        }
	
	if ((opexsatparal & PSD_3_PARALLEL) != 0)
        {
	    separation = 2 * satspace5/exsatthick5;
	    wave_space_rho = (SHORT *) AllocNode(res_rfse5*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfse5, max_pg_wamp, separation,
		      cyc_rfse5, alpha_rfse5);
	    movewaveimm(wave_space_rho, &rfse5, (INT)0, res_rfse5, 
			TOHARDWARE);

        }
	
	FreeNode(wave_space_rho);
	break;
	
    case SLR_SAT:
    case SLR_CSAT:

        switch (sat_type) 
        {
        case SLR_SAT:        	
	     strcpy(rho_file, "rfdblsatl0.rho");
	     temp_wave_rho = (SHORT *)AllocNode(RES_SLRSAT*sizeof(SHORT));
	     uextwave(temp_wave_rho, RES_SLRSAT, rho_file);
             break;
        case SLR_CSAT:
             strcpy(rho_file, "satqptbw12.rho");
             temp_wave_rho = (SHORT *)AllocNode(RES_SLRCSAT*sizeof(SHORT));
             uextwave(temp_wave_rho, RES_SLRCSAT, rho_file);

             if (sat_pulse_type == COMPLEX_RF)
             {
                strcpy(theta_file, "satqptbw12.the");
                temp_wave_theta = (SHORT *)AllocNode(RES_SLRCSAT*sizeof(SHORT));
                uextwave(temp_wave_theta, RES_SLRCSAT, theta_file);
             }
             break;
        default:
             break;
        }
	
	skip_next_sat = 0;
	if ((opexsatmask & PSD_EXPLICIT_1) != 0)
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
            {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE1_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE1_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse1,(int)rfpulseInfo[RFSE1_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE1_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE1_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse1,(int)rfpulseInfo[RFSE1_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }

		res_rfse1  = _res_rfse1.fixedflag ?  ((void)(rfpulseInfo[RFSE1_SLOT].newres), res_rfse1) : rfpulseInfo[RFSE1_SLOT].newres;
            }
	    else
            {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfse1*sizeof(SHORT));
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfse1*sizeof(SHORT));
                }

            }

	    /* Check if hadamard or pulse ON */
	    if ((opexsatparal & PSD_1_PARALLEL) != 0)
	      {
		separation = satspace1/2.0/exsatthick1;
		freqstep = 65536.0/(float)res_rfse1;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfse1, kernel_tab_rho, kernel_tab_theta, cyc_rfse1,
			 separation, gscale_rfse1, NULL, (FLOAT)0, 
			 hadamard_tab_rho, hadamard_tab_theta,freqstep);

                   movewaveimm(hadamard_tab_theta, &rfse1Theta, (INT)0, res_rfse1,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfse1, kernel_tab_rho, cyc_rfse1,
                         separation, gscale_rfse1, NULL, (FLOAT)0,
                         hadamard_tab_rho, freqstep);
                }

                movewaveimm(hadamard_tab_rho, &rfse1, (INT)0, res_rfse1,
                            TOHARDWARE);
             
		skip_next_sat = 1;
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfse1, (INT) 0, res_rfse1,
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfse1Theta, (INT) 0, res_rfse1,
                            TOHARDWARE);
                }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }
	    if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
            {
	      FreeNode(kernel_tab_rho);
              if (sat_pulse_type == COMPLEX_RF)
              {
                 FreeNode(kernel_tab_theta);
              }
            }
	  }
	

	if (((opexsatmask & PSD_EXPLICIT_2) != 0) && 
	    (skip_next_sat == 0))
	  {
	    if (rfpulseInfo[RFSE2_SLOT].change==PSD_ON)
	      {		      
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE2_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse2,(int)rfpulseInfo[RFSE2_SLOT].newres,temp_wave_rho,kernel_tab_rho);
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE2_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse2,(int)rfpulseInfo[RFSE2_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfse2  = _res_rfse2.fixedflag ?  ((void)(rfpulseInfo[RFSE2_SLOT].newres), res_rfse2) : rfpulseInfo[RFSE2_SLOT].newres;
	      }
	    else
              {
	        kernel_tab_rho = temp_wave_rho;
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                }
              }

	    movewaveimm(kernel_tab_rho, &rfse2, (INT)0, res_rfse2,
			TOHARDWARE);

            if (sat_pulse_type == COMPLEX_RF)
            {
               movewaveimm(kernel_tab_theta, &rfse2Theta, (INT) 0, res_rfse2,
                           TOHARDWARE);
            }

	    /* Free Memory */
	    if (rfpulseInfo[RFSE2_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
	  }
	
	skip_next_sat = 0;
	
	if ((opexsatmask & PSD_EXPLICIT_3) != 0)
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
	      {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE3_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE3_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse3,(int)rfpulseInfo[RFSE3_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE3_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE3_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse3,(int)rfpulseInfo[RFSE3_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfse3  = _res_rfse3.fixedflag ?  ((void)(rfpulseInfo[RFSE3_SLOT].newres), res_rfse3) : rfpulseInfo[RFSE3_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfse3*sizeof(SHORT));

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfse3*sizeof(SHORT));
                }
	      }
	    if ((opexsatparal & PSD_2_PARALLEL) != 0)
	      {
		separation = satspace3/2.0/exsatthick3;
		freqstep = 65536.0/(float) res_rfse3;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfse3, kernel_tab_rho, kernel_tab_theta, cyc_rfse3,
			 separation, gscale_rfse3, NULL, (FLOAT)0, 
			 hadamard_tab_rho, hadamard_tab_theta,freqstep);

                   movewaveimm(hadamard_tab_theta, &rfse3Theta, (INT)0, res_rfse3,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfse3, kernel_tab_rho, cyc_rfse3,
                         separation, gscale_rfse3, NULL, (FLOAT)0,
                         hadamard_tab_rho, freqstep);
                }

                movewaveimm(hadamard_tab_rho, &rfse3, (INT)0, res_rfse3,
                            TOHARDWARE);

		skip_next_sat = 1;
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfse3, (INT) 0, res_rfse3,
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfse3Theta, (INT) 0, res_rfse3,
                               TOHARDWARE);
                }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho); 
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }

	    if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	if (((opexsatmask & PSD_EXPLICIT_4) != 0) && 
	    (skip_next_sat == 0))
        {
	    if (rfpulseInfo[RFSE4_SLOT].change==PSD_ON)
	      {		      
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE4_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse4,(int)rfpulseInfo[RFSE4_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE4_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse4,(int)rfpulseInfo[RFSE4_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfse4  = _res_rfse4.fixedflag ?  ((void)(rfpulseInfo[RFSE4_SLOT].newres), res_rfse4) : rfpulseInfo[RFSE4_SLOT].newres;
	      }
	    else
              {
	        kernel_tab_rho = temp_wave_rho; 
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                }
              }

	    movewaveimm(kernel_tab_rho, &rfse4, (INT)0, res_rfse4,
			TOHARDWARE); 
            if (sat_pulse_type == COMPLEX_RF)
            {
               movewaveimm(kernel_tab_theta, &rfse4Theta, (INT)0, res_rfse4,
                           TOHARDWARE);
            }

	    /* Free Memory */
	    if (rfpulseInfo[RFSE4_SLOT].change==PSD_ON) 
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	skip_next_sat = 0;
	
	if ((opexsatmask & PSD_EXPLICIT_5) != 0)
        {
	    if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
	      {		      
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE5_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE5_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse5,(int)rfpulseInfo[RFSE5_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE5_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE5_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse5,(int)rfpulseInfo[RFSE5_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }

		res_rfse5  = _res_rfse5.fixedflag ?  ((void)(rfpulseInfo[RFSE5_SLOT].newres), res_rfse5) : rfpulseInfo[RFSE5_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfse5*sizeof(SHORT));
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfse5*sizeof(SHORT));
                }
	      }
	    
	    if ((opexsatparal & PSD_3_PARALLEL) != 0)
	      {
		separation = satspace5/2.0/exsatthick5;
		freqstep = 65536.0/(float) res_rfse5;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfse5, kernel_tab_rho, kernel_tab_theta, cyc_rfse5,
			 separation, gscale_rfse5, NULL, (FLOAT)0, 
			 hadamard_tab_rho, hadamard_tab_theta, freqstep);

                   movewaveimm(hadamard_tab_theta, &rfse5Theta, (INT)0, res_rfse5,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfse5, kernel_tab_rho, cyc_rfse5,
                         separation, gscale_rfse5, NULL, (FLOAT)0,
                         hadamard_tab_rho, freqstep);
                }
                movewaveimm(hadamard_tab_rho, &rfse5, (INT)0, res_rfse5,
                            TOHARDWARE);

		skip_next_sat = 1;
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfse5, (INT) 0, res_rfse5,
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfse5Theta, (INT) 0, res_rfse5,
                               TOHARDWARE);
                }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }

	    if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	if (((opexsatmask & PSD_EXPLICIT_6) != 0) && 
	    (skip_next_sat == 0))
        {
	    /* Check pulse scaling */
	    if (rfpulseInfo[RFSE6_SLOT].change==PSD_ON)
	      {		      
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE6_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse6,(int)rfpulseInfo[RFSE6_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE6_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse6,(int)rfpulseInfo[RFSE6_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }

		res_rfse6  = _res_rfse6.fixedflag ?  ((void)(rfpulseInfo[RFSE6_SLOT].newres), res_rfse6) : rfpulseInfo[RFSE6_SLOT].newres;
	      }
	    else
              {
	        kernel_tab_rho = temp_wave_rho;
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                }
              }

	    movewaveimm(kernel_tab_rho, &rfse6, (INT)0, res_rfse6,
			TOHARDWARE); 
            if (sat_pulse_type == COMPLEX_RF)
            {
               movewaveimm(kernel_tab_theta, &rfse6Theta, (INT)0, res_rfse6,
                           TOHARDWARE);
            }
	    /* Free Memory */
	    if (rfpulseInfo[RFSE6_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
	    } 
        }

	FreeNode(temp_wave_rho);
        if (sat_pulse_type == COMPLEX_RF)
        {
           FreeNode(temp_wave_theta);
        }
	break;
	
    default:
	break;
    }
    
    /****************************************************************
      DEFAULT SAT GRADEINTS
      
      1. Slice selection gradient
      2. Killer on y gradient
      3. If there are 2 sat bands that are parallel but do not have
      the same thickness, create a separate slice select & killer
      for the second band.
      
    ******************************************************************/
    
    if (opsatx != PSD_OFF)    /* X board */
    {
        if (opsatx == PSD_SATNEG)
            satthickdfx  = _satthickdfx.fixedflag ?  ((void)(satthickx1), satthickdfx) : satthickx1;
        else if (opsatx == PSD_SATPOS)
            satthickdfx  = _satthickdfx.fixedflag ?  ((void)(satthickx2), satthickdfx) : satthickx2;
        else
            satthickdfx  = _satthickdfx.fixedflag ?  ((void)(satthickx1), satthickdfx) : satthickx1;
	
           
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsx1", 
                                     (WF_PROCESSOR)wg_rfsx1);

    /* Modify resolution if scaling required */
    temp_res_rfsx1  = _temp_res_rfsx1.fixedflag ?  ((void)(res_rfsx1), temp_res_rfsx1) : res_rfsx1;
    if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
       res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(rfpulseInfo[RFSX1_SLOT].newres), res_rfsx1) : rfpulseInfo[RFSX1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gxrfsx1a,"gxrfsx1a");
    pulsename(&gxrfsx1,"gxrfsx1");
    pulsename(&gxrfsx1d,"gxrfsx1d");
    pulsename(&rfsx1,"rfsx1");

    /*  Now create the slice select trapezoid */
    pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.xbeta), pg_beta) : loggrd.xbeta;
    createramp(&gxrfsx1a,XGRAD,pw_gxrfsx1a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gxrfsx1a/
                                               GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gxrfsx1a,(LONG)(sp_sattemp+pw_gxrfsx1a-pw_gxrfsx1a),
                pw_gxrfsx1a,ia_gxrfsx1);
    createconst(&gxrfsx1,XGRAD,pw_gxrfsx1,MAX_PG_WAMP);
    createinstr( &gxrfsx1,(LONG)(sp_sattemp+pw_gxrfsx1a),
                pw_gxrfsx1,ia_gxrfsx1);
    createramp(&gxrfsx1d,XGRAD,pw_gxrfsx1d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gxrfsx1d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gxrfsx1d,(LONG)(sp_sattemp+pw_gxrfsx1a+pw_gxrfsx1),
                pw_gxrfsx1d,ia_gxrfsx1);

    /* Now create the rf pulse */
    createsinc(&rfsx1,(WF_PROCESSOR)wg_rfsx1,res_rfsx1,
               MAX_PG_WAMP,cyc_rfsx1, alpha_rfsx1);
    createinstr( &rfsx1,(LONG)(sp_sattemp+pw_gxrfsx1a) + psd_rf_wait,
                pw_rfsx1,ia_rfsx1);
    linkpulses(4,&rfsx1,&gxrfsx1,&gxrfsx1a,
               &gxrfsx1d);
    addrfbits(&rfsx1,off_rfsx1,(LONG)(sp_sattemp+pw_gxrfsx1a) + psd_rf_wait,
              pw_rfsx1);


    pulsename(&rfsx1Theta, "rfsx1Theta");
    createreserve(&rfsx1Theta, THETA, res_rfsx1);
    addrfbits(&rfsx1Theta, off_rfsx1, (LONG)(sp_sattemp+pw_gxrfsx1a) + psd_rf_wait , pw_rfsx1);
    createinstr(&rfsx1Theta, (LONG)(sp_sattemp+pw_gxrfsx1a) + psd_rf_wait, pw_rfsx1, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
       res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(temp_res_rfsx1), res_rfsx1) : temp_res_rfsx1;
}

	
        sp_sattemp = pend(&gxrfsx1d, "gxrfsx1d", *sat_index);
	
        ending = pendallssp(&rfsx1, *sat_index);
           
  {
    pulsename(&isi_satx1,"isi_satx1");
    createconst(&isi_satx1,(WF_PROCESSOR)wg_isi_satx1,pw_isi_satx1,(short)0); 
    createinstr( &isi_satx1,(long)(ending),pw_isi_satx1,0);
  }

        getctrl(&ctrl_word, &isi_satx1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satx1, *sat_index);
	rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	
           
  {
    pulsename(&rot_update_x1,"rot_update_x1");
    createconst(&rot_update_x1,(WF_PROCESSOR)wg_rot_update_x1,pw_rot_update_x1,(short)0); 
    createinstr( &rot_update_x1,(long)(rot_update_time),pw_rot_update_x1,0);
  }

        getctrl(&ctrl_word, &rot_update_x1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_x1, *sat_index);
	sp_sattemp = RUP_GRD(rot_update_time + pw_rotupdate);

        sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksx1a + isi_extra);
             

  trapezoid((WF_PROCESSOR)wg_gyksx1, "gyksx1", &gyksx1, &gyksx1a,
                        &gyksx1d, pw_gyksx1, pw_gyksx1a, pw_gyksx1d,
                        ia_gyksx1, 0, 0, 0, 0, sp_pos_killer-pw_gyksx1a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gyksx1d, "gyksx1d", *sat_index);

	if (area_gxksx1!=0.0)
        {
	        

  trapezoid((WF_PROCESSOR)wg_gxksx1, "gxksx1", &gxksx1, &gxksx1a,
                        &gxksx1d, pw_gxksx1, pw_gxksx1a, pw_gxksx1d,
                        ia_gxksx1, 0, 0, 0, 0, sp_pos_killer-pw_gxksx1a, TRAP_ALL,
                        &loggrd);

	    if  (pend(&gxksx1d, "gxksx1d", *sat_index)>sp_sattemp)
                sp_sattemp = pend(&gxksx1d, "gxksx1d", *sat_index);
        }

              
  {
    pulsename(&isi_satxk1,"isi_satxk1");
    createconst(&isi_satxk1,(WF_PROCESSOR)wg_isi_satxk1,pw_isi_satxk1,(short)0); 
    createinstr( &isi_satxk1,(long)(sp_sattemp-isi_satdelay),pw_isi_satxk1,0);
  }

        getctrl(&ctrl_word, &isi_satxk1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satxk1, *sat_index);

                
  {
    pulsename(&rot_update_xk1,"rot_update_xk1");
    createconst(&rot_update_xk1,(WF_PROCESSOR)wg_rot_update_xk1,pw_rot_update_xk1,(short)0); 
    createinstr( &rot_update_xk1,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_xk1,0);
  }

        getctrl(&ctrl_word, &rot_update_xk1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_xk1, *sat_index);
       
	/* RJL 08/24/95. More dynamic calculation of timing */
	sp_sattemp = RUP_GRD(sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra);

        if (opsatx == PSD_SATPARA)
        {
                
                       
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsx2", 
                                     (WF_PROCESSOR)wg_rfsx2);

    /* Modify resolution if scaling required */
    temp_res_rfsx2  = _temp_res_rfsx2.fixedflag ?  ((void)(res_rfsx2), temp_res_rfsx2) : res_rfsx2;
    if (rfpulseInfo[RFSX2_SLOT].change==PSD_ON)
       res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(rfpulseInfo[RFSX2_SLOT].newres), res_rfsx2) : rfpulseInfo[RFSX2_SLOT].newres;
    /* First create the pulses */
    pulsename(&gxrfsx2a,"gxrfsx2a");
    pulsename(&gxrfsx2,"gxrfsx2");
    pulsename(&gxrfsx2d,"gxrfsx2d");
    pulsename(&rfsx2,"rfsx2");

    /*  Now create the slice select trapezoid */
    pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.xbeta), pg_beta) : loggrd.xbeta;
    createramp(&gxrfsx2a,XGRAD,pw_gxrfsx2a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gxrfsx2a/
                                               GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gxrfsx2a,(LONG)(sp_sattemp+pw_gxrfsx2a-pw_gxrfsx2a),
                pw_gxrfsx2a,ia_gxrfsx2);
    createconst(&gxrfsx2,XGRAD,pw_gxrfsx2,MAX_PG_WAMP);
    createinstr( &gxrfsx2,(LONG)(sp_sattemp+pw_gxrfsx2a),
                pw_gxrfsx2,ia_gxrfsx2);
    createramp(&gxrfsx2d,XGRAD,pw_gxrfsx2d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gxrfsx2d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gxrfsx2d,(LONG)(sp_sattemp+pw_gxrfsx2a+pw_gxrfsx2),
                pw_gxrfsx2d,ia_gxrfsx2);

    /* Now create the rf pulse */
    createsinc(&rfsx2,(WF_PROCESSOR)wg_rfsx2,res_rfsx2,
               MAX_PG_WAMP,cyc_rfsx2, alpha_rfsx2);
    createinstr( &rfsx2,(LONG)(sp_sattemp+pw_gxrfsx2a) + psd_rf_wait,
                pw_rfsx2,ia_rfsx2);
    linkpulses(4,&rfsx2,&gxrfsx2,&gxrfsx2a,
               &gxrfsx2d);
    addrfbits(&rfsx2,off_rfsx2,(LONG)(sp_sattemp+pw_gxrfsx2a) + psd_rf_wait,
              pw_rfsx2);


    pulsename(&rfsx2Theta, "rfsx2Theta");
    createreserve(&rfsx2Theta, THETA, res_rfsx2);
    addrfbits(&rfsx2Theta, off_rfsx2, (LONG)(sp_sattemp+pw_gxrfsx2a) + psd_rf_wait , pw_rfsx2);
    createinstr(&rfsx2Theta, (LONG)(sp_sattemp+pw_gxrfsx2a) + psd_rf_wait, pw_rfsx2, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSX2_SLOT].change==PSD_ON)
       res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(temp_res_rfsx2), res_rfsx2) : temp_res_rfsx2;
}


	    sp_sattemp = pend(&gxrfsx2d, "gxrfsx2d", *sat_index) ;
	    
	    ending = pendallssp(&rfsx2, *sat_index);
	       
  {
    pulsename(&isi_satx2,"isi_satx2");
    createconst(&isi_satx2,(WF_PROCESSOR)wg_isi_satx2,pw_isi_satx2,(short)0); 
    createinstr( &isi_satx2,(long)(ending),pw_isi_satx2,0);
  }

	    getctrl(&ctrl_word, &isi_satx2, *sat_index);
	    ctrl_word = ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satx2, *sat_index);
            rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	    
	       
  {
    pulsename(&rot_update_x2,"rot_update_x2");
    createconst(&rot_update_x2,(WF_PROCESSOR)wg_rot_update_x2,pw_rot_update_x2,(short)0); 
    createinstr( &rot_update_x2,(long)(rot_update_time),pw_rot_update_x2,0);
  }

	    getctrl(&ctrl_word, &rot_update_x2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_x2, *sat_index);
	    sp_sattemp = RUP_GRD(rot_update_time + pw_rotupdate);	    

	    sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksx2a + isi_extra);
	         

  trapezoid((WF_PROCESSOR)wg_gyksx2, "gyksx2", &gyksx2, &gyksx2a,
                        &gyksx2d, pw_gyksx2, pw_gyksx2a, pw_gyksx2d,
                        ia_gyksx2, 0, 0, 0, 0, sp_pos_killer-pw_gyksx2a, TRAP_ALL,
                        &loggrd);

	    sp_sattemp = pend(&gyksx2d, "gyksx2d",*sat_index) ;
	    
	    if (area_gxksx2!=0.0)
            {
		    

  trapezoid((WF_PROCESSOR)wg_gxksx2, "gxksx2", &gxksx2, &gxksx2a,
                        &gxksx2d, pw_gxksx2, pw_gxksx2a, pw_gxksx2d,
                        ia_gxksx2, 0, 0, 0, 0, sp_pos_killer-pw_gxksx2a, TRAP_ALL,
                        &loggrd);

		if  (pend(&gxksx2d, "gxksx2d", *sat_index)>sp_sattemp)
                    sp_sattemp = pend(&gxksx2d, "gxksx2d", *sat_index);
            }
	    
	         
  {
    pulsename(&isi_satxk2,"isi_satxk2");
    createconst(&isi_satxk2,(WF_PROCESSOR)wg_isi_satxk2,pw_isi_satxk2,(short)0); 
    createinstr( &isi_satxk2,(long)(sp_sattemp-isi_satdelay),pw_isi_satxk2,0);
  }

	    getctrl(&ctrl_word, &isi_satxk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satxk2, *sat_index);
	    
	            
  {
    pulsename(&rot_update_xk2,"rot_update_xk2");
    createconst(&rot_update_xk2,(WF_PROCESSOR)wg_rot_update_xk2,pw_rot_update_xk2,(short)0); 
    createinstr( &rot_update_xk2,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_xk2,0);
  }

	    getctrl(&ctrl_word, &rot_update_xk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_xk2, *sat_index);
	    
	    /* RJL 08/24/95. More dynamic calculation of timing */
	    sp_sattemp = RUP_GRD(sp_sattemp - isi_satdelay  + pw_isisat+pw_rotupdate + isi_extra);
        }
    }

    if (opsaty != PSD_OFF)   /* Y Board */
    {
        if (opsaty == PSD_SATNEG)
            satthickdfy  = _satthickdfy.fixedflag ?  ((void)(satthicky1), satthickdfy) : satthicky1;
        else if (opsaty == PSD_SATPOS)
            satthickdfy  = _satthickdfy.fixedflag ?  ((void)(satthicky2), satthickdfy) : satthicky2;
        else
            satthickdfy  = _satthickdfy.fixedflag ?  ((void)(satthicky1), satthickdfy) : satthicky1;

             
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsy1", 
                                     (WF_PROCESSOR)wg_rfsy1);

    /* Modify resolution if scaling required */
    temp_res_rfsy1  = _temp_res_rfsy1.fixedflag ?  ((void)(res_rfsy1), temp_res_rfsy1) : res_rfsy1;
    if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
      res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(rfpulseInfo[RFSY1_SLOT].newres), res_rfsy1) : rfpulseInfo[RFSY1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gyrfsy1a,"gyrfsy1a");
    pulsename(&gyrfsy1,"gyrfsy1");
    pulsename(&gyrfsy1d,"gyrfsy1d");
    pulsename(&rfsy1,"rfsy1");

        /*  Now create the slice select trapezoid */
  pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.ybeta), pg_beta) : loggrd.ybeta;
  createramp(&gyrfsy1a,YGRAD,pw_gyrfsy1a,(short)0,MAX_PG_WAMP,
                        (short)(maxGradRes*(pw_gyrfsy1a/GRAD_UPDATE_TIME))

                        ,pg_beta);
  createinstr( &gyrfsy1a,(LONG)(sp_sattemp+pw_gyrfsy1a-pw_gyrfsy1a),
      pw_gyrfsy1a,ia_gyrfsy1);
  createconst(&gyrfsy1,YGRAD,pw_gyrfsy1,MAX_PG_WAMP);
  createinstr( &gyrfsy1,(LONG)(sp_sattemp+pw_gyrfsy1a),
      pw_gyrfsy1,ia_gyrfsy1);
  createramp(&gyrfsy1d,YGRAD,pw_gyrfsy1d,MAX_PG_WAMP,
                        (short)0,(short)(maxGradRes*(pw_gyrfsy1d/GRAD_UPDATE_TIME))
                        ,pg_beta);
  createinstr( &gyrfsy1d,(LONG)(sp_sattemp+pw_gyrfsy1a+pw_gyrfsy1),
      pw_gyrfsy1d,ia_gyrfsy1);

    /* Now create the rf pulse */
    createsinc(&rfsy1,(WF_PROCESSOR)wg_rfsy1,res_rfsy1,
               MAX_PG_WAMP,cyc_rfsy1, alpha_rfsy1);
    createinstr( &rfsy1,(LONG)(sp_sattemp+pw_gyrfsy1a) + psd_rf_wait,
                pw_rfsy1,ia_rfsy1);
    linkpulses(4,&rfsy1,&gyrfsy1,&gyrfsy1a,&gyrfsy1d);
    addrfbits(&rfsy1,off_rfsy1,(LONG)(sp_sattemp+pw_gyrfsy1a) + psd_rf_wait,
              pw_rfsy1);

    pulsename(&rfsy1Theta, "rfsy1Theta");
    createreserve(&rfsy1Theta, THETA, res_rfsy1);
    addrfbits(&rfsy1Theta, off_rfsy1, (LONG)(sp_sattemp+pw_gyrfsy1a) + psd_rf_wait , pw_rfsy1);
    createinstr(&rfsy1Theta, (LONG)(sp_sattemp+pw_gyrfsy1a) + psd_rf_wait, pw_rfsy1, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
      res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(temp_res_rfsy1), res_rfsy1) : temp_res_rfsy1;
}



        sp_sattemp = pend(&gyrfsy1d, "gyrfsy1d" , *sat_index);

        ending = pendallssp(&rfsy1, *sat_index);
           
  {
    pulsename(&isi_saty1,"isi_saty1");
    createconst(&isi_saty1,(WF_PROCESSOR)wg_isi_saty1,pw_isi_saty1,(short)0); 
    createinstr( &isi_saty1,(long)(ending),pw_isi_saty1,0);
  }

        getctrl(&ctrl_word, &isi_saty1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_saty1, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_y1,"rot_update_y1");
    createconst(&rot_update_y1,(WF_PROCESSOR)wg_rot_update_y1,pw_rot_update_y1,(short)0); 
    createinstr( &rot_update_y1,(long)(rot_update_time),pw_rot_update_y1,0);
  }

        getctrl(&ctrl_word, &rot_update_y1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_y1, *sat_index);
	sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksy1a + isi_extra);
              

  trapezoid((WF_PROCESSOR)wg_gyksy1, "gyksy1", &gyksy1, &gyksy1a,
                        &gyksy1d, pw_gyksy1, pw_gyksy1a, pw_gyksy1d,
                        ia_gyksy1, 0, 0, 0, 0, sp_pos_killer-pw_gyksy1a, TRAP_ALL,
                        &loggrd);
 
        sp_sattemp = pend(&gyksy1d, "gyksy1d", *sat_index);

	if (area_gxksy1!=0.0)
        {
	        

  trapezoid((WF_PROCESSOR)wg_gxksy1, "gxksy1", &gxksy1, &gxksy1a,
                        &gxksy1d, pw_gxksy1, pw_gxksy1a, pw_gxksy1d,
                        ia_gxksy1, 0, 0, 0, 0, sp_pos_killer-pw_gxksy1a, TRAP_ALL,
                        &loggrd);

	    if  (pend(&gxksy1d, "gxksy1d", *sat_index)>sp_sattemp)
                sp_sattemp = pend(&gxksy1d, "gxksy1d", *sat_index);
        }

              
  {
    pulsename(&isi_satyk1,"isi_satyk1");
    createconst(&isi_satyk1,(WF_PROCESSOR)wg_isi_satyk1,pw_isi_satyk1,(short)0); 
    createinstr( &isi_satyk1,(long)(sp_sattemp-isi_satdelay),pw_isi_satyk1,0);
  }

        getctrl(&ctrl_word, &isi_satyk1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satyk1, *sat_index);

                
  {
    pulsename(&rot_update_yk1,"rot_update_yk1");
    createconst(&rot_update_yk1,(WF_PROCESSOR)wg_rot_update_yk1,pw_rot_update_yk1,(short)0); 
    createinstr( &rot_update_yk1,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_yk1,0);
  }

        getctrl(&ctrl_word, &rot_update_yk1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_yk1, *sat_index);
        
	/* RJL 08/24/95. More dynamic calculation of timing */
	sp_sattemp = RUP_GRD(sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra);

        if (opsaty == PSD_SATPARA)
        {
                
                        
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsy2", 
                                     (WF_PROCESSOR)wg_rfsy2);

    /* Modify resolution if scaling required */
    temp_res_rfsy2  = _temp_res_rfsy2.fixedflag ?  ((void)(res_rfsy2), temp_res_rfsy2) : res_rfsy2;
    if (rfpulseInfo[RFSY2_SLOT].change==PSD_ON)
      res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(rfpulseInfo[RFSY2_SLOT].newres), res_rfsy2) : rfpulseInfo[RFSY2_SLOT].newres;
    /* First create the pulses */
    pulsename(&gyrfsy2a,"gyrfsy2a");
    pulsename(&gyrfsy2,"gyrfsy2");
    pulsename(&gyrfsy2d,"gyrfsy2d");
    pulsename(&rfsy2,"rfsy2");

        /*  Now create the slice select trapezoid */
  pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.ybeta), pg_beta) : loggrd.ybeta;
  createramp(&gyrfsy2a,YGRAD,pw_gyrfsy2a,(short)0,MAX_PG_WAMP,
                        (short)(maxGradRes*(pw_gyrfsy2a/GRAD_UPDATE_TIME))

                        ,pg_beta);
  createinstr( &gyrfsy2a,(LONG)(sp_sattemp+pw_gyrfsy2a-pw_gyrfsy2a),
      pw_gyrfsy2a,ia_gyrfsy2);
  createconst(&gyrfsy2,YGRAD,pw_gyrfsy2,MAX_PG_WAMP);
  createinstr( &gyrfsy2,(LONG)(sp_sattemp+pw_gyrfsy2a),
      pw_gyrfsy2,ia_gyrfsy2);
  createramp(&gyrfsy2d,YGRAD,pw_gyrfsy2d,MAX_PG_WAMP,
                        (short)0,(short)(maxGradRes*(pw_gyrfsy2d/GRAD_UPDATE_TIME))
                        ,pg_beta);
  createinstr( &gyrfsy2d,(LONG)(sp_sattemp+pw_gyrfsy2a+pw_gyrfsy2),
      pw_gyrfsy2d,ia_gyrfsy2);

    /* Now create the rf pulse */
    createsinc(&rfsy2,(WF_PROCESSOR)wg_rfsy2,res_rfsy2,
               MAX_PG_WAMP,cyc_rfsy2, alpha_rfsy2);
    createinstr( &rfsy2,(LONG)(sp_sattemp+pw_gyrfsy2a) + psd_rf_wait,
                pw_rfsy2,ia_rfsy2);
    linkpulses(4,&rfsy2,&gyrfsy2,&gyrfsy2a,&gyrfsy2d);
    addrfbits(&rfsy2,off_rfsy2,(LONG)(sp_sattemp+pw_gyrfsy2a) + psd_rf_wait,
              pw_rfsy2);

    pulsename(&rfsy2Theta, "rfsy2Theta");
    createreserve(&rfsy2Theta, THETA, res_rfsy2);
    addrfbits(&rfsy2Theta, off_rfsy2, (LONG)(sp_sattemp+pw_gyrfsy2a) + psd_rf_wait , pw_rfsy2);
    createinstr(&rfsy2Theta, (LONG)(sp_sattemp+pw_gyrfsy2a) + psd_rf_wait, pw_rfsy2, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSY2_SLOT].change==PSD_ON)
      res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(temp_res_rfsy2), res_rfsy2) : temp_res_rfsy2;
}



	    sp_sattemp = pend(&gyrfsy2d, "gyrfsy2d", *sat_index);
	    ending = pendallssp(&rfsy2, *sat_index);
	       
  {
    pulsename(&isi_saty2,"isi_saty2");
    createconst(&isi_saty2,(WF_PROCESSOR)wg_isi_saty2,pw_isi_saty2,(short)0); 
    createinstr( &isi_saty2,(long)(ending),pw_isi_saty2,0);
  }

	    getctrl(&ctrl_word, &isi_saty2, *sat_index);
	    ctrl_word =  ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_saty2, *sat_index);
            rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	    
	       
  {
    pulsename(&rot_update_y2,"rot_update_y2");
    createconst(&rot_update_y2,(WF_PROCESSOR)wg_rot_update_y2,pw_rot_update_y2,(short)0); 
    createinstr( &rot_update_y2,(long)(rot_update_time),pw_rot_update_y2,0);
  }

	    getctrl(&ctrl_word, &rot_update_y2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_y2, *sat_index);
	    sp_sattemp = rot_update_time + pw_rotupdate;    

	    sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksy2a + isi_extra);
	           

  trapezoid((WF_PROCESSOR)wg_gyksy2, "gyksy2", &gyksy2, &gyksy2a,
                        &gyksy2d, pw_gyksy2, pw_gyksy2a, pw_gyksy2d,
                        ia_gyksy2, 0, 0, 0, 0, sp_pos_killer-pw_gyksy2a, TRAP_ALL,
                        &loggrd);
 
	    sp_sattemp = pend(&gyksy2d, "gyksy2d", *sat_index);
	    
	    if (area_gxksy2!=0.0)
            {
		    

  trapezoid((WF_PROCESSOR)wg_gxksy2, "gxksy2", &gxksy2, &gxksy2a,
                        &gxksy2d, pw_gxksy2, pw_gxksy2a, pw_gxksy2d,
                        ia_gxksy2, 0, 0, 0, 0, sp_pos_killer-pw_gxksy2a, TRAP_ALL,
                        &loggrd);

		if  (pend(&gxksy2d, "gxksy2d", *sat_index)>sp_sattemp)
                    sp_sattemp = pend(&gxksy2d, "gxksy2d", *sat_index);
            }
	    
	          
  {
    pulsename(&isi_satyk2,"isi_satyk2");
    createconst(&isi_satyk2,(WF_PROCESSOR)wg_isi_satyk2,pw_isi_satyk2,(short)0); 
    createinstr( &isi_satyk2,(long)(sp_sattemp-isi_satdelay),pw_isi_satyk2,0);
  }

	    getctrl(&ctrl_word, &isi_satyk2, *sat_index);
	    ctrl_word =  ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satyk2, *sat_index);
	    
	            
  {
    pulsename(&rot_update_yk2,"rot_update_yk2");
    createconst(&rot_update_yk2,(WF_PROCESSOR)wg_rot_update_yk2,pw_rot_update_yk2,(short)0); 
    createinstr( &rot_update_yk2,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_yk2,0);
  }

	    getctrl(&ctrl_word, &rot_update_yk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_yk2, *sat_index);
	    
	    /* RJL 08/24/95. More dynamic calculation of timing */
	    sp_sattemp = RUP_GRD(sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra);
        }
    }

    if (opsatz != PSD_OFF)  /* Z Board */
    {
	if (opsatz == PSD_SATNEG)
            satthickdfz  = _satthickdfz.fixedflag ?  ((void)(satthickz1), satthickdfz) : satthickz1;
        else if (opsatz == PSD_SATPOS)
            satthickdfz  = _satthickdfz.fixedflag ?  ((void)(satthickz2), satthickdfz) : satthickz2;
        else
            satthickdfz  = _satthickdfz.fixedflag ?  ((void)(satthickz1), satthickdfz) : satthickz1;
	
             
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsz1", 
                                     (WF_PROCESSOR)wg_rfsz1);

    /* Modify resolution if scaling required */
    temp_res_rfsz1  = _temp_res_rfsz1.fixedflag ?  ((void)(res_rfsz1), temp_res_rfsz1) : res_rfsz1;
    if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
       res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(rfpulseInfo[RFSZ1_SLOT].newres), res_rfsz1) : rfpulseInfo[RFSZ1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfsz1a,"gzrfsz1a");
    pulsename(&gzrfsz1,"gzrfsz1");
    pulsename(&gzrfsz1d,"gzrfsz1d");
    pulsename(&rfsz1,"rfsz1");

    /*  Now create the slice select trapezoid */
        pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;
    createramp(&gzrfsz1a,ZGRAD,pw_gzrfsz1a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfsz1a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfsz1a,(LONG)(sp_sattemp+pw_gzrfsz1a-pw_gzrfsz1a),
                pw_gzrfsz1a,ia_gzrfsz1);
    createconst(&gzrfsz1,ZGRAD,pw_gzrfsz1,MAX_PG_WAMP);
    createinstr( &gzrfsz1,(LONG)(sp_sattemp+pw_gzrfsz1a),
                pw_gzrfsz1,ia_gzrfsz1);
    createramp(&gzrfsz1d,ZGRAD,pw_gzrfsz1d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfsz1d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfsz1d,(LONG)(sp_sattemp+pw_gzrfsz1a+pw_gzrfsz1),
                pw_gzrfsz1d,ia_gzrfsz1);

    /* Now create the rf pulse */
    createsinc(&rfsz1,(WF_PROCESSOR)wg_rfsz1,res_rfsz1,
               MAX_PG_WAMP,cyc_rfsz1, alpha_rfsz1);

    createinstr( &rfsz1,(LONG)(sp_sattemp+pw_gzrfsz1a) + psd_rf_wait,
                pw_rfsz1,ia_rfsz1);
    linkpulses(4,&rfsz1,&gzrfsz1,&gzrfsz1a,
               &gzrfsz1d);
    addrfbits(&rfsz1,off_rfsz1,(LONG)(sp_sattemp+pw_gzrfsz1a) + psd_rf_wait,
              pw_rfsz1);



    pulsename(&rfsz1Theta, "rfsz1Theta");
    createreserve(&rfsz1Theta, THETA, res_rfsz1);
    addrfbits(&rfsz1Theta, off_rfsz1, (LONG)(sp_sattemp+pw_gzrfsz1a) + psd_rf_wait , pw_rfsz1);
    createinstr(&rfsz1Theta, (LONG)(sp_sattemp+pw_gzrfsz1a) + psd_rf_wait, pw_rfsz1, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
       res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(temp_res_rfsz1), res_rfsz1) : temp_res_rfsz1;
  }


        sp_sattemp = pend(&gzrfsz1d, "gzrfsz1d", *sat_index);
	
        ending = pendallssp(&rfsz1, *sat_index);
           
  {
    pulsename(&isi_satz1,"isi_satz1");
    createconst(&isi_satz1,(WF_PROCESSOR)wg_isi_satz1,pw_isi_satz1,(short)0); 
    createinstr( &isi_satz1,(long)(ending),pw_isi_satz1,0);
  }

        getctrl(&ctrl_word, &isi_satz1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satz1, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	
           
  {
    pulsename(&rot_update_z1,"rot_update_z1");
    createconst(&rot_update_z1,(WF_PROCESSOR)wg_rot_update_z1,pw_rot_update_z1,(short)0); 
    createinstr( &rot_update_z1,(long)(rot_update_time),pw_rot_update_z1,0);
  }

        getctrl(&ctrl_word, &rot_update_z1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_z1, *sat_index);
	sp_sattemp = rot_update_time + pw_rotupdate;
	
        sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksz1a + isi_extra);
             

  trapezoid((WF_PROCESSOR)wg_gyksz1, "gyksz1", &gyksz1, &gyksz1a,
                        &gyksz1d, pw_gyksz1, pw_gyksz1a, pw_gyksz1d,
                        ia_gyksz1, 0, 0, 0, 0, sp_pos_killer-pw_gyksz1a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gyksz1d, "gyksz1d", *sat_index);
	
	if (area_gxksz1!=0.0)
        {
	        

  trapezoid((WF_PROCESSOR)wg_gxksz1, "gxksz1", &gxksz1, &gxksz1a,
                        &gxksz1d, pw_gxksz1, pw_gxksz1a, pw_gxksz1d,
                        ia_gxksz1, 0, 0, 0, 0, sp_pos_killer-pw_gxksz1a, TRAP_ALL,
                        &loggrd);

	    if  (pend(&gxksz1d, "gxksz1d", *sat_index)>sp_sattemp)
                sp_sattemp = pend(&gxksz1d, "gxksz1d", *sat_index);
        }

              
  {
    pulsename(&isi_satzk1,"isi_satzk1");
    createconst(&isi_satzk1,(WF_PROCESSOR)wg_isi_satzk1,pw_isi_satzk1,(short)0); 
    createinstr( &isi_satzk1,(long)(sp_sattemp-isi_satdelay),pw_isi_satzk1,0);
  }

        getctrl(&ctrl_word, &isi_satzk1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satzk1, *sat_index);
	
                
  {
    pulsename(&rot_update_zk1,"rot_update_zk1");
    createconst(&rot_update_zk1,(WF_PROCESSOR)wg_rot_update_zk1,pw_rot_update_zk1,(short)0); 
    createinstr( &rot_update_zk1,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_zk1,0);
  }

        getctrl(&ctrl_word, &rot_update_zk1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_zk1, *sat_index);
        
	/* RJL 08/24/95. More dynamic calculation of timing */
	sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat+pw_rotupdate + isi_extra;
	
        if (opsatz == PSD_SATPARA)
        {
                
                        
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsz2", 
                                     (WF_PROCESSOR)wg_rfsz2);

    /* Modify resolution if scaling required */
    temp_res_rfsz2  = _temp_res_rfsz2.fixedflag ?  ((void)(res_rfsz2), temp_res_rfsz2) : res_rfsz2;
    if (rfpulseInfo[RFSZ2_SLOT].change==PSD_ON)
       res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(rfpulseInfo[RFSZ2_SLOT].newres), res_rfsz2) : rfpulseInfo[RFSZ2_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfsz2a,"gzrfsz2a");
    pulsename(&gzrfsz2,"gzrfsz2");
    pulsename(&gzrfsz2d,"gzrfsz2d");
    pulsename(&rfsz2,"rfsz2");

    /*  Now create the slice select trapezoid */
        pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;
    createramp(&gzrfsz2a,ZGRAD,pw_gzrfsz2a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfsz2a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfsz2a,(LONG)(sp_sattemp+pw_gzrfsz2a-pw_gzrfsz2a),
                pw_gzrfsz2a,ia_gzrfsz2);
    createconst(&gzrfsz2,ZGRAD,pw_gzrfsz2,MAX_PG_WAMP);
    createinstr( &gzrfsz2,(LONG)(sp_sattemp+pw_gzrfsz2a),
                pw_gzrfsz2,ia_gzrfsz2);
    createramp(&gzrfsz2d,ZGRAD,pw_gzrfsz2d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfsz2d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfsz2d,(LONG)(sp_sattemp+pw_gzrfsz2a+pw_gzrfsz2),
                pw_gzrfsz2d,ia_gzrfsz2);

    /* Now create the rf pulse */
    createsinc(&rfsz2,(WF_PROCESSOR)wg_rfsz2,res_rfsz2,
               MAX_PG_WAMP,cyc_rfsz2, alpha_rfsz2);

    createinstr( &rfsz2,(LONG)(sp_sattemp+pw_gzrfsz2a) + psd_rf_wait,
                pw_rfsz2,ia_rfsz2);
    linkpulses(4,&rfsz2,&gzrfsz2,&gzrfsz2a,
               &gzrfsz2d);
    addrfbits(&rfsz2,off_rfsz2,(LONG)(sp_sattemp+pw_gzrfsz2a) + psd_rf_wait,
              pw_rfsz2);



    pulsename(&rfsz2Theta, "rfsz2Theta");
    createreserve(&rfsz2Theta, THETA, res_rfsz2);
    addrfbits(&rfsz2Theta, off_rfsz2, (LONG)(sp_sattemp+pw_gzrfsz2a) + psd_rf_wait , pw_rfsz2);
    createinstr(&rfsz2Theta, (LONG)(sp_sattemp+pw_gzrfsz2a) + psd_rf_wait, pw_rfsz2, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSZ2_SLOT].change==PSD_ON)
       res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(temp_res_rfsz2), res_rfsz2) : temp_res_rfsz2;
  }


	    sp_sattemp = pend(&gzrfsz2d, "gzrfsz2d", *sat_index);
	    
	    ending = pendallssp(&rfsz2, *sat_index);
	       
  {
    pulsename(&isi_satz2,"isi_satz2");
    createconst(&isi_satz2,(WF_PROCESSOR)wg_isi_satz2,pw_isi_satz2,(short)0); 
    createinstr( &isi_satz2,(long)(ending),pw_isi_satz2,0);
  }

	    getctrl(&ctrl_word, &isi_satz2, *sat_index);
	    ctrl_word = ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satz2, *sat_index);
            rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	    
	       
  {
    pulsename(&rot_update_z2,"rot_update_z2");
    createconst(&rot_update_z2,(WF_PROCESSOR)wg_rot_update_z2,pw_rot_update_z2,(short)0); 
    createinstr( &rot_update_z2,(long)(rot_update_time),pw_rot_update_z2,0);
  }

	    getctrl(&ctrl_word, &rot_update_z2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_z2, *sat_index);
	    sp_sattemp = rot_update_time + pw_rotupdate;	    

	    sp_pos_killer = sp_sattemp + pw_gyksz2a + isi_extra;
	          

  trapezoid((WF_PROCESSOR)wg_gyksz2, "gyksz2", &gyksz2, &gyksz2a,
                        &gyksz2d, pw_gyksz2, pw_gyksz2a, pw_gyksz2d,
                        ia_gyksz2, 0, 0, 0, 0, sp_pos_killer-pw_gyksz2a, TRAP_ALL,
                        &loggrd);
 
	    sp_sattemp = pend(&gyksz2d, "gyksz2d", *sat_index);
	    
	    if (area_gxksz2!=0.0)
            {
		    

  trapezoid((WF_PROCESSOR)wg_gxksz2, "gxksz2", &gxksz2, &gxksz2a,
                        &gxksz2d, pw_gxksz2, pw_gxksz2a, pw_gxksz2d,
                        ia_gxksz2, 0, 0, 0, 0, sp_pos_killer-pw_gxksz2a, TRAP_ALL,
                        &loggrd);

		if  (pend(&gxksz2d, "gxksz2d", *sat_index)>sp_sattemp)
                    sp_sattemp = pend(&gxksz2d, "gxksz2d", *sat_index);
            }
	    
	          
  {
    pulsename(&isi_satzk2,"isi_satzk2");
    createconst(&isi_satzk2,(WF_PROCESSOR)wg_isi_satzk2,pw_isi_satzk2,(short)0); 
    createinstr( &isi_satzk2,(long)(sp_sattemp-isi_satdelay),pw_isi_satzk2,0);
  }

	    getctrl(&ctrl_word, &isi_satzk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satzk2, *sat_index);
	    
	            
  {
    pulsename(&rot_update_zk2,"rot_update_zk2");
    createconst(&rot_update_zk2,(WF_PROCESSOR)wg_rot_update_zk2,pw_rot_update_zk2,(short)0); 
    createinstr( &rot_update_zk2,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_zk2,0);
  }

	    getctrl(&ctrl_word, &rot_update_zk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_zk2, *sat_index);
	    
	    /* RJL 08/24/95. More dynamic calculation of timing */
	    sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra;
        }
    }
    
    /* Slice select macro creates a since RF pulse. 
       A psd can use either sinc or SLR RF pulses. Parallel sat bands
       with the same thickness use a hadamard RF pulse. This one
       pulse replaces the 2 separate RF pulses. If the RF
       pulse is sinc, a hadamard sinc pulse is used. Likewise 
       if the SLR RF pulse is used, a hadamard SLR pulse is used. */
    
    /******************************************************************************
     ** This section has undergone significant restructuring to accomode rfpulse
     ** scaling following system safety requirements. The overall function is
     ** still similar. In the first case (SINC_SAT), the resolutions are changed
     ** if pulse scaling was performed. Interpolation is not required since the
     ** pulse is generated internally. For (SLR_SAT), the pulse is read into a work
     ** buffer (temp_wave), and copied over to the kernel file either in original
     ** size or increased size if scaling required. All scaling is performed before
     ** hadamard sat's are created. It is assumed that not all sat regions will have
     ** similar pulse resolutions, and scaling may or may not be required for each
     ** rfpulse SAT.  The final rfpulse is then immediate moved (movewaveimm) onto
     ** the RHO board, and allocated memory freed.
     ******************************************************************************/

    switch (sat_type) 
    {
        /* If hadamard, create and load in hadamard */
    case SINC_SAT:
	
	/* Change resolutions if rfpulse scaled */
	if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
            res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(rfpulseInfo[RFSX1_SLOT].newres), res_rfsx1) : rfpulseInfo[RFSX1_SLOT].newres;
	if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
            res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(rfpulseInfo[RFSY1_SLOT].newres), res_rfsy1) : rfpulseInfo[RFSY1_SLOT].newres;
	if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
            res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(rfpulseInfo[RFSZ1_SLOT].newres), res_rfsz1) : rfpulseInfo[RFSZ1_SLOT].newres;

	if (opsatx == PSD_SATHAD) 
	  {
	    separation = 2*satspacex1/satthickx1;
	    wave_space_rho = (SHORT *)AllocNode(res_rfsx1*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfsx1, max_pg_wamp, separation,
		      cyc_rfsx1, alpha_rfsx1);
	    movewaveimm(wave_space_rho, &rfsx1, (INT)0, res_rfsx1, TOHARDWARE);
	  }
	
	if (opsaty == PSD_SATHAD) 
	  {
	    separation = 2*satspacey1/satthicky1;
	    wave_space_rho = (SHORT *)AllocNode(res_rfsy1*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfsy1, max_pg_wamp, separation,
		      cyc_rfsy1, alpha_rfsy1);
	    movewaveimm(wave_space_rho, &rfsy1, (INT)0, res_rfsy1, TOHARDWARE);
	  }
	
	if (opsatz == PSD_SATHAD) 
	  {
	    separation = 2*satspacez1/satthickz1;
	    wave_space_rho = (SHORT *)AllocNode(res_rfsz1*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfsz1, max_pg_wamp, separation,
		      cyc_rfsz1, alpha_rfsz1);
	    movewaveimm(wave_space_rho, &rfsz1, (INT)0, res_rfsz1, TOHARDWARE);
	  }
	
	FreeNode(wave_space_rho);
	break;
	
	/* Include SLR RF files  */
    case SLR_SAT:
    case SLR_CSAT:

        switch (sat_type)
        {
        case SLR_SAT:
	     strcpy(rho_file, "rfdblsatl0.rho");
	     temp_wave_rho = (SHORT *)AllocNode(RES_SLRSAT*sizeof(SHORT));
	     uextwave(temp_wave_rho, RES_SLRSAT, rho_file);
             break;

        case SLR_CSAT:
             strcpy(rho_file, "satqptbw12.rho");
             temp_wave_rho = (SHORT *)AllocNode(RES_SLRCSAT*sizeof(SHORT));
             uextwave(temp_wave_rho, RES_SLRCSAT, rho_file);

             if (sat_pulse_type == COMPLEX_RF)
             {
                strcpy(theta_file, "satqptbw12.the");
                temp_wave_theta = (SHORT *)AllocNode(RES_SLRCSAT*sizeof(SHORT));
                uextwave(temp_wave_theta, RES_SLRCSAT, theta_file);
             }
             break;

        default:
             break;
        }
	
	if (opsatx != PSD_SATOFF) 
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
	      {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSX1_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSX1_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfsx1,(int)rfpulseInfo[RFSX1_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSX1_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSX1_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfsx1,(int)rfpulseInfo[RFSX1_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(rfpulseInfo[RFSX1_SLOT].newres), res_rfsx1) : rfpulseInfo[RFSX1_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfsx1*sizeof(SHORT));

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfsx1*sizeof(SHORT));
                }
	      }

	    if (opsatx == PSD_SATHAD)
	      { /* Hadamard sat */
		separation = satspacex1/2.0/satthickx1;
		freqstep = 65536.0/(float) res_rfsx1;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfsx1, kernel_tab_rho, kernel_tab_theta, cyc_rfsx1,
			 separation, gscale_rfsx1, NULL,
			 (FLOAT)0, hadamard_tab_rho, hadamard_tab_theta, freqstep);
                  
                   movewaveimm(hadamard_tab_theta, &rfsx1Theta, (INT)0, res_rfsx1,
                         TOHARDWARE);

                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfsx1, kernel_tab_rho, cyc_rfse3,
                         separation, gscale_rfsx1, NULL, (FLOAT)0,
                         hadamard_tab_rho, freqstep);
                }

		movewaveimm(hadamard_tab_rho, &rfsx1, (INT)0, res_rfsx1, 
				TOHARDWARE); 

		if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho); 
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }            
	      }
	    else
	      { 
		movewaveimm(kernel_tab_rho, &rfsx1, (INT)0, res_rfsx1, 
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfsx1Theta, (INT)0, res_rfsx1,
                               TOHARDWARE);
                }

		if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho); 
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }            
		/* Check for parallel sat region */
		if (opsatx == PSD_SATPARA)
		  {
		    if (rfpulseInfo[RFSX2_SLOT].change==PSD_ON)
		      {
			kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSX2_SLOT].newres*sizeof(SHORT));
			stretchpulse((int)res_rfsx2,(int)rfpulseInfo[RFSX2_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSX2_SLOT].newres*sizeof(SHORT));
                           stretchpulse((int)res_rfsx2,(int)rfpulseInfo[RFSX2_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                        }

			res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(rfpulseInfo[RFSX2_SLOT].newres), res_rfsx2) : rfpulseInfo[RFSX2_SLOT].newres;
		      }
		    else
                      {
		        kernel_tab_rho = temp_wave_rho; 
                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = temp_wave_theta;
                        }
                      }

		    movewaveimm(kernel_tab_rho, &rfsx2, (INT)0, res_rfsx2,
				TOHARDWARE); 
                    if (sat_pulse_type == COMPLEX_RF)
                    {
                       movewaveimm(kernel_tab_theta, &rfsx2Theta, (INT)0, res_rfsx2,
                                   TOHARDWARE);
                    }
		  }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }

	    if (rfpulseInfo[RFSX2_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	if (opsaty != PSD_SATOFF) 
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
	      {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSY1_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSY1_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfsy1,(int)rfpulseInfo[RFSY1_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSY1_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSY1_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfsy1,(int)rfpulseInfo[RFSY1_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(rfpulseInfo[RFSY1_SLOT].newres), res_rfsy1) : rfpulseInfo[RFSY1_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfsy1*sizeof(SHORT));

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfsy1*sizeof(SHORT));
                }
	      }

	    if (opsaty == PSD_SATHAD)
	      { /* Hadamard sat */
		separation = satspacey1/2.0/satthicky1;
		freqstep = 65536.0/(float) res_rfsy1;

                if (sat_pulse_type == COMPLEX_RF)
                {
    		   altcomplexrfgen((INT)TYPLINEAR, res_rfsy1, kernel_tab_rho, kernel_tab_theta, cyc_rfsy1,
			 separation, gscale_rfsy1, NULL,
			 (FLOAT)0, hadamard_tab_rho, hadamard_tab_theta, freqstep);

                   movewaveimm(hadamard_tab_theta, &rfsy1Theta, (INT)0, res_rfsy1,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfsy1, kernel_tab_rho, cyc_rfsy1,
                         separation, gscale_rfsy1, NULL,
                         (FLOAT)0, hadamard_tab_rho, freqstep);
                }
		movewaveimm(hadamard_tab_rho, &rfsy1, (INT)0, res_rfsy1, 
			    TOHARDWARE); 

		if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho);   
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfsy1, (INT)0, res_rfsy1, 
			    TOHARDWARE);
                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfsy1Theta, (INT)0, res_rfsy1,
                               TOHARDWARE);
                }
		if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho);  
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta); 
                   }
                }
		if (opsaty == PSD_SATPARA)
		  {
		    if (rfpulseInfo[RFSY2_SLOT].change==PSD_ON)
		      {
			kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSY2_SLOT].newres*sizeof(SHORT));
			stretchpulse((int)res_rfsy2,(int)rfpulseInfo[RFSY2_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSY2_SLOT].newres*sizeof(SHORT));
                           stretchpulse((int)res_rfsy2,(int)rfpulseInfo[RFSY2_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                        }
			res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(rfpulseInfo[RFSY2_SLOT].newres), res_rfsy2) : rfpulseInfo[RFSY2_SLOT].newres;
		      }
		    else
                      {
		        kernel_tab_rho = temp_wave_rho;  
                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = temp_wave_theta; 
                        }
                      }
		  movewaveimm(kernel_tab_rho, &rfsy2, (INT)0, res_rfsy2, 
			      TOHARDWARE);
                  if (sat_pulse_type == COMPLEX_RF)
                  {
                     movewaveimm(kernel_tab_theta, &rfsy2Theta, (INT)0, res_rfsy2,
                                 TOHARDWARE);
                  }

		  }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }
	    if (rfpulseInfo[RFSY2_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	if (opsatz != PSD_SATOFF) 
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
	      {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSZ1_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSZ1_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfsz1,(int)rfpulseInfo[RFSZ1_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSZ1_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSZ1_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfsz1,(int)rfpulseInfo[RFSZ1_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(rfpulseInfo[RFSZ1_SLOT].newres), res_rfsz1) : rfpulseInfo[RFSZ1_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfsz1*sizeof(SHORT));

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfsz1*sizeof(SHORT));
                }
	      }

	    if (opsatz == PSD_SATHAD)
	      { /* Hadamard sat */
		separation = satspacez1/2.0/satthickz1;
		freqstep = 65536.0/(float) res_rfsz1;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfsz1, kernel_tab_rho, kernel_tab_theta, cyc_rfsz1,
			 separation, gscale_rfsz1, NULL,
			 (FLOAT)0, hadamard_tab_rho, hadamard_tab_theta, freqstep);
                   movewaveimm(hadamard_tab_theta, &rfsz1Theta, (INT)0, res_rfsz1,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfsz1, kernel_tab_rho, cyc_rfsz1,
                         separation, gscale_rfsz1, NULL,
                         (FLOAT)0, hadamard_tab_rho, freqstep);
                }

		movewaveimm(hadamard_tab_rho, &rfsz1, (INT)0, res_rfsz1, 
			    TOHARDWARE);

		if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho);   
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfsz1, (INT)0, res_rfsz1, 
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfsz1Theta, (INT)0, res_rfsz1,
                              TOHARDWARE);
                }
		if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho);   
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }
		if (opsatz == PSD_SATPARA)
		  {
		    if (rfpulseInfo[RFSZ2_SLOT].change==PSD_ON)
		      {
			kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSZ2_SLOT].newres*sizeof(SHORT));
			stretchpulse((int)res_rfsz2,(int)rfpulseInfo[RFSZ2_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSZ2_SLOT].newres*sizeof(SHORT));
                           stretchpulse((int)res_rfsz2,(int)rfpulseInfo[RFSZ2_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                        } 

			res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(rfpulseInfo[RFSZ2_SLOT].newres), res_rfsz2) : rfpulseInfo[RFSZ2_SLOT].newres;
		      }
		    else
                      {
		        kernel_tab_rho = temp_wave_rho; 
                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = temp_wave_theta;
                        }
                      }

		    movewaveimm(kernel_tab_rho, &rfsz2, (INT)0, res_rfsz2, 
				TOHARDWARE); 

                    if (sat_pulse_type == COMPLEX_RF)
                    {
                       movewaveimm(kernel_tab_theta, &rfsz2Theta, (INT)0, res_rfsz2,
                                   TOHARDWARE);
                    }

		  }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }
	    if (rfpulseInfo[RFSZ2_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }

	FreeNode(temp_wave_rho);
        if (sat_pulse_type == COMPLEX_RF)
        {
           FreeNode(temp_wave_theta);
        }
	break;
	
    default:
	break;
    }
    
    *sat_index += 1;
    
    return SUCCESS;
}

STATUS
SpSatPG_fgre( INT sat_type,
              INT start_time,
              INT *sat_index,
              INT cardiacsat_pos,
              INT seq_time )
{
    SpSatPG(sat_type, start_time, sat_index, cardiacsat_pos);
  
    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return (SUCCESS);
    else
    {
          
  {
    pulsename(&seqsat_fgre,"seqsat_fgre");
    createseq(&seqsat_fgre,seq_time, off_seqsat_fgre);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqsat_fgre );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqsat_fgre = %d\n", idx_seqsat_fgre );
#endif
  }

        return (SUCCESS);
    }
}

/* Create a null sequence */
STATUS
SpSatCatRelaxPG( INT ssi_time )
{
    INT seq_time;
  
       
  {
    pulsename(&y_ccs_null,"y_ccs_null");
    createconst(&y_ccs_null,(WF_PROCESSOR)wg_y_ccs_null,pw_y_ccs_null,(short)0); 
    createinstr( &y_ccs_null,(long)(RUP_GRD(8  )),pw_y_ccs_null,0);
  }

  
    seq_time = RUP_GRD(ccs_relaxseqtime - ssi_time);
    
  {
    pulsename(&cat_seq,"cat_seq");
    createseq(&cat_seq,seq_time, off_cat_seq);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_cat_seq );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_cat_seq = %d\n", idx_cat_seq );
#endif
  }

  
    return SUCCESS;
}

STATUS
SpSatCatRelaxOffsets( SEQUENCE_ENTRIES sequence_offsets )
{
    off_cat_seq[(int)TYPXGRAD]= sequence_offsets[(int)TYPXGRAD];
    off_cat_seq[(int)TYPZGRAD]= sequence_offsets[(int)TYPZGRAD];
  
    return SUCCESS;
}

/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                             PSipg                                 *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/

/*
 *  PS1pulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1pulsegen( INT posstart )
{
    INT postemp;
    INT ta_180, tb_180, te_180;
    INT end_encode;

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/


         
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1mps1", 
                                    (WF_PROCESSOR)wg_rf1mps1);

    /* Modify resolution if scaling required */
    temp_res_rf1mps1  = _temp_res_rf1mps1.fixedflag ?  ((void)(res_rf1mps1), temp_res_rf1mps1) : res_rf1mps1;
    if (rfpulseInfo[RF1_APS1_SLOT].change==PSD_ON)
       res_rf1mps1  = _res_rf1mps1.fixedflag ?  ((void)(rfpulseInfo[RF1_APS1_SLOT].newres), res_rf1mps1) : rfpulseInfo[RF1_APS1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1mps1a,"gzrf1mps1a");
    pulsename(&gzrf1mps1,"gzrf1mps1");
    pulsename(&gzrf1mps1d,"gzrf1mps1d");
    pulsename(&rf1mps1,"rf1mps1");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf1mps1a,ZGRAD,pw_gzrf1mps1a,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1mps1a/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1mps1a,(LONG)(posstart-pw_gzrf1mps1a),
		pw_gzrf1mps1a,ia_gzrf1mps1);
    createconst(&gzrf1mps1,ZGRAD,pw_gzrf1mps1,MAX_PG_WAMP);
    createinstr( &gzrf1mps1,(LONG)(posstart),
		pw_gzrf1mps1,ia_gzrf1mps1);
    createramp(&gzrf1mps1d,ZGRAD,pw_gzrf1mps1d,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1mps1d/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1mps1d,(LONG)(posstart+pw_gzrf1mps1),
		pw_gzrf1mps1d,ia_gzrf1mps1);
    
    /* Now create the rf pulse */
    createsinc(&rf1mps1,(WF_PROCESSOR)wg_rf1mps1,res_rf1mps1,
	       MAX_PG_WAMP,cyc_rf1mps1, alpha_rf1mps1);
    createinstr( &rf1mps1,(LONG)(posstart) + psd_rf_wait,
		pw_rf1mps1,ia_rf1mps1);
    linkpulses(4,&rf1mps1,&gzrf1mps1,&gzrf1mps1a,
	       &gzrf1mps1d);
    addrfbits(&rf1mps1,off_rf1mps1,(LONG)(posstart) + psd_rf_wait, 
	      pw_rf1mps1);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_APS1_SLOT].change==PSD_ON)
       res_rf1mps1  = _res_rf1mps1.fixedflag ?  ((void)(temp_res_rf1mps1), res_rf1mps1) : temp_res_rf1mps1;
  }


    /* Refocus on Z gradient */
    postemp = RUP_GRD(pend(&gzrf1mps1d,"gzrf1mps1d",0));
         

  trapezoid((WF_PROCESSOR)wg_gz1mps1, "gz1mps1", &gz1mps1, &gz1mps1a,
                        &gz1mps1d, pw_gz1mps1, pw_gz1mps1a, pw_gz1mps1d,
                        ia_gz1mps1, 0, 0, 0, 0, postemp+pw_gz1mps1a-pw_gz1mps1a, TRAP_ALL,
                        &ps1loggrd);

    end_encode = pend(&gz1mps1d,"gz1mps1d",0);    

    /* read dephaser */
    postemp = RUP_GRD(pend(&gzrf1mps1, "gzrf1mps1", 0)+rfupd+pw_gx1mps1a);
         

  trapezoid((WF_PROCESSOR)wg_gx1mps1, "gx1mps1", &gx1mps1, &gx1mps1a,
                        &gx1mps1d, pw_gx1mps1, pw_gx1mps1a, pw_gx1mps1d,
                        ia_gx1mps1, 0, 0, 0, 0, postemp-pw_gx1mps1a, TRAP_ALL,
                        &ps1loggrd);

    if(pend(&gx1mps1d,"gx1mps1d",0)>end_encode)
    {
        end_encode = pend(&gx1mps1d,"gx1mps1d",0);
    }

    /****** figure out minimum te from z grad, compare needed 
      time before and after 180 *********/
    tb_180  =  end_encode - ( RUP_GRD(1000) + pw_rf1mps1/2 - PSoff90)
        + pw_gzrf2lmps1a + pw_gzrf2lmps1 + pw_gzrf2lmps1d + pw_rf2mps1/2;

    ta_180  = pw_rf2mps1/2 + pw_gzrf2rmps1a + pw_gzrf2rmps1 + pw_gzrf2rmps1d
        + pw_gxwmps1/2 - psd_rf_wait + psd_grd_wait + DABSETUP;

    te_180 = RUP_GRD(2*(IMax(3, ta_180, tb_180, min180te/2)));

    postemp = RUP_GRD( (RUP_GRD(1000) + pw_rf1mps1/2 - PSoff90)
                       + (te_180/2) - pw_rf2mps1/2 );

         
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2mps1", 
                                    (WF_PROCESSOR)wg_rf2mps1);

    /* Modify resolution if scaling required */
    temp_res_rf2mps1  = _temp_res_rf2mps1.fixedflag ?  ((void)(res_rf2mps1), temp_res_rf2mps1) : res_rf2mps1;
    if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
       res_rf2mps1  = _res_rf2mps1.fixedflag ?  ((void)(rfpulseInfo[RF2_APS1_SLOT].newres), res_rf2mps1) : rfpulseInfo[RF2_APS1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2mps1a,"gzrf2mps1a");
    pulsename(&gzrf2mps1,"gzrf2mps1");
    pulsename(&gzrf2mps1d,"gzrf2mps1d");
    pulsename(&rf2mps1,"rf2mps1");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf2mps1a,ZGRAD,pw_gzrf2mps1a,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2mps1a/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2mps1a,(LONG)(postemp-pw_gzrf2mps1a),
		pw_gzrf2mps1a,ia_gzrf2mps1);
    createconst(&gzrf2mps1,ZGRAD,pw_gzrf2mps1,MAX_PG_WAMP);
    createinstr( &gzrf2mps1,(LONG)(postemp),
		pw_gzrf2mps1,ia_gzrf2mps1);
    createramp(&gzrf2mps1d,ZGRAD,pw_gzrf2mps1d,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2mps1d/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2mps1d,(LONG)(postemp+pw_gzrf2mps1),
		pw_gzrf2mps1d,ia_gzrf2mps1);
    
    /* Now create the rf pulse */
    createsinc(&rf2mps1,(WF_PROCESSOR)wg_rf2mps1,res_rf2mps1,
	       MAX_PG_WAMP,cyc_rf2mps1, alpha_rf2mps1);
    createinstr( &rf2mps1,(LONG)(postemp) + psd_rf_wait,
		pw_rf2mps1,ia_rf2mps1);
    linkpulses(4,&rf2mps1,&gzrf2mps1,&gzrf2mps1a,
	       &gzrf2mps1d);
    addrfbits(&rf2mps1,off_rf2mps1,(LONG)(postemp) + psd_rf_wait, 
	      pw_rf2mps1);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
       res_rf2mps1  = _res_rf2mps1.fixedflag ?  ((void)(temp_res_rf2mps1), res_rf2mps1) : temp_res_rf2mps1;
  }


    /* crushers */
    postemp = pbeg(&gzrf2mps1,"gzrf2mps1",0) - pw_gzrf2lmps1 - pw_gzrf2lmps1d;
          

  trapezoid((WF_PROCESSOR)wg_gzrf2lmps1, "gzrf2lmps1", &gzrf2lmps1, &gzrf2lmps1a,
                        &gzrf2lmps1d, pw_gzrf2lmps1, pw_gzrf2lmps1a, pw_gzrf2lmps1d,
                        ia_gzrf2lmps1, 0, 0, 0, 0, postemp-pw_gzrf2lmps1a, TRAP_ALL,
                        &ps1loggrd);

  
           

  trapezoid((WF_PROCESSOR)wg_gzrf2rmps1, "gzrf2rmps1", &gzrf2rmps1, &gzrf2rmps1a,
                        &gzrf2rmps1d, pw_gzrf2rmps1, pw_gzrf2rmps1a, pw_gzrf2rmps1d,
                        ia_gzrf2rmps1, 0, 0, 0, 0, pendall(&gzrf2mps1,0)-pw_gzrf2rmps1a, TRAP_ALL,
                        &ps1loggrd);

  
    postemp = RUP_GRD(pmid(&gzrf2mps1,"gzrf2mps1",0)+ (te_180/2) - pw_gxwmps1/2);
         

  trapezoid((WF_PROCESSOR)wg_gxwmps1, "gxwmps1", &gxwmps1, &gxwmps1a,
                        &gxwmps1d, pw_gxwmps1, pw_gxwmps1a, pw_gxwmps1d,
                        ia_gxwmps1, 0, 0, 0, 0, postemp-pw_gxwmps1a, TRAP_ALL,
                        &ps1loggrd);
    

        
  {
    pulsename(&echo1mps1,"echo1mps1");
    acqq(&echo1mps1, (long)(pbeg(&gxwmps1,"gxwmps1",0)+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1mps1,
        (TYPDAB_PACKETS)DABNORM);
  }


      
  {
  pulsename(&attenuator_keymps1,"attenuator_keymps1");
  createatten(&attenuator_keymps1, (long)(pend(&gxwmps1,"gxwmps1",0)));
}


      
  {
    pulsename(&seqmps1,"seqmps1");
    createseq(&seqmps1,ps1_tr, off_seqmps1);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqmps1 );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqmps1 = %d\n", idx_seqmps1 );
#endif
  }


    return SUCCESS;
}

/*
 *  CFLpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLpulsegen( INT posstart )
{
    INT postemp;
    INT tsamp_delay_cfl;

    tsamp_delay_cfl = RUP_GRD(1000);

    /*  90 slice sel pulse  */
       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1cfl", 
                                    (WF_PROCESSOR)wg_rf1cfl);

    /* Modify resolution if scaling required */
    temp_res_rf1cfl  = _temp_res_rf1cfl.fixedflag ?  ((void)(res_rf1cfl), temp_res_rf1cfl) : res_rf1cfl;
    if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
       res_rf1cfl  = _res_rf1cfl.fixedflag ?  ((void)(rfpulseInfo[RF1_CFL_SLOT].newres), res_rf1cfl) : rfpulseInfo[RF1_CFL_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1cfla,"gzrf1cfla");
    pulsename(&gzrf1cfl,"gzrf1cfl");
    pulsename(&gzrf1cfld,"gzrf1cfld");
    pulsename(&rf1cfl,"rf1cfl");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(cflloggrd.zbeta), pg_beta) : cflloggrd.zbeta;
    createramp(&gzrf1cfla,ZGRAD,pw_gzrf1cfla,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfla/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1cfla,(LONG)(posstart-pw_gzrf1cfla),
		pw_gzrf1cfla,ia_gzrf1cfl);
    createconst(&gzrf1cfl,ZGRAD,pw_gzrf1cfl,MAX_PG_WAMP);
    createinstr( &gzrf1cfl,(LONG)(posstart),
		pw_gzrf1cfl,ia_gzrf1cfl);
    createramp(&gzrf1cfld,ZGRAD,pw_gzrf1cfld,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1cfld/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1cfld,(LONG)(posstart+pw_gzrf1cfl),
		pw_gzrf1cfld,ia_gzrf1cfl);
    
    /* Now create the rf pulse */
    createsinc(&rf1cfl,(WF_PROCESSOR)wg_rf1cfl,res_rf1cfl,
	       MAX_PG_WAMP,cyc_rf1cfl, alpha_rf1cfl);
    createinstr( &rf1cfl,(LONG)(posstart) + psd_rf_wait,
		pw_rf1cfl,ia_rf1cfl);
    linkpulses(4,&rf1cfl,&gzrf1cfl,&gzrf1cfla,
	       &gzrf1cfld);
    addrfbits(&rf1cfl,off_rf1cfl,(LONG)(posstart) + psd_rf_wait, 
	      pw_rf1cfl);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
       res_rf1cfl  = _res_rf1cfl.fixedflag ?  ((void)(temp_res_rf1cfl), res_rf1cfl) : temp_res_rf1cfl;
  }

  
    /* Refocusing Pulse */
        
                    

  trapezoid((WF_PROCESSOR)wg_gz1cfl, "gz1cfl", &gz1cfl, &gz1cfla,
                        &gz1cfld, pw_gz1cfl, pw_gz1cfla, pw_gz1cfld,
                        ia_gz1cfl, 0, 0, 0, 0, pbeg(&gzrf1cfl,"gzrf1cfl",0)+pw_gzrf1cfl+pw_gzrf1cfld+pw_gz1cfla-pw_gz1cfla, TRAP_ALL,
                        &cflloggrd);

  
    /* Data Acquisiton with 2K filter */
         
  {
    pulsename(&cfl_fid,"cfl_fid");
    acqq(&cfl_fid, (long)(pendall(&gz1cfl,0)+tsamp_delay_cfl),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_cfl_fid,
        (TYPDAB_PACKETS)DABNORM);
  }

    /* Assert the ESSP flag on the rf1cfl pulse */
    attenflagon(&rf1cfl, 0);

    postemp = RUP_GRD(pendall(&gz1cfl,0) + tsamp_delay_cfl + cfl_tdaq + pw_gykcfla);

     
  {
  pulsename(&cfl_attenkey,"cfl_attenkey");
  createatten(&cfl_attenkey, (long)(postemp));
}

         

  trapezoid((WF_PROCESSOR)wg_gykcfl, "gykcfl", &gykcfl, &gykcfla,
                        &gykcfld, pw_gykcfl, pw_gykcfla, pw_gykcfld,
                        ia_gykcfl, 0, 0, 0, 0, postemp-pw_gykcfla, TRAP_ALL,
                        &cflloggrd);

  
      
  {
    pulsename(&seqcfl,"seqcfl");
    createseq(&seqcfl,cfl_tr, off_seqcfl);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfl );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfl = %d\n", idx_seqcfl );
#endif
  }


    return SUCCESS;
}

/*
 *  RCVNpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNpulsegen( INT posstart )
{
    INT postemp, postemp2;
    INT tsamp_delay_rcvn;
    INT unblank_delay_rcvn;

    /* MRIhc47602/MRIhc47515/GEHmr03545 */
    if ( rcvn_flag == 1 )
    {
               

  trapezoid((WF_PROCESSOR)wg_gxkrcvn, "gxkrcvn", &gxkrcvn, &gxkrcvna,
                        &gxkrcvnd, pw_gxkrcvn, pw_gxkrcvna, pw_gxkrcvnd,
                        ia_gxkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gxkrcvna)-pw_gxkrcvna, TRAP_ALL,
                        &rcvnloggrd);

               

  trapezoid((WF_PROCESSOR)wg_gykrcvn, "gykrcvn", &gykrcvn, &gykrcvna,
                        &gykrcvnd, pw_gykrcvn, pw_gykrcvna, pw_gykrcvnd,
                        ia_gykrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gykrcvna)-pw_gykrcvna, TRAP_ALL,
                        &rcvnloggrd);

               

  trapezoid((WF_PROCESSOR)wg_gzkrcvn, "gzkrcvn", &gzkrcvn, &gzkrcvna,
                        &gzkrcvnd, pw_gzkrcvn, pw_gzkrcvna, pw_gzkrcvnd,
                        ia_gzkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gzkrcvna)-pw_gzkrcvna, TRAP_ALL,
                        &rcvnloggrd);


    }
    else if ( rcvn_flag == 2 ) /* extra delay before rcvn */
    {
        
  {
    pulsename(&rcvn_wait,"rcvn_wait");
    createconst(&rcvn_wait,(WF_PROCESSOR)wg_rcvn_wait,pw_rcvn_wait,(short)0); 
    createinstr( &rcvn_wait,(long)(RUP_GRD(posstart)),pw_rcvn_wait,0);
  }

    }
      
  {
    pulsename(&pre_rcvn,"pre_rcvn");
    createseq(&pre_rcvn,RUP_GRD(pre_rcvn_tr+posstart), off_pre_rcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_pre_rcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_pre_rcvn = %d\n", idx_pre_rcvn );
#endif
  }


    unblank_delay_rcvn = RUP_GRD(1000);
    tsamp_delay_rcvn = RUP_GRD(2000);

    /* RCVRUNBLANK & RCVRBLANK mechanism is normally taken care 
       of by the RF pulse itself. However RCVN entry point does
       not have any RF pulse so we wrap data acqusition window. */

    /* Unblank receiver before Data Acquisition window */
    
  {
    rcvrbl_pack[0] = SSPDS+RDC;
    rcvrbl_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl_pack[2] = SSPD+RUBL;
    rcvrbl_pack[3] = SSPDS;

    pulsename(&rcvrbl,"rcvrbl");
    createbits(&rcvrbl,TYPSSP,4,rcvrbl_pack);
    createinstr( &rcvrbl,(long)(unblank_delay_rcvn),4,ia_rcvrbl);
  }

  
    /* Data Acquisiton with 2K filter */
       
  {
    pulsename(&rcvn_fid,"rcvn_fid");
    acqq(&rcvn_fid, (long)(tsamp_delay_rcvn),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_rcvn_fid,
        (TYPDAB_PACKETS)DABNORM);
  }


    postemp  = RUP_GRD(tsamp_delay_rcvn + rcvn_tdaq);
    postemp2 = RUP_GRD(unblank_delay_rcvn + postemp);

     
  {
  pulsename(&rcvn_attenkey,"rcvn_attenkey");
  createatten(&rcvn_attenkey, (long)(postemp));
}


    /* Blank receiver after Data Acquisition is completed */
    
  {
    rcvrbl2_pack[0] = SSPDS+RDC;
    rcvrbl2_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl2_pack[2] = SSPD+RBL;
    rcvrbl2_pack[3] = SSPDS;

    pulsename(&rcvrbl2,"rcvrbl2");
    createbits(&rcvrbl2,TYPSSP,4,rcvrbl2_pack);
    createinstr( &rcvrbl2,(long)(postemp2),4,ia_rcvrbl2);
  }

  
      
  {
    pulsename(&seqrcvn,"seqrcvn");
    createseq(&seqrcvn,rcvn_tr, off_seqrcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrcvn = %d\n", idx_seqrcvn );
#endif
  }


    return SUCCESS;
}

/*
 *  CFHpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHpulsegen( INT posstart )
{
    INT postemp;
    INT cfh_te;   /* Run at operator TE unless below min cfh te.
                     Then run at min cfh te */
    INT cfh_te2;   /* vmx 05/02/95 YO */
    INT cfh_acq_window_pos;   /* vmx 05/02/94 YO */
    INT tsamp_delay_cfh;
    INT start_time = 0;
    INT start_time_CS = 0;
    INT start_time_MT = 0;
    INT pos_rf2;
    INT newcfh_tr;
    INT min_ssp;

    /* variables for presscfh */
    INT pos_rf3;

    tsamp_delay_cfh = RUP_GRD(1000);

    start_time = posstart;
    start_time_MT = posstart;
    start_time_CS = posstart;

    /* Check for CFH Inversion inclusion */
    if (PSD_ON == PSir)
    {
        short *temp_wave_space; /* temporary waveform space for rf scaling */
        short *wave_space; /* temporary waveform space for rf scaling */

        /* adiabatic pulse */
           
                       
                        
                          
                       
  {
    INT new_res;                  /* temp holder for new pulse resolution */

    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf0cfh", 
                                     (WF_PROCESSOR)wg_rf0cfh);

    /* First create the pulses */
    pulsename(&gzrf0cfha,"gzrf0cfha");
    pulsename(&gzrf0cfh,"gzrf0cfh");
    pulsename(&gzrf0cfhd,"gzrf0cfhd");
    pulsename(&rf0cfh,"rf0cfh");

    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(cfhloggrd.zbeta), pg_beta) : cfhloggrd.zbeta;
    createramp(&gzrf0cfha,ZGRAD,pw_gzrf0cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf0cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfha,(LONG)(posstart-pw_gzrf0cfha),
		pw_gzrf0cfha,ia_gzrf0cfh);
    if ( 0 == PLAY_GFILE)
      {
	/*********************************************************************** 
	 ** Now create the waveform & perform required system safety checks
	 ** create a temporary buffer to modify gradient data using createreserve. Here
	 ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the waveform and
	 ** copy stretched data into permanent waveform memory. It is important to
	 ** to have temp buffer have new resolution size waveform memory.
	 ************************************************************************/
	if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
	  {
	    createreserve(&gzrf0cfh,ZGRAD,rfpulseInfo[RF0_CFH_SLOT].newres/2);
	    /********************************************************************* 
	     * Change pulse type to external createreserve zero fills resolution
	     * number of points in waveform memory for use.
	     ********************************************************************/
	    gzrf0cfh.type = TYPEXTERNAL;
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);
	    /* Scale the pulse, and then move to the reserved memory */
	    temp_wave_space = (short *)AllocNode(res_gzrf0cfh*sizeof(short));
	    uextwave(temp_wave_space, res_gzrf0cfh, grad_zrf0cfh);
	    wave_space = (short *)AllocNode(rfpulseInfo[RF0_CFH_SLOT].newres/2*sizeof(short));
	    stretchpulse((int)res_gzrf0cfh,(int)rfpulseInfo[RF0_CFH_SLOT].newres/2,
			 temp_wave_space,wave_space);
	    /* res_gz$[slsel_name] = rfpulseInfo[$[rf_slot]].newres/2; */
	    new_res = rfpulseInfo[RF0_CFH_SLOT].newres/2;
	    /* Copy over original pulse data */
	    movewaveimm(wave_space, &gzrf0cfh, (int)0, new_res, TOHARDWARE);
	    FreeNode(wave_space);
	    FreeNode(temp_wave_space);
	  }
	else
	  {
	    createextwave(&gzrf0cfh,ZGRAD, 
			  res_gzrf0cfh, grad_zrf0cfh);
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);
	  }
      }
    else
      {
	createconst(&gzrf0cfh,ZGRAD, pw_rf0cfh,MAX_PG_WAMP);
	createinstr( &gzrf0cfh,(LONG)(posstart),
		    pw_gzrf0cfh,ia_gzrf0cfh);
      }
    /* Decay ramp */
    createramp(&gzrf0cfhd,ZGRAD,pw_gzrf0cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf0cfhd/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfhd,(LONG)(posstart+pw_gzrf0cfh),
		pw_gzrf0cfhd,ia_gzrf0cfh);
    
    /*********************************************************************** 
    ** Now create the rf pulse & perform required system safety checks
    ** create a temporary buffer to modify rfpulse data using createsinc. Here
    ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the pulse and
    ** copy stretched data into permanent waveform memory. It is important to
    ** to have temp buffer have new resolution size waveform memory.
    ************************************************************************/
    if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
      {
	cyc_rf0cfh  = _cyc_rf0cfh.fixedflag ?  ((void)(1.0), cyc_rf0cfh) : 1.0; /* Make sure we have a value for createsinc */
	createsinc(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,rfpulseInfo[RF0_CFH_SLOT].newres,
		   MAX_PG_WAMP,cyc_rf0cfh,alpha_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);

	/* Create some RHO waveform space, scale the pulse, and then move
	 * the local memory to the reserved RHO memory, and set pulsepointers
	 * to new stretched pulse
	 */
	temp_wave_space = (short *)AllocNode(res_rf0cfh*sizeof(short));
	uextwave(temp_wave_space, res_rf0cfh, rf_rf0cfh);
	wave_space = (short *)AllocNode(rfpulseInfo[RF0_CFH_SLOT].newres*sizeof(short));
	stretchpulse((int)res_rf0cfh,rfpulseInfo[RF0_CFH_SLOT].newres,
		     temp_wave_space,wave_space);
	/* res_$[slsel_name] = rfpulseInfo[$[rf_slot]].newres; */
	new_res = rfpulseInfo[RF0_CFH_SLOT].newres;
        /* Copy over original pulse data */
	movewaveimm(wave_space, &rf0cfh, (int)0, new_res, TOHARDWARE);
	FreeNode(wave_space);
	FreeNode(temp_wave_space);
      }
    else
      {
	/* No rf scaling required. Use createextwave to read pulse 
	 * and move to HW 
	 */
	createextwave(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,
		      res_rf0cfh,rf_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);
      }
}


           
                   
  {

    short *stretched_wave_space;  /* temporary waveform space */
    short *wave_space;            /* temporary waveform space for
                                     stretched RF pulse */
    INT old_res;                  /* temp holder for old pulse resolution */
    INT new_res;                  /* temp holder for new pulse resolution */

    if ( (wg_omegarf0cfh != TYPRHO1)  && (wg_omegarf0cfh != TYPRHO2) &&
         (wg_omegarf0cfh != TYPTHETA) && (wg_omegarf0cfh != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    old_res =  res_omegarf0cfh;
    new_res =  rfpulseInfo[rfslot_omegarf0cfh].newres;

    n_omegarf0cfh  = _n_omegarf0cfh.fixedflag ?  ((void)(1), n_omegarf0cfh) : n_omegarf0cfh+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( omegarf0cfh.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&omegarf0cfh,"omegarf0cfh");
        
        /* Scale waveform if needed */
        if( rfpulseInfo[rfslot_omegarf0cfh].change==PSD_ON ) {

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&omegarf0cfh, (WF_PROCESSOR)wg_omegarf0cfh, new_res);

            /* Allocate memory for original RF pulse */
            wave_space = (short *)AllocNode(old_res*sizeof(short));
            /* Read RF pulse from file and store to wave_space */
            uextwave(wave_space, old_res, fileloc_omegarf0cfh);

            /* Allocate memory for stretched RF pulse */
            stretched_wave_space = (short *)AllocNode(new_res*sizeof(short));
            
            stretchpulse(old_res, new_res, wave_space, stretched_wave_space);
            
            /* Move stretched pulse immediately into reserved memory */
            movewaveimm(stretched_wave_space, &omegarf0cfh,
                        (int)0, new_res, TOHARDWARE);
            
             /* Free memory allocated for original RF pulse */
            FreeNode(wave_space);
            /* Free memory allocated for stretched RF pulse */
            FreeNode(stretched_wave_space);
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_omegarf0cfh  = _res_omegarf0cfh.fixedflag ?  ((void)(new_res), res_omegarf0cfh) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&omegarf0cfh,(WF_PROCESSOR)wg_omegarf0cfh,
                          old_res,fileloc_omegarf0cfh);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &omegarf0cfh,(LONG)(posstart) + psd_rf_wait, 
                 pw_omegarf0cfh,ia_omegarf0cfh);
    

    /*** Add RF Bits ***/
    addrfbits(&omegarf0cfh,off_omegarf0cfh,(LONG)(posstart) + psd_rf_wait,
              pw_omegarf0cfh);
    

    /*** Reset Resolution ***/
    res_omegarf0cfh  = _res_omegarf0cfh.fixedflag ?  ((void)(old_res), res_omegarf0cfh) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */

  }


           
                     

  trapezoid((WF_PROCESSOR)wg_gyrf0kcfh, "gyrf0kcfh", &gyrf0kcfh, &gyrf0kcfha,
                        &gyrf0kcfhd, pw_gyrf0kcfh, pw_gyrf0kcfha, pw_gyrf0kcfhd,
                        ia_gyrf0kcfh, 0, 0, 0, 0, pend(&gzrf0cfh,"gzrf0cfh",0)+pw_gyrf0kcfha-pw_gyrf0kcfha, TRAP_ALL,
                        &cfhloggrd);

    
        /* Setting up WAIT duration */
        /* 1ms is added at the end so that ssp sequencer has no overlap 
           as 'frq', and RF amp unblank pulses are played. */
        dur_invse = RUP_GRD(cfh_ti - pw_rf0cfh/2 - pw_gyrf0kcfha - pw_gyrf0kcfh 
                            - pw_gyrf0kcfhd  - pw_gzrf1cfha - pw_rf1cfh/2 - 1000);
#ifdef PSD_CFH_CHEMSAT
        if ((cs_sat == PSD_ON) && PScs_sat)
        {
            /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
            dur_invse -= RUP_GRD(cs_sattime - specir_delay);
#else
            dur_invse -= RUP_GRD(cs_sattime);
#endif
        }
#endif
        dur_invse = RUP_GRD(dur_invse);

        
  {
    pulsename(&zticfh,"zticfh");
    createconst(&zticfh,(WF_PROCESSOR)wg_zticfh,pw_zticfh,(short)0); 
    createinstr( &zticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_zticfh,0);
  }

        
  {
    pulsename(&rticfh,"rticfh");
    createconst(&rticfh,(WF_PROCESSOR)wg_rticfh,pw_rticfh,(short)0); 
    createinstr( &rticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_rticfh,0);
  }

        
  {
    pulsename(&xticfh,"xticfh");
    createconst(&xticfh,(WF_PROCESSOR)wg_xticfh,pw_xticfh,(short)0); 
    createinstr( &xticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_xticfh,0);
  }

        
  {
    pulsename(&yticfh,"yticfh");
    createconst(&yticfh,(WF_PROCESSOR)wg_yticfh,pw_yticfh,(short)0); 
    createinstr( &yticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_yticfh,0);
  }

        
  {
    pulsename(&sticfh,"sticfh");
    createconst(&sticfh,(WF_PROCESSOR)wg_sticfh,pw_sticfh,(short)0); 
    createinstr( &sticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_sticfh,0);
  }

    
        setperiod(dur_invse,&zticfh,0);
        setperiod(dur_invse,&rticfh,0);
        setperiod(dur_invse,&xticfh,0);
        setperiod(dur_invse,&yticfh,0);
        setperiod(dur_invse,&sticfh,0);
    
        /* Change start time for the 90 180 sequence; pw_gzrf1cfha added to 
           offset start_time calc in rf1cfh call */
        start_time    = pmid(&gzrf0cfh,"gzrf0cfh",0) + cfh_ti - pw_rf1cfh/2;
        start_time_MT = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;
        start_time_CS = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;

        amp_gyrf0kcfh = ia_gyrf0kcfh;
    }
    /* End of IR sequence check */
  
  

#ifdef PSD_CFH_CHEMSAT
    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        ChemSatPG(start_time_CS, &cscfh_satindex);
        cscfh_satindex -= 1;
    }
    if( (PSir != PSD_ON) && ( ((oppseq!=PSD_IR)
                               || (ssfse_ir_on == PSD_OFF)) && PScs_sat ) )
    {
        /* MRIge30640 - already caught in SLICESELZ2 call below! */
        /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
        start_time += (cs_sattime - specir_delay);
#else
        start_time += cs_sattime;
#endif
    }
#endif
  
    /*  90 slice sel pulse  */
       
                 
                        
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1cfh", 
                                    (WF_PROCESSOR)wg_rf1cfh);

    /* Modify resolution if scaling required */
    temp_res_rf1cfh  = _temp_res_rf1cfh.fixedflag ?  ((void)(res_rf1cfh), temp_res_rf1cfh) : res_rf1cfh;
    if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
       res_rf1cfh  = _res_rf1cfh.fixedflag ?  ((void)(rfpulseInfo[RF1_CFH_SLOT].newres), res_rf1cfh) : rfpulseInfo[RF1_CFH_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1cfha,"gzrf1cfha");
    pulsename(&gzrf1cfh,"gzrf1cfh");
    pulsename(&gzrf1cfhd,"gzrf1cfhd");
    pulsename(&rf1cfh,"rf1cfh");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(cfhloggrd.zbeta), pg_beta) : cfhloggrd.zbeta;
    createramp(&gzrf1cfha,ZGRAD,pw_gzrf1cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1cfha,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)-pw_gzrf1cfha),
		pw_gzrf1cfha,ia_gzrf1cfh);
    createconst(&gzrf1cfh,ZGRAD,pw_gzrf1cfh,MAX_PG_WAMP);
    createinstr( &gzrf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)),
		pw_gzrf1cfh,ia_gzrf1cfh);
    createramp(&gzrf1cfhd,ZGRAD,pw_gzrf1cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1cfhd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1cfhd,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)+pw_gzrf1cfh),
		pw_gzrf1cfhd,ia_gzrf1cfh);
    
    /* Now create the rf pulse */
    createsinc(&rf1cfh,(WF_PROCESSOR)wg_rf1cfh,res_rf1cfh,
	       MAX_PG_WAMP,cyc_rf1cfh, alpha_rf1cfh);
    createinstr( &rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait,
		pw_rf1cfh,ia_rf1cfh);
    linkpulses(4,&rf1cfh,&gzrf1cfh,&gzrf1cfha,
	       &gzrf1cfhd);
    addrfbits(&rf1cfh,off_rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait, 
	      pw_rf1cfh);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
       res_rf1cfh  = _res_rf1cfh.fixedflag ?  ((void)(temp_res_rf1cfh), res_rf1cfh) : temp_res_rf1cfh;
  }


    min_ssp = RUP_GRD(-rfupa + rfupd + RFUNBLANK_LENGTH + RFFREQ_LENGTH);

    if(PSfield_strength <= B0_5000)
    {

        cfh_te = (0.5 * pw_rf1cfh + PSoff90 + pw_rf2cfh
                  + IMax(2, min_ssp,
                         (pw_gzrf1cfhd + pw_gzrf2lcfha
                          + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                  + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd
                  + (cfh_tdaq  * cfh_ec_position));

        cfh_te2 = ((IMax(2, min_ssp,
                         (pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd
                          + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd))
                    + pw_rf2cfh)/ 2
                   + (cfh_tdaq * cfh_ec_position));
        cfh_te2 *= 2;

        cfh_te = IMax(3, cfh_te, cfh_te2, min180te);

        pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
    }
    else
    {
        if( presscfh_ctrl == PRESSCFH_NONE )
        {
            cfh_te =  0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90
                           + IMax(2, min_ssp,
                                  (pw_gzrf1cfhd + pw_gzrf2lcfha
                                   + pw_gzrf2lcfh + pw_gzrf2lcfhd));
            if (opspf == 0)
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }
            else
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gyrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }

            /* MRIge90312 - use 50ms TE for cfh */
            cfh_te = IMax(3, cfh_te, min180te, eff_cfh_te);

            pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                    + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
        }
        else
        {
            int temp_time = 0;

            cfh_te = IMax(2, presscfh_minte, eff_cfh_te);
            if( cfh_steam_flag != PSD_ON )
            {
                int echo1te = 0;

                echo1te =  0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90 +
                    IMax(2, min_ssp, (pw_gzrf1cfhd + pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                    + presscfh_wait_rf12;

                echo1te = 2*IMax(3, echo1te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);

                echo1te = IMax(2, echo1te, min180te);
                pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                        + 0.5 * echo1te - 0.5 * pw_rf2cfh));

                temp_time = IMax(2, pw_gyrf3cfha, pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                cfh_te = IMax(2, 2*temp_time + echo1te + pw_rf3cfh, cfh_te);

                pos_rf3 = RDN_GRD((int)(pos_rf2 + 0.5*pw_gxrf2cfh + 0.5*cfh_te - 0.5*pw_rf3cfh));
            }
            else
            {
                int mix_time = 0;

                temp_time = IMax(2, 2*min_ssp,  pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd 
                                 + steam_pg_gap + pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                mix_time = RUP_GRD(0.5 * (pw_gxrf2cfh + pw_gyrf3cfh) + temp_time);

                pos_rf2 = RUP_GRD( pmid(&gzrf1cfh,"gzrf1cfh",0) + 0.5*cfh_te - 0.5*pw_gxrf2cfh );
                pos_rf3 = RUP_GRD( pos_rf2 + 0.5*pw_gxrf2cfh + mix_time - 0.5*pw_gyrf3cfh );
            }
        }
    }

    if (rfpulseInfo[RF2_CFH_SLOT].change==PSD_ON)
    {
        res_rf2cfh  = _res_rf2cfh.fixedflag ?  ((void)(rfpulseInfo[RF2_CFH_SLOT].newres), res_rf2cfh) : rfpulseInfo[RF2_CFH_SLOT].newres;
    }

         
  {
    pulsename(&rf2cfh,"rf2cfh");
    createsinc(&rf2cfh,(WF_PROCESSOR)wg_rf2cfh,res_rf2cfh,
               MAX_PG_WAMP,cyc_rf2cfh,alpha_rf2cfh);
    if ((wg_rf2cfh==TYPRHO1)||(wg_rf2cfh==TYPRHO2) ||
        (wg_rf2cfh==TYPTHETA)||(wg_rf2cfh==TYPOMEGA))
      {
        createinstr( &rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                    pw_rf2cfh,ia_rf2cfh);
        addrfbits(&rf2cfh,off_rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                  pw_rf2cfh);
      }
    else
      {
        createinstr( &rf2cfh,(long)(pos_rf2),
                    pw_rf2cfh,ia_rf2cfh);
      }
  }

    if( presscfh_ctrl != PRESSCFH_NONE ){ /* for presscfh_ctrl */
               
  {
    pulsename(&rf3cfh,"rf3cfh");
    createsinc(&rf3cfh,(WF_PROCESSOR)wg_rf3cfh,res_rf3cfh,
               MAX_PG_WAMP,cyc_rf3cfh,alpha_rf3cfh);
    if ((wg_rf3cfh==TYPRHO1)||(wg_rf3cfh==TYPRHO2) ||
        (wg_rf3cfh==TYPTHETA)||(wg_rf3cfh==TYPOMEGA))
      {
        createinstr( &rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                    pw_rf3cfh,ia_rf3cfh);
        addrfbits(&rf3cfh,off_rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                  pw_rf3cfh);
      }
    else
      {
        createinstr( &rf3cfh,(long)(pos_rf3),
                    pw_rf3cfh,ia_rf3cfh);
      }
  }
  
    } 

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TE = %d\n", cfh_te);
	printf("CFH : Mid Position of rf2cfh = %d\n", (int)(pos_rf2+pw_rf2cfh/2));
    }

    /* FOV selective gradients */
    if (opspf == 0 || presscfh_ctrl != PRESSCFH_NONE)
    {
             
                    

  trapezoid((WF_PROCESSOR)wg_gxrf2cfh, "gxrf2cfh", &gxrf2cfh, &gxrf2cfha,
                        &gxrf2cfhd, pw_gxrf2cfh, pw_gxrf2cfha, pw_gxrf2cfhd,
                        ia_gxrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gxrf2cfha, TRAP_ALL,
                        &cfhloggrd);

    }
    else
    {
             
                    

  trapezoid((WF_PROCESSOR)wg_gyrf2cfh, "gyrf2cfh", &gyrf2cfh, &gyrf2cfha,
                        &gyrf2cfhd, pw_gyrf2cfh, pw_gyrf2cfha, pw_gyrf2cfhd,
                        ia_gyrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gyrf2cfha, TRAP_ALL,
                        &cfhloggrd);

    }
    
    /* Z crushers */
        
                      

  trapezoid((WF_PROCESSOR)wg_gzrf2lcfh, "gzrf2lcfh", &gzrf2lcfh, &gzrf2lcfha,
                        &gzrf2lcfhd, pw_gzrf2lcfh, pw_gzrf2lcfha, pw_gzrf2lcfhd,
                        ia_gzrf2lcfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-(pw_gzrf2lcfh+pw_gzrf2lcfhd)-psd_rf_wait-pw_gzrf2lcfha, TRAP_ALL,
                        &cfhloggrd);

         
                  

  trapezoid((WF_PROCESSOR)wg_gzrf2rcfh, "gzrf2rcfh", &gzrf2rcfh, &gzrf2rcfha,
                        &gzrf2rcfhd, pw_gzrf2rcfh, pw_gzrf2rcfha, pw_gzrf2rcfhd,
                        ia_gzrf2rcfh, 0, 0, 0, 0, pendall(&rf2cfh,0)+pw_gzrf2rcfha-psd_rf_wait-pw_gzrf2rcfha, TRAP_ALL,
                        &cfhloggrd);


   if( presscfh_ctrl != PRESSCFH_NONE ){
             
                        

  trapezoid((WF_PROCESSOR)wg_gyrf3cfh, "gyrf3cfh", &gyrf3cfh, &gyrf3cfha,
                        &gyrf3cfhd, pw_gyrf3cfh, pw_gyrf3cfha, pw_gyrf3cfhd,
                        ia_gyrf3cfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-psd_rf_wait-pw_gyrf3cfha, TRAP_ALL,
                        &cfhloggrd);


        /* Z crushers */
            
                          

  trapezoid((WF_PROCESSOR)wg_gzrf3lcfh, "gzrf3lcfh", &gzrf3lcfh, &gzrf3lcfha,
                        &gzrf3lcfhd, pw_gzrf3lcfh, pw_gzrf3lcfha, pw_gzrf3lcfhd,
                        ia_gzrf3lcfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-(pw_gzrf3lcfh+pw_gzrf3lcfhd)-psd_rf_wait-pw_gzrf3lcfha, TRAP_ALL,
                        &cfhloggrd);

             
                      

  trapezoid((WF_PROCESSOR)wg_gzrf3rcfh, "gzrf3rcfh", &gzrf3rcfh, &gzrf3rcfha,
                        &gzrf3rcfhd, pw_gzrf3rcfh, pw_gzrf3rcfha, pw_gzrf3rcfhd,
                        ia_gzrf3rcfh, 0, 0, 0, 0, pendall(&rf3cfh,0)+pw_gzrf3rcfha-psd_rf_wait-pw_gzrf3rcfha, TRAP_ALL,
                        &cfhloggrd);


        /* steam_flag */
        if( cfh_steam_flag == PSD_ON ){
            INT pos_g1cfh = 0;
            pos_g1cfh = RUP_GRD( pbeg(&gzrf2lcfh, "gzrf2lcfh", 0) - pw_gzrf2lcfha 
                                 - pw_gy1cfh - pw_gy1cfhd );
                 

  trapezoid((WF_PROCESSOR)wg_gy1cfh, "gy1cfh", &gy1cfh, &gy1cfha,
                        &gy1cfhd, pw_gy1cfh, pw_gy1cfha, pw_gy1cfhd,
                        ia_gy1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gy1cfha, TRAP_ALL,
                        &cfhloggrd);

            pos_g1cfh = RUP_GRD( pend(&gzrf3rcfh, "gzrf3rcfh", 0) + pw_gzrf3rcfhd + pw_gx1cfha );
                 

  trapezoid((WF_PROCESSOR)wg_gx1cfh, "gx1cfh", &gx1cfh, &gx1cfha,
                        &gx1cfhd, pw_gx1cfh, pw_gx1cfha, pw_gx1cfhd,
                        ia_gx1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gx1cfha, TRAP_ALL,
                        &cfhloggrd);

        }
    }

    /* Data Acquisiton with .5K/.25k filter */
    if(PSfield_strength <= B0_5000)	/* vmx 05/02/94 */
    {
	cfh_acq_window_pos = RUP_GRD( (int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                            + cfh_te - (cfh_tdaq * cfh_ec_position)));
    }
    else
    {
        if( presscfh_ctrl == PRESSCFH_NONE ) {
	    cfh_acq_window_pos = RUP_GRD(pendall(&gzrf2rcfh,0) + tsamp_delay_cfh);
        } else {
            if( cfh_steam_flag != PSD_ON ){
	        cfh_acq_window_pos = RUP_GRD(pendall(&gzrf3rcfh,0) + tsamp_delay_cfh);
            }else{
                cfh_acq_window_pos = RUP_GRD(pendall(&gx1cfh,0) + tsamp_delay_cfh);
            }
        }
    }

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : Start of data window = %d\n", cfh_acq_window_pos);
    }

          
  {
    pulsename(&cfh_fid,"cfh_fid");
    acqq(&cfh_fid, (long)(cfh_acq_window_pos),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_cfh_fid,
        (TYPDAB_PACKETS)DABNORM);
  }

    /* vmx 05/02/05 YO */
    /* Assert the ESSP flag on the rf1cfh  and rf2cfh pulse */
    attenflagon(&rf1cfh, 0);  
    attenflagon(&rf2cfh, 0);
    if(presscfh_ctrl != PRESSCFH_NONE)
        attenflagon(&rf3cfh, 0); /* for presscfh */

    postemp = RUP_GRD(cfh_acq_window_pos + cfh_tdaq + pw_gykcfha);
     
  {
  pulsename(&cfh_attenkey,"cfh_attenkey");
  createatten(&cfh_attenkey, (long)(postemp));
}

         

  trapezoid((WF_PROCESSOR)wg_gykcfh, "gykcfh", &gykcfh, &gykcfha,
                        &gykcfhd, pw_gykcfh, pw_gykcfha, pw_gykcfhd,
                        ia_gykcfh, 0, 0, 0, 0, postemp-pw_gykcfha, TRAP_ALL,
                        &cfhloggrd);


    /*  If the TE is so long that the readout and killer are pushed out beyond
        the default cfh_tr, cfh_tr must be increased.  Setting cfh_tr to the
        end of the killer + 10ms (time_ssi should never be more than 10ms) 
        should do the trick.   */

    newcfh_tr = RUP_GRD( (((pendall(&gykcfh,0)+10000)>cfh_tr) ? (pendall(&gykcfh,0)+10000) : cfh_tr) );

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TR = %d\n", newcfh_tr);
    }

      
  {
    pulsename(&seqcfh,"seqcfh");
    createseq(&seqcfh,newcfh_tr, off_seqcfh);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfh );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfh = %d\n", idx_seqcfh );
#endif
  }


    return SUCCESS;
}


/*
 *  CoilSwitchPG
 *  
 *  Type: Private Function
 *  
 *  Description: Creates a ssp sequence which can set RF HUB index on
 *  RFHUBSEL. The sequence length needs to change depending upon
 *  setrcvportimm flag. If setrcvportimm needs to be called we need to
 *  provide additional time before starting to acquire as there is time
 *  delay in setting HW. So we add a wait pulse whos pulsewidth will be
 *  decided based on setrcvportimm flag. We also need a 'delay' sequence
 *  as explained in MRIhc14300.
 *  
 */
STATUS
CoilSwitchPG( void )
{
    INT PosContRFHubSel;

    /* SSP Packet for setting the hub index corresponding to the desired
     * coil configuration */
    short dcontrfhubsel[4] = {
        SSPDS,
        SSPOC | RFHUBSEL,
        SSPD,
        SSPDS
    };

    /* SSP Packet for changing receiver input */
    short dcontrfsel[4] = {     
        SSPDS,
        SSPOC | RRFSEL,
        SSPD | RFAUX,
        SSPDS
    };

    PosContRFHubSel = 15   + delay_rfhubsel;

    /* SSP sequence for changing RF Hub index for coil switch */
        
  {
    pulsename(&contrfhubsel,"contrfhubsel");
    createbits(&contrfhubsel,TYPSSP,sizeof(dcontrfhubsel)/2,dcontrfhubsel);
    createinstr( &contrfhubsel,(long)(PosContRFHubSel),
		pw_contrfhubsel,ia_contrfhubsel);
  }


    /* SSP Sequence for changing receiver input */
         
  {
    pulsename(&contrfsel,"contrfsel");
    createbits(&contrfsel,TYPSSP,sizeof(dcontrfsel)/2,dcontrfsel);
    createinstr( &contrfsel,(long)(pendallssp(&contrfhubsel,0)),
		pw_contrfsel,ia_contrfsel);
  }


    /* Insert a wait pulse to allow us to change the actual TR when
       a setrcvportimm() call is necessary */
        
  {
    pulsename(&csw_wait,"csw_wait");
    createconst(&csw_wait,(WF_PROCESSOR)wg_csw_wait,pw_csw_wait,(short)0); 
    createinstr( &csw_wait,(long)(pendallssp(&contrfsel,0)),pw_csw_wait,0);
  }


    csw_tr  = _csw_tr.fixedflag ?          
           ((void)(15+delay_rfhubsel+pw_contrfhubsel+pw_contrfsel+SSP_UPDATE_TIME+csw_time_ssi), csw_tr) : 15+delay_rfhubsel+pw_contrfhubsel+pw_contrfsel+SSP_UPDATE_TIME+csw_time_ssi;

    if( csw_tr < 1000 ) {
        /* Switch time needs to be long enough for RF Hub to switch the coils.
           This is much less than 1ms. */
        csw_tr  = _csw_tr.fixedflag ?  ((void)(RUP_GRD(1000)), csw_tr) : RUP_GRD(1000);
    }
        
  {
    pulsename(&seqcsw,"seqcsw");
    createseq(&seqcsw,RUP_GRD(csw_tr-csw_time_ssi), off_seqcsw);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcsw );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcsw = %d\n", idx_seqcsw );
#endif
  }


    /* MRIhc14300: Short wait pulse before setrcvportimm to avoid race
       condition with SCP */
      
  {
    pulsename(&seqcswWaitBefore,"seqcswWaitBefore");
    createseq(&seqcswWaitBefore,RUP_GRD(csw_wait_before), off_seqcswWaitBefore);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcswWaitBefore );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcswWaitBefore = %d\n", idx_seqcswWaitBefore );
#endif
  }


    return SUCCESS;
}

/*
 *  PSpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSpulsegen( void )
{
    INT posstart;

    /* MRIge82455 */
    psc_vol_index = 0;

    posstart = RUP_GRD(IMax(2, pw_gzrf1mps1a, pw_gzrf1cfla) + 1000);

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    PS1pulsegen( posstart );

    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    CFLpulsegen( posstart );

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    /* GEHmr03545 */
    RCVNpulsegen( posstart );

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    CFHpulsegen( posstart );

    /***********************************************************************
     * CoilSwitch SECTION
     ***********************************************************************/

    CoilSwitchPG( );

    return SUCCESS;
}   /* end PSpulsegen() */


/*
 *  FTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGpulsegen( void )
{
    INT ftgl_tr = 2000000;
    INT PosGz1FTG;          /* Slice dephaser location   */
    INT PosReadoutWindow;   /* Readout window location   */
    INT PosReadoutWindow2;  /* Readout window location   */
    INT postemp;
    INT prescan_start;

    ftgl_tr = ftgtr;

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    prescan_start = RUP_GRD(pw_gzrf1ftga + 1000);

    /* Z-axis slice selective with x readout gradient for 1-d projection
       after theta2 pulse; positioning of signals after theta3 pulse */

    /* Theta1 selective pulse */
         
                 
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1ftg", 
                                    (WF_PROCESSOR)wg_rf1ftg);

    /* Modify resolution if scaling required */
    temp_res_rf1ftg  = _temp_res_rf1ftg.fixedflag ?  ((void)(res_rf1ftg), temp_res_rf1ftg) : res_rf1ftg;
    if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
       res_rf1ftg  = _res_rf1ftg.fixedflag ?  ((void)(rfpulseInfo[RF1_FTG_SLOT].newres), res_rf1ftg) : rfpulseInfo[RF1_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1ftga,"gzrf1ftga");
    pulsename(&gzrf1ftg,"gzrf1ftg");
    pulsename(&gzrf1ftgd,"gzrf1ftgd");
    pulsename(&rf1ftg,"rf1ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf1ftga,ZGRAD,pw_gzrf1ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1ftga,(LONG)(prescan_start-pw_gzrf1ftga),
		pw_gzrf1ftga,ia_gzrf1ftg);
    createconst(&gzrf1ftg,ZGRAD,pw_gzrf1ftg,MAX_PG_WAMP);
    createinstr( &gzrf1ftg,(LONG)(prescan_start),
		pw_gzrf1ftg,ia_gzrf1ftg);
    createramp(&gzrf1ftgd,ZGRAD,pw_gzrf1ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1ftgd,(LONG)(prescan_start+pw_gzrf1ftg),
		pw_gzrf1ftgd,ia_gzrf1ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf1ftg,(WF_PROCESSOR)wg_rf1ftg,res_rf1ftg,
	       MAX_PG_WAMP,cyc_rf1ftg, alpha_rf1ftg);
    createinstr( &rf1ftg,(LONG)(prescan_start) + psd_rf_wait,
		pw_rf1ftg,ia_rf1ftg);
    linkpulses(4,&rf1ftg,&gzrf1ftg,&gzrf1ftga,
	       &gzrf1ftgd);
    addrfbits(&rf1ftg,off_rf1ftg,(LONG)(prescan_start) + psd_rf_wait, 
	      pw_rf1ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
       res_rf1ftg  = _res_rf1ftg.fixedflag ?  ((void)(temp_res_rf1ftg), res_rf1ftg) : temp_res_rf1ftg;
  }


    /* Theta1 rephaser - split into two parts, 2nd part after rf2tg */
    /*                   is defined.                                */
    PosGz1FTG = pendall(&gzrf1ftg, 0) + pw_gz1ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz1ftg, "gz1ftg", &gz1ftg, &gz1ftga,
                        &gz1ftgd, pw_gz1ftg, pw_gz1ftga, pw_gz1ftgd,
                        ia_gz1ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz1ftga, TRAP_ALL,
                        &ps1loggrd);



    /* Theta2 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau1-pw_rf2ftg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2ftg", 
                                    (WF_PROCESSOR)wg_rf2ftg);

    /* Modify resolution if scaling required */
    temp_res_rf2ftg  = _temp_res_rf2ftg.fixedflag ?  ((void)(res_rf2ftg), temp_res_rf2ftg) : res_rf2ftg;
    if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
       res_rf2ftg  = _res_rf2ftg.fixedflag ?  ((void)(rfpulseInfo[RF2_FTG_SLOT].newres), res_rf2ftg) : rfpulseInfo[RF2_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2ftga,"gzrf2ftga");
    pulsename(&gzrf2ftg,"gzrf2ftg");
    pulsename(&gzrf2ftgd,"gzrf2ftgd");
    pulsename(&rf2ftg,"rf2ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf2ftga,ZGRAD,pw_gzrf2ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf2ftga),
		pw_gzrf2ftga,ia_gzrf2ftg);
    createconst(&gzrf2ftg,ZGRAD,pw_gzrf2ftg,MAX_PG_WAMP);
    createinstr( &gzrf2ftg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf2ftg,ia_gzrf2ftg);
    createramp(&gzrf2ftgd,ZGRAD,pw_gzrf2ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2ftg),
		pw_gzrf2ftgd,ia_gzrf2ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf2ftg,(WF_PROCESSOR)wg_rf2ftg,res_rf2ftg,
	       MAX_PG_WAMP,cyc_rf2ftg, alpha_rf2ftg);
    createinstr( &rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf2ftg,ia_rf2ftg);
    linkpulses(4,&rf2ftg,&gzrf2ftg,&gzrf2ftga,
	       &gzrf2ftgd);
    addrfbits(&rf2ftg,off_rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf2ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
       res_rf2ftg  = _res_rf2ftg.fixedflag ?  ((void)(temp_res_rf2ftg), res_rf2ftg) : temp_res_rf2ftg;
  }


    /* Theta2 rephaser - split into two parts: gz2tg and gz2btg (below) */
    PosGz1FTG = pendall(&gzrf2ftg, 0)+pw_gz2ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz2ftg, "gz2ftg", &gz2ftg, &gz2ftga,
                        &gz2ftgd, pw_gz2ftg, pw_gz2ftga, pw_gz2ftgd,
                        ia_gz2ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2ftga, TRAP_ALL,
                        &ps1loggrd);



    /* Theta3 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau2-pw_rf3ftg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf3ftg", 
                                    (WF_PROCESSOR)wg_rf3ftg);

    /* Modify resolution if scaling required */
    temp_res_rf3ftg  = _temp_res_rf3ftg.fixedflag ?  ((void)(res_rf3ftg), temp_res_rf3ftg) : res_rf3ftg;
    if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
       res_rf3ftg  = _res_rf3ftg.fixedflag ?  ((void)(rfpulseInfo[RF3_FTG_SLOT].newres), res_rf3ftg) : rfpulseInfo[RF3_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf3ftga,"gzrf3ftga");
    pulsename(&gzrf3ftg,"gzrf3ftg");
    pulsename(&gzrf3ftgd,"gzrf3ftgd");
    pulsename(&rf3ftg,"rf3ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf3ftga,ZGRAD,pw_gzrf3ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf3ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf3ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf3ftga),
		pw_gzrf3ftga,ia_gzrf3ftg);
    createconst(&gzrf3ftg,ZGRAD,pw_gzrf3ftg,MAX_PG_WAMP);
    createinstr( &gzrf3ftg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf3ftg,ia_gzrf3ftg);
    createramp(&gzrf3ftgd,ZGRAD,pw_gzrf3ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf3ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf3ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf3ftg),
		pw_gzrf3ftgd,ia_gzrf3ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf3ftg,(WF_PROCESSOR)wg_rf3ftg,res_rf3ftg,
	       MAX_PG_WAMP,cyc_rf3ftg, alpha_rf3ftg);
    createinstr( &rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf3ftg,ia_rf3ftg);
    linkpulses(4,&rf3ftg,&gzrf3ftg,&gzrf3ftga,
	       &gzrf3ftgd);
    addrfbits(&rf3ftg,off_rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf3ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
       res_rf3ftg  = _res_rf3ftg.fixedflag ?  ((void)(temp_res_rf3ftg), res_rf3ftg) : temp_res_rf3ftg;
  }


    /* Theta3 rephaser */
    PosGz1FTG = pendall(&gzrf3ftg, 0)+pw_gz3ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz3ftg, "gz3ftg", &gz3ftg, &gz3ftga,
                        &gz3ftgd, pw_gz3ftg, pw_gz3ftga, pw_gz3ftgd,
                        ia_gz3ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz3ftga, TRAP_ALL,
                        &ps1loggrd);


    /*----------------------------------------------------------*/
    /* Readout windows and dephasers                            */ 
    /*----------------------------------------------------------*/

    postemp = (int) (pbeg(&rf2ftg,"gzrf2ftga",0)-pw_gx1ftg-pw_gx1ftgd);

           

  trapezoid((WF_PROCESSOR)wg_gx1ftg, "gx1ftg", &gx1ftg, &gx1ftga,
                        &gx1ftgd, pw_gx1ftg, pw_gx1ftga, pw_gx1ftgd,
                        ia_gx1ftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1ftga, TRAP_ALL,
                        &ps1loggrd);


    postemp = (int) (pendall(&gzrf2ftg,0) + pw_gx1bftga);

          

  trapezoid((WF_PROCESSOR)wg_gx1bftg, "gx1bftg", &gx1bftg, &gx1bftga,
                        &gx1bftgd, pw_gx1bftg, pw_gx1bftga, pw_gx1bftgd,
                        ia_gx1bftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&rf1ftg,"gzrf1ftg",0) - pw_rf1ftg/2 + 2*FTGtau1 - pw_gxw1ftg/2));

    /* HD--Error Check For Gradient Overlapp. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg 
     */
    if ( pendall(&gx1bftg,0) >= (PosReadoutWindow - pw_gxw1ftga)){
        PosReadoutWindow = pendall(&gx1bftg,0) + pw_gxw1ftga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw1ftg, "gxw1ftg", &gxw1ftg, &gxw1ftga,
                        &gxw1ftgd, pw_gxw1ftg, pw_gxw1ftga, pw_gxw1ftgd,
                        ia_gxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1ftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&gxw1ftg,"gxw1ftgd",0))+pw_postgxw1ftga);

           

  trapezoid((WF_PROCESSOR)wg_postgxw1ftg, "postgxw1ftg", &postgxw1ftg, &postgxw1ftga,
                        &postgxw1ftgd, pw_postgxw1ftg, pw_postgxw1ftga, pw_postgxw1ftgd,
                        ia_postgxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_postgxw1ftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1ftg, "gxw1ftga", 0)));

         
  {
    pulsename(&echo1ftg,"echo1ftg");
    acqq(&echo1ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1ftg,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* Second part of theta2 rephaser */
    PosGz1FTG = pbegall(&rf3ftg, 0)-(pw_gz2bftg + pw_gz2bftgd + pw_gzrf3ftga);

          

  trapezoid((WF_PROCESSOR)wg_gz2bftg, "gz2bftg", &gz2bftg, &gz2bftga,
                        &gz2bftgd, pw_gz2bftg, pw_gz2bftga, pw_gz2bftgd,
                        ia_gz2bftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2bftga, TRAP_ALL,
                        &ps1loggrd);


    /* Another refocusing pulse to insure S1 forms tau1 ms after
       center of rf3.  This is the time at which we want to
       the S1 signal to refocus:  */
    PosReadoutWindow =  RUP_GRD((int)(pendall(&rf3ftg, 0) + pw_gx2ftga));

          

  trapezoid((WF_PROCESSOR)wg_gx2ftg, "gx2ftg", &gx2ftg, &gx2ftga,
                        &gx2ftgd, pw_gx2ftg, pw_gx2ftga, pw_gx2ftgd,
                        ia_gx2ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gx2ftga, TRAP_ALL,
                        &ps1loggrd);


    /* Second readout window */
    PosReadoutWindow2 = RUP_GRD((int)(pmidall(&rf3ftg, 0) + FTGtau1 - pw_gxw2ftgleft));

    /* HD--Error Check For Gradient Overlapp. If gradients gx2ftg and
     * gxw2ftg overlap then shift the start of gxw2ftg after end of
     * gx2ftg 
     */
    if ( pendall(&gx2ftg,0) >= (PosReadoutWindow2 - pw_gxw2ftga)){
        PosReadoutWindow2 = pendall(&gx2ftg,0) + pw_gxw2ftga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw2ftg, "gxw2ftg", &gxw2ftg, &gxw2ftga,
                        &gxw2ftgd, pw_gxw2ftg, pw_gxw2ftga, pw_gxw2ftgd,
                        ia_gxw2ftg, 0, 0, 0, 0, PosReadoutWindow2-pw_gxw2ftga, TRAP_ALL,
                        &ps1loggrd);


    if (FTGtestpulse == 1)
    {
        PosReadoutWindow =  RUP_GRD((int)(pbegall(&rf3ftg, 0)+pw_gx2test + pw_gx2testd));
              

  trapezoid((WF_PROCESSOR)wg_gx2test, "gx2test", &gx2test, &gx2testa,
                        &gx2testd, pw_gx2test, pw_gx2testa, pw_gx2testd,
                        ia_gx2test, 0, 0, 0, 0, PosReadoutWindow-pw_gx2testa, TRAP_ALL,
                        &ps1loggrd);

    }    

    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw2ftg, "gxw2ftga", 0)));

        
  {
    pulsename(&echo2ftg,"echo2ftg");
    acqq(&echo2ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo2ftg,
        (TYPDAB_PACKETS)DABNORM);
  }


         
  {
  pulsename(&ftg_attenkey,"ftg_attenkey");
  createatten(&ftg_attenkey, (long)(RUP_GRD(pbegall(&gxw2ftg,0)+1000+pw_gxw2ftg)));
}


      
  {
    pulsename(&seqftg,"seqftg");
    createseq(&seqftg,ftgl_tr, off_seqftg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqftg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqftg = %d\n", idx_seqftg );
#endif
  }


    return SUCCESS;
}   /* end FTGpulsegen() */


/*
 *  XTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGpulsegen( void )
{
    INT xtgl_tr = 2000000;
    INT PosGz1XTG;          /* Slice dephaser location   */
    INT PosReadoutWindow;   /* Readout window location   */
    INT postemp;
    INT prescan_start;

    xtgl_tr = xtgtr;

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    prescan_start = RUP_GRD(pw_gzrf1xtga + 1000);

    /* Theta1 selective pulse */
        
                  
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1xtg", 
                                    (WF_PROCESSOR)wg_rf1xtg);

    /* Modify resolution if scaling required */
    temp_res_rf1xtg  = _temp_res_rf1xtg.fixedflag ?  ((void)(res_rf1xtg), temp_res_rf1xtg) : res_rf1xtg;
    if (rfpulseInfo[RF1_XTG_SLOT].change==PSD_ON)
       res_rf1xtg  = _res_rf1xtg.fixedflag ?  ((void)(rfpulseInfo[RF1_XTG_SLOT].newres), res_rf1xtg) : rfpulseInfo[RF1_XTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1xtga,"gzrf1xtga");
    pulsename(&gzrf1xtg,"gzrf1xtg");
    pulsename(&gzrf1xtgd,"gzrf1xtgd");
    pulsename(&rf1xtg,"rf1xtg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf1xtga,ZGRAD,pw_gzrf1xtga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1xtga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1xtga,(LONG)(prescan_start-pw_gzrf1xtga),
		pw_gzrf1xtga,ia_gzrf1xtg);
    createconst(&gzrf1xtg,ZGRAD,pw_gzrf1xtg,MAX_PG_WAMP);
    createinstr( &gzrf1xtg,(LONG)(prescan_start),
		pw_gzrf1xtg,ia_gzrf1xtg);
    createramp(&gzrf1xtgd,ZGRAD,pw_gzrf1xtgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1xtgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1xtgd,(LONG)(prescan_start+pw_gzrf1xtg),
		pw_gzrf1xtgd,ia_gzrf1xtg);
    
    /* Now create the rf pulse */
    createsinc(&rf1xtg,(WF_PROCESSOR)wg_rf1xtg,res_rf1xtg,
	       MAX_PG_WAMP,cyc_rf1xtg, alpha_rf1xtg);
    createinstr( &rf1xtg,(LONG)(prescan_start) + psd_rf_wait,
		pw_rf1xtg,ia_rf1xtg);
    linkpulses(4,&rf1xtg,&gzrf1xtg,&gzrf1xtga,
	       &gzrf1xtgd);
    addrfbits(&rf1xtg,off_rf1xtg,(LONG)(prescan_start) + psd_rf_wait, 
	      pw_rf1xtg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_XTG_SLOT].change==PSD_ON)
       res_rf1xtg  = _res_rf1xtg.fixedflag ?  ((void)(temp_res_rf1xtg), res_rf1xtg) : temp_res_rf1xtg;
  }


    /* Theta1 rephaser - split into two parts, 2nd part after rf2tg */
    /*                   is defined.                                */
    postemp = RUP_GRD(pend(&rf1xtg,"rf1xtg",0)+pw_gykxtgla);
           

  trapezoid((WF_PROCESSOR)wg_gykxtgl, "gykxtgl", &gykxtgl, &gykxtgla,
                        &gykxtgld, pw_gykxtgl, pw_gykxtgla, pw_gykxtgld,
                        ia_gykxtgl, 0, 0, 0, 0, postemp-pw_gykxtgla, TRAP_ALL,
                        &ps1loggrd);

    
    postemp = RUP_GRD(pendall(&gykxtgl,0));
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf3xtg", 
                                        (WF_PROCESSOR)wg_rf3xtg);

       pulsename(&rf3xtg,"rf3xtg");
       pulsename(&phs_rf3xtg,"phs_rf3xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf3xtg, (WF_PROCESSOR)wg_rf3xtg, res_rf3xtg, ext_filename);
       createinstr( &rf3xtg,(long)(postemp) + psd_rf_wait, pw_rf3xtg,ia_rf3xtg);

       createconst( &phs_rf3xtg,THETA,pw_rf3xtg,MAX_PG_WAMP);
       createinstr( &phs_rf3xtg,(long)(postemp) + psd_rf_wait, pw_rf3xtg,ia_phs_rf3xtg);


       addrfbits(&rf3xtg,off_rf3xtg,(long)(postemp) + 
                 psd_rf_wait, pw_rf3xtg);
   }


    PosGz1XTG = RUP_GRD(pend(&rf1xtg,"gzrf1xtg",0)-pw_rf1xtg/2+XTGtau1-
                        pw_rf2xtg/2-pw_gzrf2xtga-pw_gz1xtgd-pw_gz1xtg);
           

  trapezoid((WF_PROCESSOR)wg_gz1xtg, "gz1xtg", &gz1xtg, &gz1xtga,
                        &gz1xtgd, pw_gz1xtg, pw_gz1xtga, pw_gz1xtgd,
                        ia_gz1xtg, 0, 0, 0, 0, PosGz1XTG-pw_gz1xtga, TRAP_ALL,
                        &ps1loggrd);


    /* Theta2 selective pulse */
    postemp = (int) (pend(&rf1xtg,"gzrf1xtg",0)-pw_rf1xtg/2+XTGtau1-
                     pw_rf2xtg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2xtg", 
                                    (WF_PROCESSOR)wg_rf2xtg);

    /* Modify resolution if scaling required */
    temp_res_rf2xtg  = _temp_res_rf2xtg.fixedflag ?  ((void)(res_rf2xtg), temp_res_rf2xtg) : res_rf2xtg;
    if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
       res_rf2xtg  = _res_rf2xtg.fixedflag ?  ((void)(rfpulseInfo[RF2_XTG_SLOT].newres), res_rf2xtg) : rfpulseInfo[RF2_XTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2xtga,"gzrf2xtga");
    pulsename(&gzrf2xtg,"gzrf2xtg");
    pulsename(&gzrf2xtgd,"gzrf2xtgd");
    pulsename(&rf2xtg,"rf2xtg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf2xtga,ZGRAD,pw_gzrf2xtga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2xtga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2xtga,(LONG)(RUP_GRD(postemp)-pw_gzrf2xtga),
		pw_gzrf2xtga,ia_gzrf2xtg);
    createconst(&gzrf2xtg,ZGRAD,pw_gzrf2xtg,MAX_PG_WAMP);
    createinstr( &gzrf2xtg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf2xtg,ia_gzrf2xtg);
    createramp(&gzrf2xtgd,ZGRAD,pw_gzrf2xtgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2xtgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2xtgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2xtg),
		pw_gzrf2xtgd,ia_gzrf2xtg);
    
    /* Now create the rf pulse */
    createsinc(&rf2xtg,(WF_PROCESSOR)wg_rf2xtg,res_rf2xtg,
	       MAX_PG_WAMP,cyc_rf2xtg, alpha_rf2xtg);
    createinstr( &rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf2xtg,ia_rf2xtg);
    linkpulses(4,&rf2xtg,&gzrf2xtg,&gzrf2xtga,
	       &gzrf2xtgd);
    addrfbits(&rf2xtg,off_rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf2xtg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
       res_rf2xtg  = _res_rf2xtg.fixedflag ?  ((void)(temp_res_rf2xtg), res_rf2xtg) : temp_res_rf2xtg;
  }


    /* Theta2 rephaser - split into two parts: gz2tg and gz2btg (below) */
    PosGz1XTG = pendall(&gzrf2xtg, 0)+pw_gz2xtga;

           

  trapezoid((WF_PROCESSOR)wg_gz2xtg, "gz2xtg", &gz2xtg, &gz2xtga,
                        &gz2xtgd, pw_gz2xtg, pw_gz2xtga, pw_gz2xtgd,
                        ia_gz2xtg, 0, 0, 0, 0, PosGz1XTG-pw_gz2xtga, TRAP_ALL,
                        &ps1loggrd);


    postemp = RUP_GRD(pendall(&gz2xtg, 0));
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf4xtg", 
                                        (WF_PROCESSOR)wg_rf4xtg);

       pulsename(&rf4xtg,"rf4xtg");
       pulsename(&phs_rf4xtg,"phs_rf4xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf4xtg, (WF_PROCESSOR)wg_rf4xtg, res_rf4xtg, ext_filename);
       createinstr( &rf4xtg,(long)(postemp) + psd_rf_wait, pw_rf4xtg,ia_rf4xtg);

       createconst( &phs_rf4xtg,THETA,pw_rf4xtg,MAX_PG_WAMP);
       createinstr( &phs_rf4xtg,(long)(postemp) + psd_rf_wait, pw_rf4xtg,ia_phs_rf4xtg);


       addrfbits(&rf4xtg,off_rf4xtg,(long)(postemp) + 
                 psd_rf_wait, pw_rf4xtg);
   }


    postemp = RUP_GRD(pendall(&rf4xtg, 0)+pw_gykxtgra);
         

  trapezoid((WF_PROCESSOR)wg_gykxtgr, "gykxtgr", &gykxtgr, &gykxtgra,
                        &gykxtgrd, pw_gykxtgr, pw_gykxtgra, pw_gykxtgrd,
                        ia_gykxtgr, 0, 0, 0, 0, postemp-pw_gykxtgra, TRAP_ALL,
                        &ps1loggrd);

    
    postemp = RUP_GRD(pendall(&rf2xtg,0)-pw_rf2xtg/2+XTGtau1-pw_gxw1xtg/2
                      -pw_gxw1xtga-pw_gx1bxtgd-pw_gx1bxtg);
          

  trapezoid((WF_PROCESSOR)wg_gx1bxtg, "gx1bxtg", &gx1bxtg, &gx1bxtga,
                        &gx1bxtgd, pw_gx1bxtg, pw_gx1bxtga, pw_gx1bxtgd,
                        ia_gx1bxtg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bxtga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&rf1xtg,"gzrf1xtg",0) - pw_rf1xtg/2 + 
                                   2*XTGtau1 - pw_gxw1xtg/2));

    /* HD--Error Check For Gradient Overlapp. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg 
     */
    if ( pendall(&gx1bxtg,0) >= (PosReadoutWindow - pw_gxw1xtga)){
        PosReadoutWindow = pendall(&gx1bxtg,0) + pw_gxw1xtga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw1xtg, "gxw1xtg", &gxw1xtg, &gxw1xtga,
                        &gxw1xtgd, pw_gxw1xtg, pw_gxw1xtga, pw_gxw1xtgd,
                        ia_gxw1xtg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1xtga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1xtg, "gxw1xtga", 0)));

         
  {
    pulsename(&echo1xtg,"echo1xtg");
    acqq(&echo1xtg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1xtg,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* position for ATTENUATOR */
    postemp = RUP_GRD(pbegall(&gxw1xtg,0) + 1000 + pw_gxw1xtg);

     
  {
  pulsename(&xtg_attenkey,"xtg_attenkey");
  createatten(&xtg_attenkey, (long)(postemp));
}


      
  {
    pulsename(&seqxtg,"seqxtg");
    createseq(&seqxtg,xtgl_tr, off_seqxtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqxtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqxtg = %d\n", idx_seqxtg );
#endif
  }


    return SUCCESS;
}   /* end XTGpulsegen() */


/*
 *  ASpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASpulsegen( void )
{
    INT PosTemp;

    /***************************************
     * Z board
     ***************************************/
    /* Z gradient slice select */
    PosTemp = RUP_GRD(td0as + tleadas - rfupa + pw_gzrf1asa);
          
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1as", 
                                    (WF_PROCESSOR)wg_rf1as);

    /* Modify resolution if scaling required */
    temp_res_rf1as  = _temp_res_rf1as.fixedflag ?  ((void)(res_rf1as), temp_res_rf1as) : res_rf1as;
    if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
       res_rf1as  = _res_rf1as.fixedflag ?  ((void)(rfpulseInfo[RF1_AUTOSHIM].newres), res_rf1as) : rfpulseInfo[RF1_AUTOSHIM].newres;
    /* First create the pulses */
    pulsename(&gzrf1asa,"gzrf1asa");
    pulsename(&gzrf1as,"gzrf1as");
    pulsename(&gzrf1asd,"gzrf1asd");
    pulsename(&rf1as,"rf1as");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(asloggrd.zbeta), pg_beta) : asloggrd.zbeta;
    createramp(&gzrf1asa,ZGRAD,pw_gzrf1asa,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1asa/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1asa,(LONG)(PosTemp-pw_gzrf1asa),
		pw_gzrf1asa,ia_gzrf1as);
    createconst(&gzrf1as,ZGRAD,pw_gzrf1as,MAX_PG_WAMP);
    createinstr( &gzrf1as,(LONG)(PosTemp),
		pw_gzrf1as,ia_gzrf1as);
    createramp(&gzrf1asd,ZGRAD,pw_gzrf1asd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1asd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1asd,(LONG)(PosTemp+pw_gzrf1as),
		pw_gzrf1asd,ia_gzrf1as);
    
    /* Now create the rf pulse */
    createsinc(&rf1as,(WF_PROCESSOR)wg_rf1as,res_rf1as,
	       MAX_PG_WAMP,cyc_rf1as, alpha_rf1as);
    createinstr( &rf1as,(LONG)(PosTemp) + psd_rf_wait,
		pw_rf1as,ia_rf1as);
    linkpulses(4,&rf1as,&gzrf1as,&gzrf1asa,
	       &gzrf1asd);
    addrfbits(&rf1as,off_rf1as,(LONG)(PosTemp) + psd_rf_wait, 
	      pw_rf1as);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
       res_rf1as  = _res_rf1as.fixedflag ?  ((void)(temp_res_rf1as), res_rf1as) : temp_res_rf1as;
  }
 

    /* Assert the ESSP flag on the rf1as pulse */
    attenflagon(&rf1as, 0);

    /* Z gradient rephaser */
    PosTemp = pendall(&gzrf1as, 0) + pw_gz1asa;
          
                

  trapezoid((WF_PROCESSOR)wg_gz1as, "gz1as", &gz1as, &gz1asa,
                        &gz1asd, pw_gz1as, pw_gz1asa, pw_gz1asd,
                        ia_gz1as, 0, 0, 0, 0, pendall(&gzrf1as,0)+pw_gz1asa-pw_gz1asa, TRAP_ALL,
                        &asloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pmid(&gzrf1as,"gzrf1as",0)-off90as+te_as-pw_gxwas/2);
           

  trapezoid((WF_PROCESSOR)wg_gxwas, "gxwas", &gxwas, &gxwasa,
                        &gxwasd, pw_gxwas, pw_gxwasa, pw_gxwasd,
                        ia_gxwas, 0, 0, 0, 0, PosTemp-pw_gxwasa, TRAP_ALL,
                        &asloggrd);


    PosTemp = RUP_GRD(PosTemp+psd_grd_wait);
        
  {
    pulsename(&echo1as,"echo1as");
    acqq(&echo1as, (long)(PosTemp),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1as,
        (TYPDAB_PACKETS)DABNORM);
  }

    attenflagon(&echo1as,0);

    /* frequency dephaser */
    PosTemp = RUP_GRD(pbegall(&gxwas,0) - (pw_gx1as+pw_gx1asd));
           

  trapezoid((WF_PROCESSOR)wg_gx1as, "gx1as", &gx1as, &gx1asa,
                        &gx1asd, pw_gx1as, pw_gx1asa, pw_gx1asd,
                        ia_gx1as, 0, 0, 0, 0, PosTemp-pw_gx1asa, TRAP_ALL,
                        &asloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
    PosTemp = RUP_GRD( pend(&gxwas, "gxwas",0) );
     
  {
  pulsename(&attenuator_keyas,"attenuator_keyas");
  createatten(&attenuator_keyas, (long)(PosTemp));
}


    /*****************************************
     * Y board
     *****************************************/
    /* HSI - changed SINUSOID to TRAPEZOID2 */
    /* encode */
    PosTemp = RUP_GRD(pend(&gz1asd,"gz1asd",0));
           
    trapezoid((WF_PROCESSOR)wg_gy1as,"gy1as",
              &gy1as,&gy1asa,&gy1asd,
              pw_gy1as,pw_gy1asa,pw_gy1asd,
              ia_gy1as,ia_gy1aswa,ia_gy1aswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);


    /* rewind */
    PosTemp= RUP_GRD(pend(&gxwas,"gxwas",0));
           
    trapezoid((WF_PROCESSOR)wg_gy1ras,"gy1ras",
              &gy1ras,&gy1rasa,&gy1rasd,
              pw_gy1ras,pw_gy1rasa,pw_gy1rasd,
              ia_gy1ras,ia_gy1raswa,ia_gy1raswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);



    /*******************
     * X and Z Killers
     *******************/
    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gxkasa);
         

  trapezoid((WF_PROCESSOR)wg_gxkas, "gxkas", &gxkas, &gxkasa,
                        &gxkasd, pw_gxkas, pw_gxkasa, pw_gxkasd,
                        ia_gxkas, 0, 0, 0, 0, PosTemp-pw_gxkasa, TRAP_ALL,
                        &asloggrd);


    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gzkasa);
         

  trapezoid((WF_PROCESSOR)wg_gzkas, "gzkas", &gzkas, &gzkasa,
                        &gzkasd, pw_gzkas, pw_gzkasa, pw_gzkasd,
                        ia_gzkas, 0, 0, 0, 0, PosTemp-pw_gzkasa, TRAP_ALL,
                        &asloggrd);


    /**************
     * dixon shifts
     **************/
    PosTemp = RUP_GRD(td0as + tleadas - rfupa);
         
  {
    pulsename(&xdixon,"xdixon");
    createconst(&xdixon,(WF_PROCESSOR)wg_xdixon,
                pw_xdixon,MAX_PG_WAMP);
    createinstr( &xdixon,(long)(PosTemp),
		pw_xdixon,ia_xdixon);
    if ((wg_xdixon==TYPRHO1)||(wg_xdixon==TYPRHO2))
      {
	addrfbits(&xdixon,0,(long)(PosTemp),pw_xdixon);
      }
  }

         
  {
    pulsename(&ydixon,"ydixon");
    createconst(&ydixon,(WF_PROCESSOR)wg_ydixon,
                pw_ydixon,MAX_PG_WAMP);
    createinstr( &ydixon,(long)(PosTemp),
		pw_ydixon,ia_ydixon);
    if ((wg_ydixon==TYPRHO1)||(wg_ydixon==TYPRHO2))
      {
	addrfbits(&ydixon,0,(long)(PosTemp),pw_ydixon);
      }
  }


    PosTemp = pend(&gz1asd,"gz1asd",0);
         
  {
    pulsename(&zdixon,"zdixon");
    createconst(&zdixon,(WF_PROCESSOR)wg_zdixon,
                pw_zdixon,MAX_PG_WAMP);
    createinstr( &zdixon,(long)(PosTemp),
		pw_zdixon,ia_zdixon);
    if ((wg_zdixon==TYPRHO1)||(wg_zdixon==TYPRHO2))
      {
	addrfbits(&zdixon,0,(long)(PosTemp),pw_zdixon);
      }
  }


    /* just pad the ssp somewhere beyond the rf unblank */
    rfdisable_add = YES;
    PosTemp = RUP_RF(pend(&rf1as,"rf1as",0) + rfupd + 12);
         
  {
    pulsename(&sdixon,"sdixon");
    createconst(&sdixon,(WF_PROCESSOR)wg_sdixon,
                pw_sdixon,MAX_PG_WAMP);
    createinstr( &sdixon,(long)(PosTemp),
		pw_sdixon,ia_sdixon);
    if ((wg_sdixon==TYPRHO1)||(wg_sdixon==TYPRHO2))
      {
	addrfbits(&sdixon,0,(long)(PosTemp),pw_sdixon);
      }
  }


    PosTemp = RUP_RF(pbeg(&gzkas,"gzkas",0));
         
  {
    pulsename(&sdixon2,"sdixon2");
    createconst(&sdixon2,(WF_PROCESSOR)wg_sdixon2,
                pw_sdixon2,MAX_PG_WAMP);
    createinstr( &sdixon2,(long)(PosTemp),
		pw_sdixon2,ia_sdixon2);
    if ((wg_sdixon2==TYPRHO1)||(wg_sdixon2==TYPRHO2))
      {
	addrfbits(&sdixon2,0,(long)(PosTemp),pw_sdixon2);
      }
  }


    rfdisable_add = NO;
        
  {
    pulsename(&seqaushim,"seqaushim");
    createseq(&seqaushim,RUP_GRD((int)(tr_as-time_ssias)), off_seqaushim);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqaushim );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqaushim = %d\n", idx_seqaushim );
#endif
  }

    attenflagon(&seqaushim, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_aushim,"pass_aushim");
    createpass(&pass_aushim,(long)(RUP_GRD(TR_PASS3D-1000)));
  }

      
  {
    pulsename(&seqpassas,"seqpassas");
    createseq(&seqpassas,RUP_GRD(TR_PASS3D), off_seqpassas);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassas );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassas = %d\n", idx_seqpassas );
#endif
  }


    return SUCCESS;
}   /* end ASpulsegen() */




/* Include special CV download code */
#include "bbepi.cvcopy.c"

