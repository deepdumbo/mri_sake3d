/*
 *  bbepi.tgt.c
 *
 *  Do not edit this file. It is automatically generated by EPIC.
 *
 *  Date : Oct  9 2013
 *  Time : 17:18:52
 */

#include <epic_struct.h>
#if defined(MGD_TGT) && defined(PSD_HW)
#include "valuesMGD.h"
#endif /* MGD_TGT && PSD_HW */
#include "bbepi.global.h"
#include <pgen_tmpl.h>
#include <epicfuns.h>
#ifdef PSD_HW
__asm__(".align 8");
#endif

#include "bbepi.allcv.h"
#include "bbepi.tgtex.h"
#include "bbepi.tgtdecl.h"
long _header_source_rev= 1435086244;

CHAR *entry_name_list[ENTRY_POINT_MAX] = { "scan",
                                           "mps2",
                                           "aps2",
                                           "ref",
					     
/*********************************************************************
 *                    PRESCAN.E RSP SECTION                          *
 *                           PSeplist                                *
 *                                                                   *
 * Additional list of entry points for Prescan.                      *
 *********************************************************************/
         "cfl",
         "cfh",
         "mps1",
         "aps1", 
         "autoshim",
         "fasttg",
         "rcvn",
         "expresstg",
         0	/* 0 is needed for the parser */


};

int   deadtime;               /* amount of deadtime */
short viewtable[1025];        /* view table */
int   xrr_trig_time;          /* trigger time for filled or unfilled
		                 R-R interval which is not last R-R */
                  
float *viewpstart; /* starting exciter phase for 1st view of interleave */
float *viewpdelta; /* incremental delta phase between views of interleave */

short tempamp;

WF_PULSE tmppulse,*tmppulseptr;
WF_INSTR_HDR *tmpinstr;

FILE *fp;
char *infilename="ref.dat";
char *pathname="/usr/g/bin/";
char basefilename[80];

/*********************************************************************
 *                       EPI.E PULSEGEN SECTION                      *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/

/* MRIge55206 - change memory allocation if in SIM for multi-dim array support */
#ifdef SIM
#include <stdlib.h>
#define AllocMem malloc
#else
#define AllocMem AllocNode
#endif
                                          

/* BJM: SE Ref Scan */
STATUS setreadpolarity_ref( void );

/* Declaration of new function for ref scan */

int tot_etl; /* internref */
                                           
long rsprot_orig[DATA_ACQ_MAX][9]; /* rotation matrix for SAT */
extern PSD_EXIT_ARG psdexitarg;
short *acq_ptr;               /* first slice in a pass */
int   *ctlend_tab;            /* table of cardiac deadtimes */
short *slc_in_acq;            /* number of slices in each pass */
/* Frequency/Phase offsets */
int   *rf1_freq;
int   *theta_freq;
int   *rf2_freq;
int   ***recv_freq;
int   ***recv_phase;
double ***recv_phase_angle;
int   **rf_phase_spgr;
WF_PULSE **echotrainxtr;
WF_PULSE **echotrainrba;
int *echotrainramp;
int *echotrainramp1;
int *echotrainramp2;
short **echotrainrampamp;
short **echotrainrampamp1;
short **echotrainrampamp2;

WF_PULSE_ADDR rtb0echoxtr;

/* The following arrays are indexed by intleave: */
int *gy1f;      /* amplitude of gy1f pulse */
int *gymn;      /* amplitude of y gradient moment nulling pulses */
int *view1st;   /* 1st view to acquire */
int *viewskip;  /* number of views to skip */
int *tf;        /* time factor shift */
int *rfpol;     /* rf polarity */
int *blippol;   /* blip gradient polarity */
int *gradpol;   /* readout gradient polarity */
float *b0ditherval;/* B0 dither value, per slice basis */
float *delayval;   /* delay values, per slice basis */
int *gldelaycval;  /* per slice gldelayc valuse */
float *gldelayfval; /* per slice gldelayf values */
int defaultdelay = 0; /* default delay */
int mintf;         /* most negative tfon value, for echo train positioning */
int sp_satindex, cs_satindex;  /* index for multiple calls to spsat
                                  and chemsat routines */
int rcvrunblankpos;

/*jwg bb for reading external waveform*/
char rf1froot[80]; 
char rf1_datfile[80]; 
/*jwg end*/

WF_PULSE gx1a = INITPULSE;
WF_PULSE gx1 = INITPULSE;
WF_PULSE gx1d = INITPULSE;

WF_PULSE rho_killer = INITPULSE;

WF_PULSE rs_omega_attack = INITPULSE;
WF_PULSE rs_omega_decay = INITPULSE;
WF_PULSE omega_flat = INITPULSE;

/* Define some more MRE variables */
WF_PULSE touch_gx_meg = INITPULSE;
WF_PULSE touch_gy_meg = INITPULSE;
WF_PULSE touch_gz_meg = INITPULSE;

long scan_deadtime;          /* deadtime in scan entry point */
long *scan_deadtime_correct; /* deadtime for each slice after correction*/ 
long prescan_trigger;        /* save the prescan slice's trigger */
long rsptrigger_temp[1];     /* temp trigger array for pass packets 
                                sequences and other misc */
/* Original scan info */
RSP_INFO orig_rsp_info[DATA_ACQ_MAX];
long origrot[DATA_ACQ_MAX][9];
WF_INSTR_HDR *instrtemp;

/* Frequency offsets */
int *rf0_freq;
int *rf0_pha;
long ir_deadtime;     /* dead time for IR pulses */


/* BJM: SE Ref Scan */    

/* 90 Degree Pulse + Gradient */
WF_PULSE gzrf1refa = INITPULSE;
WF_PULSE gzrf1ref  = INITPULSE;
WF_PULSE gzrf1refd = INITPULSE;
WF_PULSE rf1ref = INITPULSE;
WF_PULSE thetarf1ref  = INITPULSE;

/* 180 Degree Pulse Pulse Slice-Select */
WF_PULSE gzrf2refa = INITPULSE;
WF_PULSE gzrf2ref  = INITPULSE;
WF_PULSE gzrf2refd = INITPULSE;
WF_PULSE rf2ref = INITPULSE;
WF_PULSE rf2se1b4_ref = INITPULSE;

/* Crushers Left (l1) and Right (r1) */
WF_PULSE gzrf2refl1a = INITPULSE;
WF_PULSE gzrf2refl1 = INITPULSE;
WF_PULSE gzrf2refl1d = INITPULSE;

WF_PULSE gzrf2refr1a = INITPULSE;
WF_PULSE gzrf2refr1 = INITPULSE;
WF_PULSE gzrf2refr1d = INITPULSE;

/* Ky Prephaser Pulse */
WF_PULSE refgy1a = INITPULSE;
WF_PULSE refgy1 = INITPULSE;
WF_PULSE refgy1d = INITPULSE;

/* Kx Prephaser Pulse */
WF_PULSE refgx1a = INITPULSE;
WF_PULSE refgx1 = INITPULSE;
WF_PULSE refgx1d = INITPULSE;

/* Killer Pulse on X */
WF_PULSE refgxka = INITPULSE;
WF_PULSE refgxk = INITPULSE;
WF_PULSE refgxkd = INITPULSE;

/* Killer Pulse on Y */
WF_PULSE refgyka = INITPULSE;
WF_PULSE refgyk = INITPULSE;
WF_PULSE refgykd = INITPULSE;

/* Killer Pulse on Z */
WF_PULSE refgzka = INITPULSE;
WF_PULSE refgzk = INITPULSE;
WF_PULSE refgzkd = INITPULSE;

WF_PULSE wgxref = INITPULSE;

WF_PULSE wgyref = INITPULSE;

WF_PULSE wgzref = INITPULSE;

WF_PULSE wsspref = INITPULSE;

WF_PULSE sspdelayref = INITPULSE;

WF_PULSE omegadelayref = INITPULSE;

WF_PULSE womegaref = INITPULSE;

WF_PULSE e1entnsref = INITPULSE;
short e1entnsref_pack[4] = {0,SSPOC+DREG,SSPD+DCBL,SSPDS};

WF_PULSE e1distnsref = INITPULSE;
short e1distnsref_pack[4] = {0,SSPOC+DREG,SSPD,SSPDS};

WF_PULSE sspshiftref = INITPULSE;
WF_PULSE ssp_pass_delayref = INITPULSE;


WF_PULSE rho_killerref = INITPULSE;

WF_PULSE rs_omega_attackref = INITPULSE;
WF_PULSE rs_omega_decayref = INITPULSE;
WF_PULSE omega_flatref = INITPULSE;

WF_PULSE_ADDR rf2ssp_end;

WF_PULSE **echotrainxtr_ref;
WF_PULSE **echotrainrba_ref;


/***************************** setreadpolarity *************************/
STATUS setreadpolarity_ref( void )
{
    int polarity;

    if (iref_etl%2 == 1) {
        polarity = -1;
    }
    else {
        polarity = 1;
    }

    tia_gx1 = polarity*gradpol[ileave]*ia_gx1;  /* temporary x dephaser amp */
    tia_gxw = polarity*gradpol[ileave]*ia_gxw;  /* temporary x readout amp  */
    tia_gxk = polarity*gradpol[ileave]*ia_gxk;  /* temporary x killer amp   */
    setiamp(tia_gx1, &refgx1a, 0);        /* x dephaser attack */
    setiamp(tia_gx1, &refgx1, 0);         /* x dephaser middle */
    setiamp(tia_gx1, &refgx1d, 0);        /* x dephaser decay  */
    setiamp(tia_gxw, &refgxw, 0);

    /* Ramps are handled with opposite sign because of the way they
       are defined in the EP_TRAIN_NAME macro.  Please refer to epic.h
       for more details. */

    for (echo=1; echo < tot_etl; echo++) {
        if ((echo % 2) == 1) {  /* Even echo within interleave */ 
            setiamp(-tia_gxw, &refgxwa, echo-1); /* waveforms go neg to pos in ep_train */
            setiamp(-tia_gxw, &refgxwd, echo-1);
            setiamp(-tia_gxw, &refgxw, echo);    /* const   */
        } else {                    /* Odd echo within interleave */
            setiamp(tia_gxw, &refgxwa, echo-1); /* waveforms go neg to pos in ep_train */
            setiamp(tia_gxw, &refgxwd, echo-1);
            setiamp(tia_gxw, &refgxw, echo);     /* flattop   */
        }
    }


    if ((tot_etl % 2) == 1) {

        setiamp(-tia_gxw,&refgxwde, 0);  /* decay,end */

        if (eosxkiller == 1) {
            setiamp(-tia_gxk,&refgxka, 0);   /* killer attack */
            setiamp(-tia_gxk,&refgxk, 0);    /* killer flattop */
            setiamp(-tia_gxk,&refgxkd, 0);   /* killer decay  */
        }

    } else {

        setiamp(tia_gxw,&refgxwde, 0);   /* decay,end */

        if (eosxkiller == 1) {
            setiamp(tia_gxk,&refgxka, 0);    /* killer attack */
            setiamp(tia_gxk,&refgxk, 0);     /* killer flattop */
            setiamp(tia_gxk,&refgxkd, 0);    /* killer decay  */
        }
    }

    return SUCCESS;

} /* end setreadpolarity_ref() */


/**** END of refScan.e File ****/

void
#ifdef __STDC__ 
dummyssi( void )
#else /* !__STDC__ */
    dummyssi() 
#endif /* __STDC__ */
{
    return;
}

/* Added for Inversion.e */
STATUS
#ifdef __STDC__
setupphases ( INT *phase,
              INT *freq,
              INT slice,
              FLOAT rel_phase,
              INT time_delay )
#else /* !__STDC__ */
    setupphases( phase, freq, slice, rel_phase, time_delay )
    INT *phase;                /* output phase offsets */
    INT *freq;                 /* precomputed frequency offsets */
    INT slice;                 /* slice number */
    FLOAT rel_phase;           /* in cycles */
    INT time_delay;            /* in micro seconds */
#endif /* __STDC__ */
{
    double ftime_delay;           /* floating point time delay in seconds */
    double temp_freq;             /* frequency offset */
    float tmpphase;
    int   intphase;
    int   sign;
    
    ftime_delay = ((double)time_delay)/((double)(1000000));
    
    /* Convert tardis int to frequency */
    temp_freq = ((double)(freq[slice]))*TARDIS_FREQ_RES;
    
    /* Determine phase change in radians */
    tmpphase = (rel_phase - ( temp_freq * ftime_delay ))*2.0*PI;
    
    tmpphase/= (float)PI;    /* unwrap this phase bits */
    if (tmpphase < 0) {
        sign = -1;
        tmpphase *= -1;
    } else {
        sign = 1;
    }

    if ( ((int)floor((double)tmpphase) % 2) == 1) {
        sign *= -1;
        intphase = sign * (long)((1.0-(tmpphase - (float)floor((double)tmpphase)) ) * ((double)FSI));
    } else {
        intphase = sign * (long)((tmpphase - (float)floor((double)tmpphase)) * ((double)FSI));
    }

    phase[slice] = intphase;
    
    return SUCCESS;   
} /* end setupphases */


void
#ifdef __STDC__ 
ssisat( void )
#else /* !__STDC__ */
    ssisat()
#endif /* __STDC__ */
{
#ifdef IPG
    int next_slice;

    next_slice = sp_sat_index;
    sp_update_rot_matrix( &rsprot_orig[next_slice][0], sat_rot_matrices,
                          sat_rot_ex_num, sat_rot_df_num );
#endif /* IPG */
    return;
}


/***************************** setreadpolarity *************************/
STATUS
#ifdef __STDC__ 
setreadpolarity( void )
#else /* !__STDC__ */
    setreadpolarity()
#endif /* __STDC__ */
{

    int polarity;

    if (iref_etl%2 == 1) {
        polarity = -1;
    }
    else {
        polarity = 1;
    } 

    tia_gx1 = polarity*gradpol[ileave]*ia_gx1;  /* temporary x dephaser amp */
    tia_gxw = polarity*gradpol[ileave]*ia_gxw;  /* temporary x readout amp  */
    tia_gxk = polarity*gradpol[ileave]*ia_gxk;  /* temporary x killer amp   */

    setiamp(tia_gx1, &gx1a, 0);        /* x dephaser attack */
    setiamp(tia_gx1, &gx1, 0);         /* x dephaser middle */
    setiamp(tia_gx1, &gx1d, 0);        /* x dephaser decay  */
    setiamp(tia_gxw, &gxw, 0);

    /* Ramps are handled with opposite sign because of the way they
       are defined in the EP_TRAIN macro.  Please refer to epic.h
       for more details. */
    
    for (echo=1; echo < tot_etl; echo++) {
        if ((echo % 2) == 1) {  /* Even echo within interleave */ 
            setiamp(-tia_gxw, &gxwa, echo-1); /* waveforms go neg to pos in ep_train */
            setiamp(-tia_gxw, &gxwd, echo-1);
            setiamp(-tia_gxw, &gxw, echo);    /* const   */
        } else {                    /* Odd echo within interleave */
            setiamp(tia_gxw, &gxwa, echo-1); /* waveforms go neg to pos in ep_train */
            setiamp(tia_gxw, &gxwd, echo-1);
            setiamp(tia_gxw, &gxw, echo);     /* flattop   */
        }
    }
  
    
    if ((tot_etl % 2) == 1) {

        setiamp(-tia_gxw,&gxwde, 0);  /* decay,end */

	if (eosxkiller == 1) {
            setiamp(-tia_gxk,&gxka, 0);   /* killer attack */
            setiamp(-tia_gxk,&gxk, 0);    /* killer flattop */
            setiamp(-tia_gxk,&gxkd, 0);   /* killer decay  */
	}

    } else {

        setiamp(tia_gxw,&gxwde, 0);   /* decay,end */

	if (eosxkiller == 1) {
            setiamp(tia_gxk,&gxka, 0);    /* killer attack */
            setiamp(tia_gxk,&gxk, 0);     /* killer flattop */
            setiamp(tia_gxk,&gxkd, 0);    /* killer decay  */
	}
    }
    
    return SUCCESS;
}

STATUS
pulsegen( void )
{
    EXTERN_FILENAME ext_filename; /* filename holder for externals */
    int Rf2Location[NECHO_MAX]; /* time locations of Rf2 */
    short slmod_acqs;           /* slices%acqs */
    int tempx, tempy, tempz;
    int i;
#ifdef IPG
    int temps;
#ifdef SIM
    int j;
#endif /* SIM */
#endif /* IPG */
    int temp1, temp2;
    int echoloop;
    int psd_icnt,psd_jcnt;
    int psd_seqtime;      /* sequence time */
    int pg_tsp = 0;
    int stddab;           /* 1 = use standard dab, 0 = use hsdab */
    short *wave_space;
    short *temp_wave_space; /* temporary waveform space for rf scaling */
    short temp_res;         /* temporary resolution */
    int wave_ptr;           /* hardware wave pointer */
    float temp_gmnamp;  /* temporary amplitudes for y gmn calc */
    float tempa, tempb;
    int lpfval = -1;
    LONG pulsePos;
    float betax;

    tot_etl = etl + iref_etl; /* internref */
    
  /*jwg more additions for BB*/
 if((acquire_type == SPECPSD_SLAVE_H1)|| (acquire_type == SPECPSD_SLAVE_MNS))
   {	
	 requestTransceiver( psd_board_type, SLAVE_EXCITER, ALL_RECEIVERS);
   }
 else
   {
	 requestTransceiver( psd_board_type, MASTER_EXCITER, ALL_RECEIVERS);
   }    
        
    /* Set HPC timer set to 10 seconds (5 sec. per count) */
    setwatchdogrsp(watchdogcount); /* First give pulsegen a little extra time */
    sspinit(psd_board_type);
    

#ifdef IPG
    /*
     * Execute this code only on the Tgt side
     */

#ifdef SIM

    /* Set rotation matrices for Simulation */
    simulationInit( rsprot[0] );

    /* Saved unscaled version of rotation matrices */
    for ( i = 0 ; i < (opslquant * opphases) ; i++ ) {

        if (obl_debug == PSD_ON){
            printf( "Slice %d\n", i );
        }

        for ( j = 0 ; j < 9 ; j++ ) {

            rsprot_unscaled[i][j] = rsprot[i][j];

            if (obl_debug == PSD_ON) {
                printf( "rsprot_unscaled[%d] = %ld\n", j, rsprot_unscaled[i][j] );
            }
        }
    }
#endif /* SIM */
#endif /* IPG */

    /* Initialize psdexitarg */
    psdexitarg.abcode = 0;
    strcpy(psdexitarg.text_arg, "pulsegen");
    view = slice = excitation  = 0;
 
    { /* Start of code inlined from vmx.e VMXpg */
        if( system_type == 1 )
        {
            rfupa = cv_rfupa;
        }
    } /* End of code inlined from vmx.e VMXpg */


    
  /*jwg have to fix this or download will fail*/
  ia_gxwas = 0;
       
    debugstate = debugipg;
  
    /* Allocate memory for various arrays.
     * An extra 2 locations are saved in case the user wants to do
     * some tricks. */
    acq_ptr = (short *)AllocNode((acqs*pass_reps + 2)*sizeof(short));
    ctlend_tab = (int *)AllocNode((opphases*opslquant + 2)*sizeof(int));
    slc_in_acq = (short *)AllocNode((acqs*pass_reps + 2)*sizeof(short));
    rf1_freq = (int *)AllocNode((opslquant + 2)*sizeof(int));
    theta_freq = (int *)AllocNode((opslquant + 2)*sizeof(int));
    rf2_freq = (int *)AllocNode((opslquant + 2)*sizeof(int));
    
    /* MRIge55206 */
    /* BJM - change to malloc() in SIM since AllocNode doesn't handle */
    /*       multi-dimensional arrays very well */
    recv_freq = (int ***)AllocMem(opslquant*sizeof(int **));
    for (psd_icnt = 0; psd_icnt < opslquant; psd_icnt++) {
	recv_freq[psd_icnt] = (int **)AllocMem(intleaves*sizeof(int *));
	for (psd_jcnt = 0; psd_jcnt < intleaves; psd_jcnt++)
            recv_freq[psd_icnt][psd_jcnt] = (int *)AllocMem(tot_etl*sizeof(int));
    }
    
    recv_phase = (int ***)AllocMem(opslquant*sizeof(int **));
    for (psd_icnt = 0; psd_icnt < opslquant; psd_icnt++) {
	recv_phase[psd_icnt] = (int **)AllocMem(intleaves*sizeof(int *));
	for (psd_jcnt = 0; psd_jcnt < intleaves; psd_jcnt++)
            recv_phase[psd_icnt][psd_jcnt] = (int *)AllocMem(tot_etl*sizeof(int));
    }
    
    recv_phase_angle = (double ***)AllocMem(opslquant*sizeof(double **));
    for (psd_icnt = 0; psd_icnt < opslquant; psd_icnt++) {
	recv_phase_angle[psd_icnt] = (double **)AllocMem(intleaves*sizeof(double *));
	for (psd_jcnt = 0; psd_jcnt < intleaves; psd_jcnt++)
            recv_phase_angle[psd_icnt][psd_jcnt] =
		(double *)AllocMem(tot_etl*sizeof(double));
    }
    
    rf_phase_spgr = (int **)AllocMem(opslquant*sizeof(int *));
    for (psd_icnt = 0; psd_icnt < opslquant; psd_icnt++) {
	rf_phase_spgr[psd_icnt] = (int *)AllocMem(intleaves*sizeof(int));
    }
    
    echotrainxtr = (WF_PULSE **)AllocNode(tot_etl*sizeof(WF_PULSE *));
    echotrainrba = (WF_PULSE **)AllocNode(tot_etl*sizeof(WF_PULSE *));
    echotrainramp = (int *)AllocNode(tot_etl*sizeof(int));
    echotrainramp1 = (int *)AllocNode(tot_etl*sizeof(int));
    echotrainramp2 = (int *)AllocNode(tot_etl*sizeof(int));
    echotrainrampamp = (short **)AllocNode(tot_etl*sizeof(short*));
    echotrainrampamp1 = (short **)AllocNode(tot_etl*sizeof(short*));
    echotrainrampamp2 = (short **)AllocNode(tot_etl*sizeof(short*));

    gy1f = (int *)AllocNode((intleaves+1)*sizeof(int));
    gymn = (int *)AllocNode((intleaves+1)*sizeof(int));
    view1st = (int *)AllocNode((intleaves+1)*sizeof(int));
    viewskip = (int *)AllocNode((intleaves+1)*sizeof(int));
    tf = (int *)AllocNode((intleaves+1)*sizeof(int));
    rfpol = (int *)AllocNode((intleaves+1)*sizeof(int));
    gradpol = (int *)AllocNode((intleaves+1)*sizeof(int));
    blippol = (int *)AllocNode((intleaves+1)*sizeof(int));
    b0ditherval = (float *)AllocNode((opslquant+1)*sizeof(float));
    delayval = (float *)AllocNode((opslquant+1)*sizeof(float));
    gldelaycval = (int *)AllocNode((opslquant+1)*sizeof(int));
    gldelayfval = (float *)AllocNode((opslquant+1)*sizeof(float));
    
#ifdef ERMES_DEBUG
    debugileave = 1;
#endif

    switch (ky_dir) {
    case PSD_TOP_DOWN:
	readpolar = 1;
	break;
    case PSD_BOTTOM_UP:
    case PSD_CENTER_OUT:
    default:
	if (etl % 2 == 1)  /* odd */
            readpolar = 1;
	else               /* even */
            readpolar = -1;  
	break;
    }

    /*
     * Set gradpol array for readout gradient amplitudes.
     */
    /* BJM: MRIge60610 - added num_overscan */ 
    /* internref: added iref_etl. Note etl does not count iref_etl */
    /* MRIge92386 */

    if (FAILURE == ileaveinit( fullk_nframes, ky_dir,
                               intleaves, ep_alt, readpolar, blippolar, debugileave, ia_rf1,
                               ia_gyb, pepolar, etl, seq_data, delt, tfon, fract_ky,
                               ky_offset, num_overscan, endview_iamp, esp, tsp, rhfrsize,
                               a_gxw, rhrcxres, slquant1, lpfval, iref_etl, gy1f, view1st,
                               viewskip, tf, rfpol, gradpol, blippol, &mintf ))
    {
        return FAILURE;
    }

    for (ileave = 0; ileave < intleaves; ileave++){
        if (ygmn_type == CALC_GMN1) {
            tempa = a_gy1a * (float)gy1f[ileave]/ (float)endview_iamp;
            tempb = a_gy1b * (float)gy1f[ileave]/ (float)endview_iamp;
            
            amppwygmn( gyb_tot_0thmoment, gyb_tot_1stmoment, pw_gy1a, pw_gy1,
                       pw_gy1d, tempa, tempb, loggrd.ty_xyz, (float)loggrd.yrt,
                       1, &pw_gymn1a, &pw_gymn1, &pw_gymn1d, &temp_gmnamp );
            
            gymn[ileave] = (int)((float)ia_gymn1 * a_gymn1/ temp_gmnamp);
            
            if (debugileave == 1) {
                printf( "gymn[%d] = %d, temp_gmnamp = %f\n",
                        ileave,gymn[ileave],temp_gmnamp );
            }
        } else {
            gymn[ileave] = 0;
        }
    }
    

#ifdef IPG
    /*
     * Execute this code only on the Tgt side
     */
    rdx = dx;
    rdy = dy;
    rdz = dz;
    
    dlyx = gldelayx;
    dlyy = gldelayy;
    dlyz = gldelayz;
    
    b0Dither_ifile( b0ditherval, ditheron, rdx, rdy, rdz, a_gxw, esp,
                    opslquant, debugdither, rsprot_unscaled, 
                    ccinx, cciny, ccinz, esp_in, fesp_in,
                    &g0, &num_elements, &file_exist );
    
    /* Account for rotation in delays.  Since each slice can have a different */
    /* rot mat, each slice is given its own delay */
    calcdelay( delayval, delayon, dlyx, dlyy, dlyz,
               &defaultdelay, opslquant,opgradmode, debugdelay, rsprot_unscaled ); 

#ifdef UNDEF
    calcdelayfile(delayval, delayon, dlyx, dlyy, dlyz,
                  &defaultdelay, opslquant, debugdelay, rsprot_unscaled, 
                  delay_buffer);    
#endif

    /* Set up slice dependent delays for SSP */
    for (slice = 0; slice < opslquant; slice++) {
        
        /* Adjust by daq window (e.g. ramp sampling) */
        delayval[slice] += dacq_adjust;
        
        /* Cast to nearest micro-second */
        if (delayval[slice] < 0.0)
            gldelaycval[slice] = (int)(delayval[slice] - 0.5);
        else
            gldelaycval[slice] = (int)(delayval[slice] + 0.5);
    }
    
    /* SPGR Stuff - not currently used */
    if (oppseq == PSD_SPGR)
	spgr_flag = 1;
    else
	spgr_flag = 0;
    
    for (slice = 0; slice < opslquant; slice++) {
        for (ileave = 0; ileave < intleaves; ileave++)
            rf_phase_spgr[slice][ileave] = 0;  /* call spgr function in future */
        
    }
#endif

    
       
  {
    pulsename(&x_td0,"x_td0");
    createconst(&x_td0,(WF_PROCESSOR)wg_x_td0,pw_x_td0,(short)0); 
    createinstr( &x_td0,(long)(tlead),pw_x_td0,0);
  }

       
  {
    pulsename(&y_td0,"y_td0");
    createconst(&y_td0,(WF_PROCESSOR)wg_y_td0,pw_y_td0,(short)0); 
    createinstr( &y_td0,(long)(tlead),pw_y_td0,0);
  }

       
  {
    pulsename(&z_td0,"z_td0");
    createconst(&z_td0,(WF_PROCESSOR)wg_z_td0,pw_z_td0,(short)0); 
    createinstr( &z_td0,(long)(tlead),pw_z_td0,0);
  }

       
  {
    pulsename(&rho_td0,"rho_td0");
    createconst(&rho_td0,(WF_PROCESSOR)wg_rho_td0,pw_rho_td0,(short)0); 
    createinstr( &rho_td0,(long)(tlead),pw_rho_td0,0);
  }

       
  {
    pulsename(&theta_td0,"theta_td0");
    createconst(&theta_td0,(WF_PROCESSOR)wg_theta_td0,pw_theta_td0,(short)0); 
    createinstr( &theta_td0,(long)(tlead),pw_theta_td0,0);
  }
 /* YMSmr07445 */
       
  {
    pulsename(&omega_td0,"omega_td0");
    createconst(&omega_td0,(WF_PROCESSOR)wg_omega_td0,pw_omega_td0,(short)0); 
    createinstr( &omega_td0,(long)(tlead),pw_omega_td0,0);
  }

       
  {
    pulsename(&ssp_td0,"ssp_td0");
    createconst(&ssp_td0,(WF_PROCESSOR)wg_ssp_td0,pw_ssp_td0,(short)0); 
    createinstr( &ssp_td0,(long)(tleadssp),pw_ssp_td0,0);
  }

    
    { /* Start of code inlined from Inversion.e InversionPG */
        int i;
        int j;

        if (ir_on == PSD_ON || flair_on == PSD_ON)
        {
/* MRIhc13638 - Substituting sh3t2 for shNvrg5b when 3T field is selected. */
            if (silver_hoult == PSD_ON) 
            {
				if (ir3t_flag == 0 )
				{
                	strcpy(pulse_rho,"shNvrg5b.rho");
				}
				else
				{
                	strcpy(pulse_rho,"sh3t2.rho");
				}
            }
            else
                strcpy(pulse_rho,"rfinvI0.rho");

            for (i=0; i<irslquant; i++) 
            {
                if((flair_on == PSD_ON) || ((opfast == PSD_ON) && (oppseq == PSD_SE)) ||
                   ((opfast == PSD_ON) && ( (oppseq == PSD_IR) || (opirprep == PSD_ON)) ) || (opepi == PSD_ON))       
                    pos_ref = RUP_GRD(ir_start+i*irinterval);
                else
                    pos_ref = RUP_GRD(pos_start_rf0+pw_gzrf0a);

                /* JAH/BJM/HD: Replace SLICESELZEXT_INV() with
                   SLICESELZEXT2STR() to provide automatic pulse
                   stretching for the inversion pulse. */
                   
                                       
                                       
                                      
    {
        short *orig_wave_space, *full_wave_space;

        /* Check for RF waveform generator */
        RFEnvelopeWaveformGeneratorCheck("rf0", 
                                         (WF_PROCESSOR)wg_rf0);

        /* First create the pulses */
        pulsename(&gzrf0a, "gzrf0a");
        pulsename(&gzrf0, "gzrf0");
        pulsename(&gzrf0d, "gzrf0d");
        pulsename(&rf0, "rf0");

        /*  Now create the slice select trapezoid */
	pg_beta = loggrd.zbeta;
        createramp( &gzrf0a, ZGRAD, pw_gzrf0a, (short)0,
	            MAX_PG_WAMP,
                    (short)(maxGradRes*(pw_gzrf0a/GRAD_UPDATE_TIME)),
                    pg_beta );
        createinstr( &gzrf0a,
                     (LONG)(pos_ref - pw_gzrf0a),
		     pw_gzrf0a, ia_gzrf0 );
        if( 0 == PLAY_GFILE )
        {
            /***************************************************************** 
	     Now create the waveform & perform required system safety checks
	     create a temporary buffer to modify gradient data using
             createreserve. Here the values of cyc_rf and alpha_rf are
             irrelevant. Stretch the waveform and copy stretched data into
             permanent waveform memory. It is important to to have temp buffer
             have new resolution size waveform memory.
            ******************************************************************/
	    if( PSD_ON == rfpulseInfo[RF0_SLOT].change )
	    {
	        createreserve( &gzrf0, ZGRAD,
                               rfpulseInfo[RF0_SLOT].newres/2 );
	        /************************************************************* 
	         * Change pulse type to external createreserve zero fills
                 * resolution number of points in waveform memory for use.
	         ************************************************************/
	        gzrf0.type = TYPEXTERNAL;
	        createinstr( &gzrf0, (LONG)(pos_ref),
		             pw_gzrf0, ia_gzrf0 );
	        /* Scale the pulse, and then move to the reserved memory */
	        orig_wave_space = (short *)AllocNode( res_gzrf0 * sizeof(short) );
	        uextwave( orig_wave_space, res_gzrf0, NULL );
	        full_wave_space = (short *)AllocNode( rfpulseInfo[RF0_SLOT].newres/2 * sizeof(short) );
	        stretchpulse( (int)res_gzrf0,
                              (int)rfpulseInfo[RF0_SLOT].newres/2,
                              orig_wave_space, full_wave_space );
	        res_gzrf0 = rfpulseInfo[RF0_SLOT].newres/2;
	        /* Copy over original pulse data */
	        movewaveimm( full_wave_space, &gzrf0, (int)0,
                             res_gzrf0, TOHARDWARE );
	        FreeNode( full_wave_space );
	        FreeNode( orig_wave_space );
	    }
	    else
            {
                createextwave( &gzrf0, ZGRAD, 
                               res_gzrf0, NULL );
                createinstr( &gzrf0, (LONG)(pos_ref),
                             pw_gzrf0, ia_gzrf0 );
	    }
        }
        else
        {
            createconst( &gzrf0, ZGRAD, pw_rf0,
                         MAX_PG_WAMP );
            createinstr( &gzrf0, (LONG)(pos_ref),
                         pw_gzrf0, ia_gzrf0 );
        }
        /* Decay ramp */
        createramp( &gzrf0d, ZGRAD, pw_gzrf0d, MAX_PG_WAMP,
	            (short)0,
                    (short)(maxGradRes*(pw_gzrf0d/GRAD_UPDATE_TIME)),
                    pg_beta );
        createinstr( &gzrf0d,
                     (LONG)(pos_ref+pw_gzrf0),
                     pw_gzrf0d, ia_gzrf0 );
    
        /******************************************************************* 
        ** Now create the rf pulse & perform required system safety checks
        ** create a temporary buffer to modify rfpulse data using createsinc.
        ** Here the values of cyc_rf and alpha_rf are irrelevant. Stretch the
        ** pulse and copy stretched data into permanent waveform memory.
        ** It is important to to have temp buffer have new resolution size
        ** waveform memory.
        ********************************************************************/
/* MRIhc06555 HH March 2005 - Ifdef this code to TGT */

#if defined(IPG_TGT) || defined(MGD_TGT)

        if( PSD_ON == rfpulseInfo[RF0_SLOT].change )
        {
            /* Make sure we have a value for createsinc */
            cyc_rf0 = 1.0;
	    createsinc( &rf0, (WF_PROCESSOR)wg_rf0,
                        rfpulseInfo[RF0_SLOT].newres,
                        MAX_PG_WAMP, cyc_rf0, alpha_rf0 );
            createinstr( &rf0, (LONG)(pos_ref) + psd_rf_wait,
                         pw_rf0, ia_rf0 );
            linkpulses( 4, &rf0, &gzrf0, &gzrf0a,
                        &gzrf0d );
            addrfbits( &rf0, off_rf0,
                       (LONG)(pos_ref) + psd_rf_wait,
                       pw_rf0 );

            /* Create some RHO waveform space, scale the pulse, and then move
             * the local memory to the reserved RHO memory, and set
             * pulsepointers to new stretched pulse
             */
            orig_wave_space = (short *)AllocNode( res_rf0 * sizeof(short) );
            uextwave( orig_wave_space, res_rf0, pulse_rho );
            full_wave_space = (short *)AllocNode( rfpulseInfo[RF0_SLOT].newres * sizeof(short) );
            stretchpulse( (int)res_rf0,
                          rfpulseInfo[RF0_SLOT].newres,
                          orig_wave_space, full_wave_space );

            movewaveimm( full_wave_space, &rf0, (int)0,
                        rfpulseInfo[RF0_SLOT].newres, TOHARDWARE );
            FreeNode( full_wave_space );
            FreeNode( orig_wave_space );
        }
        else
        {
            /* No rf scaling required. Use createextwave to read pulse 
             * and move to HW 
             */
            createextwave( &rf0, (WF_PROCESSOR)wg_rf0,
                           res_rf0, pulse_rho );
            createinstr( &rf0, (LONG)(pos_ref) + psd_rf_wait,
                         pw_rf0, ia_rf0 );
            linkpulses( 4, &rf0, &gzrf0, &gzrf0a,
                        &gzrf0d );
            addrfbits( &rf0, off_rf0,
                       (LONG)(pos_ref) + psd_rf_wait, pw_rf0 );
        }
#endif
    }


                if (silver_hoult == PSD_ON) 
				{
                    /* JAH/BJM/HD: Replace EXTWAVE() with EXTWAVE2() to
                       provide automatic pulse stretching for the inversion pulse. */

/* HH      02/10/06     MRIhc13638 - Substituting sh3t2 for shNvrg5b when 3T field is selected. */

        		/* Added an if loop for cffield <= 1.5T and set fileloc_omegarf0 directly*/
        		/* This makes the file_name argument in EXTWAVE2 macro irrelevant */

					if (ir3t_flag == 0 )
           				strcpy(fileloc_omegarf0, "shNvrg5b.pha");
        			else
           				strcpy(fileloc_omegarf0, "sh3t2.pha");
                        
                                
  {

    short *stretched_wave_space;  /* temporary waveform space */
    short *wave_space;            /* temporary waveform space for
                                     stretched RF pulse */
    INT old_res;                  /* temp holder for old pulse resolution */
    INT new_res;                  /* temp holder for new pulse resolution */

    if ( (wg_omegarf0 != TYPRHO1)  && (wg_omegarf0 != TYPRHO2) &&
         (wg_omegarf0 != TYPTHETA) && (wg_omegarf0 != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    old_res =  res_omegarf0;
    new_res =  rfpulseInfo[rfslot_omegarf0].newres;

    n_omegarf0 += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( omegarf0.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&omegarf0,"omegarf0");
        
        /* Scale waveform if needed */
        if( rfpulseInfo[rfslot_omegarf0].change==PSD_ON ) {

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&omegarf0, (WF_PROCESSOR)wg_omegarf0, new_res);

            /* Allocate memory for original RF pulse */
            wave_space = (short *)AllocNode(old_res*sizeof(short));
            /* Read RF pulse from file and store to wave_space */
            uextwave(wave_space, old_res, fileloc_omegarf0);

            /* Allocate memory for stretched RF pulse */
            stretched_wave_space = (short *)AllocNode(new_res*sizeof(short));
            
            stretchpulse(old_res, new_res, wave_space, stretched_wave_space);
            
            /* Move stretched pulse immediately into reserved memory */
            movewaveimm(stretched_wave_space, &omegarf0,
                        (int)0, new_res, TOHARDWARE);
            
             /* Free memory allocated for original RF pulse */
            FreeNode(wave_space);
            /* Free memory allocated for stretched RF pulse */
            FreeNode(stretched_wave_space);
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_omegarf0 = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&omegarf0,(WF_PROCESSOR)wg_omegarf0,
                          old_res,fileloc_omegarf0);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &omegarf0,(LONG)(pos_ref) + psd_rf_wait, 
                 pw_omegarf0,ia_omegarf0);
    

    /*** Add RF Bits ***/
    addrfbits(&omegarf0,off_omegarf0,(LONG)(pos_ref) + psd_rf_wait,
              pw_omegarf0);
    

    /*** Reset Resolution ***/
    res_omegarf0 = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */

  }

                }

                j = i + irslquant*ir_index; 

 /* HH      01/13/06     MRIhc13008 Fix - Use pend(gzrf0)+psd_rf_wait instead of pend(rf0) */
 /* Remove psd_rf_wait here - since it is only needed for RF axis */

                  
                          
                           

  trapezoid((WF_PROCESSOR)wg_gyk0, "gyk0", &gyk0, &gyk0a,
                        &gyk0d, pw_gyk0, pw_gyk0a, pw_gyk0d,
                        ia_gyk0, 0, 0, 0, 0, RUP_GRD(pend(&gzrf0,"gzrf0",j)+pw_gyk0a+((rfupd>>2)<<2))-pw_gyk0a, TRAP_ALL,
                        &loggrd);

            }
        }

        if (flair_on == PSD_ON) 
        {
              
  {
    pulsename(&seqinv,"seqinv");
    createseq(&seqinv,invseqlen, off_seqinv);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqinv );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqinv = %d\n", idx_seqinv );
#endif
  }

            getperiod(&ir_deadtime,&seqinv,0);

            /* Assert the ESSP flag on the sync packet byte seq length */
            attenflagon(&seqinv, 0);
        }
    } /* End of code inlined from Inversion.e InversionPG */


    /* Spatial Sat *******************************************************/
    sp_satindex = 0;
    SpSatPG(vrgsat,sp_satstart, &sp_satindex, sp_satcard_loc);
    
    /* Chem Sat **********************************************************/
    cs_satindex = 0;
    if (cs_sat) ChemSatPG(cs_satstart, &cs_satindex);
  
    /* spsp 90 RF slice select pulse *******************************************/
    
    /*jwg bb for debugging*/
    fprintf(stderr,"rf pulse is %s \n", ssrffile);
    fprintf(stderr,"gradient file is %s \n", ssgzfile);
    if (thetaflag == 1) fprintf(stderr,"theta file is %s \n", ssthetafile);
    temp_res = res_rf1;
    if (rfpulseInfo[RF1_SLOT].change == PSD_ON)  /* set to new resolution */
	res_rf1 = rfpulseInfo[RF1_SLOT].newres;
    
    /* set rfunblank_bits[2] so that addrfbits in sliceselz does not
       unblank the receiver - see EpicConf.c for defaults. Will unblank
       the receiver later - MRIge28778 */
    
    rfunblank_bits[0][2] = SSPD;
    rfunblank_bits[1][2] = SSPD;
    
          
                          
                          
                            
  {
      /* Check for RF waveform generator */
      RFEnvelopeWaveformGeneratorCheck("rf1", 
                                       (WF_PROCESSOR)wg_rf1);

      /* Select proper filename */
      grad_zrf1=  ssgzfile;
      rf_rf1 =  ssrffile;
      theta_rf1 = ssgzfile;

      /* Now create the pulses */
      pulsename(&gzrf1a,"gzrf1a");
      pulsename(&gzrf1,"gzrf1");
      pulsename(&gzrf1d,"gzrf1d");
      pulsename(&rf1,"rf1");
      pulsename(&thetarf1, "thetarf1");

      /*  Now create the slice select trapezoid */
      pg_beta = loggrd.zbeta;

      if ( gztype == PLAY_GFILE) {

#if defined(IPG_TGT) || defined(MGD_TGT)
          /* Use external gradient file for now */
          createextwave( &gzrf1, ZGRAD, res_gzrf1,
                         grad_zrf1 );

          createinstr( &gzrf1, (long)pos_start+pw_gzrf1a,
                       pw_gzrf1, ia_gzrf1 );

#elif defined(HOST_TGT)
          /* Create train of trapezoids on the Host side */
          int i;
          int polarity = 1;
       
          pulsepos = pos_start+pw_gzrf1a; 
       
          for(i = 1; i <= num_rf1lobe; i++) {
              polarity *= -1;

              trapezoid( ZGRAD,"gzrf1", &gzrf1, 
                         &gzrf1a, &gzrf1d,
                         pw_constant, pw_ss_rampz, pw_ss_rampz, 
                         (polarity*(ia_gzrf1)),
                         (polarity*(ia_gzrf1)),
                         (polarity*(ia_gzrf1)), 0, 0, 
                         pulsepos, TRAP_ALL, &loggrd );

              pulsepos += pw_constant + 2 * pw_ss_rampz;
          }
#endif

      } else {

          /* Create simple trapezoid for chem sat + rf */
          createramp( &gzrf1a,ZGRAD,pw_gzrf1a,
                      (short)0, max_pg_wamp,
                      (short)(maxGradRes *
                              (pw_gzrf1a/ GRAD_UPDATE_TIME)),
                      pg_beta );

          createinstr( &gzrf1a,
                       (long)(pos_start+pw_gzrf1a - pw_gzrf1a),
                       pw_gzrf1a, ia_gzrf1 );

          createconst( &gzrf1, ZGRAD, pw_rf1, max_pg_wamp );
          createinstr( &gzrf1, (long)pos_start+pw_gzrf1a,
                       pw_gzrf1, ia_gzrf1 );

          createramp( &gzrf1d, ZGRAD, pw_gzrf1d,
                      max_pg_wamp, (short)0,
                      (short)(maxGradRes *
                              (pw_gzrf1d/ GRAD_UPDATE_TIME)),
                      pg_beta );
          createinstr( &gzrf1d,
                       (long)(pos_start+pw_gzrf1a + pw_gzrf1),
                       pw_gzrf1d, ia_gzrf1 );

      }

      /* Now create the rf pulse */
      if ( rftype == PLAY_RFFILE) {
          createextwave( &rf1, (WF_PROCESSOR)wg_rf1, res_rf1,
                         rf_rf1);
      } else {
          createsinc( &rf1, (WF_PROCESSOR)wg_rf1, res_rf1,
                      max_pg_wamp,cyc_rf1, alpha_rf1 );
      }

      createinstr( &rf1,(long)pos_start+pw_gzrf1a + psd_rf_wait +
                   ss_rf_wait,  pw_rf1,ia_rf1);

      addrfbits( &rf1, off_rf1, (long)pos_start+pw_gzrf1a +
                 psd_rf_wait + ss_rf_wait, pw_rf1 );

      /* Now create the theta pulse */
      if ( thetatype == PLAY_THETA) {
          /*jwg force theta pulse on OMEGA*/
          /*createextwave( &theta$[slsel_name], (wg_$[slsel_name]==TYPRHO1)?TYPOMEGA:TYPTHETA,
                         res_theta$[slsel_name], theta_$[slsel_name] );	  */
          createextwave( &thetarf1, wg_omegarf1,
                         res_thetarf1, theta_rf1 );

          createinstr( &thetarf1, (long)pos_start+pw_gzrf1a + psd_rf_wait +
                       ss_rf_wait, pw_thetarf1,
                       ia_thetarf1 );

          addrfbits( &thetarf1, off_thetarf1,
                     (long)pos_start+pw_gzrf1a + psd_rf_wait + ss_rf_wait,
                     pw_thetarf1 );
      }
      if ( gztype == PLAY_GFILE) {
          #if defined(IPG_TGT) || defined(MGD_TGT)
          linkpulses( 3,
                      &rf1, &gzrf1, &thetarf1);
          #endif
      } else {
          linkpulses( 4,
                      &rf1, &gzrf1,
                      &gzrf1a, &gzrf1d);
      }
  }
 
		       
    if(thetaflag == 1) 
        {
		strcpy(fileloc_phaserf1,ssthetafile);
		/*jwg bb replace first argument THETA with wg_phaserf1*/
       		       
			   
  {
    pulsename(&phaserf1,"phaserf1");
    createextwave(&phaserf1,(WF_PROCESSOR)wg_phaserf1,
                  res_phaserf1,fileloc_phaserf1);
    if ((wg_phaserf1==TYPRHO1)||(wg_phaserf1==TYPRHO2) ||
	(wg_phaserf1==TYPTHETA)||(wg_phaserf1==TYPOMEGA))
      {
	createinstr( &phaserf1,(long)(pos_start+pw_gzrf1a) + psd_rf_wait, 
		    pw_phaserf1,ia_phaserf1);
	addrfbits(&phaserf1,off_phaserf1,(long)(pos_start+pw_gzrf1a) + psd_rf_wait,
		  pw_phaserf1);
      }
    else
      {
	createinstr( &phaserf1,(long)(pos_start+pw_gzrf1a), 
		    pw_phaserf1,ia_phaserf1);
      }
  }
		       
	}
    
    /* reset the bit */
    rfunblank_bits[0][2] = SSPD + RUBL;
    rfunblank_bits[1][2] = SSPD + RUBL;
    
    if (rfpulseInfo[RF1_SLOT].change == PSD_ON)  /* change back for ext. file */
	res_rf1 = temp_res;
   
    /* 180 RF refocusing pulse ********************************************/
    if (oppseq == PSD_SE) {
#ifndef RT
	Rf2Location[0] = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso  + opte/2
                                       - pw_rf2/2) - psd_rf_wait);  /* Find start loc of 180s */
#else
        Rf2Location[0] = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso  + opte/2
                                       - pw_rf2/2) + 1000*ase_offset - psd_rf_wait);  /* Find start loc of 180s */
#endif
        
        /* MRIge58235: moved uextwave to here so the file read from disk is always read with orig. res_rf2 */
	strcpy(ext_filename, "rfse1b4.rho");
        
	/* Create some RHO waveform space, read in the 
	   se1b4 spin echo 180 to local memory, and then move
	   the local memory to the reserved RHO memory.
        */
	temp_wave_space = (short *)AllocNode(res_rf2*sizeof(short));
	uextwave(temp_wave_space, res_rf2, ext_filename);
        
        {
            /* MRIge58235: save orig. res_rf2 for scaling */
            short orig_res;
            
            orig_res = res_rf2;
            if (rfpulseInfo[RF2_SLOT].change==PSD_ON)
                res_rf2 = rfpulseInfo[RF2_SLOT].newres;     /* Set to new resolution */
            
            /* set rfunblank_bits[2] so that addrfbits in sliceselz does not
               unblank the receiver - see EpicConf.c for defaults. Will unblank
               the receiver later - MRIge28778 */
            rfunblank_bits[0][2] = SSPD;
            rfunblank_bits[1][2] = SSPD;
            
            /*  180 slice sel pulse  */
              
                          
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2", 
                                     (WF_PROCESSOR)wg_rf2);

    /* First create the pulses */
    pulsename(&gzrf2a,"gzrf2a");
    pulsename(&gzrf2,"gzrf2");
    pulsename(&gzrf2d,"gzrf2d");
    pulsename(&rf2,"rf2");
    
    /*  Now create the slice select trapezoid */
    pg_beta = loggrd.zbeta;
    createramp(&gzrf2a,ZGRAD,pw_gzrf2a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2a,(long)(Rf2Location[0]-pw_gzrf2a),
                pw_gzrf2a,ia_gzrf2);
    createconst(&gzrf2,ZGRAD,pw_gzrf2,MAX_PG_WAMP);
    createinstr( &gzrf2,(long)(Rf2Location[0]),
                pw_gzrf2,ia_gzrf2);
    createramp(&gzrf2d,ZGRAD,pw_gzrf2d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrf2d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrf2d,(long)(Rf2Location[0]+pw_gzrf2),
                pw_gzrf2d,ia_gzrf2);
    
    /* Now create the rf pulse */
    createsinc(&rf2,(WF_PROCESSOR)wg_rf2,res_rf2,
	       MAX_PG_WAMP,cyc_rf2, alpha_rf2);
    createinstr( &rf2,(long)(Rf2Location[0]) + psd_rf_wait,
		pw_rf2,ia_rf2);
    linkpulses(4,&rf2,&gzrf2,&gzrf2a,
	       &gzrf2d);
    addrfbits(&rf2,off_rf2,(long)(Rf2Location[0]) + psd_rf_wait, 
	      pw_rf2);
  }

            
            /* reset the bit */
            rfunblank_bits[0][2] = SSPD + RUBL;
            rfunblank_bits[1][2] = SSPD + RUBL;
            
            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF2_SLOT].change==PSD_ON) {
                wave_space = (short *)AllocNode(rfpulseInfo[RF2_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)orig_res, (int)rfpulseInfo[RF2_SLOT].newres,
                             temp_wave_space,wave_space);
                FreeNode(temp_wave_space);
            } else {
                wave_space = temp_wave_space;
            }

            /* Assign temporary board memory and move immediately into permanent
               memory */
            res_rf2se1b4 = res_rf2;
              
  {
    pulsename(&rf2se1b4,"rf2se1b4");
    createreserve(&rf2se1b4,(WF_PROCESSOR)wg_rf2se1b4,
		  res_rf2se1b4);
  }

            movewaveimm(wave_space, &rf2se1b4, (int)0, res_rf2, TOHARDWARE);
            FreeNode(wave_space);
            
            /* MRIge58235: reset res_rf2 after scaling */
            res_rf2 = orig_res;
        }
        
	if (innerVol == PSD_ON) {
                 

  trapezoid((WF_PROCESSOR)wg_gyrf2iv, "gyrf2iv", &gyrf2iv, &gyrf2iva,
                        &gyrf2ivd, pw_gyrf2iv, pw_gyrf2iva, pw_gyrf2ivd,
                        ia_gyrf2iv, 0, 0, 0, 0, Rf2Location[0]-pw_gyrf2iva, TRAP_ALL,
                        &loggrd);

            ia_gzrf2 = 0;
	}
	
	setphase((float)(PI/-2.0), &rf2, 0);  /* Apply 90 phase shift to  180 */
        
	attenflagon(&rf1, 0);                 /* Assert ESSP flag on rf1 pulse */
	
	attenflagon(&rf2, 0);                 /* Assert ESSP flag on 1st rf2 */
        
        
	/* Z crushers (echo 1) ***********************************************/
	 
                     
                  

  trapezoid((WF_PROCESSOR)wg_gzrf2l1, "gzrf2l1", &gzrf2l1, &gzrf2l1a,
                        &gzrf2l1d, pw_gzrf2l1, pw_gzrf2l1a, pw_gzrf2l1d,
                        ia_gzrf2l1, 0, 0, 0, 0, pbeg(&gzrf2,"gzrf2",0)-(pw_gzrf2l1+pw_gzrf2l1d)-pw_gzrf2l1a, TRAP_ALL,
                        &loggrd);

	
	     

  trapezoid((WF_PROCESSOR)wg_gzrf2r1, "gzrf2r1", &gzrf2r1, &gzrf2r1a,
                        &gzrf2r1d, pw_gzrf2r1, pw_gzrf2r1a, pw_gzrf2r1d,
                        ia_gzrf2r1, 0, 0, 0, 0, pend(&gzrf2,"gzrf2d",0)-pw_gzrf2r1a, TRAP_ALL,
                        &loggrd);

        
    } 
    
    /***********************************************************************/
    /* X EPI readout train                                                 */
    /***********************************************************************/
    
    /* For now assume a simple retiling. */
    if (fract_ky == PSD_FRACT_KY) {

        if ( ky_dir == PSD_BOTTOM_UP ) {
            echoOffset  = num_overscan/intleaves + iref_etl;
        } else {
            /* with fract_ky = ON and TOP down, echoffset is yes/2 */       
	    /* MRIge92386 */
            echoOffset  = fullk_nframes/intleaves/2 + iref_etl;
        }       

    } else {
	if (ky_dir == PSD_TOP_DOWN || ky_dir == PSD_BOTTOM_UP)
	    /* MRIge92386 */
            echoOffset  = fullk_nframes/intleaves/2 + iref_etl;
	else
            echoOffset  = 0;
    }
    
    /* BJM: pkt_delay is included to account for any delay between */
    /* sending the RBA and the first sample acquired (hardware delay) */
    if (vrgfsamp == PSD_ON) {
        dacq_offset = pkt_delay + pw_gxwad - 
            (int)(fbhw*((float)pw_gyb/2.0 + 
                        (float)pw_gybd) + 0.5);

        if(dacq_offset < 0) dacq_offset = 0;

    } else {
        dacq_offset = pkt_delay;
    }
    
    /* MRIge58023 & 58033 need to RUP_GRD entire expression */
    if (intleaves == fullk_nframes) {
	tempx = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso + opte - pw_gxw/2 - pw_gxwl - ky_offset*esp/intleaves));
    } else {
	tempx = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso + opte - echoOffset * esp - ky_offset*esp/intleaves - pw_iref_gxwait));
    }
    
    tempy = tempx + gydelay;
    tempz = tempx;
    tempx += gxdelay;
    
    /* Set up for EP_TRAIN */
    stddab = (hsdab==PSD_ON ? 0:1);
    pg_tsp =0;
    /* internref: use tot_etl instead of etl; added iref_etl */
    /*jwg bb this is where EPI readout starts!*/
    if(sake_flag == 0) sake_max_blip = 1;
    fprintf(stderr,"Before EP_TRAIN, pw_gyb and a_gyb are %d and %f \n",pw_gyb,a_gyb);
      
              
             
             
             
             
             
               
             
             
             
             
             
    {
        int psd_gxwcnt;
        int psd_pulsepos;
        int psd_eparity;
        long psd_epxtroff;
        long psd_epdaboff;
        float psd_etbetax;
        float psd_etbetay;
        char psd_epstring[EPSTRING_LENGTH];

        psd_pulsepos = RUP_GRD((LONG)tempx+pw_gxwad);           
	if( iref_etl == 0 ){
           pw_iref_gxwait = 0;
        } 
        /* allocate on 1st pass only  */
        if ( 0 == 0 ) {
            echotrain = (WF_PULSE *)AllocNode((tot_etl + 3) * sizeof(WF_PULSE));
        }
 
        pulsename(&gxcla, "gxcla");
        pulsename(&gxcl, "gxcl");
        pulsename(&gxcld, "gxcld");
 
        pulsename(&gxwa, "gxwa");
        pulsename(&gxw, "gxw");
        pulsename(&gxwd, "gxwd");
        pulsename(&gxwde, "gxwde");
 
        pulsename(&gxgap, "gxgap");
 
        pulsename(&gyba, "gyba");
        pulsename(&gyb, "gyb");
        pulsename(&gybd, "gybd");
 
        pulsename(&gxcra, "gxcra");
        pulsename(&gxcr, "gxcr");
        pulsename(&gxcrd, "gxcrd");
 
        getbeta(&psd_etbetax, XGRAD, &epiloggrd);
        getbeta(&psd_etbetay, YGRAD, &epiloggrd);
 
        if (pw_gxcla >= GRAD_UPDATE_TIME) {
            createramp(&gxcla, XGRAD, pw_gxcla, (short)0,
                       (short)ia_gxcl, (short)(maxGradRes*(pw_gxcla/
                                                           GRAD_UPDATE_TIME)), psd_etbetax);
            createinstr(&gxcla, (long)psd_pulsepos,
                        pw_gxcla, max_pg_iamp);
            psd_pulsepos += pw_gxcla;
        }
    
        if (pw_gxcl >= GRAD_UPDATE_TIME) {
            createconst(&gxcl, XGRAD, pw_gxcl, max_pg_wamp);
            createinstr(&gxcl, (long)psd_pulsepos,
                        pw_gxcl, ia_gxcl);
            psd_pulsepos += pw_gxcl;
        }
    
        if (pw_gxcld >= GRAD_UPDATE_TIME) {
            createramp(&gxcld, XGRAD, pw_gxcld, (short)ia_gxcl,
                       (short)ia_gxw, (short)(maxGradRes*(pw_gxcld/
                                                          GRAD_UPDATE_TIME)), psd_etbetax);
            createinstr(&gxcld, (long)psd_pulsepos,
                        pw_gxcld, max_pg_iamp);
            psd_pulsepos += pw_gxcld;
        }
    
        createconst(&gxw, XGRAD, pw_gxwl+pw_gxw+pw_gxwr, max_pg_wamp);
        createinstr(&gxw, (long)psd_pulsepos,
                    pw_gxwl+pw_gxw+pw_gxwr, ia_gxw);
        psd_pulsepos += pw_gxwl;
    
        sprintf(psd_epstring, "echo%04d", 0);
        pulsename(&(echotrain[0]), psd_epstring);
    
        if (dab_offset == 0)
            psd_epdaboff = 0;
        else
            psd_epdaboff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + dab_offset);            
        if (xtr_offset == 0)
            psd_epxtroff = 0;
        else
            psd_epxtroff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + xtr_offset);            
    
        epiacqq(&(echotrain[0]),                
                (long)(psd_pulsepos + psd_grd_wait-dacq_offset),
                psd_epdaboff, psd_epxtroff,
                (long)scanslot, 
                (TYPDAB_PACKETS)DABNORM,
                (long)fast_rec,
                (long)stddab);
    
        psd_pulsepos += pw_gxw + pw_gxwr;      
    
        psd_eparity = 1;
        for (psd_gxwcnt = 2; psd_gxwcnt <= tot_etl; psd_gxwcnt++) {
            psd_eparity *= -1;
	 if( psd_gxwcnt - 1 > iref_etl ){  
	    createramp(&gyba, YGRAD, pw_gyba, 0, max_pg_wamp,
                       (short)((maxGradRes*pw_gyba)/GRAD_UPDATE_TIME), psd_etbetay);
            createinstr(&gyba, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 -
                                      (pw_gyba + pw_gyb/2)), pw_gyba, ia_gyb);
        
            if (pw_gyb >= GRAD_UPDATE_TIME) {
                createconst(&gyb, YGRAD, pw_gyb, max_pg_wamp);
                createinstr(&gyb, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 -
                                         pw_gyb/2), pw_gyb, ia_gyb);
            }
        
            createramp(&gybd, YGRAD, pw_gybd, max_pg_wamp, 0,
                       (short)((maxGradRes*pw_gybd)/GRAD_UPDATE_TIME), psd_etbetay);
            createinstr(&gybd, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 +
                                      pw_gyb/2), pw_gybd, ia_gyb);
        
            linkpulses(3,&gyb,&gyba,&gybd);
           }
	   createramp(&gxwd, XGRAD, pw_gxwad, -max_pg_wamp, 0,
                      (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME),
                      psd_etbetax);
           createinstr(&gxwd, (long)psd_pulsepos, pw_gxwad, psd_eparity* ia_gxw);
           psd_pulsepos += pw_gxwad;

           if( pw_gxgap == 0 ){
               if( (pw_iref_gxwait != 0) && (psd_gxwcnt == iref_etl) ){ 
                   createconst(&gxgap, XGRAD, pw_iref_gxwait, 0);
                   createinstr(&gxgap, (long)psd_pulsepos, pw_iref_gxwait, 0);
                   psd_pulsepos += pw_iref_gxwait;
               }
           }else{ 
               int gapgap;
               if( (pw_iref_gxwait == 0) || (psd_gxwcnt != iref_etl) ){
                      gapgap = pw_gxgap;
               }else{
                      gapgap = pw_gxgap+pw_iref_gxwait;
               }
               createconst(&gxgap, XGRAD, gapgap, 0);
               createinstr(&gxgap, (long)psd_pulsepos, gapgap, 0);
               psd_pulsepos += gapgap;
           }

           createramp(&gxwa, XGRAD, pw_gxwad, 0, max_pg_wamp,
                      (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), psd_etbetax);
           createinstr(&gxwa, (long)psd_pulsepos, pw_gxwad, psd_eparity* ia_gxw);
           psd_pulsepos += pw_gxwad;
	                     
            createconst(&gxw, XGRAD, pw_gxwl+pw_gxw+pw_gxwr, max_pg_wamp);
            createinstr(&gxw, (long)psd_pulsepos,
                        pw_gxwl+pw_gxw+pw_gxwr, psd_eparity*ia_gxw);
            psd_pulsepos += pw_gxwl;
        
            sprintf(psd_epstring, "echo%04d", psd_gxwcnt-1 + 0);
            pulsename(&(echotrain[psd_gxwcnt-1+0]), psd_epstring);
        
            if (dab_offset == 0)                                           
                psd_epdaboff = 0;
            else
                psd_epdaboff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + dab_offset);
        
            if (xtr_offset == 0)
                psd_epxtroff = 0;
            else
                psd_epxtroff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + xtr_offset);
            
	    epiacqq(&(echotrain[psd_gxwcnt-1+0]),                
                    (long)(psd_pulsepos + psd_grd_wait-dacq_offset),
                    psd_epdaboff, psd_epxtroff,
                    (long)scanslot, 
                    (TYPDAB_PACKETS)DABNORM,
                    (long)fast_rec,
                    (long)stddab);
        
            psd_pulsepos += pw_gxw + pw_gxwr;      
        }     
        if ((tot_etl % 2) == 1) {    /* views per shot is odd */          
            if (pw_gxcra >= GRAD_UPDATE_TIME) {
                createramp(&gxcra, XGRAD, pw_gxcra, (short)ia_gxw,
                           (short)ia_gxcr, (short)(maxGradRes*(pw_gxcra/
                           GRAD_UPDATE_TIME)), psd_etbetax);
                createinstr(&gxcra, (long)(psd_pulsepos), pw_gxcra, max_pg_iamp);
                psd_pulsepos += pw_gxcra;
            }
        } else { /* views per shot is even */
            /* single transition ramp into crusher */                  
            if ((ia_gxw == ia_gxcr) && (pw_gxwad == pw_gxcra)) {
                createramp(&gxwd, XGRAD, 2*pw_gxwad, -max_pg_wamp, max_pg_wamp,
                           (short)(maxGradRes*(2*pw_gxwad)/GRAD_UPDATE_TIME),
                           psd_etbetax);
                createinstr(&gxwd, (long)psd_pulsepos, 2*pw_gxwad, ia_gxw);
                psd_pulsepos += 2*pw_gxwad;
            } else {    /* two separate ramps, decay ramp needs new waveform */
                createramp(&gxwde, XGRAD, pw_gxwad, -max_pg_wamp, 0,              
                           (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), psd_etbetax);
                createinstr(&gxwde, (long)psd_pulsepos, pw_gxwad, ia_gxw);
                psd_pulsepos += pw_gxwad;

                if (pw_gxcra >= GRAD_UPDATE_TIME) {
                    createramp(&gxcra, XGRAD, pw_gxcra, (short)0,
                               (short)ia_gxcr, (short)(maxGradRes*(pw_gxcra/
                                GRAD_UPDATE_TIME)),psd_etbetax);
                    createinstr(&gxcra, (long)(psd_pulsepos),pw_gxcra, max_pg_iamp);
                    psd_pulsepos += pw_gxcra;
                }
            }   
        }        
        if (pw_gxcr >= GRAD_UPDATE_TIME) {
            createconst(&gxcr, XGRAD, pw_gxcr, max_pg_wamp);
            createinstr(&gxcr, (long)psd_pulsepos,pw_gxcr, ia_gxcr);
            psd_pulsepos += pw_gxcr;
        }

        if (pw_gxcrd >= GRAD_UPDATE_TIME) {
            createramp(&gxcrd, XGRAD, pw_gxcrd, (short)ia_gxcr,
                       (short)0, (short)(maxGradRes*(pw_gxcrd/
                        GRAD_UPDATE_TIME)), psd_etbetax);                             
            createinstr(&gxcrd, (long)psd_pulsepos,pw_gxcrd, max_pg_iamp);
            psd_pulsepos += pw_gxcrd;
        }
    }

    fprintf(stderr,"After EP_TRAIN, pw_gyb and a_gyb are %d and %f \n",pw_gyb,a_gyb);	     

    /*jwg bb run amppwgrad so that we can generate 'worst-case scenario' blip scheme*/
    /*if(sake_flag > 0)
    {
    	amppwgrad(area_gyb * (int)sake_max_blip, 5.0, 0.0, 0.0, loggrd.yrt, MIN_PLATEAU_TIME, &a_gyb, &pw_gyba, &pw_gyb, &pw_gybd);
    }
    */

    /* unblank receiver rcvr_ub_off us prior to first xtr/dab/rba packet */
    getssppulse(&(echotrainxtr[0]), &(echotrain[0]), "xtr", 0);
    rcvrunblankpos = echotrainxtr[0]->inst_hdr_tail->start;
    rcvrunblankpos += rcvr_ub_off;
     
  {
    rec_unblank_pack[0] = SSPDS+RDC;
    rec_unblank_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rec_unblank_pack[2] = SSPD+RUBL;
    rec_unblank_pack[3] = SSPDS;

    pulsename(&rec_unblank,"rec_unblank");
    createbits(&rec_unblank,TYPSSP,4,rec_unblank_pack);
    createinstr( &rec_unblank,(long)(rcvrunblankpos),4,ia_rec_unblank);
  }


    if (tot_etl % 2 == 1) {
	getbeta(&betax, XGRAD, &epiloggrd);
	pulsePos = pend(&gxw, "gxw", tot_etl-1);
	createramp(&gxwde, XGRAD, pw_gxwad, -max_pg_wamp, 0,
                   (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), betax);
	createinstr(&gxwde, pulsePos, pw_gxwad, -ia_gxw);
	pulsePos += pw_gxwad;
    }
    
    /***********************************************************************/
    /* X dephaser                                                          */
    /***********************************************************************/
    
    if (gx1pos == PSD_POST_180)
	temp1 = RUP_GRD((int)(pbeg(&gxw,"gxw",0) - (pw_gxwad + pw_gx1a +
						    pw_gx1 + pw_gx1d)));
    else
	temp1 = RUP_GRD((int)(pendall(&gzrf1, gzrf1.ninsts-1) + pw_gx1a +
                              pw_wgx + rfupd));
    
    pg_beta = loggrd.xbeta;
    
    pulsename(&gx1a,"gx1a");
    createramp(&gx1a,XGRAD,pw_gx1a,(short)0,
               max_pg_wamp,(short)(maxGradRes*(pw_gx1a/
                                               GRAD_UPDATE_TIME)),
               pg_beta);
    createinstr(&gx1a, (LONG)temp1, pw_gx1a, ia_gx1);
    
    if (pw_gx1 >= GRAD_UPDATE_TIME) {
	pulsename(&gx1,"gx1");
	createconst(&gx1,XGRAD,pw_gx1,max_pg_wamp);
	createinstr( &gx1,(LONG)(LONG)temp1+pw_gx1a,
                     pw_gx1,ia_gx1);
    }
    
    pulsename(&gx1d, "gx1d");
    if (single_ramp_gx1d == PSD_ON) {   /* Single ramp for gx1 decay into gxw
                                           attack */
        createramp(&gx1d, XGRAD, pw_gxwad, max_pg_wamp, -max_pg_wamp,
                   (short)(maxGradRes*(2*pw_gxwad/GRAD_UPDATE_TIME)), pg_beta);
        createinstr(&gx1d, (LONG)(temp1+pw_gx1a+pw_gx1), 2*pw_gxwad, ia_gx1);
    } else {                     /* decay ramp for gx1 */
        createramp(&gx1d,XGRAD,pw_gx1d,max_pg_wamp,
                   (short)0,(short)(maxGradRes*(pw_gx1d/GRAD_UPDATE_TIME)),
                   pg_beta);
	createinstr( &gx1d,(LONG)((LONG)temp1+pw_gx1a+pw_gx1),
                     pw_gx1d,ia_gx1);
        
	pulsename(&gxwa, "gxwa");  /* attack ramp for epi train */
	createramp(&gxwa, XGRAD, pw_gxwad, (short)0, max_pg_wamp,
                   (short)(maxGradRes*(pw_gxwad/GRAD_UPDATE_TIME)), pg_beta);
        if ( tot_etl%2 == 0 && ky_dir != PSD_TOP_DOWN )
            createinstr(&gxwa, (LONG)tempx, pw_gxwad, -ia_gxw);
        else
            createinstr(&gxwa, (LONG)tempx, pw_gxwad, ia_gxw);
    }
    
    /* Set readout polarity to gradpol[ileave] value */
    ileave = 0;
    setreadpolarity();
    
    if(rtb0_flag)
    {
        temp2 = pendall(&rf1, 0) + IMax(2, pw_gz1_tot, rfupd + 4   + rtb0_minintervalb4acq)+rtb0_acq_delay;
            
  {
    pulsename(&rtb0echo,"rtb0echo");
    acqq(&rtb0echo, (long)(temp2),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_rtb0echo,
        (TYPDAB_PACKETS)DABNORM);
  }

        attenflagon( &(rtb0echo), 0 );

        getssppulse(&(rtb0echoxtr), &(rtb0echo), "xtr", 0);
        rcvrunblankpos = rtb0echoxtr->inst_hdr_tail->start;
        rcvrunblankpos += rcvr_ub_off;
         
  {
    rec_unblank2_pack[0] = SSPDS+RDC;
    rec_unblank2_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rec_unblank2_pack[2] = SSPD+RUBL;
    rec_unblank2_pack[3] = SSPDS;

    pulsename(&rec_unblank2,"rec_unblank2");
    createbits(&rec_unblank2,TYPSSP,4,rec_unblank2_pack);
    createinstr( &rec_unblank2,(long)(rcvrunblankpos),4,ia_rec_unblank2);
  }


        temp2 += esp;
    }
    else
    {
        /* Hyperscan DAB packet */
        temp2 = pendall(&rf1, 0) + rfupd + 4  ;  /* 4us for unblank receiver */
    }

     
{
    pulsename(&hyperdab,"hyperdab");

        createhsdab(&hyperdab, (long)(temp2));
  }

    
    /* If we don't reset frequency and phase on each view, then it is best
       to use a single packet at the beginning of the frame - one that doesn't
       shift with interleave.  This is because we want the constant part of Ahn
       correction to see continuous phase evolution across the views. */
    
    if (oppseq == PSD_SE) {
	temp2 = pendall(&rf2, 0) + rfupd + 4  ;  /* 4us for unblank receiver */
    } else {
	temp2 = pendall(&rf1, 0) + rfupd + 4  ;  /* 4us for unblank receiver */
    }
   
    /* Y prephaser ************************************************************/
    if (gy1pos == PSD_POST_180) {
	temp1 = pbeg(&gxw, "gxw", iref_etl) - pw_gxwad - pw_gy1_tot; /* internref */
        if(no_gy1_ol_gxw && iref_etl > 0) {
            temp1 -= esp;
        }
	temp1 = RDN_GRD(temp1);
    } else {
	temp1 = RDN_GRD(pend(&rf1,"rf1",0) + rfupd);
    }
    
        
    trapezoid((WF_PROCESSOR)wg_gy1,"gy1",
              &gy1,&gy1a,&gy1d,
              pw_gy1,pw_gy1a,pw_gy1d,
              ia_gy1,ia_gy1wa,ia_gy1wb,
              0,0,temp1,TRAP_ALL_SLOPED,
                          &loggrd);

    
    if (ygmn_type == CALC_GMN1) {
	temp1 = pbeg(&gy1a, "gy1a", 0) - pw_gymn2 - pw_gymn2d;
	     

  trapezoid((WF_PROCESSOR)wg_gymn2, "gymn2", &gymn2, &gymn2a,
                        &gymn2d, pw_gymn2, pw_gymn2a, pw_gymn2d,
                        ia_gymn2, 0, 0, 0, 0, temp1-pw_gymn2a, TRAP_ALL,
                        &loggrd);
 
	temp1 = pbeg(&gy1a, "gy1a", 0) - pw_gymn2_tot - pw_gymn1 - pw_gymn1d;
	     

  trapezoid((WF_PROCESSOR)wg_gymn1, "gymn1", &gymn1, &gymn1a,
                        &gymn1d, pw_gymn1, pw_gymn1a, pw_gymn1d,
                        ia_gymn1, 0, 0, 0, 0, temp1-pw_gymn1a, TRAP_ALL,
                        &loggrd);
 
    }
    
    /* Z prephaser ************************************************************/
    if (oppseq != PSD_SE || zgmn_type == CALC_GMN1) {
        if(ss_rf1 == PSD_ON)
        {
#if defined(IPG_TGT) || defined(MGD_TGT)
	   temp1 = RDN_GRD(pend(&gzrf1, "gzrf1", gzrf1.ninsts-1) + pw_gz1a);
#elif defined(HOST_TGT)
           temp1 = RDN_GRD(pend(&gzrf1d, "gzrf1d", gzrf1.ninsts-1) + pw_gz1a);
#endif
        }
        else
        {
	    temp1 = RDN_GRD(pendall(&gzrf1d, gzrf1.ninsts-1) + pw_gz1a);	
        }       

	/*jwg bb change start time of rephaser to decay ramp if needed*/
	if( opuser20 == 0) /*using default fat/water spsp rf*/
	{ 
	temp1 = RDN_GRD(pendall(&gzrf1, gzrf1.ninsts-1) + pw_gz1a); 
	} 
	else 
	{
	if ((int)opuser20 == 1)  /*only move to end of decay ramp if using a sinc, which is case 1*/
	{
	temp1 = RDN_GRD(pendall(&gzrf1d, gzrf1.ninsts-1) + pw_gz1a);			
	} 
	else /*using c13 spsp rf, no decay ramp */
	{ 
	temp1 = RDN_GRD(pendall(&gzrf1, gzrf1.ninsts-1) + pw_gz1a); 
	}
	}	
	
	/*fprintf(stderr,"rephaser starts at %d",temp1);*/
	      

  trapezoid((WF_PROCESSOR)wg_gz1, "gz1", &gz1, &gz1a,
                        &gz1d, pw_gz1, pw_gz1a, pw_gz1d,
                        ia_gz1, 0, 0, 0, 0, temp1-pw_gz1a, TRAP_ALL,
                        &loggrd);

	
	if (zgmn_type == CALC_GMN1) {
            temp1 += (pw_gz1 + pw_gz1d + pw_gzmna);
                  

  trapezoid((WF_PROCESSOR)wg_gzmn, "gzmn", &gzmn, &gzmna,
                        &gzmnd, pw_gzmn, pw_gzmna, pw_gzmnd,
                        ia_gzmn, 0, 0, 0, 0, temp1-pw_gzmna, TRAP_ALL,
                        &loggrd);
 
	}
    }
    
    /* Added for Inversion.e */
      
  {
    pulsename(&rf2se1,"rf2se1");
    createreserve(&rf2se1,(WF_PROCESSOR)wg_rf2se1,
		  res_rf2se1);
  }

    
    /* X killer pulse *********************************************************/
    if (eosxkiller == PSD_ON) {
	tempx = RUP_GRD(pend(&gxwde,"gxwde",0) + gkdelay + pw_gxka);
	     

  trapezoid((WF_PROCESSOR)wg_gxk, "gxk", &gxk, &gxka,
                        &gxkd, pw_gxk, pw_gxka, pw_gxkd,
                        ia_gxk, 0, 0, 0, 0, tempx-pw_gxka, TRAP_ALL,
                        &loggrd);

    }
    
    /* Y killer pulse *****************************************************/
    if (eosykiller == PSD_ON) {
	tempy = RUP_GRD(pend(&gxwde,"gxwde",0) + gkdelay + pw_gyka);
	     

  trapezoid((WF_PROCESSOR)wg_gyk, "gyk", &gyk, &gyka,
                        &gykd, pw_gyk, pw_gyka, pw_gykd,
                        ia_gyk, 0, 0, 0, 0, tempy-pw_gyka, TRAP_ALL,
                        &loggrd);

    }
    
    /* Z killer pulse *****************************************************/
    if (eoszkiller == PSD_ON) {
	tempz = RUP_GRD(pend(&gxwde,"gxwde",0) + gkdelay + pw_gzka);
	     

  trapezoid((WF_PROCESSOR)wg_gzk, "gzk", &gzk, &gzka,
                        &gzkd, pw_gzk, pw_gzka, pw_gzkd,
                        ia_gzk, 0, 0, 0, 0, tempz-pw_gzka, TRAP_ALL,
                        &loggrd);

    }

    /* Add MRE waveforms */
/* Start inline from touch.e TouchPg */
/* Put the motion-encoding gradients and trigger pulses into the sequence */
if( touch_flag )
{
    int pos_enc, pos_enc0, pos_enc0_2;
    short dab6on[4];
    short dab6off[4];
    int i;

    dab6on[0] = SSPDS + EDC;
    dab6on[1] = SSPOC + DREG;
    dab6on[2] = SSPD + DABOUT6; /* SSPD+2*DSCP */
    dab6on[3] = SSPDS + 0x8000;
    dab6off[0] = SSPDS + EDC;
    dab6off[1] = SSPOC + DREG;
    dab6off[2] = SSPD;
    dab6off[3] = SSPDS + 0x8000;

    /* ***************************************************************
     Encoding gradients
     *****************************************************************/
    /* pos_enc will be the start of the motion-encoding gradients */
    if( oppseq == PSD_SE )
    {
        if( meg_mode == 0 )
        { /* left-side-only MEGs */
            if( opfcomp )
            {
                pos_enc0 = pend(&gzmnd, "gzmnd", 0); /* if flow comp. is on, MEG's start after GZMN . . . */
            }
            else
            {
                pos_enc0 = pendall(&gzrf1, gzrf1.ninsts - 1); /* otherwise they start after RF1 */
            }
        }
        else
        {
            pos_enc0 = RUP_GRD(pbeg(&gzrf2, "gzrf2", 0) + pw_gzrf2/ 2 - rf2_time/ 2 - touch_time); /* if there will be MEG's on both sides of RF2, position them in a symmetric and synchronized fashion */
        }
    }
    else
    {
        pos_enc0 = ((opfcomp) ? pend(&gzmnd, "gzmnd", 0) : pend(&gz1d, "gz1d", 0)); /* for GRE EPI, put the MEG's after GZ1, or GZMN if flow comp. is on */
    }
    pos_enc0 = RUP_GRD(pos_enc0);
    pos_enc = pos_enc0;
    if( touch_fcomp == 1 )
    {
        if( touch_gnum )
        {
            AddEncodeFcomp(pos_enc, 0);
            AddEncodeDown(pos_enc + touch_lobe_meg, 0);
            pos_enc += touch_period_meg;
            for( i = 1; i < touch_gnum; i++ )
            {
                AddEncodeUp(pos_enc, 0);
                AddEncodeDown(pos_enc + touch_lobe_meg, 0);
                pos_enc += touch_period_meg;
            }
            AddEncodeFcomp(pos_enc, 0);
        }
    }
    else if( touch_fcomp == 2 )
    {
        if( touch_gnum )
        {
            AddEncodeFcomp(pos_enc, 0);
            AddEncodeDown(pos_enc + touch_lobe_meg/ 2, 0);
            pos_enc += 3 * touch_lobe_meg/ 2;
            for( i = 1; i < touch_gnum; i++ )
            {
                AddEncodeUp(pos_enc, 0);
                AddEncodeDown(pos_enc + touch_lobe_meg, 0);
                pos_enc += touch_period_meg;
            }
            AddEncodeFcomp(pos_enc, 0);
        }
    }
    else
    {
        if( touch_gnum > 0 )
        {
            for( i = 0; i < ceil(touch_gnum); i++ )
            {
                AddEncodeUp(pos_enc, 0);
                if( ((int)touch_gnum) == ceil(touch_gnum) )
                { /* if full MEG, always add down MEG */
                    AddEncodeDown(pos_enc + touch_lobe_meg, 0);
                }
                else
                { /* if half MEG, don't add last down MEG */
                    if( i < (ceil(touch_gnum) - 1) )
                    {
                        AddEncodeDown(pos_enc + touch_lobe_meg, 0);
                    }
                }
                pos_enc += touch_period_meg;
            }
        }
    }

    /* 2nd set of MEGs after the refocusing pulse */
    if( meg_mode >= 1 )
    {
        pos_enc0_2 = RUP_GRD(pos_enc0 + touch_time + rf2_time);
        pos_enc = pos_enc0_2;

        if( touch_fcomp == 1 )
        {
            if( touch_gnum )
            {
                AddEncodeFcomp(pos_enc, 1);
                AddEncodeDown(pos_enc + touch_lobe_meg, 1);
                pos_enc += touch_period_meg;
                for( i = 1; i < touch_gnum; i++ )
                {
                    AddEncodeUp(pos_enc, 1);
                    AddEncodeDown(pos_enc + touch_lobe_meg, 1);
                    pos_enc += touch_period_meg;
                }
                AddEncodeFcomp(pos_enc, 1);
            }
        }
        else if( touch_fcomp == 2 )
        {
            if( touch_gnum )
            {
                AddEncodeFcomp(pos_enc, 1);
                AddEncodeDown(pos_enc + touch_lobe_meg/ 2, 1);
                pos_enc += 3 * touch_lobe_meg/ 2;
                for( i = 1; i < touch_gnum; i++ )
                {
                    AddEncodeUp(pos_enc, 1);
                    AddEncodeDown(pos_enc + touch_lobe_meg, 1);
                    pos_enc += touch_period_meg;
                }
                AddEncodeFcomp(pos_enc, 1);
            }
        }
        else
        {
            if( touch_gnum > 0 )
            {
                for( i = 0; i < ceil(touch_gnum); i++ )
                {
                    AddEncodeUp(pos_enc, 1);
                    if( ((int)touch_gnum) == ceil(touch_gnum) )
                    { /* if full MEG, always add down MEG */
                        AddEncodeDown(pos_enc + touch_lobe_meg, 1);
                    }
                    else
                    { /* if half MEG, don't add last down MEG */
                        if( i < (ceil(touch_gnum) - 1) )
                        {
                            AddEncodeDown(pos_enc + touch_lobe_meg, 1);
                        }
                    }
                    pos_enc += touch_period_meg;
                }
            }
        }
    }

    /* ********************
     Sync Pulses
     *******************/
    int pos_sync = touch_pos_sync;

    /* if overlapping trigger pulses with the MEG's, start the trigger pulses after RF1, otherwise put them at the beginning of the sequence */
    pos_sync = pendallssp(&hyperdab, 0) + (multi_phases - 1.) * touch_delta + cont_drive_ssp_delay;

    while( pos_sync < 40   )
        pos_sync += act_tr + time_ssi;
    for( i = 0; i < multi_phases; i++ )
    {
           
  {
    pulsename(&sync_on_2,"sync_on_2");
    createbits(&sync_on_2,TYPSSP,sizeof(dab6on)/2,dab6on);
    createinstr( &sync_on_2,(long)(pos_sync),
		4,ia_sync_on_2);
  }

           
  {
    pulsename(&sync_off_2,"sync_off_2");
    createbits(&sync_off_2,TYPSSP,sizeof(dab6off)/2,dab6off);
    createinstr( &sync_off_2,(long)(pos_sync+touch_sync_pw-4),
		4,ia_sync_off_2);
  }

        pos_sync -= touch_delta;
    }
    getwave(&wave_trigon, &sync_on_2);
    getwave(&wave_trigoff, &sync_off_2);
}
/* End inline from touch.e TouchPg */


    /* RHO killer? pulse ***********************************************/
    /* This pulse is specific to MGD.  It forces the RHO sequencer to  */
    /* EOS after all other RF sequencers (omega & theta) as a temp fix */
    /* for a sequencer buffer glitch.                                  */

    if (eosrhokiller == PSD_ON) {

        int pw_rho_killer = 2;
        int ia_rho_killer = 0;

	tempz = RUP_GRD(pend(&gxwde,"gxwde",0) + gkdelay + pw_gzka);
        pulsename(&rho_killer,"rho_killer");
        createconst(&rho_killer,RHO,pw_rho_killer,MAX_PG_WAMP);
        createinstr( &rho_killer,(long)(tempz),
                     pw_rho_killer,ia_rho_killer);
    }
   
#ifdef IPG
    /*
     * Execute this code only on the Tgt side
     */
    /* Major "Wait" Pulses ************************************************/
    if (gy1pos == PSD_POST_180)
        tempy = pbeg(&gy1a, "gy1a", 0) - pw_wgy;
    else
        tempy = pbeg(&gyba, "gyba", 0) - pw_wgy;
    
    if (ygmn_type == CALC_GMN1)
        tempy = pbeg(&gymn1a, "gymn1a", 0) - pw_wgy;
    
    if (gx1pos == PSD_POST_180)
        tempx = pbeg(&gx1a, "gx1a", 0) - pw_wgx;
    else
        tempx = pbeg(&gxwa, "gxwa", 0) - pw_wgx;
    
    /* TFON sliding data acq. window wait intervals */
        
  {
    pulsename(&wgx,"wgx");
    createconst(&wgx,(WF_PROCESSOR)wg_wgx,pw_wgx,(short)0); 
    createinstr( &wgx,(long)(tempx),pw_wgx,0);
  }

        
  {
    pulsename(&wgy,"wgy");
    createconst(&wgy,(WF_PROCESSOR)wg_wgy,pw_wgy,(short)0); 
    createinstr( &wgy,(long)(tempy),pw_wgy,0);
  }

    
    if (oppseq == PSD_SE) {
	tempz = pendall(&gzrf2r1, 0);
    } else {
	if (zgmn_type == CALC_GMN1) {
            tempz = pendall(&gzmnd, 0);
        } else {
            tempz = pendall(&gz1d, 0); /*jwg bb i think there may be a problem here, come back to*/
        }
    }
 
    /* For MR-Touch, match with wgx by using tempx instead of tempz */
           
  {
    pulsename(&wgz,"wgz");
    createconst(&wgz,(WF_PROCESSOR)wg_wgz,pw_wgz,(short)0); 
    createinstr( &wgz,(long)(touch_flag?tempx:tempz),pw_wgz,0);
  }


    if (oppseq == PSD_SE) {
        temps = pendall(&rf2, 0) + rfupd + 4  ;
    } else {
        temps = pendall(&rf1, 0) + rfupd + 4   + (int)HSDAB_length;
    }

       
  {
    pulsename(&wssp,"wssp");
    createconst(&wssp,(WF_PROCESSOR)wg_wssp,pw_wssp,(short)0); 
    createinstr( &wssp,(long)(temps),pw_wssp,0);
  }

    
    pw_sspdelay = defaultdelay + 1  ;	/* 1us is the min time for ssp,
					   per L. Ploetz. YPD */
         
  {
    pulsename(&sspdelay,"sspdelay");
    createconst(&sspdelay,(WF_PROCESSOR)wg_sspdelay,pw_sspdelay,(short)0); 
    createinstr( &sspdelay,(long)(temps+pw_wssp),pw_sspdelay,0);
  }

    
    pw_omegadelay = RUP_RF(defaultdelay+2  ); /* 2us is the min time for omega,
                                                 per L. Ploetz. YPD */
        
  {
    pulsename(&omegadelay,"omegadelay");
    createconst(&omegadelay,(WF_PROCESSOR)wg_omegadelay,pw_omegadelay,(short)0); 
    createinstr( &omegadelay,(long)(RUP_GRD(temps)),pw_omegadelay,0);
  }

    
       
  {
    pulsename(&womega,"womega");
    createconst(&womega,(WF_PROCESSOR)wg_womega,pw_womega,(short)0); 
    createinstr( &womega,(long)(RUP_GRD(temps)+pw_omegadelay),pw_womega,0);
  }

    
    /* pulse names for Omega Freq Mod pulses */ 
    pulsename(&rs_omega_attack, "rs_omega_attack");
    pulsename(&rs_omega_decay, "rs_omega_decay");
    pulsename(&omega_flat, "omega_flat");

    /* internref: use tot_etl instead of etl */
    for (echoloop = 0; echoloop < tot_etl; echoloop++ ) {
        getssppulse(&(echotrainrba[echoloop]), &(echotrain[echoloop]), "rba", 0);

        {   /* local scope */

            int time_offset = 0;
            pulsepos = pendallssp(echotrainrba[echoloop], 0); 
            time_offset = pw_gxwad - dacq_offset;  
 
            /* TURN TNS ON at the first etl and OFF at the last etl so that */
            /* the xtr and TNS do not overlap. */
            if ( echoloop == 0) 
  {
    e1entns_pack[0] = SSPDS+EDC;
    pulsename(&e1entns,"e1entns");
    createbits(&e1entns,TYPSSP,4,e1entns_pack);
    createinstr( &e1entns,(LONG)(pulsepos),4,0);
  }

            if ( echoloop == tot_etl-1)   
  {
    e1distns_pack[0] = SSPDS+EDC;
    pulsename(&e1distns,"e1distns");
    createbits(&e1distns,TYPSSP,4,e1distns_pack);
    createinstr( &e1distns,(LONG)(pulsepos+(int)(tsp*(float)rhfrsize)),4,0);
  }


            if (vrgfsamp) {
	        /*jwg bb change first variable from OMEGA to wg_omegaro1 so we can broadband this sucker*/
                trapezoid( wg_omegaro1,"omega", &omega_flat, 
                           &rs_omega_attack, &rs_omega_decay,
                           pw_gxwl+pw_gxw+pw_gxwr,  pw_gxwad, pw_gxwad, 
                           ia_omega,ia_omega,ia_omega, 0, 0, 
                           RUP_RF(pulsepos-time_offset+start_pulse), TRAP_ALL, &loggrd);    
            } else {
                
                /* BJM: to offset frequency, play constant on omega */
		/* jwg bb and we'll do the same thing down here, in case we're not ramp sampling*/
                createconst(&omega_flat, wg_omegaro1, pw_gxw, max_pg_wamp);
                createinstr(&omega_flat, RUP_RF(pulsepos+start_pulse), pw_gxw, ia_omega);
            }

        }
    }
    
    /* 4us for the e1distns pack */
    temps = pendallssp(&echotrain[tot_etl-1], 0) + (int)(tsp*(float)rhfrsize)+ 4; 
    
     
  {
  pulsename(&atten,"atten");
  createatten(&atten, (long)(temps));
}



    /* spring for sspdelay */
         
  {
    pulsename(&sspshift,"sspshift");
    createconst(&sspshift,(WF_PROCESSOR)wg_sspshift,pw_sspshift,(short)0); 
    createinstr( &sspshift,(long)(temps+7  ),pw_sspshift,0);
  }

    
    temps = pendallssp(&sspshift, 0);
   
    for (i=0; i<num_passdelay; i++) { 
           
  {
    pulsename(&ssp_pass_delay,"ssp_pass_delay");
    createconst(&ssp_pass_delay,(WF_PROCESSOR)wg_ssp_pass_delay,pw_ssp_pass_delay,(short)0); 
    createinstr( &ssp_pass_delay,(long)(temps),pw_ssp_pass_delay,0);
  }

        temps = pendallssp(&ssp_pass_delay, i);
    }
    
    
     
  {
    pulsename(&pass_pulse,"pass_pulse");
    createpass(&pass_pulse,(long)(temps));
  }


    /*jwg bb testing out different delays here to try and fix the shifts in PE direction*/    
    temps = pendallssp(&pass_pulse, 0);
      
  {
    pulsename(&jwg_delay,"jwg_delay");
    createconst(&jwg_delay,(WF_PROCESSOR)wg_jwg_delay,pw_jwg_delay,(short)0); 
    createinstr( &jwg_delay,(long)(temps),pw_jwg_delay,0);
  }

    /*jwg bb end*/

    if (touch_flag) {
        /* Add WAIT pulse to SSP to sync trigger pulses with MEG */
           
  {
    pulsename(&touch_wssp,"touch_wssp");
    createconst(&touch_wssp,(WF_PROCESSOR)wg_touch_wssp,pw_touch_wssp,(short)0); 
    createinstr( &touch_wssp,(long)(pendallssp(&pass_pulse,0)),pw_touch_wssp,0);
  }

    }

#endif /* IPG */
    
    /* Actual deadtimes for cardiac scans will be rewritten later */
    if(opcgate==PSD_ON)
	    psd_seqtime = RUP_GRD(tmin);
    else
    {
        if(tr_corr_mode == 0) psd_seqtime = RUP_GRD(act_tr/slquant1 - time_ssi);
        else psd_seqtime = RDN_GRD(act_tr/slquant1 - time_ssi);
    }
    
    
  {
    pulsename(&seqcore,"seqcore");
    createseq(&seqcore,psd_seqtime, off_seqcore);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcore );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcore = %d\n", idx_seqcore );
#endif
  }

    
    getperiod(&scan_deadtime, &seqcore, 0);

    if(opcgate == PSD_OFF)
    {
        int num;
        /* To make sure repetition time is exactly equal to act_tr */
        scan_deadtime_correct = (long *)AllocNode((slquant1 + 2)*sizeof(long));
        switch(tr_corr_mode)
        {
            case 0:
                for(i=0; i<slquant1; i++)
                {
                     scan_deadtime_correct[i] = scan_deadtime;
                }
            break;

            case 1:
                num = (act_tr - (psd_seqtime+time_ssi)*slquant1)/GRAD_UPDATE_TIME;
                for(i=0; i<slquant1; i++)
                {
                    if(i<num) scan_deadtime_correct[i] = scan_deadtime+GRAD_UPDATE_TIME;
                    else scan_deadtime_correct[i] = scan_deadtime;
                }
            break;

            case 2:
                for(i=0; i<slquant1-1; i++)
                {
                    scan_deadtime_correct[i] = scan_deadtime;
                }
                scan_deadtime_correct[slquant1-1] = scan_deadtime + act_tr - (psd_seqtime+time_ssi)*slquant1; 
            break;
        }
    }

    /* BJM: SE Ref Scan */

if(se_ref == PSD_ON) {

    /* BJM: reuse all the pulse parameters of the imaging sequence */
    /* spsp 90 RF slice select pulse *******************************************/
    temp_res = res_rf1;
    if (rfpulseInfo[RF1_SLOT].change == PSD_ON)  /* set to new resolution */
        res_rf1 = rfpulseInfo[RF1_SLOT].newres;
    
    /* set rfunblank_bits[2] so that addrfbits in sliceselz does not
       unblank the receiver - see EpicConf.c for defaults. Will unblank
       the receiver later - MRIge28778 */
    
    rfunblank_bits[0][2] = SSPD;
    rfunblank_bits[1][2] = SSPD;

    {
      /* Now create the pulses */
      pulsename(&gzrf1refa,"gzrf1refa");
      pulsename(&gzrf1ref,"gzrf1ref");
      pulsename(&gzrf1refd,"gzrf1refd");
      pulsename(&rf1ref,"rf1ref");
      pulsename(&thetarf1ref, "thetarf1ref");

      /*  Now create the slice select trapezoid */
      pg_beta = loggrd.zbeta;

      if ( gztype == PLAY_GFILE) {

#if defined(IPG_TGT) || defined(MGD_TGT)
          /* Use external gradient file for now */
          createextwave( &gzrf1ref, ZGRAD, res_gzrf1,
                         grad_zrf1);

          createinstr( &gzrf1ref, (long)pos_start+pw_gzrf1a,
                       pw_gzrf1, ia_gzrf1 );

#elif defined(HOST_TGT)
          /* Create train of trapezoids on the Host side */
          int i;
          int polarity = 1;
       
          pulsepos = pos_start+pw_gzrf1a; 
       
          for(i = 1; i <= num_rf1lobe; i++) {
              polarity *= -1;

              trapezoid( ZGRAD,"gzrf1ref", &gzrf1ref, 
                         &gzrf1refa, &gzrf1refd,
                         pw_constant, pw_ss_rampz, pw_ss_rampz, 
                         (polarity*(ia_gzrf1)),
                         (polarity*(ia_gzrf1)),
                         (polarity*(ia_gzrf1)), 0, 0, 
                         pulsepos, TRAP_ALL, &loggrd );

              pulsepos += pw_constant + 2 * pw_ss_rampz;
          }
#endif

      } else {

          /* Create simple trapezoid for chem sat + rf */
          createramp( &gzrf1refa,ZGRAD,pw_gzrf1a,
                      (short)0, max_pg_wamp,
                      (short)(maxGradRes *
                              (pw_gzrf1a/ GRAD_UPDATE_TIME)),
                      pg_beta );

          createinstr( &gzrf1refa,
                       (long)(pos_start+pw_gzrf1a - pw_gzrf1a),
                       pw_gzrf1a, ia_gzrf1 );

          createconst( &gzrf1ref, ZGRAD, pw_rf1, max_pg_wamp );
          createinstr( &gzrf1ref, (long)pos_start+pw_gzrf1a,
                       pw_gzrf1, ia_gzrf1 );

          createramp( &gzrf1refd, ZGRAD, pw_gzrf1d,
                      max_pg_wamp, (short)0,
                      (short)(maxGradRes *
                              (pw_gzrf1d/ GRAD_UPDATE_TIME)),
                      pg_beta );
          createinstr( &gzrf1refd,
                       (long)(pos_start+pw_gzrf1a + pw_gzrf1),
                       pw_gzrf1d, ia_gzrf1 );

      }

      /* Now create the rf pulse */
      if ( rftype == PLAY_RFFILE) {
          createextwave( &rf1ref,TYPRHO1, res_rf1,
                         rf_rf1);
      } else {
          createsinc( &rf1ref,TYPRHO1, res_rf1,
                      max_pg_wamp,cyc_rf1, alpha_rf1 );
      }

      createinstr( &rf1ref,(long)pos_start+pw_gzrf1a + psd_rf_wait +
                   ss_rf_wait,  pw_rf1,ia_rf1);

      addrfbits( &rf1ref, off_rf1, (long)pos_start+pw_gzrf1a +
                 psd_rf_wait + ss_rf_wait, pw_rf1 );

      /* Now create the theta pulse */
      if ( thetatype == PLAY_THETA) {
          createextwave( &thetarf1ref, TYPOMEGA,
                         res_thetarf1, theta_rf1);

          createinstr( &thetarf1ref, (long)pos_start+pw_gzrf1a + psd_rf_wait +
                       ss_rf_wait, pw_thetarf1,
                       ia_thetarf1);

          addrfbits( &thetarf1ref, off_thetarf1,
                     (long)pos_start+pw_gzrf1a + psd_rf_wait + ss_rf_wait,
                     pw_thetarf1 );
      }
#if defined(IPG_TGT) || defined(MGD_TGT)
      if ( gztype == PLAY_GFILE) {
          linkpulses( 3,
                      &rf1ref, &gzrf1ref, &thetarf1ref);
      } else {
          linkpulses( 4,
                      &rf1ref, &gzrf1ref,
                      &gzrf1refa, &gzrf1refd);
      }
#endif
  }
    
    /* reset the bit */
    rfunblank_bits[0][2] = SSPD + RUBL;
    rfunblank_bits[1][2] = SSPD + RUBL;
    
    if (rfpulseInfo[RF1_SLOT].change == PSD_ON)  /* change back for ext. file */
        res_rf1 = temp_res;
    
    /* 180 RF refocusing pulse ********************************************/
    Rf2Location[0] = RUP_GRD((int)(pend(&rf1ref,"rf1ref",0) - rfExIso  + refScanTe/2
                                       - pw_rf2/2) - psd_rf_wait);  /* Find start loc of 180s */
        
        /* MRIge58235: moved uextwave to here so the file read from disk is always read with orig. res_rf2 */
    strcpy(ext_filename, "rfse1b4.rho");
        
    /* Create some RHO waveform space, read in the 
       se1b4 spin echo 180 to local memory, and then move
       the local memory to the reserved RHO memory.
     */
    temp_wave_space = (short *)AllocNode(res_rf2*sizeof(short));
    uextwave(temp_wave_space, res_rf2, ext_filename);
        
    {
        /* MRIge58235: save orig. res_rf2ref for scaling */
        short orig_res;
            
        orig_res = res_rf2;
        if (rfpulseInfo[RF2_SLOT].change==PSD_ON)
            res_rf2 = rfpulseInfo[RF2_SLOT].newres;     /* Set to new resolution */
            
        /* set rfunblank_bits[2] so that addrfbits in sliceselz does not
           unblank the receiver - see EpicConf.c for defaults. Will unblank
           the receiver later - MRIge28778 */
        rfunblank_bits[0][2] = SSPD;
        rfunblank_bits[1][2] = SSPD;

        /*  180 slice sel pulse  */
        {
            /* First create the pulses */
            pulsename(&gzrf2refa,"gzrf2refa");
            pulsename(&gzrf2ref,"gzrf2ref");
            pulsename(&gzrf2refd,"gzrf2refd");
            pulsename(&rf2ref,"rf2ref");

            /*  Now create the slice select trapezoid */
            pg_beta = loggrd.zbeta;
            createramp(&gzrf2refa,ZGRAD,pw_gzrf2a,(short)0,
                       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2a/
                                                       GRAD_UPDATE_TIME)),pg_beta);
            createinstr( &gzrf2refa,(long)(Rf2Location[0]-pw_gzrf2a),
                         pw_gzrf2a,ia_gzrf2);
            createconst(&gzrf2ref,ZGRAD,pw_gzrf2,MAX_PG_WAMP);
            createinstr( &gzrf2ref,(long)(Rf2Location[0]),
                         pw_gzrf2,ia_gzrf2);
            createramp(&gzrf2refd,ZGRAD,pw_gzrf2d,MAX_PG_WAMP,
                       (short)0,(short)(maxGradRes*(pw_gzrf2d/GRAD_UPDATE_TIME)),
                       pg_beta);
            createinstr( &gzrf2refd,(long)(Rf2Location[0]+pw_gzrf2),
                         pw_gzrf2d,ia_gzrf2);

            /* Now create the rf pulse */
            createsinc(&rf2ref,TYPRHO1,res_rf2,
                       MAX_PG_WAMP,cyc_rf2, alpha_rf2);
            createinstr( &rf2ref,(long)(Rf2Location[0]) + psd_rf_wait,
                         pw_rf2,ia_rf2);
            linkpulses(4,&rf2ref,&gzrf2ref,&gzrf2refa,
                       &gzrf2refd);
            addrfbits(&rf2ref,off_rf2,(long)(Rf2Location[0]) + psd_rf_wait, 
                      pw_rf2);
        }

        /* reset the bit */
        rfunblank_bits[0][2] = SSPD + RUBL;
        rfunblank_bits[1][2] = SSPD + RUBL;

        /* Stretch rf pw if needed */
        if (rfpulseInfo[RF2_SLOT].change==PSD_ON) {
            wave_space = (short *)AllocNode(rfpulseInfo[RF2_SLOT].newres*
                                            sizeof(short));
            stretchpulse((int)orig_res, (int)rfpulseInfo[RF2_SLOT].newres,
                         temp_wave_space,wave_space);
            FreeNode(temp_wave_space);
        } else {
            wave_space = temp_wave_space;
        }

        /* Assign temporary board memory and move immediately into permanent
           memory */
        res_rf2se1b4 = res_rf2;
        pulsename(&rf2se1b4_ref,"rf2se1b4_ref");
        createreserve(&rf2se1b4_ref,RHO, res_rf2se1b4);
        movewaveimm(wave_space, &rf2se1b4_ref, (int)0, res_rf2, TOHARDWARE);
        FreeNode(wave_space);

        /* MRIge58235: reset res_rf2 after scaling */
        res_rf2 = orig_res;
    }

    setphase((float)(PI/-2.0), &rf2ref, 0);  /* Apply 90 phase shift to  180 */

    attenflagon(&rf1ref, 0);                 /* Assert ESSP flag on rf1 pulse */

    attenflagon(&rf2ref, 0);                 /* Assert ESSP flag on 1st rf2 */

    /* Z crushers (echo 1) ***********************************************/
    trapezoid(ZGRADB, "gzrf2refl1", &gzrf2refl1, &gzrf2refl1a,
              &gzrf2refl1d, pw_gzrf2l1, pw_gzrf2l1a, pw_gzrf2l1d,
              ia_gzrf2l1, 0, 0, 0, 0, pbeg(&gzrf2ref,"gzrf2ref",0)-(pw_gzrf2l1+pw_gzrf2l1d)-pw_gzrf2l1a, TRAP_ALL,
              &loggrd);

    trapezoid(ZGRADB, "gzrf2refr1", &gzrf2refr1, &gzrf2refr1a,
              &gzrf2refr1d, pw_gzrf2r1, pw_gzrf2r1a, pw_gzrf2r1d,
              ia_gzrf2r1, 0, 0, 0, 0, pend(&gzrf2ref,"gzrf2refd",0)-pw_gzrf2r1a, TRAP_ALL,
              &loggrd);

    /* unblank receiver rcvr_ub_off us prior to first xtr/dab/rba packet */
    /* BJM: move DAB packet after RF for less upfront deadtime */
    getssppulse(&rf2ssp_end, &rf2ref, "ubr", 0);
    rcvrunblankpos = pendallssp(rf2ssp_end, 0);
     
  {
    rec_unblankref_pack[0] = SSPDS+RDC;
    rec_unblankref_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rec_unblankref_pack[2] = SSPD+RUBL;
    rec_unblankref_pack[3] = SSPDS;

    pulsename(&rec_unblankref,"rec_unblankref");
    createbits(&rec_unblankref,TYPSSP,4,rec_unblankref_pack);
    createinstr( &rec_unblankref,(long)(rcvrunblankpos),4,ia_rec_unblankref);
  }


    /***********************************************************************/
    /* X EPI readout train                                                 */
    /***********************************************************************/

    /* These arrays are used to hold the addresses of the data acq pulses.. */
    echotrainxtr_ref = (WF_PULSE **)AllocNode(tot_etl*sizeof(WF_PULSE *));
    echotrainrba_ref = (WF_PULSE **)AllocNode(tot_etl*sizeof(WF_PULSE *));

    /* BJM: pkt_delay is included to account for any delay between */
    /* sending the RBA and the first sample acquired (hardware delay) */
    if (vrgfsamp == PSD_ON) {
        dacq_offset = pkt_delay + pw_gxwad - 
            (int)(fbhw*((float)pw_gyb/2.0 + 
                        (float)pw_gybd) + 0.5);
    } else {
        dacq_offset = pkt_delay;
    }

    /* MRIge58023 & 58033 need to RUP_GRD entire expression */
    if (intleaves == opyres) {
        tempx = RUP_GRD((int)(pend(&rf1ref,"rf1ref",0) - rfExIso + refScanTe - pw_gxw/2 - pw_gxwl - ky_offset*esp/intleaves));
    } else {
        tempx = RUP_GRD((int)(pend(&rf1ref,"rf1ref",0) - rfExIso + refScanTe - echoOffset * esp - ky_offset*esp/intleaves + 1000));
    }

    tempy = tempx + gydelay;
    tempz = tempx;
    tempx += gxdelay;

    /* Set up for EP_TRAIN */
    stddab = (hsdab==PSD_ON ? 0:1);
    pg_tsp =0;

    
                    
                  
                  
                  
                  
                  
                  
                    
                  
                  
                  
                  
                  
    {
        int psd_gxwcnt;
        int psd_pulsepos;
        int psd_eparity;
        long psd_epxtroff;
        long psd_epdaboff;
        float psd_etbetax;
        float psd_etbetay;
        char psd_epstring[EPSTRING_LENGTH];

        psd_pulsepos = RUP_GRD(tempx+pw_gxwad);           
 
        if ( 0 == 0 ) {
            refechotrain = (WF_PULSE *)AllocNode((tot_etl + 3) * sizeof(WF_PULSE));
        }
 
        pulsename(&refgxcla, "refgxcla");
        pulsename(&refgxcl, "refgxcl");
        pulsename(&refgxcld, "refgxcld");
 
        pulsename(&refgxwa, "refgxwa");
        pulsename(&refgxw, "refgxw");
        pulsename(&refgxwd, "refgxwd");
        pulsename(&refgxwde, "refgxwde");
 
        pulsename(&refgxgap, "refgxgap");
 
        pulsename(&refgyba, "refgyba");
        pulsename(&refgyb, "refgyb");
        pulsename(&refgybd, "refgybd");
 
        pulsename(&refgxcra, "refgxcra");
        pulsename(&refgxcr, "refgxcr");
        pulsename(&refgxcrd, "refgxcrd");
 
        getbeta(&psd_etbetax, XGRAD, &epiloggrd);
        getbeta(&psd_etbetay, YGRAD, &epiloggrd);
 
        if (pw_gxcla >= GRAD_UPDATE_TIME) {
            createramp(&refgxcla, XGRAD, pw_gxcla, (short)0,
                       (short)ia_gxcl, (short)(maxGradRes*(pw_gxcla/
                       GRAD_UPDATE_TIME)), psd_etbetax);
            createinstr(&refgxcla, (long)psd_pulsepos,
                        pw_gxcla, max_pg_iamp);
            psd_pulsepos += pw_gxcla;
        }
    
        if (pw_gxcl >= GRAD_UPDATE_TIME) {
            createconst(&refgxcl, XGRAD, pw_gxcl, max_pg_wamp);
            createinstr(&refgxcl, (long)psd_pulsepos, pw_gxcl, ia_gxcl);
            psd_pulsepos += pw_gxcl;
        }
    
        if (pw_gxcld >= GRAD_UPDATE_TIME) {
            createramp(&refgxcld, XGRAD, pw_gxcld, (short)ia_gxcl,
                       (short)ia_gxw, (short)(maxGradRes*(pw_gxcld/
                       GRAD_UPDATE_TIME)), psd_etbetax);
            createinstr(&refgxcld, (long)psd_pulsepos,
                        pw_gxcld, max_pg_iamp);
            psd_pulsepos += pw_gxcld;
        }
    
        createconst(&refgxw, XGRAD, pw_gxwl+pw_gxw+pw_gxwr, max_pg_wamp);
        createinstr(&refgxw, (long)psd_pulsepos, pw_gxwl+pw_gxw+pw_gxwr, ia_gxw);
        psd_pulsepos += pw_gxwl;
    
        sprintf(psd_epstring, "echo%04d",0);
        pulsename(&(refechotrain[0]), psd_epstring);
    
        if (dab_offset == 0)
            psd_epdaboff = 0;
        else
            psd_epdaboff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + dab_offset);            
        if (xtr_offset == 0)
            psd_epxtroff = 0;
        else
            psd_epxtroff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + xtr_offset);            
    
        epiacqq(&(refechotrain[0]),                
                (long)(psd_pulsepos + psd_grd_wait-dacq_offset),
                psd_epdaboff, psd_epxtroff,
                (long)scanslot, 
                (TYPDAB_PACKETS)DABNORM,
                (long)fast_rec,
                (long)stddab);
    
        psd_pulsepos += pw_gxw + pw_gxwr;      
    
        psd_eparity = 1;
        for (psd_gxwcnt = 2; psd_gxwcnt <= tot_etl; psd_gxwcnt++) {
            psd_eparity *= -1;
          if( psd_gxwcnt-1 > iref_etl ){ /* internref */ 
            createramp(&refgyba, YGRAD, pw_gyba, 0, max_pg_wamp,
                       (short)((maxGradRes*pw_gyba)/GRAD_UPDATE_TIME), psd_etbetay);
            createinstr(&refgyba, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 -
                        (pw_gyba + pw_gyb/2)), pw_gyba, ia_gyb);
        
            if (pw_gyb >= GRAD_UPDATE_TIME) {
                createconst(&refgyb, YGRAD, pw_gyb, max_pg_wamp);
                createinstr(&refgyb, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 -
                            pw_gyb/2), pw_gyb, ia_gyb);
            }
        
            createramp(&refgybd, YGRAD, pw_gybd, max_pg_wamp, 0,
                       (short)((maxGradRes*pw_gybd)/GRAD_UPDATE_TIME), psd_etbetay);
            createinstr(&refgybd, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 +
                        pw_gyb/2), pw_gybd, ia_gyb);
        
            linkpulses(3,&refgyb,&refgyba,&refgybd);
          } 

          createramp(&refgxwd, XGRAD, pw_gxwad, -max_pg_wamp, 0,
                           (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), psd_etbetax);
          createinstr(&refgxwd, (long)psd_pulsepos, pw_gxwad, psd_eparity*ia_gxw);
          psd_pulsepos += pw_gxwad;

          if( pw_gxgap == 0 ){
               if( (pw_iref_gxwait != 0) && (psd_gxwcnt == iref_etl) ){ 
                   createconst(&refgxgap, XGRAD, pw_iref_gxwait, 0);
                   createinstr(&refgxgap, (long)psd_pulsepos, pw_iref_gxwait, 0);
                   psd_pulsepos += pw_iref_gxwait;
               }
          }else{ 
               int gapgap;
               if( (pw_iref_gxwait == 0) || (psd_gxwcnt != iref_etl) ){
                   gapgap = pw_gxgap;
               }else{
                   gapgap = pw_gxgap+pw_iref_gxwait;
               }
               createconst(&refgxgap, XGRAD, gapgap, 0);
               createinstr(&refgxgap, (long)psd_pulsepos, gapgap, 0);
               psd_pulsepos += gapgap;
          }

          createramp(&refgxwa, XGRAD, pw_gxwad, 0, max_pg_wamp,
                     (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), psd_etbetax);
          createinstr(&refgxwa, (long)psd_pulsepos, pw_gxwad, psd_eparity*ia_gxw);
          psd_pulsepos += pw_gxwad;
        
            createconst(&refgxw, XGRAD, pw_gxwl+pw_gxw+pw_gxwr, max_pg_wamp);
            createinstr(&refgxw, (long)psd_pulsepos,
                        pw_gxwl+pw_gxw+pw_gxwr, psd_eparity*ia_gxw);
            psd_pulsepos += pw_gxwl;
        
            sprintf(psd_epstring, "echo%04d", psd_gxwcnt-1 + 0);
            pulsename(&(refechotrain[psd_gxwcnt-1+0]), psd_epstring);
        
            if (dab_offset == 0)                                           
                psd_epdaboff = 0;
            else
                psd_epdaboff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + dab_offset);
        
            if (xtr_offset == 0)
                psd_epxtroff = 0;
            else
                psd_epxtroff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + xtr_offset);
        
            epiacqq(&(refechotrain[psd_gxwcnt-1+0]),                
                    (long)(psd_pulsepos + psd_grd_wait-dacq_offset),
                    psd_epdaboff, psd_epxtroff,
                    (long)scanslot, 
                    (TYPDAB_PACKETS)DABNORM,
                    (long)fast_rec,
                    (long)stddab);
        
            psd_pulsepos += pw_gxw + pw_gxwr;      
        } 
    
        if ((tot_etl % 2) == 1) {    /* views per shot is odd */          
            if (pw_gxcra >= GRAD_UPDATE_TIME) {
                createramp(&refgxcra, XGRAD, pw_gxcra, (short)ia_gxw,
                           (short)ia_gxcr, (short)(maxGradRes*(pw_gxcra/
                           GRAD_UPDATE_TIME)), psd_etbetax);
                createinstr(&refgxcra, (long)(psd_pulsepos), pw_gxcra, max_pg_iamp);
                psd_pulsepos += pw_gxcra;
            }
        } else {                        /* views per shot is even */
            /* single transition ramp into crusher */                  
            if ((ia_gxw == ia_gxcr) && (pw_gxwad == pw_gxcra)) {
                createramp(&refgxwd, XGRAD, 2*pw_gxwad, -max_pg_wamp, max_pg_wamp,
                           (short)(maxGradRes*(2*pw_gxwad)/GRAD_UPDATE_TIME), psd_etbetax);
                createinstr(&refgxwd, (long)psd_pulsepos, 2*pw_gxwad, ia_gxw);
                psd_pulsepos += 2*pw_gxwad;
            } else {    /* two separate ramps, decay ramp needs new waveform */
                createramp(&refgxwde, XGRAD, pw_gxwad, -max_pg_wamp, 0,              
                           (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), psd_etbetax);
                createinstr(&refgxwde, (long)psd_pulsepos, pw_gxwad, ia_gxw);
                psd_pulsepos += pw_gxwad;

                if (pw_gxcra >= GRAD_UPDATE_TIME) {
                    createramp(&refgxcra, XGRAD, pw_gxcra, (short)0,
                               (short)ia_gxcr, (short)(maxGradRes*(pw_gxcra/
                               GRAD_UPDATE_TIME)), psd_etbetax);
                    createinstr(&refgxcra, (long)(psd_pulsepos), pw_gxcra, max_pg_iamp);
                    psd_pulsepos += pw_gxcra;
                }
            }   
        }        
     }
  

    if (tot_etl % 2 == 1) {
        getbeta(&betax, XGRAD, &epiloggrd);
        pulsePos = pend(&refgxw, "refgxw", tot_etl-1);
        createramp(&refgxwde, XGRAD, pw_gxwad, -max_pg_wamp, 0,
                   (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), betax);
        createinstr(&refgxwde, pulsePos, pw_gxwad, -ia_gxw);
        pulsePos += pw_gxwad;
    }

    /***********************************************************************/
    /* X dephaser                                                          */
    /***********************************************************************/
    temp1 = RUP_GRD((int)(pbeg(&refgxw,"refgxw",0) - (pw_gxwad + pw_gx1a +
                                                      pw_gx1 + pw_gx1d)));
    pg_beta = loggrd.xbeta;
    
    /* Gx1ref Attack Pulse */
    pulsename(&refgx1a,"refgx1a");
    createramp(&refgx1a,XGRAD,pw_gx1a,(short)0,
               max_pg_wamp,(short)(maxGradRes*(pw_gx1a/GRAD_UPDATE_TIME)),
               pg_beta);
    createinstr(&refgx1a, (LONG)temp1, pw_gx1a, ia_gx1);
    
    /* Gx1ref Pulse */
    if (pw_gx1 >= GRAD_UPDATE_TIME) {
        pulsename(&refgx1,"refgx1");
        createconst(&refgx1,XGRAD,pw_gx1,max_pg_wamp);
        createinstr( &refgx1,(LONG)(LONG)temp1+pw_gx1a,
                     pw_gx1,ia_gx1);
    }

    /* Gx1ref Decay Pulse */
    pulsename(&refgx1d, "refgx1d");
    createramp(&refgx1d,XGRAD,pw_gx1d,max_pg_wamp,
               (short)0,(short)(maxGradRes*(pw_gx1d/GRAD_UPDATE_TIME)),
               pg_beta);
    createinstr( &refgx1d,(LONG)((LONG)temp1+pw_gx1a+pw_gx1),
                 pw_gx1d,ia_gx1);

    pulsename(&refgxwa, "refgxwa");  /* attack ramp for epi train */
    createramp(&refgxwa, XGRAD, pw_gxwad, (short)0, max_pg_wamp,
               (short)(maxGradRes*(pw_gxwad/GRAD_UPDATE_TIME)), pg_beta);
    if ( etl%2 == 0 && ky_dir != PSD_TOP_DOWN  )
        createinstr(&refgxwa, (LONG)tempx, pw_gxwad, -ia_gxw);
    else
        createinstr(&refgxwa, (LONG)tempx, pw_gxwad, ia_gxw);

    /* Set readout polarity to gradpol[ileave] value */
    ileave = 0;
    setreadpolarity_ref();

    /* Hyperscan DAB packet */
    temp2 = pendall(&rf1ref, 0) + rfupd + 4  ;  /* 4us for unblank receiver */
     
{
    pulsename(&hyperdabref,"hyperdabref");

        createhsdab(&hyperdabref, (long)(temp2));
  }


    /* If we don't reset frequency and phase on each view, then it is best
       to use a single packet at the beginning of the frame - one that doesn't
       shift with interleave.  This is because we want the constant part of Ahn
       correction to see continuous phase evolution across the views. */

    temp2 = pendall(&rf2ref, 0) + rfupd + 4  ;  /* 4us for unblank receiver */

    /* Y prephaser ************************************************************/
    temp1 = pbeg(&refgxw, "refgxw", iref_etl) - pw_gxwad - pw_gy1_tot;
    temp1 = RDN_GRD(temp1);

    /* Setup the Ky Prephaser for Ref Scan */
    trapezoid(YGRAD,"refgy1",
              &refgy1,&refgy1a,&refgy1d,
              pw_gy1,pw_gy1a,pw_gy1d,
              ia_gy1,ia_gy1wa,ia_gy1wb,
              0,0,temp1,TRAP_ALL_SLOPED, &loggrd);

    /* TRAPEZOID2(YGRAD, refgy1, temp1, TRAP_ALL_SLOPED,,,endview_scale, loggrd); */

    /* X killer pulse *********************************************************/
    if (eosxkiller == PSD_ON) {
        tempx = RUP_GRD(pend(&refgxwde,"refgxwde",0) + gkdelay + pw_gxka);

        trapezoid(XGRAD, "refgxk", &refgxk, &refgxka,
                  &refgxkd, pw_gxk, pw_gxka, pw_gxkd,
                  ia_gxk, 0, 0, 0, 0, tempx-pw_gxka, TRAP_ALL,
                  &loggrd);

        /* TRAPEZOID(XGRAD, refgxk, tempx, 0, TYPNDEF, loggrd); */
    }

    /* Y killer pulse *****************************************************/
    if (eosykiller == PSD_ON) {
        tempy = RUP_GRD(pend(&refgxwde,"refgxwde",0) + gkdelay + pw_gyka);

        trapezoid(YGRAD, "refgyk", &refgyk, &refgyka,
                  &refgykd, pw_gyk, pw_gyka, pw_gykd,
                  ia_gyk, 0, 0, 0, 0, tempy-pw_gyka, TRAP_ALL,
                  &loggrd);

        /* TRAPEZOID(YGRAD, refgyk, tempy, 0, TYPNDEF, loggrd); */
    }

    /* Z killer pulse *****************************************************/
    if (eoszkiller == PSD_ON) {
        tempz = RUP_GRD(pend(&refgxwde,"refgxwde",0) + gkdelay + pw_gzka);

        trapezoid(ZGRAD, "refgzk", &refgzk, &refgzka,
                  &refgzkd, pw_gzk, pw_gzka, pw_gzkd,
                  ia_gzk, 0, 0, 0, 0, tempz-pw_gzka, TRAP_ALL,
                  &loggrd);

        /* TRAPEZOID(ZGRAD, refgzk, tempz, 0, TYPNDEF, loggrd); */
    }

    /* RHO killer? pulse ***********************************************/
    /* This pulse is specific to MGD.  It forces the RHO sequencer to  */
    /* EOS after all other RF sequencers (omega & theta) as a temp fix */
    /* for a sequencer buffer glitch.                                  */

    if (eosrhokiller == PSD_ON) {

        int pw_rho_killer = 2;
        int ia_rho_killer = 0;

        tempz = RUP_GRD(pend(&refgxwde,"refgxwde",0) + gkdelay + pw_gzka);
        pulsename(&rho_killerref,"rho_killerref");
        createconst(&rho_killerref,RHO,pw_rho_killer,MAX_PG_WAMP);
        createinstr( &rho_killerref,(long)(tempz),
                     pw_rho_killer,ia_rho_killer);
    }

#ifdef IPG
    /*
     * Execute this code only on the Tgt side
     */
    /* Major "Wait" Pulses ************************************************/

    tempy = pbeg(&refgy1a, "refgy1a", 0) - pw_wgy;
    tempx = pbeg(&refgx1a, "refgx1a", 0) - pw_wgx;
    /* TFON sliding data acq. window wait intervals */

    /* WAIT Pulse on X */
    pulsename(&wgxref,"wgxref");
    createconst(&wgxref,XGRAD,pw_wgx,(short)0); 
    createinstr( &wgxref,(long)(tempx),pw_wgx,0);

    /* WAIT Pulse on Y */
    pulsename(&wgyref,"wgyref");
    createconst(&wgyref,YGRAD,pw_wgy,(short)0); 
    createinstr( &wgyref,(long)(tempy),pw_wgy,0);

    tempz = pendall(&gzrf2refr1, 0);    

    /* WAIT Pulse on Z */
    pulsename(&wgzref,"wgzref");
    createconst(&wgzref,ZGRAD,pw_wgz,(short)0); 
    createinstr( &wgzref,(long)(tempz),pw_wgz,0);

    temps = pendall(&rf2ref, 0) + rfupd + 4  ;

    /* WAIT on SSP */ 
    pulsename(&wsspref,"wsspref");
    createconst(&wsspref,SSP,pw_wssp,(short)0); 
    createinstr( &wsspref,(long)(temps),pw_wssp,0);
   
    /* 1us is the min time for ssp, per L. Ploetz. YPD */ 
    pw_sspdelay = defaultdelay + 1  ;
    
    /* WAIT for SSP Delay */ 
    pulsename(&sspdelayref,"sspdelayref");
    createconst(&sspdelayref,SSP,pw_sspdelay,(short)0); 
    createinstr( &sspdelayref,(long)(temps+pw_wssp),pw_sspdelay,0);
    
    pw_omegadelay = RUP_RF(defaultdelay+2  ); /* 2us is the min time for omega,
                                                 per L. Ploetz. YPD */
    /* WAIT for Omega Delay */ 
    pulsename(&omegadelayref,"omegadelayref");
    createconst(&omegadelayref,OMEGA,pw_omegadelay,(short)0); 
    createinstr( &omegadelayref,(long)(RUP_GRD(temps)),pw_omegadelay,0);
    
    pulsename(&womegaref,"womegaref");
    createconst(&womegaref,OMEGA,pw_womega,(short)0); 
    createinstr( &womegaref,(long)(RUP_GRD(temps)+pw_omegadelay),pw_womega,0);

    /* pulse names for Omega Freq Mod pulses */ 
    pulsename(&rs_omega_attackref, "rs_omega_attackref");
    pulsename(&rs_omega_decayref, "rs_omega_decayref");
    pulsename(&omega_flatref, "omega_flatref");

    for (echoloop = 0; echoloop < tot_etl; echoloop++ ) {
        getssppulse(&(echotrainrba_ref[echoloop]), &(refechotrain[echoloop]), "rba", 0);

        {   /* local scope */

            int time_offset = 0;
            pulsepos = pendallssp(echotrainrba_ref[echoloop], 0); 
            time_offset = pw_gxwad - dacq_offset;  
 
            /* TURN TNS ON at the first etl and OFF at the last etl so that */
            /* the xtr and TNS do not overlap. */
            if ( echoloop == 0)  {
                e1entnsref_pack[0] = SSPDS+EDC;
                pulsename(&e1entnsref,"e1entnsref");
                createbits(&e1entnsref,TYPSSP,4,e1entnsref_pack);
                createinstr( &e1entnsref,(LONG)(pulsepos),4,0);
            }

            if ( echoloop == tot_etl-1) {
                e1distnsref_pack[0] = SSPDS+EDC;
                pulsename(&e1distnsref,"e1distnsref");
                createbits(&e1distnsref,TYPSSP,4,e1distnsref_pack);
                createinstr( &e1distnsref,(LONG)(pulsepos+(int)(tsp*(float)rhfrsize)),4,0);
            }

            if (vrgfsamp) {
	        /*jwg bb change first variable from OMEGA to wg_omegaro1 so we can broadband this sucker*/	    
                trapezoid( wg_omegaro1,"omegaref", &omega_flatref, 
                           &rs_omega_attackref, &rs_omega_decayref,
                           pw_gxwl+pw_gxw+pw_gxwr,  pw_gxwad, pw_gxwad, 
                           ia_omega,ia_omega,ia_omega, 0, 0, 
                           RUP_RF(pulsepos-time_offset), TRAP_ALL, &loggrd);    
            } else {
                
                /* BJM: to offset frequency, play constant on omega */
		/* jwg bb and we'll do the same thing down here, in case we're not ramp sampling*/		
                createconst(&omega_flatref, wg_omegaro1, pw_gxwl+pw_gxw+pw_gxwr, 
                            max_pg_wamp);
                createinstr(&omega_flatref, RUP_RF(pulsepos),
                            pw_gxwl+pw_gxw+pw_gxwr, ia_omega);            
            }

        }
    }
    
    /* 4us for the e1distns pack */
    temps = pendallssp(&refechotrain[tot_etl-1], 0) + (int)(tsp*(float)rhfrsize)+ 4; 
    
    /* "Spring" for sspdelay - keeps TR constant for sliding read window */
    pulsename(&sspshiftref,"sspshiftref");
    createconst(&sspshiftref,SSP,pw_sspshift,(short)0); 
    createinstr( &sspshiftref,(long)(temps+7  ),pw_sspshift,0);

    temps = pendallssp(&sspshiftref, 0);
    pulsename(&ssp_pass_delayref,"ssp_pass_delayref");
    createconst(&ssp_pass_delayref,SSP,pw_ssp_pass_delay,(short)0); 
    createinstr( &ssp_pass_delayref,(long)(temps),pw_ssp_pass_delay,0);
    
    temps = pendallssp(&ssp_pass_delayref, 0);
    
     
  {
    pulsename(&pass_pulseref,"pass_pulseref");
    createpass(&pass_pulseref,(long)(temps));
  }

    
#endif /* IPG */
    
/* BJM: What if the number of spin-echo slices cannot fit into the GRE TR?? */
/* compensate here...*/

    {
        int tminSeRef = tmin;
        int actTrSe = act_tr;

        /* Determine of tmin calculated is ok */
        if(tmin < RUP_GRD(non_tetime + refScanTe)) {
           tminSeRef = RUP_GRD(non_tetime + refScanTe);

        } else {

           tminSeRef = tmin;
        }

        /* MRIge78651 - removed divide by zero condition */
        /* Will the slices requested fit work for a SE Ref? */
        if( act_tr < slquant1 * tminSeRef) {

          actTrSe = RUP_GRD(slquant1*tminSeRef) + 1000;

        } else {

          actTrSe = act_tr;

        }

        /* Actual deadtimes for cardiac scans will be rewritten later */
        if(opcgate==PSD_ON)
            psd_seqtime = RUP_GRD(tminSeRef);
        else
            psd_seqtime = RUP_GRD(actTrSe/slquant1 - time_ssi);
    }

      
  {
    pulsename(&seqrefcore,"seqrefcore");
    createseq(&seqrefcore,psd_seqtime, off_seqrefcore);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrefcore );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrefcore = %d\n", idx_seqrefcore );
#endif
  }


    /* Fill echotrain xtr and rba arrays with SSP pulse structures */
    for (echoloop = 0; echoloop < tot_etl; echoloop++ ) {
        getssppulse(&(echotrainxtr_ref[echoloop]), &(refechotrain[echoloop]), "xtr", 0);
        getssppulse(&(echotrainrba_ref[echoloop]), &(refechotrain[echoloop]), "rba", 0);
    }
    
} /* End if(se_ref == PSD_ON) */

/********* End of RefScan Pulsgen Section **************/


    /* PS **************************************************************/
/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                          PSpulsegen                               *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/
PSpulsegen();
FTGpulsegen();
XTGpulsegen();
ASpulsegen();

  
    if (SatRelaxers) /* Create Null sequence for Relaxers */
        SpSatCatRelaxPG(time_ssi);
    
    /* Baseline Acquisition *********************************************/
       
  {
    bline_unblank_pack[0] = SSPDS+RDC;
    bline_unblank_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    bline_unblank_pack[2] = SSPD+RUBL;
    bline_unblank_pack[3] = SSPDS;

    pulsename(&bline_unblank,"bline_unblank");
    createbits(&bline_unblank,TYPSSP,4,bline_unblank_pack);
    createinstr( &bline_unblank,(long)((LONG)(3000)),4,ia_bline_unblank);
  }

    
                     
                    
                    
                    
                    
                    
  {
    pulsename(&blineacq1,"blineacq1");
 
    epiacqq(&blineacq1, (long)((LONG)(5000)),(long)((LONG)0),
             (long)((LONG)0), (long)(filter_blineacq1),
             (TYPDAB_PACKETS)((TYPDAB_PACKETS)DABNORM), (long)((LONG)fast_rec),
                         (long)((LONG)stddab));
  }

    
    /* set up HyperScan Dab for Baseline */
    
{
    pulsename(&hyperdabbl,"hyperdabbl");

        createhsdab(&hyperdabbl, (long)(1000));
  }

    
      
  {
    pulsename(&seqblineacq,"seqblineacq");
    createseq(&seqblineacq,bl_acq_tr2, off_seqblineacq);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqblineacq );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqblineacq = %d\n", idx_seqblineacq );
#endif
  }


      
  {
    pulsename(&seqRTclock,"seqRTclock");
    createseq(&seqRTclock,RDN_GRD(time_ssi+4), off_seqRTclock);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqRTclock );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqRTclock = %d\n", idx_seqRTclock );
#endif
  }


    buildinstr();              /* load the sequencer memory */

    if (SatRelaxers) /* Use X and Z Grad offsets from off seqcore */
        SpSatCatRelaxOffsets(off_seqcore);
    
    { /* Start of code inlined from Inversion.e InversionPG1 */
        if(ir_sys_type == 1) rfupa = ir_rfupa; /* vmx 3/13/95 YI */

/* HH      01/13/06     MRIhc13008 Fix - Enclose the whole section with ifdef IPG */
#if defined(IPG_TGT) || defined(MGD_TGT) /* MRIhc13008 */
        if (ir_on == PSD_ON)
        {
            int newres;
            int i;

            newres = res_rf0;
            if(PSD_ON == rfpulseInfo[RF0_SLOT].change) {
                newres = rfpulseInfo[RF0_SLOT].newres;
            }

            setperiod((int)pw_rf0/newres, &rf0, 0);

            rf0_freq = (int *)AllocNode((opphases*opslquant + 2)*sizeof(int));
            rf0_pha = (int *)AllocNode((opphases*opslquant + 2)*sizeof(int));

            setupslices(rf0_freq, rsp_info, opslquant, a_gzrf0,
                        1.0, rhfreqscale*opfov, TYPTRANSMIT);

            for (i=0; i<opslquant; i++)
                setupphases(rf0_pha, rf0_freq, i, rf0_phase, 0);
        }
#endif
    } /* End of code inlined from Inversion.e InversionPG1 */


    if (PSD_ON == touch_flag)
    {
#ifdef IPG
        if((fp=fopen(".SKIP_MRE_DRIVER","r"))==NULL)
        {
            /* Make frequency slightly larger to ensure that the driver
             * completes prior TR */
            if ( FAILURE == setmrtouchdriver(touch_act_freq/0.99,
                                             touch_burst_count,
                                             touch_driver_amp) )
            {
                return FAILURE;
            }
        }
#endif
    }

    /*  ***********************************************************
        Initialization
        ********************************************************** */
  
    if (oppseq == PSD_SE) {   /* point to proper waveform */
        getwave(&wave_ptr, &rf2se1b4);
	setwave(wave_ptr, &rf2, 0);
    }
    
    rspdex = dex;
    rspech = 0;
    rspchp = CHOP_ALL;
    
    num_freqs = (int)opuser21; /*jwg bb*/
   /* for (i = 0; i < opfphases; i++)
    {
	vfa_flips_angle[i] = vfa_flips[i];
    }
    */
    
#ifdef IPG
    /*
     * Execute this code only on the Tgt side
     */
    /* Find frequency offsets */
    setupslices(rf1_freq, rsp_info, opslquant, a_gzrf1, 
                (float)1, (opfov*freq_scale), TYPTRANSMIT); 
    setupslices(theta_freq, rsp_info, opslquant, a_gzrf1/omega_scale,
                (float)1, (opfov*freq_scale), TYPTRANSMIT);
    
    if (oppseq == PSD_SE || se_ref == PSD_ON)
	setupslices(rf2_freq, rsp_info, opslquant, a_gzrf2,
                    (float)1, (opfov*freq_scale), TYPTRANSMIT);

    if (ipg_trigtest == 0) {
	/* Inform the Tgt of the trigger array to be used */
	/* Following code is just here to support Tgt oversize
	   board which only supports internal gating */
	for (slice=0; slice < opslquant*opphases; slice++)
            rsptrigger[slice] = (short)TRIG_INTERN;
	slice = 0;
    }
    
    settriggerarray((short)(opslquant*opphases),rsptrigger);
    
    /* Inform the Tgt of the rotation matrix array to be used.
       For everything but CFH and CFL the sat pulses are played
       out so load the sat rotation matrix. Otherwise
       the original slice rotation matrix is used. */

    /*jwg bb may need to change this to account for num_freq loop, if needed!*/
    SpSat_set_sat1_matrix(rsprot_orig, rsprot, opslquant*opphases,
                          sat_rot_matrices, sat_rot_ex_num, sat_rot_df_num,
                          sp_satcard_loc, 0);
    
    /* Inform the Tgt of the rotation matrix array to be used */
    setrotatearray( (short)(opslquant * opphases), rsprot[0] );
#endif /* IPG */

    sl_rcvcf = (int)((float)cfreceiveroffsetfreq/ TARDIS_FREQ_RES);
    
    /* Set up SlcInAcq and AcqPtr tables for multipass scans and
     * multi-repetition scans, including cardiac gating, interleaved,
     * and sequential multi-rep modes.
     * SlcInAcq array gives number of slices per array.
     * AcqPtr array gives index to the first slice in the 
     * multislice tables for each pass. */
    
    /* cardiac gated multi-slice, multi-phase, multi-rep */
    if (opcgate==PSD_ON) {
        rspcardiacinit((short)ophrep, (short)piclckcnt);
        sliceindex = acqs - 1; /* with cardiac gating, acqs is the no. of slices */
        for (pass = 0; pass < acqs; pass++)  {
            slc_in_acq[pass] = slquant1*opphases;
            if (pass == 0) {
                acq_ptr[pass] = 0;
            } else {
                acq_ptr[pass] = sliceindex;
                sliceindex = sliceindex - 1;
	    }
  	} /* repeat the table for multi-reps */
        for (pass_rep = 1; pass_rep < pass_reps; pass_rep++)  {
            for (pass = 0; pass < acqs; pass++)  {
                slc_in_acq[pass + pass_rep*acqs] = slc_in_acq[pass];
                acq_ptr[pass + pass_rep*acqs] = acq_ptr[pass];
	    }
	}
    } else {
        if ( mph_flag==PSD_OFF ) {  /* single-rep interleaved multi-slice */
            slmod_acqs = (opslquant*reps)%acqs;
            for (pass = 0; pass < acqs; pass++) {
                slc_in_acq[pass] = (opslquant*reps)/acqs;
                if (slmod_acqs > pass)
                    slc_in_acq[pass] = slc_in_acq[pass] + 1;
                acq_ptr[pass] = (int)(opslquant/acqs) *pass;
                if (slmod_acqs <= pass)
                    acq_ptr[pass] = acq_ptr[pass] + slmod_acqs;
                else
                    acq_ptr[pass] = acq_ptr[pass] + pass;
            }
        }
        if ( (mph_flag==PSD_ON) && (acqmode==1)) {  /* mph, sequential */
            for (pass=0; pass<acqs; pass++) {  /* for sequential, acqs=opslquant */
                slc_in_acq[pass] = reps;
                acq_ptr[pass] = pass;
            }
        }
        if ( (mph_flag==PSD_ON) && (acqmode==0) ) {  /* mph, interleaved, single pass */
            for (pass = 0; pass < acqs; pass++) {
                slc_in_acq[pass] = slquant1;
                acq_ptr[pass] = 0;
                slmod_acqs = (opslquant*reps)%acqs;
                for (pass = 0; pass < acqs; pass++) {
                    slc_in_acq[pass] = (opslquant*reps)/acqs;
                    if (slmod_acqs > pass)
                        slc_in_acq[pass] = slc_in_acq[pass] + 1;
                    acq_ptr[pass] = (int)(opslquant/acqs) *pass;
                    if (slmod_acqs <= pass)
                        acq_ptr[pass] = acq_ptr[pass] + slmod_acqs;
                    else
                        acq_ptr[pass] = acq_ptr[pass] + pass;
                }
            }
            for (pass_rep = 1; pass_rep < pass_reps; pass_rep++) { /* repeat the table for multi-reps */
                for (pass = 0; pass < acqs; pass++) {
                    slc_in_acq[pass + pass_rep*acqs] = slc_in_acq[pass];
                    acq_ptr[pass + pass_rep*acqs] = acq_ptr[pass];
                }
            }
        }
    }
    
    /* Save the trigger for the prescan slice. */
    prescan_trigger = rsptrigger[acq_ptr[pre_pass] + pre_slice];

    rsptrigger_temp[0] = TRIG_INTERN;
    
#ifdef IPG
    /*
     * Execute this code only on the Tgt side
     */
    /* Save copy of scan_info table */ 
    for(temp1=0; temp1<opslquant; temp1++) {
        orig_rsp_info[temp1].rsptloc = rsp_info[temp1].rsptloc;
        orig_rsp_info[temp1].rsprloc = rsp_info[temp1].rsprloc;
        orig_rsp_info[temp1].rspphasoff = rsp_info[temp1].rspphasoff;
        for (temp2=0; temp2<9; temp2++) {
            origrot[temp1][temp2] = rsprot[temp1][temp2];
        }
    }
    
    /* Fill echotrain xtr and rba arrays with SSP pulse structures */
    for (echoloop = 0; echoloop < tot_etl; echoloop++ ) {
        getssppulse(&(echotrainxtr[echoloop]), &(echotrain[echoloop]), "xtr", 0);
        getssppulse(&(echotrainrba[echoloop]), &(echotrain[echoloop]), "rba", 0);

        if(vrgfsamp) {
            /* Attack Ramp */
            instrtemp = (WF_INSTR_HDR *)GetPulseInstrNode(&rs_omega_attack,(int)echoloop);
            echotrainramp1[echoloop] = (int)instrtemp->wf_instr_ptr;
            echotrainrampamp1[echoloop] = (short*)(&(instrtemp->amplitude)); 

            /* Flattop */
            instrtemp = (WF_INSTR_HDR *)GetPulseInstrNode(&omega_flat,(int)echoloop);
            echotrainramp[echoloop] = (int)instrtemp->wf_instr_ptr;   
            echotrainrampamp[echoloop] = (short*)(&(instrtemp->amplitude)); 
 
            /* Decay Ramp */
            instrtemp = (WF_INSTR_HDR *)GetPulseInstrNode(&rs_omega_decay,(int)echoloop);
            echotrainramp2[echoloop] = (int)instrtemp->wf_instr_ptr;
            echotrainrampamp2[echoloop] = (short*)(&(instrtemp->amplitude)); 

        } else {
           
            /* Constant Freq Offset, no ramp samp */
            instrtemp = (WF_INSTR_HDR *)GetPulseInstrNode(&omega_flat,(int)echoloop);
            echotrainramp[echoloop] = (int)instrtemp->wf_instr_ptr; 
            echotrainrampamp[echoloop] = (short*)(&(instrtemp->amplitude)); 
            
        } /* end vrgfsamp */

    } /* end echoloop */
    
    hsdabmask = PSD_LOAD_HSDAB_ALL;
    scaleomega = 0;

    /* Initialize MRE RSP variables */
/* Start inline from touch.e TouchRspInit */
if( touch_flag )
{
    /* set scale factor for 2nd set of MEGs after 180 */
    if(meg_mode == 3)
    {
        meg2_amp = (int)pow(-1.0, M_half_periods + 1);
    }
    else if(meg_mode == 2)
    {
        meg2_amp = 1;
    }
    else if(meg_mode == 1)
    {
        meg2_amp = -1;
    }
    else
    {
        meg2_amp = 0;
    }

    /* ***************************************************************************************************** */
    /* put gradient amplitudes for each motion-encoding direction into arrays to be accessed during the scan */
    /* ***************************************************************************************************** */
    touchxuamp[0] = ia_gxtouchu;
    touchxuamp[1] = touch_gamp2 * ia_gxtouchu;
    touchxdamp[0] = ia_gxtouchd;
    touchxdamp[1] = touch_gamp2 * ia_gxtouchd;
    touchxfamp[0] = ia_gxtouchf;
    touchxfamp[1] = touch_gamp2 * ia_gxtouchf;
    touchyuamp[0] = ia_gytouchu;
    touchyuamp[1] = touch_gamp2 * ia_gytouchu;
    touchydamp[0] = ia_gytouchd;
    touchydamp[1] = touch_gamp2 * ia_gytouchd;
    touchyfamp[0] = ia_gytouchf;
    touchyfamp[1] = touch_gamp2 * ia_gytouchf;
    touchzuamp[0] = ia_gztouchu;
    touchzuamp[1] = touch_gamp2 * ia_gztouchu;
    touchzdamp[0] = ia_gztouchd;
    touchzdamp[1] = touch_gamp2 * ia_gztouchd;
    touchzfamp[0] = ia_gztouchf;
    touchzfamp[1] = touch_gamp2 * ia_gztouchf;
    /* MEGs after RF2 */
    touchxuamp2[0] = meg2_amp * ia_gxtouchu2;
    touchxuamp2[1] = meg2_amp * touch_gamp2 * ia_gxtouchu2;
    touchxdamp2[0] = meg2_amp * ia_gxtouchd2;
    touchxdamp2[1] = meg2_amp * touch_gamp2 * ia_gxtouchd2;
    touchxfamp2[0] = meg2_amp * ia_gxtouchf2;
    touchxfamp2[1] = meg2_amp * touch_gamp2 * ia_gxtouchf2;
    touchyuamp2[0] = meg2_amp * ia_gytouchu2;
    touchyuamp2[1] = meg2_amp * touch_gamp2 * ia_gytouchu2;
    touchydamp2[0] = meg2_amp * ia_gytouchd2;
    touchydamp2[1] = meg2_amp * touch_gamp2 * ia_gytouchd2;
    touchyfamp2[0] = meg2_amp * ia_gytouchf2;
    touchyfamp2[1] = meg2_amp * touch_gamp2 * ia_gytouchf2;
    touchzuamp2[0] = meg2_amp * ia_gztouchu2;
    touchzuamp2[1] = meg2_amp * touch_gamp2 * ia_gztouchu2;
    touchzdamp2[0] = meg2_amp * ia_gztouchd2;
    touchzdamp2[1] = meg2_amp * touch_gamp2 * ia_gztouchd2;
    touchzfamp2[0] = meg2_amp * ia_gztouchf2;
    touchzfamp2[1] = meg2_amp * touch_gamp2 * ia_gztouchf2;

    SetTouchAmp(0);
} /* ends if (touch_flag) { */
/* End inline from touch.e TouchRspInit */


#endif /* IPG */

    return SUCCESS;

} /* end pulsegen */

/* Add MRE RSP functions for manipulating the MEG */
/* Start inline from touch.e TouchEncodePg */
void AddEncodeUp( int pos,
                  int meg_set )
{
    if( meg_set == 1 )
    {
        if( touch_xdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gxtouchu2, "gxtouchu2", &gxtouchu2, &gxtouchu2a,
                        &gxtouchu2d, pw_gxtouchu2, pw_gxtouchu2a, pw_gxtouchu2d,
                        ia_gxtouchu2, 0, 0, 0, 0, pos+pw_gxtouchu2a-pw_gxtouchu2a, TRAP_ALL,
                        &loggrd);

        }
        if( touch_ydir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gytouchu2, "gytouchu2", &gytouchu2, &gytouchu2a,
                        &gytouchu2d, pw_gytouchu2, pw_gytouchu2a, pw_gytouchu2d,
                        ia_gytouchu2, 0, 0, 0, 0, pos+pw_gytouchu2a-pw_gytouchu2a, TRAP_ALL,
                        &loggrd);

        }
        if( touch_zdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gztouchu2, "gztouchu2", &gztouchu2, &gztouchu2a,
                        &gztouchu2d, pw_gztouchu2, pw_gztouchu2a, pw_gztouchu2d,
                        ia_gztouchu2, 0, 0, 0, 0, pos+pw_gztouchu2a-pw_gztouchu2a, TRAP_ALL,
                        &loggrd);

        }
    }
    else
    {
        if( touch_xdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gxtouchu, "gxtouchu", &gxtouchu, &gxtouchua,
                        &gxtouchud, pw_gxtouchu, pw_gxtouchua, pw_gxtouchud,
                        ia_gxtouchu, 0, 0, 0, 0, pos+pw_gxtouchua-pw_gxtouchua, TRAP_ALL,
                        &loggrd);

        }
        if( touch_ydir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gytouchu, "gytouchu", &gytouchu, &gytouchua,
                        &gytouchud, pw_gytouchu, pw_gytouchua, pw_gytouchud,
                        ia_gytouchu, 0, 0, 0, 0, pos+pw_gytouchua-pw_gytouchua, TRAP_ALL,
                        &loggrd);

        }
        if( touch_zdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gztouchu, "gztouchu", &gztouchu, &gztouchua,
                        &gztouchud, pw_gztouchu, pw_gztouchua, pw_gztouchud,
                        ia_gztouchu, 0, 0, 0, 0, pos+pw_gztouchua-pw_gztouchua, TRAP_ALL,
                        &loggrd);

        }
    }
}

void AddEncodeDown( int pos,
                    int meg_set )
{
    if( meg_set == 1 )
    {
        if( touch_xdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gxtouchd2, "gxtouchd2", &gxtouchd2, &gxtouchd2a,
                        &gxtouchd2d, pw_gxtouchd2, pw_gxtouchd2a, pw_gxtouchd2d,
                        ia_gxtouchd2, 0, 0, 0, 0, pos+pw_gxtouchd2a-pw_gxtouchd2a, TRAP_ALL,
                        &loggrd);

        }
        if( touch_ydir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gytouchd2, "gytouchd2", &gytouchd2, &gytouchd2a,
                        &gytouchd2d, pw_gytouchd2, pw_gytouchd2a, pw_gytouchd2d,
                        ia_gytouchd2, 0, 0, 0, 0, pos+pw_gytouchd2a-pw_gytouchd2a, TRAP_ALL,
                        &loggrd);

        }
        if( touch_zdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gztouchd2, "gztouchd2", &gztouchd2, &gztouchd2a,
                        &gztouchd2d, pw_gztouchd2, pw_gztouchd2a, pw_gztouchd2d,
                        ia_gztouchd2, 0, 0, 0, 0, pos+pw_gztouchd2a-pw_gztouchd2a, TRAP_ALL,
                        &loggrd);

        }
    }
    else
    {
        if( touch_xdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gxtouchd, "gxtouchd", &gxtouchd, &gxtouchda,
                        &gxtouchdd, pw_gxtouchd, pw_gxtouchda, pw_gxtouchdd,
                        ia_gxtouchd, 0, 0, 0, 0, pos+pw_gxtouchda-pw_gxtouchda, TRAP_ALL,
                        &loggrd);

        }
        if( touch_ydir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gytouchd, "gytouchd", &gytouchd, &gytouchda,
                        &gytouchdd, pw_gytouchd, pw_gytouchda, pw_gytouchdd,
                        ia_gytouchd, 0, 0, 0, 0, pos+pw_gytouchda-pw_gytouchda, TRAP_ALL,
                        &loggrd);

        }
        if( touch_zdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gztouchd, "gztouchd", &gztouchd, &gztouchda,
                        &gztouchdd, pw_gztouchd, pw_gztouchda, pw_gztouchdd,
                        ia_gztouchd, 0, 0, 0, 0, pos+pw_gztouchda-pw_gztouchda, TRAP_ALL,
                        &loggrd);

        }
    }
}

void AddEncodeFcomp( int pos,
                     int meg_set )
{
    if( meg_set == 1 )
    {
        if( touch_xdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gxtouchf2, "gxtouchf2", &gxtouchf2, &gxtouchf2a,
                        &gxtouchf2d, pw_gxtouchf2, pw_gxtouchf2a, pw_gxtouchf2d,
                        ia_gxtouchf2, 0, 0, 0, 0, pos+pw_gxtouchf2a-pw_gxtouchf2a, TRAP_ALL,
                        &loggrd);

        }
        if( touch_ydir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gytouchf2, "gytouchf2", &gytouchf2, &gytouchf2a,
                        &gytouchf2d, pw_gytouchf2, pw_gytouchf2a, pw_gytouchf2d,
                        ia_gytouchf2, 0, 0, 0, 0, pos+pw_gytouchf2a-pw_gytouchf2a, TRAP_ALL,
                        &loggrd);

        }
        if( touch_zdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gztouchf2, "gztouchf2", &gztouchf2, &gztouchf2a,
                        &gztouchf2d, pw_gztouchf2, pw_gztouchf2a, pw_gztouchf2d,
                        ia_gztouchf2, 0, 0, 0, 0, pos+pw_gztouchf2a-pw_gztouchf2a, TRAP_ALL,
                        &loggrd);

        }
    }
    else
    {
        if( touch_xdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gxtouchf, "gxtouchf", &gxtouchf, &gxtouchfa,
                        &gxtouchfd, pw_gxtouchf, pw_gxtouchfa, pw_gxtouchfd,
                        ia_gxtouchf, 0, 0, 0, 0, pos+pw_gxtouchfa-pw_gxtouchfa, TRAP_ALL,
                        &loggrd);

        }
        if( touch_ydir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gytouchf, "gytouchf", &gytouchf, &gytouchfa,
                        &gytouchfd, pw_gytouchf, pw_gytouchfa, pw_gytouchfd,
                        ia_gytouchf, 0, 0, 0, 0, pos+pw_gytouchfa-pw_gytouchfa, TRAP_ALL,
                        &loggrd);

        }
        if( touch_zdir )
        {
                   

  trapezoid((WF_PROCESSOR)wg_gztouchf, "gztouchf", &gztouchf, &gztouchfa,
                        &gztouchfd, pw_gztouchf, pw_gztouchfa, pw_gztouchfd,
                        ia_gztouchf, 0, 0, 0, 0, pos+pw_gztouchfa-pw_gztouchfa, TRAP_ALL,
                        &loggrd);

        }
    }
}
/* End inline from touch.e TouchEncodePg */


#include <stdlib.h>

/* SPSP fat sat pulse*/
int *rfcssat_freq;
int *theta_cssat_freq;

/* SPSP fat sat pulse */
WF_PULSE gzrfcssat = INITPULSE;
WF_PULSE thetarfcssat = INITPULSE;


STATUS
ChemSatPG( INT chemsat_start,
           INT *cssat_index )
{
    CHAR rhoFile[256], phaFile[256];
    SHORT *rhoPulse, *phaPulse;
    SHORT *tempPulse;
    SHORT temp_res;

    int i;

    if(csat_sys_type == 1) rfupa = csat_rfupa; /* vmx 3/13/95 YI */
  
    /* Check to see if pw scaled during predownload. If TRUE then set resolution to
    ** scaled resolution.
    */
    temp_res = res_rfcssat;
    if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON)
        res_rfcssat = rfpulseInfo[RFCSSAT_SLOT].newres;
    /*  Create skeleton chemsat pulse. */
      
  {
    pulsename(&rfcssat,"rfcssat");
    createreserve(&rfcssat,(WF_PROCESSOR)wg_rfcssat,
		  res_rfcssat);
  }


    addrfbits(&rfcssat, off_rfcssat, chemsat_start+psd_rf_wait, pw_rfcssat);

    createinstr(&rfcssat, chemsat_start+psd_rf_wait, pw_rfcssat, ia_rfcssat);

    /* Reset resolution to old resolution in case of external rf pulse */
    if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
        res_rfcssat = temp_res;
    }

    switch (ChemSatPulse) {
   
    case SINC_PULSE:
    default:
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            res_rfcssat = rfpulseInfo[RFCSSAT_SLOT].newres;
        }
        rhoPulse = (short *)AllocNode(res_rfcssat*sizeof(short));
        usinc(rhoPulse, res_rfcssat, (short)max_pg_wamp, cyc_rfcssat, alpha_rfcssat);
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);
        break;

    /* SPSP fat sat pulse */
    case SPSP_FATSAT_PULSE:

        rfcssat_freq = (int *)AllocNode((opslquant + 2)*sizeof(int));
        theta_cssat_freq = (int *)AllocNode((opslquant + 2)*sizeof(int));

        for (i = 0; i < opslquant; i++)
        {
            if (spsp_fatsat_spatial_mode == 0)  /* normal mode*/
            {
                theta_cssat_freq[i] = GAM * (a_gzrfcssat/spsp_fatsat_omega_scale) * 
                                      (rsp_info[i].rsptloc + spsp_fatsat_spatial_offset)/ (10 * TARDIS_FREQ_RES);
            }
            else   /* fixed spatial sat region mode */
            {
                float center_slice_loc;
                if (opslquant%2 == 0)
                    center_slice_loc = (rsp_info[opslquant/2 - 1].rsptloc + rsp_info[opslquant/2].rsptloc)/2;
                else
                    center_slice_loc = rsp_info[(opslquant-1)/2].rsptloc;

                theta_cssat_freq[i] = GAM * (a_gzrfcssat/spsp_fatsat_omega_scale) * 
                                      (center_slice_loc + spsp_fatsat_spatial_offset)/ (10 * TARDIS_FREQ_RES);
            }
         }
         if (debug_spsp_fatsat)
         {
             FILE * debug_file_ptr;
             debug_file_ptr = fopen("/usr/g/service/log/dbgdata_theta_cssat_freq", "w");

             if (NULL != debug_file_ptr)
             {
                 fprintf(debug_file_ptr, "spsp_fatsat_spatial_mode = %d\tspsp_fatsat_spatial_offset = %f\n", 
                         spsp_fatsat_spatial_mode, spsp_fatsat_spatial_offset);
                 fprintf(debug_file_ptr, "a_gzrfcssat = %f\n", a_gzrfcssat);

                 for (i = 0; i<opslquant; i++)
                 {
                     fprintf(debug_file_ptr, "slice %d\tcssat freq = %d\n", i+1, theta_cssat_freq[i]);
                 }

                 fclose(debug_file_ptr);
             }
         }

        /* RHO */
        strcpy(rhoFile, ext_spsp_fatsat_rf_filename);
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
	        
            res_rfcssat = rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        /* Gz */                
        pulsename(&gzrfcssat,"gzrfcssat");
        createextwave( &gzrfcssat, ZGRAD, res_gzrfcssat, ext_spsp_fatsat_gz_filename );
        createinstr( &gzrfcssat, chemsat_start, pw_gzrfcssat, ia_gzrfcssat );                               

        /* Frequency */
        pulsename(&thetarfcssat,"thetarfcssat");
        createextwave( &thetarfcssat, TYPOMEGA, res_thetarfcssat, ext_spsp_fatsat_gz_filename );
        createinstr( &thetarfcssat, (long)chemsat_start + psd_rf_wait, pw_thetarfcssat, ia_thetarfcssat );
        addrfbits( &thetarfcssat, 0, (long)chemsat_start + psd_rf_wait, pw_thetarfcssat );
        
        /* Link all 3 pulses */
        linkpulses( 3, &rfcssat, &gzrfcssat, &thetarfcssat);

        break;


    case CSM_PULSE:

        strcpy(rhoFile, "rfcsm.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
	        
            res_rfcssat = rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        break;
      
    case CSMIN8_PULSE:

        strcpy(rhoFile, "rfcsmin8.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat = rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }

        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        break;
      
    case CSMAX8_PULSE:

        strcpy(rhoFile, "rfcsmax8.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);

        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat = rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else { 
            rhoPulse = tempPulse;
        }

        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        break;

    case CS3T_PULSE:				/*YH*/

        strcpy(rhoFile, "rfcs3t.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat = rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);
        break;

    case CS_HS:	
    case CS_HS_20MS:
        if (ChemSatPulse == CS_HS_20MS)
        {
            strcpy(rhoFile, "hs.rho");
            strcpy(phaFile, "hs.pha");
        }
        else if (ChemSatPulse == CS_HS)
        {
            strcpy(rhoFile, "hs_40ms.rho");
            strcpy(phaFile, "hs_40ms.pha");
        }
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat = rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        /* THETA pulse */
        {
              
  {
    pulsename(&omega_hs_rfcssat,"omega_hs_rfcssat");
    createreserve(&omega_hs_rfcssat,(WF_PROCESSOR)wg_omega_hs_rfcssat,
		  res_omega_hs_rfcssat);
  }


            addrfbits(&omega_hs_rfcssat, 0, chemsat_start+psd_rf_wait, pw_rfcssat);

            createinstr(&omega_hs_rfcssat, chemsat_start+psd_rf_wait, pw_rfcssat, ia_omega_hs_rfcssat);

            tempPulse =(short *)AllocNode(temp_res*sizeof(short));
            uextwave(tempPulse, temp_res, phaFile);
            if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
                phaPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
                stretchpulse((int)temp_res,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,phaPulse);
                FreeNode(tempPulse);
            } else {
                phaPulse = tempPulse;
            }
            movewaveimm(phaPulse, &omega_hs_rfcssat, 0, res_rfcssat, TOHARDWARE);
            FreeNode(phaPulse);
        }
        break;
    }
   
   if (PSD_ON == selectiveChemsat) 
   { 
             

  trapezoid((WF_PROCESSOR)wg_gzrfcs, "gzrfcs", &gzrfcs, &gzrfcsa,
                        &gzrfcsd, pw_gzrfcs, pw_gzrfcsa, pw_gzrfcsd,
                        ia_gzrfcs, 0, 0, 0, 0, chemsat_start-pw_gzrfcsa, TRAP_ALL,
                        &loggrd);
	
    }
   /*  Y board crusher for Chem Sat pulse  */
    /* MRIge62364 : karun Rounded up the postion for the pulses */

         
                                         

  trapezoid((WF_PROCESSOR)wg_gykcs, "gykcs", &gykcs, &gykcsa,
                        &gykcsd, pw_gykcs, pw_gykcsa, pw_gykcsd,
                        ia_gykcs, 0, 0, 0, 0, RUP_GRD(pendall(&rfcssat,*cssat_index)+pw_gykcsa-psd_rf_wait)-pw_gykcsa, TRAP_ALL,
                        &loggrd);
 
#ifdef CSXKILLER
    /*  X board crusher for Chem Sat pulse  */
         
                                         

  trapezoid((WF_PROCESSOR)wg_gxkcs, "gxkcs", &gxkcs, &gxkcsa,
                        &gxkcsd, pw_gxkcs, pw_gxkcsa, pw_gxkcsd,
                        ia_gxkcs, 0, 0, 0, 0, RUP_GRD(pendall(&rfcssat,*cssat_index)+pw_gxkcsa-psd_rf_wait)-pw_gxkcsa, TRAP_ALL,
                        &loggrd);

#endif
#ifdef CSZKILLER
    /*  Z board crusher for Chem Sat pulse  */
         
                                         

  trapezoid((WF_PROCESSOR)wg_gzkcs, "gzkcs", &gzkcs, &gzkcsa,
                        &gzkcsd, pw_gzkcs, pw_gzkcsa, pw_gzkcsd,
                        ia_gzkcs, 0, 0, 0, 0, RUP_GRD(pendall(&rfcssat,*cssat_index)+pw_gzrfcsd+pw_gzkcsa-psd_rf_wait)-pw_gzkcsa, TRAP_ALL,
                        &loggrd);


#endif
	
#ifdef PSD_CHEMSAT_SEQ
    if (*cssat_index == 0)
    {
          
  {
    pulsename(&seqcssat,"seqcssat");
    createseq(&seqcssat,RUP_GRD(cs_sattime+cs_satstart), off_seqcssat);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcssat );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcssat = %d\n", idx_seqcssat );
#endif
  }

        /* Assert the ESSP flag on the sync packet byte seq length */
        attenflagon(&seqcssat, 0);
    }
#endif
	
    /* Initialize for RSP */
    cstun = 0;
    amp_gykcs = ia_gykcs;
#ifdef CSXKILLER
    amp_gxkcs = ia_gxkcs;
#endif
#ifdef CSZKILLER
    amp_gzkcs = ia_gzkcs;
#endif
    csa = a_rfcssat * 1000;
    csf = off_rfcssat;
    *cssat_index += 1;

    /* Set the maximum of the csa corresponds to 360 degree */      
    max_csa = csa * CS_MAXFLIP/ flip_sat;  
	
    return SUCCESS;
} 
    
    
STATUS
SpSatPG( INT sat_type,
         INT start_time,
         INT *sat_index,
         INT cardiacsat_pos )
{
    SHORT *kernel_tab_rho = NULL; 
    SHORT *hadamard_tab_rho = NULL;
    SHORT *temp_wave_rho = NULL;
    SHORT *wave_space_rho = NULL;
    SHORT *kernel_tab_theta = NULL;
    SHORT *hadamard_tab_theta = NULL;
    SHORT *temp_wave_theta = NULL;
    EXTERN_FILENAME rho_file;
    EXTERN_FILENAME theta_file;  

    INT    skip_next_sat;
    long    ctrl_word;

    INT    sp_sattemp;
    FLOAT  separation; /* slice separation of hadamards in slice thickness */
    INT    sp_pos_killer;
    FLOAT  freqstep;
    INT  temp_sat_index;
  
    int rot_update_time;

    int ending;

    if(spsat_sys_type == 1) rfupa = spsat_rfupa; /* vmx 3/13/95 YI */

    sp_first_scan = 1;  /* First scan since download. This flag is used
                           to determine when rotation matrices need to
                           be copied over. This needs to be set even if
                           sat is off. */

    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return(SUCCESS);

    /* Change resolutions since SpSatPG can be called multiple times. i.e. sat1, sat2, sat3 
       conditions*/
    switch (sat_type)
    {
    case SINC_SAT:
	{
            res_rfse1 = RES_NVRGSAT;
            res_rfse2 = RES_NVRGSAT;
            res_rfse3 = RES_NVRGSAT;
            res_rfse4 = RES_NVRGSAT;
            res_rfse5 = RES_NVRGSAT;
            res_rfse6 = RES_NVRGSAT;
            res_rfsx1 = RES_NVRGSAT;
            res_rfsx2 = RES_NVRGSAT;
            res_rfsy1 = RES_NVRGSAT;
            res_rfsy2 = RES_NVRGSAT;
            res_rfsz1 = RES_NVRGSAT;
            res_rfsz2 = RES_NVRGSAT;
	    /* YMSmr09579 04-Oct-2006 HK */
            if (pw_rfse1==4800 ) res_rfse1 = RES_SLRSAT;
            if (pw_rfse2==4800 ) res_rfse2 = RES_SLRSAT;
            if (pw_rfse3==4800 ) res_rfse3 = RES_SLRSAT;
            if (pw_rfse4==4800 ) res_rfse4 = RES_SLRSAT;
            if (pw_rfse5==4800 ) res_rfse5 = RES_SLRSAT;
            if (pw_rfse6==4800 ) res_rfse6 = RES_SLRSAT;
            if (pw_rfsx1==4800 ) res_rfsx1 = RES_SLRSAT;
            if (pw_rfsx2==4800 ) res_rfsx2 = RES_SLRSAT;
            if (pw_rfsy1==4800 ) res_rfsy1 = RES_SLRSAT;
            if (pw_rfsy2==4800 ) res_rfsy2 = RES_SLRSAT;
            if (pw_rfsz1==4800 ) res_rfsz1 = RES_SLRSAT;
            if (pw_rfsz2==4800 ) res_rfsz2 = RES_SLRSAT;
            break;
	}
    case SLR_SAT:
	{
            res_rfse1 = RES_SLRSAT;
            res_rfse2 = RES_SLRSAT;
            res_rfse3 = RES_SLRSAT;
            res_rfse4 = RES_SLRSAT;
            res_rfse5 = RES_SLRSAT;
            res_rfse6 = RES_SLRSAT;
            res_rfsx1 = RES_SLRSAT;
            res_rfsx2 = RES_SLRSAT;
            res_rfsy1 = RES_SLRSAT;
            res_rfsy2 = RES_SLRSAT;
            res_rfsz1 = RES_SLRSAT;
            res_rfsz2 = RES_SLRSAT;
            break;
	}
    case SLR_CSAT:
        {
            res_rfse1 = RES_SLRCSAT;
            res_rfse2 = RES_SLRCSAT;
            res_rfse3 = RES_SLRCSAT;
            res_rfse4 = RES_SLRCSAT;
            res_rfse5 = RES_SLRCSAT;
            res_rfse6 = RES_SLRCSAT;
            res_rfsx1 = RES_SLRCSAT;
            res_rfsx2 = RES_SLRCSAT;
            res_rfsy1 = RES_SLRCSAT;
            res_rfsy2 = RES_SLRCSAT;
            res_rfsz1 = RES_SLRCSAT;
            res_rfsz2 = RES_SLRCSAT;
            break;
        }
    default:
	break;
    }

    sp_sattemp = start_time;

    /* In cardiac scan, there may not be enough time at the beginning
       of the scan for the sat pulses. In this case, the sats are moved
       to the end of the sequence. (i.e. cardiacsat_pos != 0 ) For this
       case an isi interrupt is added before the sats the prepare the
       first rotation matrix.

       If the sats are played at the beginning of a sequence, the first
       rotation matrix is loaded by the psd. 

       Note that the sat index is 0. Since only one sat sequence will
       use this extra SSP packet, the index is 0 not sat_index. */

    /* ************************************************************ *
     * MRIge50713 - change the index to sat_index instead of using  *
     * index 0 always.                                              *
     *                                                              *
     * This is necessary because in the new FSE phase correction,   *
     * two copies of SpSat instructions are generated. The first    *
     * is for fse pulse sequence (seqcore), the 2nd copy is for fse *
     * phase correction pulse sequence (seqfseps). If the index     *
     * remains always 0, the seqfseps will overwrite the seqcore.   *
     * ************************************************************ */
 
    if (cardiacsat_pos != 0)
    {

    	/*
          MRIge51141 - Use sat_index only for FAST sequences.
	*/

        if ( opfast==PSD_ON )	{
            temp_sat_index = *sat_index ;
	} else 	{
            temp_sat_index = 0;
	}

           
  {
    pulsename(&isi_cardiacsat,"isi_cardiacsat");
    createconst(&isi_cardiacsat,(WF_PROCESSOR)wg_isi_cardiacsat,pw_isi_cardiacsat,(short)0); 
    createinstr( &isi_cardiacsat,(long)(sp_sattemp),pw_isi_cardiacsat,0);
  }

        getctrl(&ctrl_word, &isi_cardiacsat, temp_sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT ;
        setctrl(ctrl_word, &isi_cardiacsat, temp_sat_index);
        sp_sattemp =  sp_sattemp + pw_isisat;

           
  {
    pulsename(&rot_update_cardiacsat,"rot_update_cardiacsat");
    createconst(&rot_update_cardiacsat,(WF_PROCESSOR)wg_rot_update_cardiacsat,pw_rot_update_cardiacsat,(short)0); 
    createinstr( &rot_update_cardiacsat,(long)(sp_sattemp),pw_rot_update_cardiacsat,0);
  }

        getctrl(&ctrl_word, &rot_update_cardiacsat, temp_sat_index);
        ctrl_word = ctrl_word |PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_cardiacsat, temp_sat_index);
        sp_sattemp =  sp_sattemp + pw_rotupdate;

    }
 
    /****************************************************************

            EXPLICIT SAT GRADIENTS

       1. Slice selection gradient
       2. Killer on y gradient
       3. If there are 2 sat bands that are parallel but do not have
          the same thickness, create a separate slice select & killer
          for the second band.
    ******************************************************************/

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_1) != 0)
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse1", 
                                     (WF_PROCESSOR)wg_rfse1);

    /* Modify resolution if scaling required */
    temp_res_rfse1 = res_rfse1;
    if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
       res_rfse1 = rfpulseInfo[RFSE1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse1a,"gzrfse1a");
    pulsename(&gzrfse1,"gzrfse1");
    pulsename(&gzrfse1d,"gzrfse1d");
    pulsename(&rfse1,"rfse1");

    /*  Now create the slice select trapezoid */
        pg_beta = satloggrd.zbeta;
    createramp(&gzrfse1a,ZGRAD,pw_gzrfse1a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse1a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse1a,(LONG)(sp_sattemp+pw_gzrfse1a-pw_gzrfse1a),
                pw_gzrfse1a,ia_gzrfse1);
    createconst(&gzrfse1,ZGRAD,pw_gzrfse1,MAX_PG_WAMP);
    createinstr( &gzrfse1,(LONG)(sp_sattemp+pw_gzrfse1a),
                pw_gzrfse1,ia_gzrfse1);
    createramp(&gzrfse1d,ZGRAD,pw_gzrfse1d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse1d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse1d,(LONG)(sp_sattemp+pw_gzrfse1a+pw_gzrfse1),
                pw_gzrfse1d,ia_gzrfse1);

    /* Now create the rf pulse */
    createsinc(&rfse1,(WF_PROCESSOR)wg_rfse1,res_rfse1,
               MAX_PG_WAMP,cyc_rfse1, alpha_rfse1);

    createinstr( &rfse1,(LONG)(sp_sattemp+pw_gzrfse1a) + psd_rf_wait,
                pw_rfse1,ia_rfse1);
    linkpulses(4,&rfse1,&gzrfse1,&gzrfse1a,
               &gzrfse1d);
    addrfbits(&rfse1,off_rfse1,(LONG)(sp_sattemp+pw_gzrfse1a) + psd_rf_wait,
              pw_rfse1);



    pulsename(&rfse1Theta, "rfse1Theta");
    createreserve(&rfse1Theta, THETA, res_rfse1);
    addrfbits(&rfse1Theta, off_rfse1, (LONG)(sp_sattemp+pw_gzrfse1a) + psd_rf_wait , pw_rfse1);
    createinstr(&rfse1Theta, (LONG)(sp_sattemp+pw_gzrfse1a) + psd_rf_wait, pw_rfse1, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
       res_rfse1 = temp_res_rfse1;
  }


        sp_sattemp = pend(&gzrfse1d, "gzrfse1d", *sat_index);

        ending = pendallssp(&rfse1, *sat_index);
 
           
  {
    pulsename(&isi_sate1,"isi_sate1");
    createconst(&isi_sate1,(WF_PROCESSOR)wg_isi_sate1,pw_isi_sate1,(short)0); 
    createinstr( &isi_sate1,(long)(ending),pw_isi_sate1,0);
  }

        getctrl(&ctrl_word, &isi_sate1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT ;
        setctrl(ctrl_word, &isi_sate1, *sat_index);

        rot_update_time = RUP_GRD(IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
           
  {
    pulsename(&rot_update_e1,"rot_update_e1");
    createconst(&rot_update_e1,(WF_PROCESSOR)wg_rot_update_e1,pw_rot_update_e1,(short)0); 
    createinstr( &rot_update_e1,(long)(rot_update_time),pw_rot_update_e1,0);
  }

        getctrl(&ctrl_word, &rot_update_e1, *sat_index);
        ctrl_word = ctrl_word |PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_e1, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse1a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse1, "gykse1", &gykse1, &gykse1a,
                        &gykse1d, pw_gykse1, pw_gykse1a, pw_gykse1d,
                        ia_gykse1, 0, 0, 0, 0, sp_pos_killer-pw_gykse1a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse1d, "gykse1d", *sat_index);

        if (area_gxkse1!=0.0)
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse1, "gxkse1", &gxkse1, &gxkse1a,
                        &gxkse1d, pw_gxkse1, pw_gxkse1a, pw_gxkse1d,
                        ia_gxkse1, 0, 0, 0, 0, sp_pos_killer-pw_gxkse1a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse1d, "gxkse1d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse1d, "gxkse1d", *sat_index);
        }
	  
             
  {
    pulsename(&isi_satek1,"isi_satek1");
    createconst(&isi_satek1,(WF_PROCESSOR)wg_isi_satek1,pw_isi_satek1,(short)0); 
    createinstr( &isi_satek1,(long)(sp_sattemp-isi_satdelay),pw_isi_satek1,0);
  }

        getctrl(&ctrl_word, &isi_satek1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT ;
        setctrl(ctrl_word, &isi_satek1, *sat_index);
	  
               
  {
    pulsename(&rot_update_ek1,"rot_update_ek1");
    createconst(&rot_update_ek1,(WF_PROCESSOR)wg_rot_update_ek1,pw_rot_update_ek1,(short)0); 
    createinstr( &rot_update_ek1,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek1,0);
  }

        getctrl(&ctrl_word, &rot_update_ek1, *sat_index);
        ctrl_word = ctrl_word |PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_ek1, *sat_index);

        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay + pw_isisat + pw_rotupdate + isi_extra;

        if ((opexsatparal & PSD_1_PARALLEL) != 0)
            skip_next_sat = 1;
    }

    if (((opexsatmask & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0))
    {
             
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse2", 
                                     (WF_PROCESSOR)wg_rfse2);

    /* Modify resolution if scaling required */
    temp_res_rfse2 = res_rfse2;
    if (rfpulseInfo[RFSE2_SLOT].change==PSD_ON)
       res_rfse2 = rfpulseInfo[RFSE2_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse2a,"gzrfse2a");
    pulsename(&gzrfse2,"gzrfse2");
    pulsename(&gzrfse2d,"gzrfse2d");
    pulsename(&rfse2,"rfse2");

    /*  Now create the slice select trapezoid */
        pg_beta = satloggrd.zbeta;
    createramp(&gzrfse2a,ZGRAD,pw_gzrfse2a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse2a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse2a,(LONG)(sp_sattemp+pw_gzrfse2a-pw_gzrfse2a),
                pw_gzrfse2a,ia_gzrfse2);
    createconst(&gzrfse2,ZGRAD,pw_gzrfse2,MAX_PG_WAMP);
    createinstr( &gzrfse2,(LONG)(sp_sattemp+pw_gzrfse2a),
                pw_gzrfse2,ia_gzrfse2);
    createramp(&gzrfse2d,ZGRAD,pw_gzrfse2d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse2d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse2d,(LONG)(sp_sattemp+pw_gzrfse2a+pw_gzrfse2),
                pw_gzrfse2d,ia_gzrfse2);

    /* Now create the rf pulse */
    createsinc(&rfse2,(WF_PROCESSOR)wg_rfse2,res_rfse2,
               MAX_PG_WAMP,cyc_rfse2, alpha_rfse2);

    createinstr( &rfse2,(LONG)(sp_sattemp+pw_gzrfse2a) + psd_rf_wait,
                pw_rfse2,ia_rfse2);
    linkpulses(4,&rfse2,&gzrfse2,&gzrfse2a,
               &gzrfse2d);
    addrfbits(&rfse2,off_rfse2,(LONG)(sp_sattemp+pw_gzrfse2a) + psd_rf_wait,
              pw_rfse2);



    pulsename(&rfse2Theta, "rfse2Theta");
    createreserve(&rfse2Theta, THETA, res_rfse2);
    addrfbits(&rfse2Theta, off_rfse2, (LONG)(sp_sattemp+pw_gzrfse2a) + psd_rf_wait , pw_rfse2);
    createinstr(&rfse2Theta, (LONG)(sp_sattemp+pw_gzrfse2a) + psd_rf_wait, pw_rfse2, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE2_SLOT].change==PSD_ON)
       res_rfse2 = temp_res_rfse2;
  }

        sp_sattemp = pend(&gzrfse2d, "gzrfse2d" , *sat_index);

        ending = pendallssp(&rfse2, *sat_index);

           
  {
    pulsename(&isi_sate2,"isi_sate2");
    createconst(&isi_sate2,(WF_PROCESSOR)wg_isi_sate2,pw_isi_sate2,(short)0); 
    createinstr( &isi_sate2,(long)(ending),pw_isi_sate2,0);
  }

        getctrl(&ctrl_word, &isi_sate2, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate2, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e2,"rot_update_e2");
    createconst(&rot_update_e2,(WF_PROCESSOR)wg_rot_update_e2,pw_rot_update_e2,(short)0); 
    createinstr( &rot_update_e2,(long)(rot_update_time),pw_rot_update_e2,0);
  }

        getctrl(&ctrl_word, &rot_update_e2, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_e2, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse2a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse2, "gykse2", &gykse2, &gykse2a,
                        &gykse2d, pw_gykse2, pw_gykse2a, pw_gykse2d,
                        ia_gykse2, 0, 0, 0, 0, sp_pos_killer-pw_gykse2a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse2d, "gykse2d", *sat_index);

        if (area_gxkse2!=0.0)
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse2, "gxkse2", &gxkse2, &gxkse2a,
                        &gxkse2d, pw_gxkse2, pw_gxkse2a, pw_gxkse2d,
                        ia_gxkse2, 0, 0, 0, 0, sp_pos_killer-pw_gxkse2a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse2d, "gxkse2d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse2d, "gxkse2d", *sat_index);
        }

             
  {
    pulsename(&isi_satek2,"isi_satek2");
    createconst(&isi_satek2,(WF_PROCESSOR)wg_isi_satek2,pw_isi_satek2,(short)0); 
    createinstr( &isi_satek2,(long)(sp_sattemp-isi_satdelay),pw_isi_satek2,0);
  }

        getctrl(&ctrl_word, &isi_satek2, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek2, *sat_index);

               
  {
    pulsename(&rot_update_ek2,"rot_update_ek2");
    createconst(&rot_update_ek2,(WF_PROCESSOR)wg_rot_update_ek2,pw_rot_update_ek2,(short)0); 
    createinstr( &rot_update_ek2,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek2,0);
  }

        getctrl(&ctrl_word, &rot_update_ek2, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_ek2, *sat_index);

        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat + pw_rotupdate + isi_extra;
    } 

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_3) != 0)
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse3", 
                                     (WF_PROCESSOR)wg_rfse3);

    /* Modify resolution if scaling required */
    temp_res_rfse3 = res_rfse3;
    if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
       res_rfse3 = rfpulseInfo[RFSE3_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse3a,"gzrfse3a");
    pulsename(&gzrfse3,"gzrfse3");
    pulsename(&gzrfse3d,"gzrfse3d");
    pulsename(&rfse3,"rfse3");

    /*  Now create the slice select trapezoid */
        pg_beta = satloggrd.zbeta;
    createramp(&gzrfse3a,ZGRAD,pw_gzrfse3a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse3a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse3a,(LONG)(sp_sattemp+pw_gzrfse3a-pw_gzrfse3a),
                pw_gzrfse3a,ia_gzrfse3);
    createconst(&gzrfse3,ZGRAD,pw_gzrfse3,MAX_PG_WAMP);
    createinstr( &gzrfse3,(LONG)(sp_sattemp+pw_gzrfse3a),
                pw_gzrfse3,ia_gzrfse3);
    createramp(&gzrfse3d,ZGRAD,pw_gzrfse3d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse3d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse3d,(LONG)(sp_sattemp+pw_gzrfse3a+pw_gzrfse3),
                pw_gzrfse3d,ia_gzrfse3);

    /* Now create the rf pulse */
    createsinc(&rfse3,(WF_PROCESSOR)wg_rfse3,res_rfse3,
               MAX_PG_WAMP,cyc_rfse3, alpha_rfse3);

    createinstr( &rfse3,(LONG)(sp_sattemp+pw_gzrfse3a) + psd_rf_wait,
                pw_rfse3,ia_rfse3);
    linkpulses(4,&rfse3,&gzrfse3,&gzrfse3a,
               &gzrfse3d);
    addrfbits(&rfse3,off_rfse3,(LONG)(sp_sattemp+pw_gzrfse3a) + psd_rf_wait,
              pw_rfse3);



    pulsename(&rfse3Theta, "rfse3Theta");
    createreserve(&rfse3Theta, THETA, res_rfse3);
    addrfbits(&rfse3Theta, off_rfse3, (LONG)(sp_sattemp+pw_gzrfse3a) + psd_rf_wait , pw_rfse3);
    createinstr(&rfse3Theta, (LONG)(sp_sattemp+pw_gzrfse3a) + psd_rf_wait, pw_rfse3, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
       res_rfse3 = temp_res_rfse3;
  }


        sp_sattemp = pend(&gzrfse3d, "gzrfse3d" , *sat_index);

        ending = pendallssp(&rfse3, *sat_index);

           
  {
    pulsename(&isi_sate3,"isi_sate3");
    createconst(&isi_sate3,(WF_PROCESSOR)wg_isi_sate3,pw_isi_sate3,(short)0); 
    createinstr( &isi_sate3,(long)(ending),pw_isi_sate3,0);
  }

        getctrl(&ctrl_word, &isi_sate3, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate3, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e3,"rot_update_e3");
    createconst(&rot_update_e3,(WF_PROCESSOR)wg_rot_update_e3,pw_rot_update_e3,(short)0); 
    createinstr( &rot_update_e3,(long)(rot_update_time),pw_rot_update_e3,0);
  }

        getctrl(&ctrl_word, &rot_update_e3, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_e3, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse3a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse3, "gykse3", &gykse3, &gykse3a,
                        &gykse3d, pw_gykse3, pw_gykse3a, pw_gykse3d,
                        ia_gykse3, 0, 0, 0, 0, sp_pos_killer-pw_gykse3a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse3d, "gykse3d", *sat_index);

        if (area_gxkse3!=0.0)
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse3, "gxkse3", &gxkse3, &gxkse3a,
                        &gxkse3d, pw_gxkse3, pw_gxkse3a, pw_gxkse3d,
                        ia_gxkse3, 0, 0, 0, 0, sp_pos_killer-pw_gxkse3a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse3d, "gxkse3d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse3d, "gxkse3d", *sat_index);
        }

              
  {
    pulsename(&isi_satek3,"isi_satek3");
    createconst(&isi_satek3,(WF_PROCESSOR)wg_isi_satek3,pw_isi_satek3,(short)0); 
    createinstr( &isi_satek3,(long)(sp_sattemp-isi_satdelay),pw_isi_satek3,0);
  }

        getctrl(&ctrl_word, &isi_satek3, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek3, *sat_index);

                
  {
    pulsename(&rot_update_ek3,"rot_update_ek3");
    createconst(&rot_update_ek3,(WF_PROCESSOR)wg_rot_update_ek3,pw_rot_update_ek3,(short)0); 
    createinstr( &rot_update_ek3,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek3,0);
  }

        getctrl(&ctrl_word, &rot_update_ek3, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_ek3, *sat_index);

        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat + pw_rotupdate + isi_extra;

        if ((opexsatparal &  PSD_2_PARALLEL) != 0)
            skip_next_sat = 1;
    }

    if (((opexsatmask & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0))
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse4", 
                                     (WF_PROCESSOR)wg_rfse4);

    /* Modify resolution if scaling required */
    temp_res_rfse4 = res_rfse4;
    if (rfpulseInfo[RFSE4_SLOT].change==PSD_ON)
       res_rfse4 = rfpulseInfo[RFSE4_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse4a,"gzrfse4a");
    pulsename(&gzrfse4,"gzrfse4");
    pulsename(&gzrfse4d,"gzrfse4d");
    pulsename(&rfse4,"rfse4");

    /*  Now create the slice select trapezoid */
        pg_beta = satloggrd.zbeta;
    createramp(&gzrfse4a,ZGRAD,pw_gzrfse4a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse4a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse4a,(LONG)(sp_sattemp+pw_gzrfse4a-pw_gzrfse4a),
                pw_gzrfse4a,ia_gzrfse4);
    createconst(&gzrfse4,ZGRAD,pw_gzrfse4,MAX_PG_WAMP);
    createinstr( &gzrfse4,(LONG)(sp_sattemp+pw_gzrfse4a),
                pw_gzrfse4,ia_gzrfse4);
    createramp(&gzrfse4d,ZGRAD,pw_gzrfse4d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse4d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse4d,(LONG)(sp_sattemp+pw_gzrfse4a+pw_gzrfse4),
                pw_gzrfse4d,ia_gzrfse4);

    /* Now create the rf pulse */
    createsinc(&rfse4,(WF_PROCESSOR)wg_rfse4,res_rfse4,
               MAX_PG_WAMP,cyc_rfse4, alpha_rfse4);

    createinstr( &rfse4,(LONG)(sp_sattemp+pw_gzrfse4a) + psd_rf_wait,
                pw_rfse4,ia_rfse4);
    linkpulses(4,&rfse4,&gzrfse4,&gzrfse4a,
               &gzrfse4d);
    addrfbits(&rfse4,off_rfse4,(LONG)(sp_sattemp+pw_gzrfse4a) + psd_rf_wait,
              pw_rfse4);



    pulsename(&rfse4Theta, "rfse4Theta");
    createreserve(&rfse4Theta, THETA, res_rfse4);
    addrfbits(&rfse4Theta, off_rfse4, (LONG)(sp_sattemp+pw_gzrfse4a) + psd_rf_wait , pw_rfse4);
    createinstr(&rfse4Theta, (LONG)(sp_sattemp+pw_gzrfse4a) + psd_rf_wait, pw_rfse4, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE4_SLOT].change==PSD_ON)
       res_rfse4 = temp_res_rfse4;
  }


        sp_sattemp = pend(&gzrfse4d, "gzrfse4d" , *sat_index);

        ending = pendallssp(&rfse4, *sat_index);
           
  {
    pulsename(&isi_sate4,"isi_sate4");
    createconst(&isi_sate4,(WF_PROCESSOR)wg_isi_sate4,pw_isi_sate4,(short)0); 
    createinstr( &isi_sate4,(long)(ending),pw_isi_sate4,0);
  }

        getctrl(&ctrl_word, &isi_sate4, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate4, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e4,"rot_update_e4");
    createconst(&rot_update_e4,(WF_PROCESSOR)wg_rot_update_e4,pw_rot_update_e4,(short)0); 
    createinstr( &rot_update_e4,(long)(rot_update_time),pw_rot_update_e4,0);
  }

        getctrl(&ctrl_word, &rot_update_e4, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_e4, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse4a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse4, "gykse4", &gykse4, &gykse4a,
                        &gykse4d, pw_gykse4, pw_gykse4a, pw_gykse4d,
                        ia_gykse4, 0, 0, 0, 0, sp_pos_killer-pw_gykse4a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse4d, "gykse4d", *sat_index);

        if (area_gxkse4!=0.0)
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse4, "gxkse4", &gxkse4, &gxkse4a,
                        &gxkse4d, pw_gxkse4, pw_gxkse4a, pw_gxkse4d,
                        ia_gxkse4, 0, 0, 0, 0, sp_pos_killer-pw_gxkse4a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse4d, "gxkse4d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse4d, "gxkse4d", *sat_index);
        }

              
  {
    pulsename(&isi_satek4,"isi_satek4");
    createconst(&isi_satek4,(WF_PROCESSOR)wg_isi_satek4,pw_isi_satek4,(short)0); 
    createinstr( &isi_satek4,(long)(sp_sattemp-isi_satdelay),pw_isi_satek4,0);
  }

        getctrl(&ctrl_word, &isi_satek4, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek4, *sat_index);

                
  {
    pulsename(&rot_update_ek4,"rot_update_ek4");
    createconst(&rot_update_ek4,(WF_PROCESSOR)wg_rot_update_ek4,pw_rot_update_ek4,(short)0); 
    createinstr( &rot_update_ek4,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek4,0);
  }

        getctrl(&ctrl_word, &rot_update_ek4, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_ek4, *sat_index);

        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat + pw_rotupdate + isi_extra;
    } 

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_5) != 0)
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse5", 
                                     (WF_PROCESSOR)wg_rfse5);

    /* Modify resolution if scaling required */
    temp_res_rfse5 = res_rfse5;
    if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
       res_rfse5 = rfpulseInfo[RFSE5_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse5a,"gzrfse5a");
    pulsename(&gzrfse5,"gzrfse5");
    pulsename(&gzrfse5d,"gzrfse5d");
    pulsename(&rfse5,"rfse5");

    /*  Now create the slice select trapezoid */
        pg_beta = satloggrd.zbeta;
    createramp(&gzrfse5a,ZGRAD,pw_gzrfse5a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse5a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse5a,(LONG)(sp_sattemp+pw_gzrfse5a-pw_gzrfse5a),
                pw_gzrfse5a,ia_gzrfse5);
    createconst(&gzrfse5,ZGRAD,pw_gzrfse5,MAX_PG_WAMP);
    createinstr( &gzrfse5,(LONG)(sp_sattemp+pw_gzrfse5a),
                pw_gzrfse5,ia_gzrfse5);
    createramp(&gzrfse5d,ZGRAD,pw_gzrfse5d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse5d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse5d,(LONG)(sp_sattemp+pw_gzrfse5a+pw_gzrfse5),
                pw_gzrfse5d,ia_gzrfse5);

    /* Now create the rf pulse */
    createsinc(&rfse5,(WF_PROCESSOR)wg_rfse5,res_rfse5,
               MAX_PG_WAMP,cyc_rfse5, alpha_rfse5);

    createinstr( &rfse5,(LONG)(sp_sattemp+pw_gzrfse5a) + psd_rf_wait,
                pw_rfse5,ia_rfse5);
    linkpulses(4,&rfse5,&gzrfse5,&gzrfse5a,
               &gzrfse5d);
    addrfbits(&rfse5,off_rfse5,(LONG)(sp_sattemp+pw_gzrfse5a) + psd_rf_wait,
              pw_rfse5);



    pulsename(&rfse5Theta, "rfse5Theta");
    createreserve(&rfse5Theta, THETA, res_rfse5);
    addrfbits(&rfse5Theta, off_rfse5, (LONG)(sp_sattemp+pw_gzrfse5a) + psd_rf_wait , pw_rfse5);
    createinstr(&rfse5Theta, (LONG)(sp_sattemp+pw_gzrfse5a) + psd_rf_wait, pw_rfse5, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
       res_rfse5 = temp_res_rfse5;
  }


        sp_sattemp = pend(&gzrfse5d, "gzrfse5d" , *sat_index);

        ending = pendallssp(&rfse5, *sat_index);
           
  {
    pulsename(&isi_sate5,"isi_sate5");
    createconst(&isi_sate5,(WF_PROCESSOR)wg_isi_sate5,pw_isi_sate5,(short)0); 
    createinstr( &isi_sate5,(long)(ending),pw_isi_sate5,0);
  }

        getctrl(&ctrl_word, &isi_sate5, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate5, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e5,"rot_update_e5");
    createconst(&rot_update_e5,(WF_PROCESSOR)wg_rot_update_e5,pw_rot_update_e5,(short)0); 
    createinstr( &rot_update_e5,(long)(rot_update_time),pw_rot_update_e5,0);
  }

        getctrl(&ctrl_word, &rot_update_e5, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_e5, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse5a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse5, "gykse5", &gykse5, &gykse5a,
                        &gykse5d, pw_gykse5, pw_gykse5a, pw_gykse5d,
                        ia_gykse5, 0, 0, 0, 0, sp_pos_killer-pw_gykse5a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse5d, "gykse5d", *sat_index);

        if (area_gxkse5!=0.0)
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse5, "gxkse5", &gxkse5, &gxkse5a,
                        &gxkse5d, pw_gxkse5, pw_gxkse5a, pw_gxkse5d,
                        ia_gxkse5, 0, 0, 0, 0, sp_pos_killer-pw_gxkse5a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse5d, "gxkse5d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse5d, "gxkse5d", *sat_index);
        }

              
  {
    pulsename(&isi_satek5,"isi_satek5");
    createconst(&isi_satek5,(WF_PROCESSOR)wg_isi_satek5,pw_isi_satek5,(short)0); 
    createinstr( &isi_satek5,(long)(sp_sattemp-isi_satdelay),pw_isi_satek5,0);
  }

        getctrl(&ctrl_word, &isi_satek5, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek5, *sat_index);

                
  {
    pulsename(&rot_update_ek5,"rot_update_ek5");
    createconst(&rot_update_ek5,(WF_PROCESSOR)wg_rot_update_ek5,pw_rot_update_ek5,(short)0); 
    createinstr( &rot_update_ek5,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek5,0);
  }

        getctrl(&ctrl_word, &rot_update_ek5, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_ek5, *sat_index);
          
        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat+pw_rotupdate + isi_extra;

        if ((opexsatparal & PSD_3_PARALLEL) != 0)
            skip_next_sat = 1;
    }

    if (((opexsatmask & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0))
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse6", 
                                     (WF_PROCESSOR)wg_rfse6);

    /* Modify resolution if scaling required */
    temp_res_rfse6 = res_rfse6;
    if (rfpulseInfo[RFSE6_SLOT].change==PSD_ON)
       res_rfse6 = rfpulseInfo[RFSE6_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse6a,"gzrfse6a");
    pulsename(&gzrfse6,"gzrfse6");
    pulsename(&gzrfse6d,"gzrfse6d");
    pulsename(&rfse6,"rfse6");

    /*  Now create the slice select trapezoid */
        pg_beta = satloggrd.zbeta;
    createramp(&gzrfse6a,ZGRAD,pw_gzrfse6a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse6a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse6a,(LONG)(sp_sattemp+pw_gzrfse6a-pw_gzrfse6a),
                pw_gzrfse6a,ia_gzrfse6);
    createconst(&gzrfse6,ZGRAD,pw_gzrfse6,MAX_PG_WAMP);
    createinstr( &gzrfse6,(LONG)(sp_sattemp+pw_gzrfse6a),
                pw_gzrfse6,ia_gzrfse6);
    createramp(&gzrfse6d,ZGRAD,pw_gzrfse6d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse6d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse6d,(LONG)(sp_sattemp+pw_gzrfse6a+pw_gzrfse6),
                pw_gzrfse6d,ia_gzrfse6);

    /* Now create the rf pulse */
    createsinc(&rfse6,(WF_PROCESSOR)wg_rfse6,res_rfse6,
               MAX_PG_WAMP,cyc_rfse6, alpha_rfse6);

    createinstr( &rfse6,(LONG)(sp_sattemp+pw_gzrfse6a) + psd_rf_wait,
                pw_rfse6,ia_rfse6);
    linkpulses(4,&rfse6,&gzrfse6,&gzrfse6a,
               &gzrfse6d);
    addrfbits(&rfse6,off_rfse6,(LONG)(sp_sattemp+pw_gzrfse6a) + psd_rf_wait,
              pw_rfse6);



    pulsename(&rfse6Theta, "rfse6Theta");
    createreserve(&rfse6Theta, THETA, res_rfse6);
    addrfbits(&rfse6Theta, off_rfse6, (LONG)(sp_sattemp+pw_gzrfse6a) + psd_rf_wait , pw_rfse6);
    createinstr(&rfse6Theta, (LONG)(sp_sattemp+pw_gzrfse6a) + psd_rf_wait, pw_rfse6, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE6_SLOT].change==PSD_ON)
       res_rfse6 = temp_res_rfse6;
  }


        sp_sattemp = pend(&gzrfse6d, "gzrfse6d" , *sat_index);

        ending = pendallssp(&rfse6, *sat_index);
           
  {
    pulsename(&isi_sate6,"isi_sate6");
    createconst(&isi_sate6,(WF_PROCESSOR)wg_isi_sate6,pw_isi_sate6,(short)0); 
    createinstr( &isi_sate6,(long)(ending),pw_isi_sate6,0);
  }

        getctrl(&ctrl_word, &isi_sate6, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate6, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e6,"rot_update_e6");
    createconst(&rot_update_e6,(WF_PROCESSOR)wg_rot_update_e6,pw_rot_update_e6,(short)0); 
    createinstr( &rot_update_e6,(long)(rot_update_time),pw_rot_update_e6,0);
  }

        getctrl(&ctrl_word, &rot_update_e6, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_e6, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse6a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse6, "gykse6", &gykse6, &gykse6a,
                        &gykse6d, pw_gykse6, pw_gykse6a, pw_gykse6d,
                        ia_gykse6, 0, 0, 0, 0, sp_pos_killer-pw_gykse6a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse6d, "gykse6d", *sat_index);

        if (area_gxkse6!=0.0)
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse6, "gxkse6", &gxkse6, &gxkse6a,
                        &gxkse6d, pw_gxkse6, pw_gxkse6a, pw_gxkse6d,
                        ia_gxkse6, 0, 0, 0, 0, sp_pos_killer-pw_gxkse6a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse6d, "gxkse6d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse6d, "gxkse6d", *sat_index);
        }

              
  {
    pulsename(&isi_satek6,"isi_satek6");
    createconst(&isi_satek6,(WF_PROCESSOR)wg_isi_satek6,pw_isi_satek6,(short)0); 
    createinstr( &isi_satek6,(long)(sp_sattemp-isi_satdelay),pw_isi_satek6,0);
  }

        getctrl(&ctrl_word, &isi_satek6, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek6, *sat_index);

                
  {
    pulsename(&rot_update_ek6,"rot_update_ek6");
    createconst(&rot_update_ek6,(WF_PROCESSOR)wg_rot_update_ek6,pw_rot_update_ek6,(short)0); 
    createinstr( &rot_update_ek6,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek6,0);
  }

        getctrl(&ctrl_word, &rot_update_ek6, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_ek6, *sat_index);
          
        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra;
    } 

    /* Slice select macro creates a since RF pulse. 
       A psd can use either sinc or SLR RF pulses. Parallel sat bands
       with the same thickness use a hadamard RF pulse. This one
       pulse replaces the 2 separate RF pulses. If the RF
       pulse is sinc, a hadamard sinc pulse is used. Likewise 
       if the SLR RF pulse is used, a hadamard SLR pulse is used. */

    /******************************************************************************
     ** This section has undergone significant restructuring to accomode rfpulse
     ** scaling following system safety requirements. The overall function is
     ** still similar. In the first case (SINC_SAT), the resolutions are changed
     ** if pulse scaling was performed. Interpolation is not required since the
     ** pulse is generated internally. For (SLR_SAT), the pulse is read into a work
     ** buffer (temp_wave), and copied over to the kernel file either in original
     ** size or increased size if scaling required. All scaling is performed before
     ** hadamard sat's are created. It is assumed that not all sat regions will have
     ** similar pulse resolutions, and scaling may or may not be required for each
     ** rfpulse SAT. The final rfpulse is then immediate moved (movewaveimm) onto
     ** the RHO board, and allocated memory freed.
     ******************************************************************************/
    
    switch (sat_type)
    {
    case SINC_SAT:
	
	/* Handle rf scaling */
	if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
            res_rfse1 = rfpulseInfo[RFSE1_SLOT].newres;
	if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
            res_rfse3 = rfpulseInfo[RFSE3_SLOT].newres;
	if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
            res_rfse5 = rfpulseInfo[RFSE5_SLOT].newres;
	
	if ((opexsatparal & PSD_1_PARALLEL) != 0)
        {
	    separation = 2 * satspace1/exsatthick1;
	    wave_space_rho = (SHORT *) AllocNode(res_rfse1*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfse1, max_pg_wamp, separation,
		      cyc_rfse1, alpha_rfse1);
	    movewaveimm(wave_space_rho, &rfse1, (INT)0, res_rfse1, 
			TOHARDWARE);
        }
	
	if ((opexsatparal & PSD_2_PARALLEL) != 0)
        {
	    separation = 2 * satspace3/exsatthick3;
	    wave_space_rho = (SHORT *) AllocNode(res_rfse3*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfse3, max_pg_wamp, separation,
		      cyc_rfse3, alpha_rfse3);
	    movewaveimm(wave_space_rho, &rfse3, (INT)0, res_rfse3, 
			TOHARDWARE);

        }
	
	if ((opexsatparal & PSD_3_PARALLEL) != 0)
        {
	    separation = 2 * satspace5/exsatthick5;
	    wave_space_rho = (SHORT *) AllocNode(res_rfse5*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfse5, max_pg_wamp, separation,
		      cyc_rfse5, alpha_rfse5);
	    movewaveimm(wave_space_rho, &rfse5, (INT)0, res_rfse5, 
			TOHARDWARE);

        }
	
	FreeNode(wave_space_rho);
	break;
	
    case SLR_SAT:
    case SLR_CSAT:

        switch (sat_type) 
        {
        case SLR_SAT:        	
	     strcpy(rho_file, "rfdblsatl0.rho");
	     temp_wave_rho = (SHORT *)AllocNode(RES_SLRSAT*sizeof(SHORT));
	     uextwave(temp_wave_rho, RES_SLRSAT, rho_file);
             break;
        case SLR_CSAT:
             strcpy(rho_file, "satqptbw12.rho");
             temp_wave_rho = (SHORT *)AllocNode(RES_SLRCSAT*sizeof(SHORT));
             uextwave(temp_wave_rho, RES_SLRCSAT, rho_file);

             if (sat_pulse_type == COMPLEX_RF)
             {
                strcpy(theta_file, "satqptbw12.the");
                temp_wave_theta = (SHORT *)AllocNode(RES_SLRCSAT*sizeof(SHORT));
                uextwave(temp_wave_theta, RES_SLRCSAT, theta_file);
             }
             break;
        default:
             break;
        }
	
	skip_next_sat = 0;
	if ((opexsatmask & PSD_EXPLICIT_1) != 0)
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
            {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE1_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE1_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse1,(int)rfpulseInfo[RFSE1_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE1_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE1_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse1,(int)rfpulseInfo[RFSE1_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }

		res_rfse1 = rfpulseInfo[RFSE1_SLOT].newres;
            }
	    else
            {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfse1*sizeof(SHORT));
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfse1*sizeof(SHORT));
                }

            }

	    /* Check if hadamard or pulse ON */
	    if ((opexsatparal & PSD_1_PARALLEL) != 0)
	      {
		separation = satspace1/2.0/exsatthick1;
		freqstep = 65536.0/(float)res_rfse1;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfse1, kernel_tab_rho, kernel_tab_theta, cyc_rfse1,
			 separation, gscale_rfse1, NULL, (FLOAT)0, 
			 hadamard_tab_rho, hadamard_tab_theta,freqstep);

                   movewaveimm(hadamard_tab_theta, &rfse1Theta, (INT)0, res_rfse1,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfse1, kernel_tab_rho, cyc_rfse1,
                         separation, gscale_rfse1, NULL, (FLOAT)0,
                         hadamard_tab_rho, freqstep);
                }

                movewaveimm(hadamard_tab_rho, &rfse1, (INT)0, res_rfse1,
                            TOHARDWARE);
             
		skip_next_sat = 1;
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfse1, (INT) 0, res_rfse1,
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfse1Theta, (INT) 0, res_rfse1,
                            TOHARDWARE);
                }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }
	    if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
            {
	      FreeNode(kernel_tab_rho);
              if (sat_pulse_type == COMPLEX_RF)
              {
                 FreeNode(kernel_tab_theta);
              }
            }
	  }
	

	if (((opexsatmask & PSD_EXPLICIT_2) != 0) && 
	    (skip_next_sat == 0))
	  {
	    if (rfpulseInfo[RFSE2_SLOT].change==PSD_ON)
	      {		      
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE2_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse2,(int)rfpulseInfo[RFSE2_SLOT].newres,temp_wave_rho,kernel_tab_rho);
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE2_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse2,(int)rfpulseInfo[RFSE2_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfse2 = rfpulseInfo[RFSE2_SLOT].newres;
	      }
	    else
              {
	        kernel_tab_rho = temp_wave_rho;
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                }
              }

	    movewaveimm(kernel_tab_rho, &rfse2, (INT)0, res_rfse2,
			TOHARDWARE);

            if (sat_pulse_type == COMPLEX_RF)
            {
               movewaveimm(kernel_tab_theta, &rfse2Theta, (INT) 0, res_rfse2,
                           TOHARDWARE);
            }

	    /* Free Memory */
	    if (rfpulseInfo[RFSE2_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
	  }
	
	skip_next_sat = 0;
	
	if ((opexsatmask & PSD_EXPLICIT_3) != 0)
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
	      {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE3_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE3_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse3,(int)rfpulseInfo[RFSE3_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE3_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE3_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse3,(int)rfpulseInfo[RFSE3_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfse3 = rfpulseInfo[RFSE3_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfse3*sizeof(SHORT));

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfse3*sizeof(SHORT));
                }
	      }
	    if ((opexsatparal & PSD_2_PARALLEL) != 0)
	      {
		separation = satspace3/2.0/exsatthick3;
		freqstep = 65536.0/(float) res_rfse3;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfse3, kernel_tab_rho, kernel_tab_theta, cyc_rfse3,
			 separation, gscale_rfse3, NULL, (FLOAT)0, 
			 hadamard_tab_rho, hadamard_tab_theta,freqstep);

                   movewaveimm(hadamard_tab_theta, &rfse3Theta, (INT)0, res_rfse3,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfse3, kernel_tab_rho, cyc_rfse3,
                         separation, gscale_rfse3, NULL, (FLOAT)0,
                         hadamard_tab_rho, freqstep);
                }

                movewaveimm(hadamard_tab_rho, &rfse3, (INT)0, res_rfse3,
                            TOHARDWARE);

		skip_next_sat = 1;
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfse3, (INT) 0, res_rfse3,
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfse3Theta, (INT) 0, res_rfse3,
                               TOHARDWARE);
                }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho); 
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }

	    if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	if (((opexsatmask & PSD_EXPLICIT_4) != 0) && 
	    (skip_next_sat == 0))
        {
	    if (rfpulseInfo[RFSE4_SLOT].change==PSD_ON)
	      {		      
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE4_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse4,(int)rfpulseInfo[RFSE4_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE4_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse4,(int)rfpulseInfo[RFSE4_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfse4 = rfpulseInfo[RFSE4_SLOT].newres;
	      }
	    else
              {
	        kernel_tab_rho = temp_wave_rho; 
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                }
              }

	    movewaveimm(kernel_tab_rho, &rfse4, (INT)0, res_rfse4,
			TOHARDWARE); 
            if (sat_pulse_type == COMPLEX_RF)
            {
               movewaveimm(kernel_tab_theta, &rfse4Theta, (INT)0, res_rfse4,
                           TOHARDWARE);
            }

	    /* Free Memory */
	    if (rfpulseInfo[RFSE4_SLOT].change==PSD_ON) 
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	skip_next_sat = 0;
	
	if ((opexsatmask & PSD_EXPLICIT_5) != 0)
        {
	    if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
	      {		      
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE5_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE5_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse5,(int)rfpulseInfo[RFSE5_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE5_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE5_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse5,(int)rfpulseInfo[RFSE5_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }

		res_rfse5 = rfpulseInfo[RFSE5_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfse5*sizeof(SHORT));
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfse5*sizeof(SHORT));
                }
	      }
	    
	    if ((opexsatparal & PSD_3_PARALLEL) != 0)
	      {
		separation = satspace5/2.0/exsatthick5;
		freqstep = 65536.0/(float) res_rfse5;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfse5, kernel_tab_rho, kernel_tab_theta, cyc_rfse5,
			 separation, gscale_rfse5, NULL, (FLOAT)0, 
			 hadamard_tab_rho, hadamard_tab_theta, freqstep);

                   movewaveimm(hadamard_tab_theta, &rfse5Theta, (INT)0, res_rfse5,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfse5, kernel_tab_rho, cyc_rfse5,
                         separation, gscale_rfse5, NULL, (FLOAT)0,
                         hadamard_tab_rho, freqstep);
                }
                movewaveimm(hadamard_tab_rho, &rfse5, (INT)0, res_rfse5,
                            TOHARDWARE);

		skip_next_sat = 1;
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfse5, (INT) 0, res_rfse5,
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfse5Theta, (INT) 0, res_rfse5,
                               TOHARDWARE);
                }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }

	    if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	if (((opexsatmask & PSD_EXPLICIT_6) != 0) && 
	    (skip_next_sat == 0))
        {
	    /* Check pulse scaling */
	    if (rfpulseInfo[RFSE6_SLOT].change==PSD_ON)
	      {		      
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE6_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse6,(int)rfpulseInfo[RFSE6_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE6_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse6,(int)rfpulseInfo[RFSE6_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }

		res_rfse6 = rfpulseInfo[RFSE6_SLOT].newres;
	      }
	    else
              {
	        kernel_tab_rho = temp_wave_rho;
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                }
              }

	    movewaveimm(kernel_tab_rho, &rfse6, (INT)0, res_rfse6,
			TOHARDWARE); 
            if (sat_pulse_type == COMPLEX_RF)
            {
               movewaveimm(kernel_tab_theta, &rfse6Theta, (INT)0, res_rfse6,
                           TOHARDWARE);
            }
	    /* Free Memory */
	    if (rfpulseInfo[RFSE6_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
	    } 
        }

	FreeNode(temp_wave_rho);
        if (sat_pulse_type == COMPLEX_RF)
        {
           FreeNode(temp_wave_theta);
        }
	break;
	
    default:
	break;
    }
    
    /****************************************************************
      DEFAULT SAT GRADEINTS
      
      1. Slice selection gradient
      2. Killer on y gradient
      3. If there are 2 sat bands that are parallel but do not have
      the same thickness, create a separate slice select & killer
      for the second band.
      
    ******************************************************************/
    
    if (opsatx != PSD_OFF)    /* X board */
    {
        if (opsatx == PSD_SATNEG)
            satthickdfx = satthickx1;
        else if (opsatx == PSD_SATPOS)
            satthickdfx = satthickx2;
        else
            satthickdfx = satthickx1;
	
           
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsx1", 
                                     (WF_PROCESSOR)wg_rfsx1);

    /* Modify resolution if scaling required */
    temp_res_rfsx1 = res_rfsx1;
    if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
       res_rfsx1 = rfpulseInfo[RFSX1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gxrfsx1a,"gxrfsx1a");
    pulsename(&gxrfsx1,"gxrfsx1");
    pulsename(&gxrfsx1d,"gxrfsx1d");
    pulsename(&rfsx1,"rfsx1");

    /*  Now create the slice select trapezoid */
    pg_beta = loggrd.xbeta;
    createramp(&gxrfsx1a,XGRAD,pw_gxrfsx1a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gxrfsx1a/
                                               GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gxrfsx1a,(LONG)(sp_sattemp+pw_gxrfsx1a-pw_gxrfsx1a),
                pw_gxrfsx1a,ia_gxrfsx1);
    createconst(&gxrfsx1,XGRAD,pw_gxrfsx1,MAX_PG_WAMP);
    createinstr( &gxrfsx1,(LONG)(sp_sattemp+pw_gxrfsx1a),
                pw_gxrfsx1,ia_gxrfsx1);
    createramp(&gxrfsx1d,XGRAD,pw_gxrfsx1d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gxrfsx1d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gxrfsx1d,(LONG)(sp_sattemp+pw_gxrfsx1a+pw_gxrfsx1),
                pw_gxrfsx1d,ia_gxrfsx1);

    /* Now create the rf pulse */
    createsinc(&rfsx1,(WF_PROCESSOR)wg_rfsx1,res_rfsx1,
               MAX_PG_WAMP,cyc_rfsx1, alpha_rfsx1);
    createinstr( &rfsx1,(LONG)(sp_sattemp+pw_gxrfsx1a) + psd_rf_wait,
                pw_rfsx1,ia_rfsx1);
    linkpulses(4,&rfsx1,&gxrfsx1,&gxrfsx1a,
               &gxrfsx1d);
    addrfbits(&rfsx1,off_rfsx1,(LONG)(sp_sattemp+pw_gxrfsx1a) + psd_rf_wait,
              pw_rfsx1);


    pulsename(&rfsx1Theta, "rfsx1Theta");
    createreserve(&rfsx1Theta, THETA, res_rfsx1);
    addrfbits(&rfsx1Theta, off_rfsx1, (LONG)(sp_sattemp+pw_gxrfsx1a) + psd_rf_wait , pw_rfsx1);
    createinstr(&rfsx1Theta, (LONG)(sp_sattemp+pw_gxrfsx1a) + psd_rf_wait, pw_rfsx1, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
       res_rfsx1 = temp_res_rfsx1;
}

	
        sp_sattemp = pend(&gxrfsx1d, "gxrfsx1d", *sat_index);
	
        ending = pendallssp(&rfsx1, *sat_index);
           
  {
    pulsename(&isi_satx1,"isi_satx1");
    createconst(&isi_satx1,(WF_PROCESSOR)wg_isi_satx1,pw_isi_satx1,(short)0); 
    createinstr( &isi_satx1,(long)(ending),pw_isi_satx1,0);
  }

        getctrl(&ctrl_word, &isi_satx1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satx1, *sat_index);
	rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	
           
  {
    pulsename(&rot_update_x1,"rot_update_x1");
    createconst(&rot_update_x1,(WF_PROCESSOR)wg_rot_update_x1,pw_rot_update_x1,(short)0); 
    createinstr( &rot_update_x1,(long)(rot_update_time),pw_rot_update_x1,0);
  }

        getctrl(&ctrl_word, &rot_update_x1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_x1, *sat_index);
	sp_sattemp = RUP_GRD(rot_update_time + pw_rotupdate);

        sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksx1a + isi_extra);
             

  trapezoid((WF_PROCESSOR)wg_gyksx1, "gyksx1", &gyksx1, &gyksx1a,
                        &gyksx1d, pw_gyksx1, pw_gyksx1a, pw_gyksx1d,
                        ia_gyksx1, 0, 0, 0, 0, sp_pos_killer-pw_gyksx1a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gyksx1d, "gyksx1d", *sat_index);

	if (area_gxksx1!=0.0)
        {
	        

  trapezoid((WF_PROCESSOR)wg_gxksx1, "gxksx1", &gxksx1, &gxksx1a,
                        &gxksx1d, pw_gxksx1, pw_gxksx1a, pw_gxksx1d,
                        ia_gxksx1, 0, 0, 0, 0, sp_pos_killer-pw_gxksx1a, TRAP_ALL,
                        &loggrd);

	    if  (pend(&gxksx1d, "gxksx1d", *sat_index)>sp_sattemp)
                sp_sattemp = pend(&gxksx1d, "gxksx1d", *sat_index);
        }

              
  {
    pulsename(&isi_satxk1,"isi_satxk1");
    createconst(&isi_satxk1,(WF_PROCESSOR)wg_isi_satxk1,pw_isi_satxk1,(short)0); 
    createinstr( &isi_satxk1,(long)(sp_sattemp-isi_satdelay),pw_isi_satxk1,0);
  }

        getctrl(&ctrl_word, &isi_satxk1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satxk1, *sat_index);

                
  {
    pulsename(&rot_update_xk1,"rot_update_xk1");
    createconst(&rot_update_xk1,(WF_PROCESSOR)wg_rot_update_xk1,pw_rot_update_xk1,(short)0); 
    createinstr( &rot_update_xk1,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_xk1,0);
  }

        getctrl(&ctrl_word, &rot_update_xk1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_xk1, *sat_index);
       
	/* RJL 08/24/95. More dynamic calculation of timing */
	sp_sattemp = RUP_GRD(sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra);

        if (opsatx == PSD_SATPARA)
        {
                
                       
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsx2", 
                                     (WF_PROCESSOR)wg_rfsx2);

    /* Modify resolution if scaling required */
    temp_res_rfsx2 = res_rfsx2;
    if (rfpulseInfo[RFSX2_SLOT].change==PSD_ON)
       res_rfsx2 = rfpulseInfo[RFSX2_SLOT].newres;
    /* First create the pulses */
    pulsename(&gxrfsx2a,"gxrfsx2a");
    pulsename(&gxrfsx2,"gxrfsx2");
    pulsename(&gxrfsx2d,"gxrfsx2d");
    pulsename(&rfsx2,"rfsx2");

    /*  Now create the slice select trapezoid */
    pg_beta = loggrd.xbeta;
    createramp(&gxrfsx2a,XGRAD,pw_gxrfsx2a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gxrfsx2a/
                                               GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gxrfsx2a,(LONG)(sp_sattemp+pw_gxrfsx2a-pw_gxrfsx2a),
                pw_gxrfsx2a,ia_gxrfsx2);
    createconst(&gxrfsx2,XGRAD,pw_gxrfsx2,MAX_PG_WAMP);
    createinstr( &gxrfsx2,(LONG)(sp_sattemp+pw_gxrfsx2a),
                pw_gxrfsx2,ia_gxrfsx2);
    createramp(&gxrfsx2d,XGRAD,pw_gxrfsx2d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gxrfsx2d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gxrfsx2d,(LONG)(sp_sattemp+pw_gxrfsx2a+pw_gxrfsx2),
                pw_gxrfsx2d,ia_gxrfsx2);

    /* Now create the rf pulse */
    createsinc(&rfsx2,(WF_PROCESSOR)wg_rfsx2,res_rfsx2,
               MAX_PG_WAMP,cyc_rfsx2, alpha_rfsx2);
    createinstr( &rfsx2,(LONG)(sp_sattemp+pw_gxrfsx2a) + psd_rf_wait,
                pw_rfsx2,ia_rfsx2);
    linkpulses(4,&rfsx2,&gxrfsx2,&gxrfsx2a,
               &gxrfsx2d);
    addrfbits(&rfsx2,off_rfsx2,(LONG)(sp_sattemp+pw_gxrfsx2a) + psd_rf_wait,
              pw_rfsx2);


    pulsename(&rfsx2Theta, "rfsx2Theta");
    createreserve(&rfsx2Theta, THETA, res_rfsx2);
    addrfbits(&rfsx2Theta, off_rfsx2, (LONG)(sp_sattemp+pw_gxrfsx2a) + psd_rf_wait , pw_rfsx2);
    createinstr(&rfsx2Theta, (LONG)(sp_sattemp+pw_gxrfsx2a) + psd_rf_wait, pw_rfsx2, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSX2_SLOT].change==PSD_ON)
       res_rfsx2 = temp_res_rfsx2;
}


	    sp_sattemp = pend(&gxrfsx2d, "gxrfsx2d", *sat_index) ;
	    
	    ending = pendallssp(&rfsx2, *sat_index);
	       
  {
    pulsename(&isi_satx2,"isi_satx2");
    createconst(&isi_satx2,(WF_PROCESSOR)wg_isi_satx2,pw_isi_satx2,(short)0); 
    createinstr( &isi_satx2,(long)(ending),pw_isi_satx2,0);
  }

	    getctrl(&ctrl_word, &isi_satx2, *sat_index);
	    ctrl_word = ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satx2, *sat_index);
            rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	    
	       
  {
    pulsename(&rot_update_x2,"rot_update_x2");
    createconst(&rot_update_x2,(WF_PROCESSOR)wg_rot_update_x2,pw_rot_update_x2,(short)0); 
    createinstr( &rot_update_x2,(long)(rot_update_time),pw_rot_update_x2,0);
  }

	    getctrl(&ctrl_word, &rot_update_x2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_x2, *sat_index);
	    sp_sattemp = RUP_GRD(rot_update_time + pw_rotupdate);	    

	    sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksx2a + isi_extra);
	         

  trapezoid((WF_PROCESSOR)wg_gyksx2, "gyksx2", &gyksx2, &gyksx2a,
                        &gyksx2d, pw_gyksx2, pw_gyksx2a, pw_gyksx2d,
                        ia_gyksx2, 0, 0, 0, 0, sp_pos_killer-pw_gyksx2a, TRAP_ALL,
                        &loggrd);

	    sp_sattemp = pend(&gyksx2d, "gyksx2d",*sat_index) ;
	    
	    if (area_gxksx2!=0.0)
            {
		    

  trapezoid((WF_PROCESSOR)wg_gxksx2, "gxksx2", &gxksx2, &gxksx2a,
                        &gxksx2d, pw_gxksx2, pw_gxksx2a, pw_gxksx2d,
                        ia_gxksx2, 0, 0, 0, 0, sp_pos_killer-pw_gxksx2a, TRAP_ALL,
                        &loggrd);

		if  (pend(&gxksx2d, "gxksx2d", *sat_index)>sp_sattemp)
                    sp_sattemp = pend(&gxksx2d, "gxksx2d", *sat_index);
            }
	    
	         
  {
    pulsename(&isi_satxk2,"isi_satxk2");
    createconst(&isi_satxk2,(WF_PROCESSOR)wg_isi_satxk2,pw_isi_satxk2,(short)0); 
    createinstr( &isi_satxk2,(long)(sp_sattemp-isi_satdelay),pw_isi_satxk2,0);
  }

	    getctrl(&ctrl_word, &isi_satxk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satxk2, *sat_index);
	    
	            
  {
    pulsename(&rot_update_xk2,"rot_update_xk2");
    createconst(&rot_update_xk2,(WF_PROCESSOR)wg_rot_update_xk2,pw_rot_update_xk2,(short)0); 
    createinstr( &rot_update_xk2,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_xk2,0);
  }

	    getctrl(&ctrl_word, &rot_update_xk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_xk2, *sat_index);
	    
	    /* RJL 08/24/95. More dynamic calculation of timing */
	    sp_sattemp = RUP_GRD(sp_sattemp - isi_satdelay  + pw_isisat+pw_rotupdate + isi_extra);
        }
    }

    if (opsaty != PSD_OFF)   /* Y Board */
    {
        if (opsaty == PSD_SATNEG)
            satthickdfy = satthicky1;
        else if (opsaty == PSD_SATPOS)
            satthickdfy = satthicky2;
        else
            satthickdfy = satthicky1;

             
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsy1", 
                                     (WF_PROCESSOR)wg_rfsy1);

    /* Modify resolution if scaling required */
    temp_res_rfsy1 = res_rfsy1;
    if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
      res_rfsy1 = rfpulseInfo[RFSY1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gyrfsy1a,"gyrfsy1a");
    pulsename(&gyrfsy1,"gyrfsy1");
    pulsename(&gyrfsy1d,"gyrfsy1d");
    pulsename(&rfsy1,"rfsy1");

        /*  Now create the slice select trapezoid */
  pg_beta = loggrd.ybeta;
  createramp(&gyrfsy1a,YGRAD,pw_gyrfsy1a,(short)0,MAX_PG_WAMP,
                        (short)(maxGradRes*(pw_gyrfsy1a/GRAD_UPDATE_TIME))

                        ,pg_beta);
  createinstr( &gyrfsy1a,(LONG)(sp_sattemp+pw_gyrfsy1a-pw_gyrfsy1a),
      pw_gyrfsy1a,ia_gyrfsy1);
  createconst(&gyrfsy1,YGRAD,pw_gyrfsy1,MAX_PG_WAMP);
  createinstr( &gyrfsy1,(LONG)(sp_sattemp+pw_gyrfsy1a),
      pw_gyrfsy1,ia_gyrfsy1);
  createramp(&gyrfsy1d,YGRAD,pw_gyrfsy1d,MAX_PG_WAMP,
                        (short)0,(short)(maxGradRes*(pw_gyrfsy1d/GRAD_UPDATE_TIME))
                        ,pg_beta);
  createinstr( &gyrfsy1d,(LONG)(sp_sattemp+pw_gyrfsy1a+pw_gyrfsy1),
      pw_gyrfsy1d,ia_gyrfsy1);

    /* Now create the rf pulse */
    createsinc(&rfsy1,(WF_PROCESSOR)wg_rfsy1,res_rfsy1,
               MAX_PG_WAMP,cyc_rfsy1, alpha_rfsy1);
    createinstr( &rfsy1,(LONG)(sp_sattemp+pw_gyrfsy1a) + psd_rf_wait,
                pw_rfsy1,ia_rfsy1);
    linkpulses(4,&rfsy1,&gyrfsy1,&gyrfsy1a,&gyrfsy1d);
    addrfbits(&rfsy1,off_rfsy1,(LONG)(sp_sattemp+pw_gyrfsy1a) + psd_rf_wait,
              pw_rfsy1);

    pulsename(&rfsy1Theta, "rfsy1Theta");
    createreserve(&rfsy1Theta, THETA, res_rfsy1);
    addrfbits(&rfsy1Theta, off_rfsy1, (LONG)(sp_sattemp+pw_gyrfsy1a) + psd_rf_wait , pw_rfsy1);
    createinstr(&rfsy1Theta, (LONG)(sp_sattemp+pw_gyrfsy1a) + psd_rf_wait, pw_rfsy1, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
      res_rfsy1 = temp_res_rfsy1;
}



        sp_sattemp = pend(&gyrfsy1d, "gyrfsy1d" , *sat_index);

        ending = pendallssp(&rfsy1, *sat_index);
           
  {
    pulsename(&isi_saty1,"isi_saty1");
    createconst(&isi_saty1,(WF_PROCESSOR)wg_isi_saty1,pw_isi_saty1,(short)0); 
    createinstr( &isi_saty1,(long)(ending),pw_isi_saty1,0);
  }

        getctrl(&ctrl_word, &isi_saty1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_saty1, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_y1,"rot_update_y1");
    createconst(&rot_update_y1,(WF_PROCESSOR)wg_rot_update_y1,pw_rot_update_y1,(short)0); 
    createinstr( &rot_update_y1,(long)(rot_update_time),pw_rot_update_y1,0);
  }

        getctrl(&ctrl_word, &rot_update_y1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_y1, *sat_index);
	sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksy1a + isi_extra);
              

  trapezoid((WF_PROCESSOR)wg_gyksy1, "gyksy1", &gyksy1, &gyksy1a,
                        &gyksy1d, pw_gyksy1, pw_gyksy1a, pw_gyksy1d,
                        ia_gyksy1, 0, 0, 0, 0, sp_pos_killer-pw_gyksy1a, TRAP_ALL,
                        &loggrd);
 
        sp_sattemp = pend(&gyksy1d, "gyksy1d", *sat_index);

	if (area_gxksy1!=0.0)
        {
	        

  trapezoid((WF_PROCESSOR)wg_gxksy1, "gxksy1", &gxksy1, &gxksy1a,
                        &gxksy1d, pw_gxksy1, pw_gxksy1a, pw_gxksy1d,
                        ia_gxksy1, 0, 0, 0, 0, sp_pos_killer-pw_gxksy1a, TRAP_ALL,
                        &loggrd);

	    if  (pend(&gxksy1d, "gxksy1d", *sat_index)>sp_sattemp)
                sp_sattemp = pend(&gxksy1d, "gxksy1d", *sat_index);
        }

              
  {
    pulsename(&isi_satyk1,"isi_satyk1");
    createconst(&isi_satyk1,(WF_PROCESSOR)wg_isi_satyk1,pw_isi_satyk1,(short)0); 
    createinstr( &isi_satyk1,(long)(sp_sattemp-isi_satdelay),pw_isi_satyk1,0);
  }

        getctrl(&ctrl_word, &isi_satyk1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satyk1, *sat_index);

                
  {
    pulsename(&rot_update_yk1,"rot_update_yk1");
    createconst(&rot_update_yk1,(WF_PROCESSOR)wg_rot_update_yk1,pw_rot_update_yk1,(short)0); 
    createinstr( &rot_update_yk1,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_yk1,0);
  }

        getctrl(&ctrl_word, &rot_update_yk1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_yk1, *sat_index);
        
	/* RJL 08/24/95. More dynamic calculation of timing */
	sp_sattemp = RUP_GRD(sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra);

        if (opsaty == PSD_SATPARA)
        {
                
                        
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsy2", 
                                     (WF_PROCESSOR)wg_rfsy2);

    /* Modify resolution if scaling required */
    temp_res_rfsy2 = res_rfsy2;
    if (rfpulseInfo[RFSY2_SLOT].change==PSD_ON)
      res_rfsy2 = rfpulseInfo[RFSY2_SLOT].newres;
    /* First create the pulses */
    pulsename(&gyrfsy2a,"gyrfsy2a");
    pulsename(&gyrfsy2,"gyrfsy2");
    pulsename(&gyrfsy2d,"gyrfsy2d");
    pulsename(&rfsy2,"rfsy2");

        /*  Now create the slice select trapezoid */
  pg_beta = loggrd.ybeta;
  createramp(&gyrfsy2a,YGRAD,pw_gyrfsy2a,(short)0,MAX_PG_WAMP,
                        (short)(maxGradRes*(pw_gyrfsy2a/GRAD_UPDATE_TIME))

                        ,pg_beta);
  createinstr( &gyrfsy2a,(LONG)(sp_sattemp+pw_gyrfsy2a-pw_gyrfsy2a),
      pw_gyrfsy2a,ia_gyrfsy2);
  createconst(&gyrfsy2,YGRAD,pw_gyrfsy2,MAX_PG_WAMP);
  createinstr( &gyrfsy2,(LONG)(sp_sattemp+pw_gyrfsy2a),
      pw_gyrfsy2,ia_gyrfsy2);
  createramp(&gyrfsy2d,YGRAD,pw_gyrfsy2d,MAX_PG_WAMP,
                        (short)0,(short)(maxGradRes*(pw_gyrfsy2d/GRAD_UPDATE_TIME))
                        ,pg_beta);
  createinstr( &gyrfsy2d,(LONG)(sp_sattemp+pw_gyrfsy2a+pw_gyrfsy2),
      pw_gyrfsy2d,ia_gyrfsy2);

    /* Now create the rf pulse */
    createsinc(&rfsy2,(WF_PROCESSOR)wg_rfsy2,res_rfsy2,
               MAX_PG_WAMP,cyc_rfsy2, alpha_rfsy2);
    createinstr( &rfsy2,(LONG)(sp_sattemp+pw_gyrfsy2a) + psd_rf_wait,
                pw_rfsy2,ia_rfsy2);
    linkpulses(4,&rfsy2,&gyrfsy2,&gyrfsy2a,&gyrfsy2d);
    addrfbits(&rfsy2,off_rfsy2,(LONG)(sp_sattemp+pw_gyrfsy2a) + psd_rf_wait,
              pw_rfsy2);

    pulsename(&rfsy2Theta, "rfsy2Theta");
    createreserve(&rfsy2Theta, THETA, res_rfsy2);
    addrfbits(&rfsy2Theta, off_rfsy2, (LONG)(sp_sattemp+pw_gyrfsy2a) + psd_rf_wait , pw_rfsy2);
    createinstr(&rfsy2Theta, (LONG)(sp_sattemp+pw_gyrfsy2a) + psd_rf_wait, pw_rfsy2, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSY2_SLOT].change==PSD_ON)
      res_rfsy2 = temp_res_rfsy2;
}



	    sp_sattemp = pend(&gyrfsy2d, "gyrfsy2d", *sat_index);
	    ending = pendallssp(&rfsy2, *sat_index);
	       
  {
    pulsename(&isi_saty2,"isi_saty2");
    createconst(&isi_saty2,(WF_PROCESSOR)wg_isi_saty2,pw_isi_saty2,(short)0); 
    createinstr( &isi_saty2,(long)(ending),pw_isi_saty2,0);
  }

	    getctrl(&ctrl_word, &isi_saty2, *sat_index);
	    ctrl_word =  ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_saty2, *sat_index);
            rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	    
	       
  {
    pulsename(&rot_update_y2,"rot_update_y2");
    createconst(&rot_update_y2,(WF_PROCESSOR)wg_rot_update_y2,pw_rot_update_y2,(short)0); 
    createinstr( &rot_update_y2,(long)(rot_update_time),pw_rot_update_y2,0);
  }

	    getctrl(&ctrl_word, &rot_update_y2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_y2, *sat_index);
	    sp_sattemp = rot_update_time + pw_rotupdate;    

	    sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksy2a + isi_extra);
	           

  trapezoid((WF_PROCESSOR)wg_gyksy2, "gyksy2", &gyksy2, &gyksy2a,
                        &gyksy2d, pw_gyksy2, pw_gyksy2a, pw_gyksy2d,
                        ia_gyksy2, 0, 0, 0, 0, sp_pos_killer-pw_gyksy2a, TRAP_ALL,
                        &loggrd);
 
	    sp_sattemp = pend(&gyksy2d, "gyksy2d", *sat_index);
	    
	    if (area_gxksy2!=0.0)
            {
		    

  trapezoid((WF_PROCESSOR)wg_gxksy2, "gxksy2", &gxksy2, &gxksy2a,
                        &gxksy2d, pw_gxksy2, pw_gxksy2a, pw_gxksy2d,
                        ia_gxksy2, 0, 0, 0, 0, sp_pos_killer-pw_gxksy2a, TRAP_ALL,
                        &loggrd);

		if  (pend(&gxksy2d, "gxksy2d", *sat_index)>sp_sattemp)
                    sp_sattemp = pend(&gxksy2d, "gxksy2d", *sat_index);
            }
	    
	          
  {
    pulsename(&isi_satyk2,"isi_satyk2");
    createconst(&isi_satyk2,(WF_PROCESSOR)wg_isi_satyk2,pw_isi_satyk2,(short)0); 
    createinstr( &isi_satyk2,(long)(sp_sattemp-isi_satdelay),pw_isi_satyk2,0);
  }

	    getctrl(&ctrl_word, &isi_satyk2, *sat_index);
	    ctrl_word =  ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satyk2, *sat_index);
	    
	            
  {
    pulsename(&rot_update_yk2,"rot_update_yk2");
    createconst(&rot_update_yk2,(WF_PROCESSOR)wg_rot_update_yk2,pw_rot_update_yk2,(short)0); 
    createinstr( &rot_update_yk2,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_yk2,0);
  }

	    getctrl(&ctrl_word, &rot_update_yk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_yk2, *sat_index);
	    
	    /* RJL 08/24/95. More dynamic calculation of timing */
	    sp_sattemp = RUP_GRD(sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra);
        }
    }

    if (opsatz != PSD_OFF)  /* Z Board */
    {
	if (opsatz == PSD_SATNEG)
            satthickdfz = satthickz1;
        else if (opsatz == PSD_SATPOS)
            satthickdfz = satthickz2;
        else
            satthickdfz = satthickz1;
	
             
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsz1", 
                                     (WF_PROCESSOR)wg_rfsz1);

    /* Modify resolution if scaling required */
    temp_res_rfsz1 = res_rfsz1;
    if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
       res_rfsz1 = rfpulseInfo[RFSZ1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfsz1a,"gzrfsz1a");
    pulsename(&gzrfsz1,"gzrfsz1");
    pulsename(&gzrfsz1d,"gzrfsz1d");
    pulsename(&rfsz1,"rfsz1");

    /*  Now create the slice select trapezoid */
        pg_beta = loggrd.zbeta;
    createramp(&gzrfsz1a,ZGRAD,pw_gzrfsz1a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfsz1a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfsz1a,(LONG)(sp_sattemp+pw_gzrfsz1a-pw_gzrfsz1a),
                pw_gzrfsz1a,ia_gzrfsz1);
    createconst(&gzrfsz1,ZGRAD,pw_gzrfsz1,MAX_PG_WAMP);
    createinstr( &gzrfsz1,(LONG)(sp_sattemp+pw_gzrfsz1a),
                pw_gzrfsz1,ia_gzrfsz1);
    createramp(&gzrfsz1d,ZGRAD,pw_gzrfsz1d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfsz1d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfsz1d,(LONG)(sp_sattemp+pw_gzrfsz1a+pw_gzrfsz1),
                pw_gzrfsz1d,ia_gzrfsz1);

    /* Now create the rf pulse */
    createsinc(&rfsz1,(WF_PROCESSOR)wg_rfsz1,res_rfsz1,
               MAX_PG_WAMP,cyc_rfsz1, alpha_rfsz1);

    createinstr( &rfsz1,(LONG)(sp_sattemp+pw_gzrfsz1a) + psd_rf_wait,
                pw_rfsz1,ia_rfsz1);
    linkpulses(4,&rfsz1,&gzrfsz1,&gzrfsz1a,
               &gzrfsz1d);
    addrfbits(&rfsz1,off_rfsz1,(LONG)(sp_sattemp+pw_gzrfsz1a) + psd_rf_wait,
              pw_rfsz1);



    pulsename(&rfsz1Theta, "rfsz1Theta");
    createreserve(&rfsz1Theta, THETA, res_rfsz1);
    addrfbits(&rfsz1Theta, off_rfsz1, (LONG)(sp_sattemp+pw_gzrfsz1a) + psd_rf_wait , pw_rfsz1);
    createinstr(&rfsz1Theta, (LONG)(sp_sattemp+pw_gzrfsz1a) + psd_rf_wait, pw_rfsz1, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
       res_rfsz1 = temp_res_rfsz1;
  }


        sp_sattemp = pend(&gzrfsz1d, "gzrfsz1d", *sat_index);
	
        ending = pendallssp(&rfsz1, *sat_index);
           
  {
    pulsename(&isi_satz1,"isi_satz1");
    createconst(&isi_satz1,(WF_PROCESSOR)wg_isi_satz1,pw_isi_satz1,(short)0); 
    createinstr( &isi_satz1,(long)(ending),pw_isi_satz1,0);
  }

        getctrl(&ctrl_word, &isi_satz1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satz1, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	
           
  {
    pulsename(&rot_update_z1,"rot_update_z1");
    createconst(&rot_update_z1,(WF_PROCESSOR)wg_rot_update_z1,pw_rot_update_z1,(short)0); 
    createinstr( &rot_update_z1,(long)(rot_update_time),pw_rot_update_z1,0);
  }

        getctrl(&ctrl_word, &rot_update_z1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_z1, *sat_index);
	sp_sattemp = rot_update_time + pw_rotupdate;
	
        sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksz1a + isi_extra);
             

  trapezoid((WF_PROCESSOR)wg_gyksz1, "gyksz1", &gyksz1, &gyksz1a,
                        &gyksz1d, pw_gyksz1, pw_gyksz1a, pw_gyksz1d,
                        ia_gyksz1, 0, 0, 0, 0, sp_pos_killer-pw_gyksz1a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gyksz1d, "gyksz1d", *sat_index);
	
	if (area_gxksz1!=0.0)
        {
	        

  trapezoid((WF_PROCESSOR)wg_gxksz1, "gxksz1", &gxksz1, &gxksz1a,
                        &gxksz1d, pw_gxksz1, pw_gxksz1a, pw_gxksz1d,
                        ia_gxksz1, 0, 0, 0, 0, sp_pos_killer-pw_gxksz1a, TRAP_ALL,
                        &loggrd);

	    if  (pend(&gxksz1d, "gxksz1d", *sat_index)>sp_sattemp)
                sp_sattemp = pend(&gxksz1d, "gxksz1d", *sat_index);
        }

              
  {
    pulsename(&isi_satzk1,"isi_satzk1");
    createconst(&isi_satzk1,(WF_PROCESSOR)wg_isi_satzk1,pw_isi_satzk1,(short)0); 
    createinstr( &isi_satzk1,(long)(sp_sattemp-isi_satdelay),pw_isi_satzk1,0);
  }

        getctrl(&ctrl_word, &isi_satzk1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satzk1, *sat_index);
	
                
  {
    pulsename(&rot_update_zk1,"rot_update_zk1");
    createconst(&rot_update_zk1,(WF_PROCESSOR)wg_rot_update_zk1,pw_rot_update_zk1,(short)0); 
    createinstr( &rot_update_zk1,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_zk1,0);
  }

        getctrl(&ctrl_word, &rot_update_zk1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_zk1, *sat_index);
        
	/* RJL 08/24/95. More dynamic calculation of timing */
	sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat+pw_rotupdate + isi_extra;
	
        if (opsatz == PSD_SATPARA)
        {
                
                        
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsz2", 
                                     (WF_PROCESSOR)wg_rfsz2);

    /* Modify resolution if scaling required */
    temp_res_rfsz2 = res_rfsz2;
    if (rfpulseInfo[RFSZ2_SLOT].change==PSD_ON)
       res_rfsz2 = rfpulseInfo[RFSZ2_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfsz2a,"gzrfsz2a");
    pulsename(&gzrfsz2,"gzrfsz2");
    pulsename(&gzrfsz2d,"gzrfsz2d");
    pulsename(&rfsz2,"rfsz2");

    /*  Now create the slice select trapezoid */
        pg_beta = loggrd.zbeta;
    createramp(&gzrfsz2a,ZGRAD,pw_gzrfsz2a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfsz2a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfsz2a,(LONG)(sp_sattemp+pw_gzrfsz2a-pw_gzrfsz2a),
                pw_gzrfsz2a,ia_gzrfsz2);
    createconst(&gzrfsz2,ZGRAD,pw_gzrfsz2,MAX_PG_WAMP);
    createinstr( &gzrfsz2,(LONG)(sp_sattemp+pw_gzrfsz2a),
                pw_gzrfsz2,ia_gzrfsz2);
    createramp(&gzrfsz2d,ZGRAD,pw_gzrfsz2d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfsz2d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfsz2d,(LONG)(sp_sattemp+pw_gzrfsz2a+pw_gzrfsz2),
                pw_gzrfsz2d,ia_gzrfsz2);

    /* Now create the rf pulse */
    createsinc(&rfsz2,(WF_PROCESSOR)wg_rfsz2,res_rfsz2,
               MAX_PG_WAMP,cyc_rfsz2, alpha_rfsz2);

    createinstr( &rfsz2,(LONG)(sp_sattemp+pw_gzrfsz2a) + psd_rf_wait,
                pw_rfsz2,ia_rfsz2);
    linkpulses(4,&rfsz2,&gzrfsz2,&gzrfsz2a,
               &gzrfsz2d);
    addrfbits(&rfsz2,off_rfsz2,(LONG)(sp_sattemp+pw_gzrfsz2a) + psd_rf_wait,
              pw_rfsz2);



    pulsename(&rfsz2Theta, "rfsz2Theta");
    createreserve(&rfsz2Theta, THETA, res_rfsz2);
    addrfbits(&rfsz2Theta, off_rfsz2, (LONG)(sp_sattemp+pw_gzrfsz2a) + psd_rf_wait , pw_rfsz2);
    createinstr(&rfsz2Theta, (LONG)(sp_sattemp+pw_gzrfsz2a) + psd_rf_wait, pw_rfsz2, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSZ2_SLOT].change==PSD_ON)
       res_rfsz2 = temp_res_rfsz2;
  }


	    sp_sattemp = pend(&gzrfsz2d, "gzrfsz2d", *sat_index);
	    
	    ending = pendallssp(&rfsz2, *sat_index);
	       
  {
    pulsename(&isi_satz2,"isi_satz2");
    createconst(&isi_satz2,(WF_PROCESSOR)wg_isi_satz2,pw_isi_satz2,(short)0); 
    createinstr( &isi_satz2,(long)(ending),pw_isi_satz2,0);
  }

	    getctrl(&ctrl_word, &isi_satz2, *sat_index);
	    ctrl_word = ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satz2, *sat_index);
            rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	    
	       
  {
    pulsename(&rot_update_z2,"rot_update_z2");
    createconst(&rot_update_z2,(WF_PROCESSOR)wg_rot_update_z2,pw_rot_update_z2,(short)0); 
    createinstr( &rot_update_z2,(long)(rot_update_time),pw_rot_update_z2,0);
  }

	    getctrl(&ctrl_word, &rot_update_z2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_z2, *sat_index);
	    sp_sattemp = rot_update_time + pw_rotupdate;	    

	    sp_pos_killer = sp_sattemp + pw_gyksz2a + isi_extra;
	          

  trapezoid((WF_PROCESSOR)wg_gyksz2, "gyksz2", &gyksz2, &gyksz2a,
                        &gyksz2d, pw_gyksz2, pw_gyksz2a, pw_gyksz2d,
                        ia_gyksz2, 0, 0, 0, 0, sp_pos_killer-pw_gyksz2a, TRAP_ALL,
                        &loggrd);
 
	    sp_sattemp = pend(&gyksz2d, "gyksz2d", *sat_index);
	    
	    if (area_gxksz2!=0.0)
            {
		    

  trapezoid((WF_PROCESSOR)wg_gxksz2, "gxksz2", &gxksz2, &gxksz2a,
                        &gxksz2d, pw_gxksz2, pw_gxksz2a, pw_gxksz2d,
                        ia_gxksz2, 0, 0, 0, 0, sp_pos_killer-pw_gxksz2a, TRAP_ALL,
                        &loggrd);

		if  (pend(&gxksz2d, "gxksz2d", *sat_index)>sp_sattemp)
                    sp_sattemp = pend(&gxksz2d, "gxksz2d", *sat_index);
            }
	    
	          
  {
    pulsename(&isi_satzk2,"isi_satzk2");
    createconst(&isi_satzk2,(WF_PROCESSOR)wg_isi_satzk2,pw_isi_satzk2,(short)0); 
    createinstr( &isi_satzk2,(long)(sp_sattemp-isi_satdelay),pw_isi_satzk2,0);
  }

	    getctrl(&ctrl_word, &isi_satzk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satzk2, *sat_index);
	    
	            
  {
    pulsename(&rot_update_zk2,"rot_update_zk2");
    createconst(&rot_update_zk2,(WF_PROCESSOR)wg_rot_update_zk2,pw_rot_update_zk2,(short)0); 
    createinstr( &rot_update_zk2,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_zk2,0);
  }

	    getctrl(&ctrl_word, &rot_update_zk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_zk2, *sat_index);
	    
	    /* RJL 08/24/95. More dynamic calculation of timing */
	    sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra;
        }
    }
    
    /* Slice select macro creates a since RF pulse. 
       A psd can use either sinc or SLR RF pulses. Parallel sat bands
       with the same thickness use a hadamard RF pulse. This one
       pulse replaces the 2 separate RF pulses. If the RF
       pulse is sinc, a hadamard sinc pulse is used. Likewise 
       if the SLR RF pulse is used, a hadamard SLR pulse is used. */
    
    /******************************************************************************
     ** This section has undergone significant restructuring to accomode rfpulse
     ** scaling following system safety requirements. The overall function is
     ** still similar. In the first case (SINC_SAT), the resolutions are changed
     ** if pulse scaling was performed. Interpolation is not required since the
     ** pulse is generated internally. For (SLR_SAT), the pulse is read into a work
     ** buffer (temp_wave), and copied over to the kernel file either in original
     ** size or increased size if scaling required. All scaling is performed before
     ** hadamard sat's are created. It is assumed that not all sat regions will have
     ** similar pulse resolutions, and scaling may or may not be required for each
     ** rfpulse SAT.  The final rfpulse is then immediate moved (movewaveimm) onto
     ** the RHO board, and allocated memory freed.
     ******************************************************************************/

    switch (sat_type) 
    {
        /* If hadamard, create and load in hadamard */
    case SINC_SAT:
	
	/* Change resolutions if rfpulse scaled */
	if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
            res_rfsx1 = rfpulseInfo[RFSX1_SLOT].newres;
	if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
            res_rfsy1 = rfpulseInfo[RFSY1_SLOT].newres;
	if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
            res_rfsz1 = rfpulseInfo[RFSZ1_SLOT].newres;

	if (opsatx == PSD_SATHAD) 
	  {
	    separation = 2*satspacex1/satthickx1;
	    wave_space_rho = (SHORT *)AllocNode(res_rfsx1*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfsx1, max_pg_wamp, separation,
		      cyc_rfsx1, alpha_rfsx1);
	    movewaveimm(wave_space_rho, &rfsx1, (INT)0, res_rfsx1, TOHARDWARE);
	  }
	
	if (opsaty == PSD_SATHAD) 
	  {
	    separation = 2*satspacey1/satthicky1;
	    wave_space_rho = (SHORT *)AllocNode(res_rfsy1*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfsy1, max_pg_wamp, separation,
		      cyc_rfsy1, alpha_rfsy1);
	    movewaveimm(wave_space_rho, &rfsy1, (INT)0, res_rfsy1, TOHARDWARE);
	  }
	
	if (opsatz == PSD_SATHAD) 
	  {
	    separation = 2*satspacez1/satthickz1;
	    wave_space_rho = (SHORT *)AllocNode(res_rfsz1*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfsz1, max_pg_wamp, separation,
		      cyc_rfsz1, alpha_rfsz1);
	    movewaveimm(wave_space_rho, &rfsz1, (INT)0, res_rfsz1, TOHARDWARE);
	  }
	
	FreeNode(wave_space_rho);
	break;
	
	/* Include SLR RF files  */
    case SLR_SAT:
    case SLR_CSAT:

        switch (sat_type)
        {
        case SLR_SAT:
	     strcpy(rho_file, "rfdblsatl0.rho");
	     temp_wave_rho = (SHORT *)AllocNode(RES_SLRSAT*sizeof(SHORT));
	     uextwave(temp_wave_rho, RES_SLRSAT, rho_file);
             break;

        case SLR_CSAT:
             strcpy(rho_file, "satqptbw12.rho");
             temp_wave_rho = (SHORT *)AllocNode(RES_SLRCSAT*sizeof(SHORT));
             uextwave(temp_wave_rho, RES_SLRCSAT, rho_file);

             if (sat_pulse_type == COMPLEX_RF)
             {
                strcpy(theta_file, "satqptbw12.the");
                temp_wave_theta = (SHORT *)AllocNode(RES_SLRCSAT*sizeof(SHORT));
                uextwave(temp_wave_theta, RES_SLRCSAT, theta_file);
             }
             break;

        default:
             break;
        }
	
	if (opsatx != PSD_SATOFF) 
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
	      {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSX1_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSX1_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfsx1,(int)rfpulseInfo[RFSX1_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSX1_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSX1_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfsx1,(int)rfpulseInfo[RFSX1_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfsx1 = rfpulseInfo[RFSX1_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfsx1*sizeof(SHORT));

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfsx1*sizeof(SHORT));
                }
	      }

	    if (opsatx == PSD_SATHAD)
	      { /* Hadamard sat */
		separation = satspacex1/2.0/satthickx1;
		freqstep = 65536.0/(float) res_rfsx1;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfsx1, kernel_tab_rho, kernel_tab_theta, cyc_rfsx1,
			 separation, gscale_rfsx1, NULL,
			 (FLOAT)0, hadamard_tab_rho, hadamard_tab_theta, freqstep);
                  
                   movewaveimm(hadamard_tab_theta, &rfsx1Theta, (INT)0, res_rfsx1,
                         TOHARDWARE);

                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfsx1, kernel_tab_rho, cyc_rfse3,
                         separation, gscale_rfsx1, NULL, (FLOAT)0,
                         hadamard_tab_rho, freqstep);
                }

		movewaveimm(hadamard_tab_rho, &rfsx1, (INT)0, res_rfsx1, 
				TOHARDWARE); 

		if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho); 
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }            
	      }
	    else
	      { 
		movewaveimm(kernel_tab_rho, &rfsx1, (INT)0, res_rfsx1, 
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfsx1Theta, (INT)0, res_rfsx1,
                               TOHARDWARE);
                }

		if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho); 
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }            
		/* Check for parallel sat region */
		if (opsatx == PSD_SATPARA)
		  {
		    if (rfpulseInfo[RFSX2_SLOT].change==PSD_ON)
		      {
			kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSX2_SLOT].newres*sizeof(SHORT));
			stretchpulse((int)res_rfsx2,(int)rfpulseInfo[RFSX2_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSX2_SLOT].newres*sizeof(SHORT));
                           stretchpulse((int)res_rfsx2,(int)rfpulseInfo[RFSX2_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                        }

			res_rfsx2 = rfpulseInfo[RFSX2_SLOT].newres;
		      }
		    else
                      {
		        kernel_tab_rho = temp_wave_rho; 
                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = temp_wave_theta;
                        }
                      }

		    movewaveimm(kernel_tab_rho, &rfsx2, (INT)0, res_rfsx2,
				TOHARDWARE); 
                    if (sat_pulse_type == COMPLEX_RF)
                    {
                       movewaveimm(kernel_tab_theta, &rfsx2Theta, (INT)0, res_rfsx2,
                                   TOHARDWARE);
                    }
		  }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }

	    if (rfpulseInfo[RFSX2_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	if (opsaty != PSD_SATOFF) 
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
	      {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSY1_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSY1_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfsy1,(int)rfpulseInfo[RFSY1_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSY1_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSY1_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfsy1,(int)rfpulseInfo[RFSY1_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfsy1 = rfpulseInfo[RFSY1_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfsy1*sizeof(SHORT));

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfsy1*sizeof(SHORT));
                }
	      }

	    if (opsaty == PSD_SATHAD)
	      { /* Hadamard sat */
		separation = satspacey1/2.0/satthicky1;
		freqstep = 65536.0/(float) res_rfsy1;

                if (sat_pulse_type == COMPLEX_RF)
                {
    		   altcomplexrfgen((INT)TYPLINEAR, res_rfsy1, kernel_tab_rho, kernel_tab_theta, cyc_rfsy1,
			 separation, gscale_rfsy1, NULL,
			 (FLOAT)0, hadamard_tab_rho, hadamard_tab_theta, freqstep);

                   movewaveimm(hadamard_tab_theta, &rfsy1Theta, (INT)0, res_rfsy1,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfsy1, kernel_tab_rho, cyc_rfsy1,
                         separation, gscale_rfsy1, NULL,
                         (FLOAT)0, hadamard_tab_rho, freqstep);
                }
		movewaveimm(hadamard_tab_rho, &rfsy1, (INT)0, res_rfsy1, 
			    TOHARDWARE); 

		if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho);   
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfsy1, (INT)0, res_rfsy1, 
			    TOHARDWARE);
                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfsy1Theta, (INT)0, res_rfsy1,
                               TOHARDWARE);
                }
		if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho);  
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta); 
                   }
                }
		if (opsaty == PSD_SATPARA)
		  {
		    if (rfpulseInfo[RFSY2_SLOT].change==PSD_ON)
		      {
			kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSY2_SLOT].newres*sizeof(SHORT));
			stretchpulse((int)res_rfsy2,(int)rfpulseInfo[RFSY2_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSY2_SLOT].newres*sizeof(SHORT));
                           stretchpulse((int)res_rfsy2,(int)rfpulseInfo[RFSY2_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                        }
			res_rfsy2 = rfpulseInfo[RFSY2_SLOT].newres;
		      }
		    else
                      {
		        kernel_tab_rho = temp_wave_rho;  
                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = temp_wave_theta; 
                        }
                      }
		  movewaveimm(kernel_tab_rho, &rfsy2, (INT)0, res_rfsy2, 
			      TOHARDWARE);
                  if (sat_pulse_type == COMPLEX_RF)
                  {
                     movewaveimm(kernel_tab_theta, &rfsy2Theta, (INT)0, res_rfsy2,
                                 TOHARDWARE);
                  }

		  }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }
	    if (rfpulseInfo[RFSY2_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	if (opsatz != PSD_SATOFF) 
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
	      {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSZ1_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSZ1_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfsz1,(int)rfpulseInfo[RFSZ1_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSZ1_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSZ1_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfsz1,(int)rfpulseInfo[RFSZ1_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfsz1 = rfpulseInfo[RFSZ1_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfsz1*sizeof(SHORT));

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfsz1*sizeof(SHORT));
                }
	      }

	    if (opsatz == PSD_SATHAD)
	      { /* Hadamard sat */
		separation = satspacez1/2.0/satthickz1;
		freqstep = 65536.0/(float) res_rfsz1;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfsz1, kernel_tab_rho, kernel_tab_theta, cyc_rfsz1,
			 separation, gscale_rfsz1, NULL,
			 (FLOAT)0, hadamard_tab_rho, hadamard_tab_theta, freqstep);
                   movewaveimm(hadamard_tab_theta, &rfsz1Theta, (INT)0, res_rfsz1,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfsz1, kernel_tab_rho, cyc_rfsz1,
                         separation, gscale_rfsz1, NULL,
                         (FLOAT)0, hadamard_tab_rho, freqstep);
                }

		movewaveimm(hadamard_tab_rho, &rfsz1, (INT)0, res_rfsz1, 
			    TOHARDWARE);

		if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho);   
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfsz1, (INT)0, res_rfsz1, 
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfsz1Theta, (INT)0, res_rfsz1,
                              TOHARDWARE);
                }
		if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho);   
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }
		if (opsatz == PSD_SATPARA)
		  {
		    if (rfpulseInfo[RFSZ2_SLOT].change==PSD_ON)
		      {
			kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSZ2_SLOT].newres*sizeof(SHORT));
			stretchpulse((int)res_rfsz2,(int)rfpulseInfo[RFSZ2_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSZ2_SLOT].newres*sizeof(SHORT));
                           stretchpulse((int)res_rfsz2,(int)rfpulseInfo[RFSZ2_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                        } 

			res_rfsz2 = rfpulseInfo[RFSZ2_SLOT].newres;
		      }
		    else
                      {
		        kernel_tab_rho = temp_wave_rho; 
                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = temp_wave_theta;
                        }
                      }

		    movewaveimm(kernel_tab_rho, &rfsz2, (INT)0, res_rfsz2, 
				TOHARDWARE); 

                    if (sat_pulse_type == COMPLEX_RF)
                    {
                       movewaveimm(kernel_tab_theta, &rfsz2Theta, (INT)0, res_rfsz2,
                                   TOHARDWARE);
                    }

		  }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }
	    if (rfpulseInfo[RFSZ2_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }

	FreeNode(temp_wave_rho);
        if (sat_pulse_type == COMPLEX_RF)
        {
           FreeNode(temp_wave_theta);
        }
	break;
	
    default:
	break;
    }
    
    *sat_index += 1;
    
    return SUCCESS;
}

STATUS
SpSatPG_fgre( INT sat_type,
              INT start_time,
              INT *sat_index,
              INT cardiacsat_pos,
              INT seq_time )
{
    SpSatPG(sat_type, start_time, sat_index, cardiacsat_pos);
  
    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return (SUCCESS);
    else
    {
          
  {
    pulsename(&seqsat_fgre,"seqsat_fgre");
    createseq(&seqsat_fgre,seq_time, off_seqsat_fgre);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqsat_fgre );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqsat_fgre = %d\n", idx_seqsat_fgre );
#endif
  }

        return (SUCCESS);
    }
}

/* Create a null sequence */
STATUS
SpSatCatRelaxPG( INT ssi_time )
{
    INT seq_time;
  
       
  {
    pulsename(&y_ccs_null,"y_ccs_null");
    createconst(&y_ccs_null,(WF_PROCESSOR)wg_y_ccs_null,pw_y_ccs_null,(short)0); 
    createinstr( &y_ccs_null,(long)(RUP_GRD(8  )),pw_y_ccs_null,0);
  }

  
    seq_time = RUP_GRD(ccs_relaxseqtime - ssi_time);
    
  {
    pulsename(&cat_seq,"cat_seq");
    createseq(&cat_seq,seq_time, off_cat_seq);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_cat_seq );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_cat_seq = %d\n", idx_cat_seq );
#endif
  }

  
    return SUCCESS;
}

STATUS
SpSatCatRelaxOffsets( SEQUENCE_ENTRIES sequence_offsets )
{
    off_cat_seq[(int)TYPXGRAD]= sequence_offsets[(int)TYPXGRAD];
    off_cat_seq[(int)TYPZGRAD]= sequence_offsets[(int)TYPZGRAD];
  
    return SUCCESS;
}

/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                             PSipg                                 *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/

/*
 *  PS1pulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1pulsegen( INT posstart )
{
    INT postemp;
    INT ta_180, tb_180, te_180;
    INT end_encode;

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/


         
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1mps1", 
                                    (WF_PROCESSOR)wg_rf1mps1);

    /* Modify resolution if scaling required */
    temp_res_rf1mps1 = res_rf1mps1;
    if (rfpulseInfo[RF1_APS1_SLOT].change==PSD_ON)
       res_rf1mps1 = rfpulseInfo[RF1_APS1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1mps1a,"gzrf1mps1a");
    pulsename(&gzrf1mps1,"gzrf1mps1");
    pulsename(&gzrf1mps1d,"gzrf1mps1d");
    pulsename(&rf1mps1,"rf1mps1");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf1mps1a,ZGRAD,pw_gzrf1mps1a,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1mps1a/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1mps1a,(LONG)(posstart-pw_gzrf1mps1a),
		pw_gzrf1mps1a,ia_gzrf1mps1);
    createconst(&gzrf1mps1,ZGRAD,pw_gzrf1mps1,MAX_PG_WAMP);
    createinstr( &gzrf1mps1,(LONG)(posstart),
		pw_gzrf1mps1,ia_gzrf1mps1);
    createramp(&gzrf1mps1d,ZGRAD,pw_gzrf1mps1d,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1mps1d/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1mps1d,(LONG)(posstart+pw_gzrf1mps1),
		pw_gzrf1mps1d,ia_gzrf1mps1);
    
    /* Now create the rf pulse */
    createsinc(&rf1mps1,(WF_PROCESSOR)wg_rf1mps1,res_rf1mps1,
	       MAX_PG_WAMP,cyc_rf1mps1, alpha_rf1mps1);
    createinstr( &rf1mps1,(LONG)(posstart) + psd_rf_wait,
		pw_rf1mps1,ia_rf1mps1);
    linkpulses(4,&rf1mps1,&gzrf1mps1,&gzrf1mps1a,
	       &gzrf1mps1d);
    addrfbits(&rf1mps1,off_rf1mps1,(LONG)(posstart) + psd_rf_wait, 
	      pw_rf1mps1);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_APS1_SLOT].change==PSD_ON)
       res_rf1mps1 = temp_res_rf1mps1;
  }


    /* Refocus on Z gradient */
    postemp = RUP_GRD(pend(&gzrf1mps1d,"gzrf1mps1d",0));
         

  trapezoid((WF_PROCESSOR)wg_gz1mps1, "gz1mps1", &gz1mps1, &gz1mps1a,
                        &gz1mps1d, pw_gz1mps1, pw_gz1mps1a, pw_gz1mps1d,
                        ia_gz1mps1, 0, 0, 0, 0, postemp+pw_gz1mps1a-pw_gz1mps1a, TRAP_ALL,
                        &ps1loggrd);

    end_encode = pend(&gz1mps1d,"gz1mps1d",0);    

    /* read dephaser */
    postemp = RUP_GRD(pend(&gzrf1mps1, "gzrf1mps1", 0)+rfupd+pw_gx1mps1a);
         

  trapezoid((WF_PROCESSOR)wg_gx1mps1, "gx1mps1", &gx1mps1, &gx1mps1a,
                        &gx1mps1d, pw_gx1mps1, pw_gx1mps1a, pw_gx1mps1d,
                        ia_gx1mps1, 0, 0, 0, 0, postemp-pw_gx1mps1a, TRAP_ALL,
                        &ps1loggrd);

    if(pend(&gx1mps1d,"gx1mps1d",0)>end_encode)
    {
        end_encode = pend(&gx1mps1d,"gx1mps1d",0);
    }

    /****** figure out minimum te from z grad, compare needed 
      time before and after 180 *********/
    tb_180  =  end_encode - ( RUP_GRD(1000) + pw_rf1mps1/2 - PSoff90)
        + pw_gzrf2lmps1a + pw_gzrf2lmps1 + pw_gzrf2lmps1d + pw_rf2mps1/2;

    ta_180  = pw_rf2mps1/2 + pw_gzrf2rmps1a + pw_gzrf2rmps1 + pw_gzrf2rmps1d
        + pw_gxwmps1/2 - psd_rf_wait + psd_grd_wait + DABSETUP;

    te_180 = RUP_GRD(2*(IMax(3, ta_180, tb_180, min180te/2)));

    postemp = RUP_GRD( (RUP_GRD(1000) + pw_rf1mps1/2 - PSoff90)
                       + (te_180/2) - pw_rf2mps1/2 );

         
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2mps1", 
                                    (WF_PROCESSOR)wg_rf2mps1);

    /* Modify resolution if scaling required */
    temp_res_rf2mps1 = res_rf2mps1;
    if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
       res_rf2mps1 = rfpulseInfo[RF2_APS1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2mps1a,"gzrf2mps1a");
    pulsename(&gzrf2mps1,"gzrf2mps1");
    pulsename(&gzrf2mps1d,"gzrf2mps1d");
    pulsename(&rf2mps1,"rf2mps1");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf2mps1a,ZGRAD,pw_gzrf2mps1a,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2mps1a/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2mps1a,(LONG)(postemp-pw_gzrf2mps1a),
		pw_gzrf2mps1a,ia_gzrf2mps1);
    createconst(&gzrf2mps1,ZGRAD,pw_gzrf2mps1,MAX_PG_WAMP);
    createinstr( &gzrf2mps1,(LONG)(postemp),
		pw_gzrf2mps1,ia_gzrf2mps1);
    createramp(&gzrf2mps1d,ZGRAD,pw_gzrf2mps1d,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2mps1d/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2mps1d,(LONG)(postemp+pw_gzrf2mps1),
		pw_gzrf2mps1d,ia_gzrf2mps1);
    
    /* Now create the rf pulse */
    createsinc(&rf2mps1,(WF_PROCESSOR)wg_rf2mps1,res_rf2mps1,
	       MAX_PG_WAMP,cyc_rf2mps1, alpha_rf2mps1);
    createinstr( &rf2mps1,(LONG)(postemp) + psd_rf_wait,
		pw_rf2mps1,ia_rf2mps1);
    linkpulses(4,&rf2mps1,&gzrf2mps1,&gzrf2mps1a,
	       &gzrf2mps1d);
    addrfbits(&rf2mps1,off_rf2mps1,(LONG)(postemp) + psd_rf_wait, 
	      pw_rf2mps1);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
       res_rf2mps1 = temp_res_rf2mps1;
  }


    /* crushers */
    postemp = pbeg(&gzrf2mps1,"gzrf2mps1",0) - pw_gzrf2lmps1 - pw_gzrf2lmps1d;
          

  trapezoid((WF_PROCESSOR)wg_gzrf2lmps1, "gzrf2lmps1", &gzrf2lmps1, &gzrf2lmps1a,
                        &gzrf2lmps1d, pw_gzrf2lmps1, pw_gzrf2lmps1a, pw_gzrf2lmps1d,
                        ia_gzrf2lmps1, 0, 0, 0, 0, postemp-pw_gzrf2lmps1a, TRAP_ALL,
                        &ps1loggrd);

  
           

  trapezoid((WF_PROCESSOR)wg_gzrf2rmps1, "gzrf2rmps1", &gzrf2rmps1, &gzrf2rmps1a,
                        &gzrf2rmps1d, pw_gzrf2rmps1, pw_gzrf2rmps1a, pw_gzrf2rmps1d,
                        ia_gzrf2rmps1, 0, 0, 0, 0, pendall(&gzrf2mps1,0)-pw_gzrf2rmps1a, TRAP_ALL,
                        &ps1loggrd);

  
    postemp = RUP_GRD(pmid(&gzrf2mps1,"gzrf2mps1",0)+ (te_180/2) - pw_gxwmps1/2);
         

  trapezoid((WF_PROCESSOR)wg_gxwmps1, "gxwmps1", &gxwmps1, &gxwmps1a,
                        &gxwmps1d, pw_gxwmps1, pw_gxwmps1a, pw_gxwmps1d,
                        ia_gxwmps1, 0, 0, 0, 0, postemp-pw_gxwmps1a, TRAP_ALL,
                        &ps1loggrd);
    

        
  {
    pulsename(&echo1mps1,"echo1mps1");
    acqq(&echo1mps1, (long)(pbeg(&gxwmps1,"gxwmps1",0)+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1mps1,
        (TYPDAB_PACKETS)DABNORM);
  }


      
  {
  pulsename(&attenuator_keymps1,"attenuator_keymps1");
  createatten(&attenuator_keymps1, (long)(pend(&gxwmps1,"gxwmps1",0)));
}


      
  {
    pulsename(&seqmps1,"seqmps1");
    createseq(&seqmps1,ps1_tr, off_seqmps1);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqmps1 );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqmps1 = %d\n", idx_seqmps1 );
#endif
  }


    return SUCCESS;
}

/*
 *  CFLpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLpulsegen( INT posstart )
{
    INT postemp;
    INT tsamp_delay_cfl;

    tsamp_delay_cfl = RUP_GRD(1000);

    /*  90 slice sel pulse  */
       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1cfl", 
                                    (WF_PROCESSOR)wg_rf1cfl);

    /* Modify resolution if scaling required */
    temp_res_rf1cfl = res_rf1cfl;
    if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
       res_rf1cfl = rfpulseInfo[RF1_CFL_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1cfla,"gzrf1cfla");
    pulsename(&gzrf1cfl,"gzrf1cfl");
    pulsename(&gzrf1cfld,"gzrf1cfld");
    pulsename(&rf1cfl,"rf1cfl");
    
    /*  Now create the slice select trapezoid */
	pg_beta = cflloggrd.zbeta;
    createramp(&gzrf1cfla,ZGRAD,pw_gzrf1cfla,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfla/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1cfla,(LONG)(posstart-pw_gzrf1cfla),
		pw_gzrf1cfla,ia_gzrf1cfl);
    createconst(&gzrf1cfl,ZGRAD,pw_gzrf1cfl,MAX_PG_WAMP);
    createinstr( &gzrf1cfl,(LONG)(posstart),
		pw_gzrf1cfl,ia_gzrf1cfl);
    createramp(&gzrf1cfld,ZGRAD,pw_gzrf1cfld,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1cfld/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1cfld,(LONG)(posstart+pw_gzrf1cfl),
		pw_gzrf1cfld,ia_gzrf1cfl);
    
    /* Now create the rf pulse */
    createsinc(&rf1cfl,(WF_PROCESSOR)wg_rf1cfl,res_rf1cfl,
	       MAX_PG_WAMP,cyc_rf1cfl, alpha_rf1cfl);
    createinstr( &rf1cfl,(LONG)(posstart) + psd_rf_wait,
		pw_rf1cfl,ia_rf1cfl);
    linkpulses(4,&rf1cfl,&gzrf1cfl,&gzrf1cfla,
	       &gzrf1cfld);
    addrfbits(&rf1cfl,off_rf1cfl,(LONG)(posstart) + psd_rf_wait, 
	      pw_rf1cfl);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
       res_rf1cfl = temp_res_rf1cfl;
  }

  
    /* Refocusing Pulse */
        
                    

  trapezoid((WF_PROCESSOR)wg_gz1cfl, "gz1cfl", &gz1cfl, &gz1cfla,
                        &gz1cfld, pw_gz1cfl, pw_gz1cfla, pw_gz1cfld,
                        ia_gz1cfl, 0, 0, 0, 0, pbeg(&gzrf1cfl,"gzrf1cfl",0)+pw_gzrf1cfl+pw_gzrf1cfld+pw_gz1cfla-pw_gz1cfla, TRAP_ALL,
                        &cflloggrd);

  
    /* Data Acquisiton with 2K filter */
         
  {
    pulsename(&cfl_fid,"cfl_fid");
    acqq(&cfl_fid, (long)(pendall(&gz1cfl,0)+tsamp_delay_cfl),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_cfl_fid,
        (TYPDAB_PACKETS)DABNORM);
  }

    /* Assert the ESSP flag on the rf1cfl pulse */
    attenflagon(&rf1cfl, 0);

    postemp = RUP_GRD(pendall(&gz1cfl,0) + tsamp_delay_cfl + cfl_tdaq + pw_gykcfla);

     
  {
  pulsename(&cfl_attenkey,"cfl_attenkey");
  createatten(&cfl_attenkey, (long)(postemp));
}

         

  trapezoid((WF_PROCESSOR)wg_gykcfl, "gykcfl", &gykcfl, &gykcfla,
                        &gykcfld, pw_gykcfl, pw_gykcfla, pw_gykcfld,
                        ia_gykcfl, 0, 0, 0, 0, postemp-pw_gykcfla, TRAP_ALL,
                        &cflloggrd);

  
      
  {
    pulsename(&seqcfl,"seqcfl");
    createseq(&seqcfl,cfl_tr, off_seqcfl);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfl );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfl = %d\n", idx_seqcfl );
#endif
  }


    return SUCCESS;
}

/*
 *  RCVNpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNpulsegen( INT posstart )
{
    INT postemp, postemp2;
    INT tsamp_delay_rcvn;
    INT unblank_delay_rcvn;

    /* MRIhc47602/MRIhc47515/GEHmr03545 */
    if ( rcvn_flag == 1 )
    {
               

  trapezoid((WF_PROCESSOR)wg_gxkrcvn, "gxkrcvn", &gxkrcvn, &gxkrcvna,
                        &gxkrcvnd, pw_gxkrcvn, pw_gxkrcvna, pw_gxkrcvnd,
                        ia_gxkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gxkrcvna)-pw_gxkrcvna, TRAP_ALL,
                        &rcvnloggrd);

               

  trapezoid((WF_PROCESSOR)wg_gykrcvn, "gykrcvn", &gykrcvn, &gykrcvna,
                        &gykrcvnd, pw_gykrcvn, pw_gykrcvna, pw_gykrcvnd,
                        ia_gykrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gykrcvna)-pw_gykrcvna, TRAP_ALL,
                        &rcvnloggrd);

               

  trapezoid((WF_PROCESSOR)wg_gzkrcvn, "gzkrcvn", &gzkrcvn, &gzkrcvna,
                        &gzkrcvnd, pw_gzkrcvn, pw_gzkrcvna, pw_gzkrcvnd,
                        ia_gzkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gzkrcvna)-pw_gzkrcvna, TRAP_ALL,
                        &rcvnloggrd);


    }
    else if ( rcvn_flag == 2 ) /* extra delay before rcvn */
    {
        
  {
    pulsename(&rcvn_wait,"rcvn_wait");
    createconst(&rcvn_wait,(WF_PROCESSOR)wg_rcvn_wait,pw_rcvn_wait,(short)0); 
    createinstr( &rcvn_wait,(long)(RUP_GRD(posstart)),pw_rcvn_wait,0);
  }

    }
      
  {
    pulsename(&pre_rcvn,"pre_rcvn");
    createseq(&pre_rcvn,RUP_GRD(pre_rcvn_tr+posstart), off_pre_rcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_pre_rcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_pre_rcvn = %d\n", idx_pre_rcvn );
#endif
  }


    unblank_delay_rcvn = RUP_GRD(1000);
    tsamp_delay_rcvn = RUP_GRD(2000);

    /* RCVRUNBLANK & RCVRBLANK mechanism is normally taken care 
       of by the RF pulse itself. However RCVN entry point does
       not have any RF pulse so we wrap data acqusition window. */

    /* Unblank receiver before Data Acquisition window */
    
  {
    rcvrbl_pack[0] = SSPDS+RDC;
    rcvrbl_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl_pack[2] = SSPD+RUBL;
    rcvrbl_pack[3] = SSPDS;

    pulsename(&rcvrbl,"rcvrbl");
    createbits(&rcvrbl,TYPSSP,4,rcvrbl_pack);
    createinstr( &rcvrbl,(long)(unblank_delay_rcvn),4,ia_rcvrbl);
  }

  
    /* Data Acquisiton with 2K filter */
       
  {
    pulsename(&rcvn_fid,"rcvn_fid");
    acqq(&rcvn_fid, (long)(tsamp_delay_rcvn),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_rcvn_fid,
        (TYPDAB_PACKETS)DABNORM);
  }


    postemp  = RUP_GRD(tsamp_delay_rcvn + rcvn_tdaq);
    postemp2 = RUP_GRD(unblank_delay_rcvn + postemp);

     
  {
  pulsename(&rcvn_attenkey,"rcvn_attenkey");
  createatten(&rcvn_attenkey, (long)(postemp));
}


    /* Blank receiver after Data Acquisition is completed */
    
  {
    rcvrbl2_pack[0] = SSPDS+RDC;
    rcvrbl2_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl2_pack[2] = SSPD+RBL;
    rcvrbl2_pack[3] = SSPDS;

    pulsename(&rcvrbl2,"rcvrbl2");
    createbits(&rcvrbl2,TYPSSP,4,rcvrbl2_pack);
    createinstr( &rcvrbl2,(long)(postemp2),4,ia_rcvrbl2);
  }

  
      
  {
    pulsename(&seqrcvn,"seqrcvn");
    createseq(&seqrcvn,rcvn_tr, off_seqrcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrcvn = %d\n", idx_seqrcvn );
#endif
  }


    return SUCCESS;
}

/*
 *  CFHpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHpulsegen( INT posstart )
{
    INT postemp;
    INT cfh_te;   /* Run at operator TE unless below min cfh te.
                     Then run at min cfh te */
    INT cfh_te2;   /* vmx 05/02/95 YO */
    INT cfh_acq_window_pos;   /* vmx 05/02/94 YO */
    INT tsamp_delay_cfh;
    INT start_time = 0;
    INT start_time_CS = 0;
    INT start_time_MT = 0;
    INT pos_rf2;
    INT newcfh_tr;
    INT min_ssp;

    /* variables for presscfh */
    INT pos_rf3;

    tsamp_delay_cfh = RUP_GRD(1000);

    start_time = posstart;
    start_time_MT = posstart;
    start_time_CS = posstart;

    /* Check for CFH Inversion inclusion */
    if (PSD_ON == PSir)
    {
        short *temp_wave_space; /* temporary waveform space for rf scaling */
        short *wave_space; /* temporary waveform space for rf scaling */

        /* adiabatic pulse */
           
                       
                        
                          
                       
  {
    INT new_res;                  /* temp holder for new pulse resolution */

    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf0cfh", 
                                     (WF_PROCESSOR)wg_rf0cfh);

    /* First create the pulses */
    pulsename(&gzrf0cfha,"gzrf0cfha");
    pulsename(&gzrf0cfh,"gzrf0cfh");
    pulsename(&gzrf0cfhd,"gzrf0cfhd");
    pulsename(&rf0cfh,"rf0cfh");

    /*  Now create the slice select trapezoid */
	pg_beta = cfhloggrd.zbeta;
    createramp(&gzrf0cfha,ZGRAD,pw_gzrf0cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf0cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfha,(LONG)(posstart-pw_gzrf0cfha),
		pw_gzrf0cfha,ia_gzrf0cfh);
    if ( 0 == PLAY_GFILE)
      {
	/*********************************************************************** 
	 ** Now create the waveform & perform required system safety checks
	 ** create a temporary buffer to modify gradient data using createreserve. Here
	 ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the waveform and
	 ** copy stretched data into permanent waveform memory. It is important to
	 ** to have temp buffer have new resolution size waveform memory.
	 ************************************************************************/
	if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
	  {
	    createreserve(&gzrf0cfh,ZGRAD,rfpulseInfo[RF0_CFH_SLOT].newres/2);
	    /********************************************************************* 
	     * Change pulse type to external createreserve zero fills resolution
	     * number of points in waveform memory for use.
	     ********************************************************************/
	    gzrf0cfh.type = TYPEXTERNAL;
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);
	    /* Scale the pulse, and then move to the reserved memory */
	    temp_wave_space = (short *)AllocNode(res_gzrf0cfh*sizeof(short));
	    uextwave(temp_wave_space, res_gzrf0cfh, grad_zrf0cfh);
	    wave_space = (short *)AllocNode(rfpulseInfo[RF0_CFH_SLOT].newres/2*sizeof(short));
	    stretchpulse((int)res_gzrf0cfh,(int)rfpulseInfo[RF0_CFH_SLOT].newres/2,
			 temp_wave_space,wave_space);
	    /* res_gz$[slsel_name] = rfpulseInfo[$[rf_slot]].newres/2; */
	    new_res = rfpulseInfo[RF0_CFH_SLOT].newres/2;
	    /* Copy over original pulse data */
	    movewaveimm(wave_space, &gzrf0cfh, (int)0, new_res, TOHARDWARE);
	    FreeNode(wave_space);
	    FreeNode(temp_wave_space);
	  }
	else
	  {
	    createextwave(&gzrf0cfh,ZGRAD, 
			  res_gzrf0cfh, grad_zrf0cfh);
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);
	  }
      }
    else
      {
	createconst(&gzrf0cfh,ZGRAD, pw_rf0cfh,MAX_PG_WAMP);
	createinstr( &gzrf0cfh,(LONG)(posstart),
		    pw_gzrf0cfh,ia_gzrf0cfh);
      }
    /* Decay ramp */
    createramp(&gzrf0cfhd,ZGRAD,pw_gzrf0cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf0cfhd/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfhd,(LONG)(posstart+pw_gzrf0cfh),
		pw_gzrf0cfhd,ia_gzrf0cfh);
    
    /*********************************************************************** 
    ** Now create the rf pulse & perform required system safety checks
    ** create a temporary buffer to modify rfpulse data using createsinc. Here
    ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the pulse and
    ** copy stretched data into permanent waveform memory. It is important to
    ** to have temp buffer have new resolution size waveform memory.
    ************************************************************************/
    if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
      {
	cyc_rf0cfh = 1.0; /* Make sure we have a value for createsinc */
	createsinc(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,rfpulseInfo[RF0_CFH_SLOT].newres,
		   MAX_PG_WAMP,cyc_rf0cfh,alpha_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);

	/* Create some RHO waveform space, scale the pulse, and then move
	 * the local memory to the reserved RHO memory, and set pulsepointers
	 * to new stretched pulse
	 */
	temp_wave_space = (short *)AllocNode(res_rf0cfh*sizeof(short));
	uextwave(temp_wave_space, res_rf0cfh, rf_rf0cfh);
	wave_space = (short *)AllocNode(rfpulseInfo[RF0_CFH_SLOT].newres*sizeof(short));
	stretchpulse((int)res_rf0cfh,rfpulseInfo[RF0_CFH_SLOT].newres,
		     temp_wave_space,wave_space);
	/* res_$[slsel_name] = rfpulseInfo[$[rf_slot]].newres; */
	new_res = rfpulseInfo[RF0_CFH_SLOT].newres;
        /* Copy over original pulse data */
	movewaveimm(wave_space, &rf0cfh, (int)0, new_res, TOHARDWARE);
	FreeNode(wave_space);
	FreeNode(temp_wave_space);
      }
    else
      {
	/* No rf scaling required. Use createextwave to read pulse 
	 * and move to HW 
	 */
	createextwave(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,
		      res_rf0cfh,rf_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);
      }
}


           
                   
  {

    short *stretched_wave_space;  /* temporary waveform space */
    short *wave_space;            /* temporary waveform space for
                                     stretched RF pulse */
    INT old_res;                  /* temp holder for old pulse resolution */
    INT new_res;                  /* temp holder for new pulse resolution */

    if ( (wg_omegarf0cfh != TYPRHO1)  && (wg_omegarf0cfh != TYPRHO2) &&
         (wg_omegarf0cfh != TYPTHETA) && (wg_omegarf0cfh != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    old_res =  res_omegarf0cfh;
    new_res =  rfpulseInfo[rfslot_omegarf0cfh].newres;

    n_omegarf0cfh += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( omegarf0cfh.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&omegarf0cfh,"omegarf0cfh");
        
        /* Scale waveform if needed */
        if( rfpulseInfo[rfslot_omegarf0cfh].change==PSD_ON ) {

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&omegarf0cfh, (WF_PROCESSOR)wg_omegarf0cfh, new_res);

            /* Allocate memory for original RF pulse */
            wave_space = (short *)AllocNode(old_res*sizeof(short));
            /* Read RF pulse from file and store to wave_space */
            uextwave(wave_space, old_res, fileloc_omegarf0cfh);

            /* Allocate memory for stretched RF pulse */
            stretched_wave_space = (short *)AllocNode(new_res*sizeof(short));
            
            stretchpulse(old_res, new_res, wave_space, stretched_wave_space);
            
            /* Move stretched pulse immediately into reserved memory */
            movewaveimm(stretched_wave_space, &omegarf0cfh,
                        (int)0, new_res, TOHARDWARE);
            
             /* Free memory allocated for original RF pulse */
            FreeNode(wave_space);
            /* Free memory allocated for stretched RF pulse */
            FreeNode(stretched_wave_space);
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_omegarf0cfh = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&omegarf0cfh,(WF_PROCESSOR)wg_omegarf0cfh,
                          old_res,fileloc_omegarf0cfh);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &omegarf0cfh,(LONG)(posstart) + psd_rf_wait, 
                 pw_omegarf0cfh,ia_omegarf0cfh);
    

    /*** Add RF Bits ***/
    addrfbits(&omegarf0cfh,off_omegarf0cfh,(LONG)(posstart) + psd_rf_wait,
              pw_omegarf0cfh);
    

    /*** Reset Resolution ***/
    res_omegarf0cfh = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */

  }


           
                     

  trapezoid((WF_PROCESSOR)wg_gyrf0kcfh, "gyrf0kcfh", &gyrf0kcfh, &gyrf0kcfha,
                        &gyrf0kcfhd, pw_gyrf0kcfh, pw_gyrf0kcfha, pw_gyrf0kcfhd,
                        ia_gyrf0kcfh, 0, 0, 0, 0, pend(&gzrf0cfh,"gzrf0cfh",0)+pw_gyrf0kcfha-pw_gyrf0kcfha, TRAP_ALL,
                        &cfhloggrd);

    
        /* Setting up WAIT duration */
        /* 1ms is added at the end so that ssp sequencer has no overlap 
           as 'frq', and RF amp unblank pulses are played. */
        dur_invse = RUP_GRD(cfh_ti - pw_rf0cfh/2 - pw_gyrf0kcfha - pw_gyrf0kcfh 
                            - pw_gyrf0kcfhd  - pw_gzrf1cfha - pw_rf1cfh/2 - 1000);
#ifdef PSD_CFH_CHEMSAT
        if ((cs_sat == PSD_ON) && PScs_sat)
        {
            /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
            dur_invse -= RUP_GRD(cs_sattime - specir_delay);
#else
            dur_invse -= RUP_GRD(cs_sattime);
#endif
        }
#endif
        dur_invse = RUP_GRD(dur_invse);

        
  {
    pulsename(&zticfh,"zticfh");
    createconst(&zticfh,(WF_PROCESSOR)wg_zticfh,pw_zticfh,(short)0); 
    createinstr( &zticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_zticfh,0);
  }

        
  {
    pulsename(&rticfh,"rticfh");
    createconst(&rticfh,(WF_PROCESSOR)wg_rticfh,pw_rticfh,(short)0); 
    createinstr( &rticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_rticfh,0);
  }

        
  {
    pulsename(&xticfh,"xticfh");
    createconst(&xticfh,(WF_PROCESSOR)wg_xticfh,pw_xticfh,(short)0); 
    createinstr( &xticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_xticfh,0);
  }

        
  {
    pulsename(&yticfh,"yticfh");
    createconst(&yticfh,(WF_PROCESSOR)wg_yticfh,pw_yticfh,(short)0); 
    createinstr( &yticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_yticfh,0);
  }

        
  {
    pulsename(&sticfh,"sticfh");
    createconst(&sticfh,(WF_PROCESSOR)wg_sticfh,pw_sticfh,(short)0); 
    createinstr( &sticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_sticfh,0);
  }

    
        setperiod(dur_invse,&zticfh,0);
        setperiod(dur_invse,&rticfh,0);
        setperiod(dur_invse,&xticfh,0);
        setperiod(dur_invse,&yticfh,0);
        setperiod(dur_invse,&sticfh,0);
    
        /* Change start time for the 90 180 sequence; pw_gzrf1cfha added to 
           offset start_time calc in rf1cfh call */
        start_time    = pmid(&gzrf0cfh,"gzrf0cfh",0) + cfh_ti - pw_rf1cfh/2;
        start_time_MT = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;
        start_time_CS = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;

        amp_gyrf0kcfh = ia_gyrf0kcfh;
    }
    /* End of IR sequence check */
  
  

#ifdef PSD_CFH_CHEMSAT
    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        ChemSatPG(start_time_CS, &cscfh_satindex);
        cscfh_satindex -= 1;
    }
    if( (PSir != PSD_ON) && ( ((oppseq!=PSD_IR)
                               || (ssfse_ir_on == PSD_OFF)) && PScs_sat ) )
    {
        /* MRIge30640 - already caught in SLICESELZ2 call below! */
        /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
        start_time += (cs_sattime - specir_delay);
#else
        start_time += cs_sattime;
#endif
    }
#endif
  
    /*  90 slice sel pulse  */
       
                 
                        
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1cfh", 
                                    (WF_PROCESSOR)wg_rf1cfh);

    /* Modify resolution if scaling required */
    temp_res_rf1cfh = res_rf1cfh;
    if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
       res_rf1cfh = rfpulseInfo[RF1_CFH_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1cfha,"gzrf1cfha");
    pulsename(&gzrf1cfh,"gzrf1cfh");
    pulsename(&gzrf1cfhd,"gzrf1cfhd");
    pulsename(&rf1cfh,"rf1cfh");
    
    /*  Now create the slice select trapezoid */
	pg_beta = cfhloggrd.zbeta;
    createramp(&gzrf1cfha,ZGRAD,pw_gzrf1cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1cfha,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)-pw_gzrf1cfha),
		pw_gzrf1cfha,ia_gzrf1cfh);
    createconst(&gzrf1cfh,ZGRAD,pw_gzrf1cfh,MAX_PG_WAMP);
    createinstr( &gzrf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)),
		pw_gzrf1cfh,ia_gzrf1cfh);
    createramp(&gzrf1cfhd,ZGRAD,pw_gzrf1cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1cfhd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1cfhd,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)+pw_gzrf1cfh),
		pw_gzrf1cfhd,ia_gzrf1cfh);
    
    /* Now create the rf pulse */
    createsinc(&rf1cfh,(WF_PROCESSOR)wg_rf1cfh,res_rf1cfh,
	       MAX_PG_WAMP,cyc_rf1cfh, alpha_rf1cfh);
    createinstr( &rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait,
		pw_rf1cfh,ia_rf1cfh);
    linkpulses(4,&rf1cfh,&gzrf1cfh,&gzrf1cfha,
	       &gzrf1cfhd);
    addrfbits(&rf1cfh,off_rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait, 
	      pw_rf1cfh);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
       res_rf1cfh = temp_res_rf1cfh;
  }


    min_ssp = RUP_GRD(-rfupa + rfupd + RFUNBLANK_LENGTH + RFFREQ_LENGTH);

    if(PSfield_strength <= B0_5000)
    {

        cfh_te = (0.5 * pw_rf1cfh + PSoff90 + pw_rf2cfh
                  + IMax(2, min_ssp,
                         (pw_gzrf1cfhd + pw_gzrf2lcfha
                          + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                  + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd
                  + (cfh_tdaq  * cfh_ec_position));

        cfh_te2 = ((IMax(2, min_ssp,
                         (pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd
                          + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd))
                    + pw_rf2cfh)/ 2
                   + (cfh_tdaq * cfh_ec_position));
        cfh_te2 *= 2;

        cfh_te = IMax(3, cfh_te, cfh_te2, min180te);

        pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
    }
    else
    {
        if( presscfh_ctrl == PRESSCFH_NONE )
        {
            cfh_te =  0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90
                           + IMax(2, min_ssp,
                                  (pw_gzrf1cfhd + pw_gzrf2lcfha
                                   + pw_gzrf2lcfh + pw_gzrf2lcfhd));
            if (opspf == 0)
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }
            else
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gyrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }

            /* MRIge90312 - use 50ms TE for cfh */
            cfh_te = IMax(3, cfh_te, min180te, eff_cfh_te);

            pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                    + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
        }
        else
        {
            int temp_time = 0;

            cfh_te = IMax(2, presscfh_minte, eff_cfh_te);
            if( cfh_steam_flag != PSD_ON )
            {
                int echo1te = 0;

                echo1te =  0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90 +
                    IMax(2, min_ssp, (pw_gzrf1cfhd + pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                    + presscfh_wait_rf12;

                echo1te = 2*IMax(3, echo1te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);

                echo1te = IMax(2, echo1te, min180te);
                pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                        + 0.5 * echo1te - 0.5 * pw_rf2cfh));

                temp_time = IMax(2, pw_gyrf3cfha, pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                cfh_te = IMax(2, 2*temp_time + echo1te + pw_rf3cfh, cfh_te);

                pos_rf3 = RDN_GRD((int)(pos_rf2 + 0.5*pw_gxrf2cfh + 0.5*cfh_te - 0.5*pw_rf3cfh));
            }
            else
            {
                int mix_time = 0;

                temp_time = IMax(2, 2*min_ssp,  pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd 
                                 + steam_pg_gap + pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                mix_time = RUP_GRD(0.5 * (pw_gxrf2cfh + pw_gyrf3cfh) + temp_time);

                pos_rf2 = RUP_GRD( pmid(&gzrf1cfh,"gzrf1cfh",0) + 0.5*cfh_te - 0.5*pw_gxrf2cfh );
                pos_rf3 = RUP_GRD( pos_rf2 + 0.5*pw_gxrf2cfh + mix_time - 0.5*pw_gyrf3cfh );
            }
        }
    }

    if (rfpulseInfo[RF2_CFH_SLOT].change==PSD_ON)
    {
        res_rf2cfh = rfpulseInfo[RF2_CFH_SLOT].newres;
    }

         
  {
    pulsename(&rf2cfh,"rf2cfh");
    createsinc(&rf2cfh,(WF_PROCESSOR)wg_rf2cfh,res_rf2cfh,
               MAX_PG_WAMP,cyc_rf2cfh,alpha_rf2cfh);
    if ((wg_rf2cfh==TYPRHO1)||(wg_rf2cfh==TYPRHO2) ||
        (wg_rf2cfh==TYPTHETA)||(wg_rf2cfh==TYPOMEGA))
      {
        createinstr( &rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                    pw_rf2cfh,ia_rf2cfh);
        addrfbits(&rf2cfh,off_rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                  pw_rf2cfh);
      }
    else
      {
        createinstr( &rf2cfh,(long)(pos_rf2),
                    pw_rf2cfh,ia_rf2cfh);
      }
  }

    if( presscfh_ctrl != PRESSCFH_NONE ){ /* for presscfh_ctrl */
               
  {
    pulsename(&rf3cfh,"rf3cfh");
    createsinc(&rf3cfh,(WF_PROCESSOR)wg_rf3cfh,res_rf3cfh,
               MAX_PG_WAMP,cyc_rf3cfh,alpha_rf3cfh);
    if ((wg_rf3cfh==TYPRHO1)||(wg_rf3cfh==TYPRHO2) ||
        (wg_rf3cfh==TYPTHETA)||(wg_rf3cfh==TYPOMEGA))
      {
        createinstr( &rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                    pw_rf3cfh,ia_rf3cfh);
        addrfbits(&rf3cfh,off_rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                  pw_rf3cfh);
      }
    else
      {
        createinstr( &rf3cfh,(long)(pos_rf3),
                    pw_rf3cfh,ia_rf3cfh);
      }
  }
  
    } 

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TE = %d\n", cfh_te);
	printf("CFH : Mid Position of rf2cfh = %d\n", (int)(pos_rf2+pw_rf2cfh/2));
    }

    /* FOV selective gradients */
    if (opspf == 0 || presscfh_ctrl != PRESSCFH_NONE)
    {
             
                    

  trapezoid((WF_PROCESSOR)wg_gxrf2cfh, "gxrf2cfh", &gxrf2cfh, &gxrf2cfha,
                        &gxrf2cfhd, pw_gxrf2cfh, pw_gxrf2cfha, pw_gxrf2cfhd,
                        ia_gxrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gxrf2cfha, TRAP_ALL,
                        &cfhloggrd);

    }
    else
    {
             
                    

  trapezoid((WF_PROCESSOR)wg_gyrf2cfh, "gyrf2cfh", &gyrf2cfh, &gyrf2cfha,
                        &gyrf2cfhd, pw_gyrf2cfh, pw_gyrf2cfha, pw_gyrf2cfhd,
                        ia_gyrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gyrf2cfha, TRAP_ALL,
                        &cfhloggrd);

    }
    
    /* Z crushers */
        
                      

  trapezoid((WF_PROCESSOR)wg_gzrf2lcfh, "gzrf2lcfh", &gzrf2lcfh, &gzrf2lcfha,
                        &gzrf2lcfhd, pw_gzrf2lcfh, pw_gzrf2lcfha, pw_gzrf2lcfhd,
                        ia_gzrf2lcfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-(pw_gzrf2lcfh+pw_gzrf2lcfhd)-psd_rf_wait-pw_gzrf2lcfha, TRAP_ALL,
                        &cfhloggrd);

         
                  

  trapezoid((WF_PROCESSOR)wg_gzrf2rcfh, "gzrf2rcfh", &gzrf2rcfh, &gzrf2rcfha,
                        &gzrf2rcfhd, pw_gzrf2rcfh, pw_gzrf2rcfha, pw_gzrf2rcfhd,
                        ia_gzrf2rcfh, 0, 0, 0, 0, pendall(&rf2cfh,0)+pw_gzrf2rcfha-psd_rf_wait-pw_gzrf2rcfha, TRAP_ALL,
                        &cfhloggrd);


   if( presscfh_ctrl != PRESSCFH_NONE ){
             
                        

  trapezoid((WF_PROCESSOR)wg_gyrf3cfh, "gyrf3cfh", &gyrf3cfh, &gyrf3cfha,
                        &gyrf3cfhd, pw_gyrf3cfh, pw_gyrf3cfha, pw_gyrf3cfhd,
                        ia_gyrf3cfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-psd_rf_wait-pw_gyrf3cfha, TRAP_ALL,
                        &cfhloggrd);


        /* Z crushers */
            
                          

  trapezoid((WF_PROCESSOR)wg_gzrf3lcfh, "gzrf3lcfh", &gzrf3lcfh, &gzrf3lcfha,
                        &gzrf3lcfhd, pw_gzrf3lcfh, pw_gzrf3lcfha, pw_gzrf3lcfhd,
                        ia_gzrf3lcfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-(pw_gzrf3lcfh+pw_gzrf3lcfhd)-psd_rf_wait-pw_gzrf3lcfha, TRAP_ALL,
                        &cfhloggrd);

             
                      

  trapezoid((WF_PROCESSOR)wg_gzrf3rcfh, "gzrf3rcfh", &gzrf3rcfh, &gzrf3rcfha,
                        &gzrf3rcfhd, pw_gzrf3rcfh, pw_gzrf3rcfha, pw_gzrf3rcfhd,
                        ia_gzrf3rcfh, 0, 0, 0, 0, pendall(&rf3cfh,0)+pw_gzrf3rcfha-psd_rf_wait-pw_gzrf3rcfha, TRAP_ALL,
                        &cfhloggrd);


        /* steam_flag */
        if( cfh_steam_flag == PSD_ON ){
            INT pos_g1cfh = 0;
            pos_g1cfh = RUP_GRD( pbeg(&gzrf2lcfh, "gzrf2lcfh", 0) - pw_gzrf2lcfha 
                                 - pw_gy1cfh - pw_gy1cfhd );
                 

  trapezoid((WF_PROCESSOR)wg_gy1cfh, "gy1cfh", &gy1cfh, &gy1cfha,
                        &gy1cfhd, pw_gy1cfh, pw_gy1cfha, pw_gy1cfhd,
                        ia_gy1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gy1cfha, TRAP_ALL,
                        &cfhloggrd);

            pos_g1cfh = RUP_GRD( pend(&gzrf3rcfh, "gzrf3rcfh", 0) + pw_gzrf3rcfhd + pw_gx1cfha );
                 

  trapezoid((WF_PROCESSOR)wg_gx1cfh, "gx1cfh", &gx1cfh, &gx1cfha,
                        &gx1cfhd, pw_gx1cfh, pw_gx1cfha, pw_gx1cfhd,
                        ia_gx1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gx1cfha, TRAP_ALL,
                        &cfhloggrd);

        }
    }

    /* Data Acquisiton with .5K/.25k filter */
    if(PSfield_strength <= B0_5000)	/* vmx 05/02/94 */
    {
	cfh_acq_window_pos = RUP_GRD( (int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                            + cfh_te - (cfh_tdaq * cfh_ec_position)));
    }
    else
    {
        if( presscfh_ctrl == PRESSCFH_NONE ) {
	    cfh_acq_window_pos = RUP_GRD(pendall(&gzrf2rcfh,0) + tsamp_delay_cfh);
        } else {
            if( cfh_steam_flag != PSD_ON ){
	        cfh_acq_window_pos = RUP_GRD(pendall(&gzrf3rcfh,0) + tsamp_delay_cfh);
            }else{
                cfh_acq_window_pos = RUP_GRD(pendall(&gx1cfh,0) + tsamp_delay_cfh);
            }
        }
    }

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : Start of data window = %d\n", cfh_acq_window_pos);
    }

          
  {
    pulsename(&cfh_fid,"cfh_fid");
    acqq(&cfh_fid, (long)(cfh_acq_window_pos),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_cfh_fid,
        (TYPDAB_PACKETS)DABNORM);
  }

    /* vmx 05/02/05 YO */
    /* Assert the ESSP flag on the rf1cfh  and rf2cfh pulse */
    attenflagon(&rf1cfh, 0);  
    attenflagon(&rf2cfh, 0);
    if(presscfh_ctrl != PRESSCFH_NONE)
        attenflagon(&rf3cfh, 0); /* for presscfh */

    postemp = RUP_GRD(cfh_acq_window_pos + cfh_tdaq + pw_gykcfha);
     
  {
  pulsename(&cfh_attenkey,"cfh_attenkey");
  createatten(&cfh_attenkey, (long)(postemp));
}

         

  trapezoid((WF_PROCESSOR)wg_gykcfh, "gykcfh", &gykcfh, &gykcfha,
                        &gykcfhd, pw_gykcfh, pw_gykcfha, pw_gykcfhd,
                        ia_gykcfh, 0, 0, 0, 0, postemp-pw_gykcfha, TRAP_ALL,
                        &cfhloggrd);


    /*  If the TE is so long that the readout and killer are pushed out beyond
        the default cfh_tr, cfh_tr must be increased.  Setting cfh_tr to the
        end of the killer + 10ms (time_ssi should never be more than 10ms) 
        should do the trick.   */

    newcfh_tr = RUP_GRD( (((pendall(&gykcfh,0)+10000)>cfh_tr) ? (pendall(&gykcfh,0)+10000) : cfh_tr) );

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TR = %d\n", newcfh_tr);
    }

      
  {
    pulsename(&seqcfh,"seqcfh");
    createseq(&seqcfh,newcfh_tr, off_seqcfh);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfh );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfh = %d\n", idx_seqcfh );
#endif
  }


    return SUCCESS;
}


/*
 *  CoilSwitchPG
 *  
 *  Type: Private Function
 *  
 *  Description: Creates a ssp sequence which can set RF HUB index on
 *  RFHUBSEL. The sequence length needs to change depending upon
 *  setrcvportimm flag. If setrcvportimm needs to be called we need to
 *  provide additional time before starting to acquire as there is time
 *  delay in setting HW. So we add a wait pulse whos pulsewidth will be
 *  decided based on setrcvportimm flag. We also need a 'delay' sequence
 *  as explained in MRIhc14300.
 *  
 */
STATUS
CoilSwitchPG( void )
{
    INT PosContRFHubSel;

    /* SSP Packet for setting the hub index corresponding to the desired
     * coil configuration */
    short dcontrfhubsel[4] = {
        SSPDS,
        SSPOC | RFHUBSEL,
        SSPD,
        SSPDS
    };

    /* SSP Packet for changing receiver input */
    short dcontrfsel[4] = {     
        SSPDS,
        SSPOC | RRFSEL,
        SSPD | RFAUX,
        SSPDS
    };

    PosContRFHubSel = 15   + delay_rfhubsel;

    /* SSP sequence for changing RF Hub index for coil switch */
        
  {
    pulsename(&contrfhubsel,"contrfhubsel");
    createbits(&contrfhubsel,TYPSSP,sizeof(dcontrfhubsel)/2,dcontrfhubsel);
    createinstr( &contrfhubsel,(long)(PosContRFHubSel),
		pw_contrfhubsel,ia_contrfhubsel);
  }


    /* SSP Sequence for changing receiver input */
         
  {
    pulsename(&contrfsel,"contrfsel");
    createbits(&contrfsel,TYPSSP,sizeof(dcontrfsel)/2,dcontrfsel);
    createinstr( &contrfsel,(long)(pendallssp(&contrfhubsel,0)),
		pw_contrfsel,ia_contrfsel);
  }


    /* Insert a wait pulse to allow us to change the actual TR when
       a setrcvportimm() call is necessary */
        
  {
    pulsename(&csw_wait,"csw_wait");
    createconst(&csw_wait,(WF_PROCESSOR)wg_csw_wait,pw_csw_wait,(short)0); 
    createinstr( &csw_wait,(long)(pendallssp(&contrfsel,0)),pw_csw_wait,0);
  }


    csw_tr = 15   + delay_rfhubsel + pw_contrfhubsel + pw_contrfsel
        + SSP_UPDATE_TIME + csw_time_ssi;

    if( csw_tr < 1000 ) {
        /* Switch time needs to be long enough for RF Hub to switch the coils.
           This is much less than 1ms. */
        csw_tr = RUP_GRD(1000);
    }
        
  {
    pulsename(&seqcsw,"seqcsw");
    createseq(&seqcsw,RUP_GRD(csw_tr-csw_time_ssi), off_seqcsw);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcsw );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcsw = %d\n", idx_seqcsw );
#endif
  }


    /* MRIhc14300: Short wait pulse before setrcvportimm to avoid race
       condition with SCP */
      
  {
    pulsename(&seqcswWaitBefore,"seqcswWaitBefore");
    createseq(&seqcswWaitBefore,RUP_GRD(csw_wait_before), off_seqcswWaitBefore);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcswWaitBefore );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcswWaitBefore = %d\n", idx_seqcswWaitBefore );
#endif
  }


    return SUCCESS;
}

/*
 *  PSpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSpulsegen( void )
{
    INT posstart;

    /* MRIge82455 */
    psc_vol_index = 0;

    posstart = RUP_GRD(IMax(2, pw_gzrf1mps1a, pw_gzrf1cfla) + 1000);

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    PS1pulsegen( posstart );

    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    CFLpulsegen( posstart );

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    /* GEHmr03545 */
    RCVNpulsegen( posstart );

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    CFHpulsegen( posstart );

    /***********************************************************************
     * CoilSwitch SECTION
     ***********************************************************************/

    CoilSwitchPG( );

    return SUCCESS;
}   /* end PSpulsegen() */


/*
 *  FTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGpulsegen( void )
{
    INT ftgl_tr = 2000000;
    INT PosGz1FTG;          /* Slice dephaser location   */
    INT PosReadoutWindow;   /* Readout window location   */
    INT PosReadoutWindow2;  /* Readout window location   */
    INT postemp;
    INT prescan_start;

    ftgl_tr = ftgtr;

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    prescan_start = RUP_GRD(pw_gzrf1ftga + 1000);

    /* Z-axis slice selective with x readout gradient for 1-d projection
       after theta2 pulse; positioning of signals after theta3 pulse */

    /* Theta1 selective pulse */
         
                 
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1ftg", 
                                    (WF_PROCESSOR)wg_rf1ftg);

    /* Modify resolution if scaling required */
    temp_res_rf1ftg = res_rf1ftg;
    if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
       res_rf1ftg = rfpulseInfo[RF1_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1ftga,"gzrf1ftga");
    pulsename(&gzrf1ftg,"gzrf1ftg");
    pulsename(&gzrf1ftgd,"gzrf1ftgd");
    pulsename(&rf1ftg,"rf1ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf1ftga,ZGRAD,pw_gzrf1ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1ftga,(LONG)(prescan_start-pw_gzrf1ftga),
		pw_gzrf1ftga,ia_gzrf1ftg);
    createconst(&gzrf1ftg,ZGRAD,pw_gzrf1ftg,MAX_PG_WAMP);
    createinstr( &gzrf1ftg,(LONG)(prescan_start),
		pw_gzrf1ftg,ia_gzrf1ftg);
    createramp(&gzrf1ftgd,ZGRAD,pw_gzrf1ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1ftgd,(LONG)(prescan_start+pw_gzrf1ftg),
		pw_gzrf1ftgd,ia_gzrf1ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf1ftg,(WF_PROCESSOR)wg_rf1ftg,res_rf1ftg,
	       MAX_PG_WAMP,cyc_rf1ftg, alpha_rf1ftg);
    createinstr( &rf1ftg,(LONG)(prescan_start) + psd_rf_wait,
		pw_rf1ftg,ia_rf1ftg);
    linkpulses(4,&rf1ftg,&gzrf1ftg,&gzrf1ftga,
	       &gzrf1ftgd);
    addrfbits(&rf1ftg,off_rf1ftg,(LONG)(prescan_start) + psd_rf_wait, 
	      pw_rf1ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
       res_rf1ftg = temp_res_rf1ftg;
  }


    /* Theta1 rephaser - split into two parts, 2nd part after rf2tg */
    /*                   is defined.                                */
    PosGz1FTG = pendall(&gzrf1ftg, 0) + pw_gz1ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz1ftg, "gz1ftg", &gz1ftg, &gz1ftga,
                        &gz1ftgd, pw_gz1ftg, pw_gz1ftga, pw_gz1ftgd,
                        ia_gz1ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz1ftga, TRAP_ALL,
                        &ps1loggrd);



    /* Theta2 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau1-pw_rf2ftg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2ftg", 
                                    (WF_PROCESSOR)wg_rf2ftg);

    /* Modify resolution if scaling required */
    temp_res_rf2ftg = res_rf2ftg;
    if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
       res_rf2ftg = rfpulseInfo[RF2_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2ftga,"gzrf2ftga");
    pulsename(&gzrf2ftg,"gzrf2ftg");
    pulsename(&gzrf2ftgd,"gzrf2ftgd");
    pulsename(&rf2ftg,"rf2ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf2ftga,ZGRAD,pw_gzrf2ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf2ftga),
		pw_gzrf2ftga,ia_gzrf2ftg);
    createconst(&gzrf2ftg,ZGRAD,pw_gzrf2ftg,MAX_PG_WAMP);
    createinstr( &gzrf2ftg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf2ftg,ia_gzrf2ftg);
    createramp(&gzrf2ftgd,ZGRAD,pw_gzrf2ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2ftg),
		pw_gzrf2ftgd,ia_gzrf2ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf2ftg,(WF_PROCESSOR)wg_rf2ftg,res_rf2ftg,
	       MAX_PG_WAMP,cyc_rf2ftg, alpha_rf2ftg);
    createinstr( &rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf2ftg,ia_rf2ftg);
    linkpulses(4,&rf2ftg,&gzrf2ftg,&gzrf2ftga,
	       &gzrf2ftgd);
    addrfbits(&rf2ftg,off_rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf2ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
       res_rf2ftg = temp_res_rf2ftg;
  }


    /* Theta2 rephaser - split into two parts: gz2tg and gz2btg (below) */
    PosGz1FTG = pendall(&gzrf2ftg, 0)+pw_gz2ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz2ftg, "gz2ftg", &gz2ftg, &gz2ftga,
                        &gz2ftgd, pw_gz2ftg, pw_gz2ftga, pw_gz2ftgd,
                        ia_gz2ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2ftga, TRAP_ALL,
                        &ps1loggrd);



    /* Theta3 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau2-pw_rf3ftg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf3ftg", 
                                    (WF_PROCESSOR)wg_rf3ftg);

    /* Modify resolution if scaling required */
    temp_res_rf3ftg = res_rf3ftg;
    if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
       res_rf3ftg = rfpulseInfo[RF3_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf3ftga,"gzrf3ftga");
    pulsename(&gzrf3ftg,"gzrf3ftg");
    pulsename(&gzrf3ftgd,"gzrf3ftgd");
    pulsename(&rf3ftg,"rf3ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf3ftga,ZGRAD,pw_gzrf3ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf3ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf3ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf3ftga),
		pw_gzrf3ftga,ia_gzrf3ftg);
    createconst(&gzrf3ftg,ZGRAD,pw_gzrf3ftg,MAX_PG_WAMP);
    createinstr( &gzrf3ftg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf3ftg,ia_gzrf3ftg);
    createramp(&gzrf3ftgd,ZGRAD,pw_gzrf3ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf3ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf3ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf3ftg),
		pw_gzrf3ftgd,ia_gzrf3ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf3ftg,(WF_PROCESSOR)wg_rf3ftg,res_rf3ftg,
	       MAX_PG_WAMP,cyc_rf3ftg, alpha_rf3ftg);
    createinstr( &rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf3ftg,ia_rf3ftg);
    linkpulses(4,&rf3ftg,&gzrf3ftg,&gzrf3ftga,
	       &gzrf3ftgd);
    addrfbits(&rf3ftg,off_rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf3ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
       res_rf3ftg = temp_res_rf3ftg;
  }


    /* Theta3 rephaser */
    PosGz1FTG = pendall(&gzrf3ftg, 0)+pw_gz3ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz3ftg, "gz3ftg", &gz3ftg, &gz3ftga,
                        &gz3ftgd, pw_gz3ftg, pw_gz3ftga, pw_gz3ftgd,
                        ia_gz3ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz3ftga, TRAP_ALL,
                        &ps1loggrd);


    /*----------------------------------------------------------*/
    /* Readout windows and dephasers                            */ 
    /*----------------------------------------------------------*/

    postemp = (int) (pbeg(&rf2ftg,"gzrf2ftga",0)-pw_gx1ftg-pw_gx1ftgd);

           

  trapezoid((WF_PROCESSOR)wg_gx1ftg, "gx1ftg", &gx1ftg, &gx1ftga,
                        &gx1ftgd, pw_gx1ftg, pw_gx1ftga, pw_gx1ftgd,
                        ia_gx1ftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1ftga, TRAP_ALL,
                        &ps1loggrd);


    postemp = (int) (pendall(&gzrf2ftg,0) + pw_gx1bftga);

          

  trapezoid((WF_PROCESSOR)wg_gx1bftg, "gx1bftg", &gx1bftg, &gx1bftga,
                        &gx1bftgd, pw_gx1bftg, pw_gx1bftga, pw_gx1bftgd,
                        ia_gx1bftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&rf1ftg,"gzrf1ftg",0) - pw_rf1ftg/2 + 2*FTGtau1 - pw_gxw1ftg/2));

    /* HD--Error Check For Gradient Overlapp. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg 
     */
    if ( pendall(&gx1bftg,0) >= (PosReadoutWindow - pw_gxw1ftga)){
        PosReadoutWindow = pendall(&gx1bftg,0) + pw_gxw1ftga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw1ftg, "gxw1ftg", &gxw1ftg, &gxw1ftga,
                        &gxw1ftgd, pw_gxw1ftg, pw_gxw1ftga, pw_gxw1ftgd,
                        ia_gxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1ftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&gxw1ftg,"gxw1ftgd",0))+pw_postgxw1ftga);

           

  trapezoid((WF_PROCESSOR)wg_postgxw1ftg, "postgxw1ftg", &postgxw1ftg, &postgxw1ftga,
                        &postgxw1ftgd, pw_postgxw1ftg, pw_postgxw1ftga, pw_postgxw1ftgd,
                        ia_postgxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_postgxw1ftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1ftg, "gxw1ftga", 0)));

         
  {
    pulsename(&echo1ftg,"echo1ftg");
    acqq(&echo1ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1ftg,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* Second part of theta2 rephaser */
    PosGz1FTG = pbegall(&rf3ftg, 0)-(pw_gz2bftg + pw_gz2bftgd + pw_gzrf3ftga);

          

  trapezoid((WF_PROCESSOR)wg_gz2bftg, "gz2bftg", &gz2bftg, &gz2bftga,
                        &gz2bftgd, pw_gz2bftg, pw_gz2bftga, pw_gz2bftgd,
                        ia_gz2bftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2bftga, TRAP_ALL,
                        &ps1loggrd);


    /* Another refocusing pulse to insure S1 forms tau1 ms after
       center of rf3.  This is the time at which we want to
       the S1 signal to refocus:  */
    PosReadoutWindow =  RUP_GRD((int)(pendall(&rf3ftg, 0) + pw_gx2ftga));

          

  trapezoid((WF_PROCESSOR)wg_gx2ftg, "gx2ftg", &gx2ftg, &gx2ftga,
                        &gx2ftgd, pw_gx2ftg, pw_gx2ftga, pw_gx2ftgd,
                        ia_gx2ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gx2ftga, TRAP_ALL,
                        &ps1loggrd);


    /* Second readout window */
    PosReadoutWindow2 = RUP_GRD((int)(pmidall(&rf3ftg, 0) + FTGtau1 - pw_gxw2ftgleft));

    /* HD--Error Check For Gradient Overlapp. If gradients gx2ftg and
     * gxw2ftg overlap then shift the start of gxw2ftg after end of
     * gx2ftg 
     */
    if ( pendall(&gx2ftg,0) >= (PosReadoutWindow2 - pw_gxw2ftga)){
        PosReadoutWindow2 = pendall(&gx2ftg,0) + pw_gxw2ftga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw2ftg, "gxw2ftg", &gxw2ftg, &gxw2ftga,
                        &gxw2ftgd, pw_gxw2ftg, pw_gxw2ftga, pw_gxw2ftgd,
                        ia_gxw2ftg, 0, 0, 0, 0, PosReadoutWindow2-pw_gxw2ftga, TRAP_ALL,
                        &ps1loggrd);


    if (FTGtestpulse == 1)
    {
        PosReadoutWindow =  RUP_GRD((int)(pbegall(&rf3ftg, 0)+pw_gx2test + pw_gx2testd));
              

  trapezoid((WF_PROCESSOR)wg_gx2test, "gx2test", &gx2test, &gx2testa,
                        &gx2testd, pw_gx2test, pw_gx2testa, pw_gx2testd,
                        ia_gx2test, 0, 0, 0, 0, PosReadoutWindow-pw_gx2testa, TRAP_ALL,
                        &ps1loggrd);

    }    

    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw2ftg, "gxw2ftga", 0)));

        
  {
    pulsename(&echo2ftg,"echo2ftg");
    acqq(&echo2ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo2ftg,
        (TYPDAB_PACKETS)DABNORM);
  }


         
  {
  pulsename(&ftg_attenkey,"ftg_attenkey");
  createatten(&ftg_attenkey, (long)(RUP_GRD(pbegall(&gxw2ftg,0)+1000+pw_gxw2ftg)));
}


      
  {
    pulsename(&seqftg,"seqftg");
    createseq(&seqftg,ftgl_tr, off_seqftg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqftg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqftg = %d\n", idx_seqftg );
#endif
  }


    return SUCCESS;
}   /* end FTGpulsegen() */


/*
 *  XTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGpulsegen( void )
{
    INT xtgl_tr = 2000000;
    INT PosGz1XTG;          /* Slice dephaser location   */
    INT PosReadoutWindow;   /* Readout window location   */
    INT postemp;
    INT prescan_start;

    xtgl_tr = xtgtr;

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    prescan_start = RUP_GRD(pw_gzrf1xtga + 1000);

    /* Theta1 selective pulse */
        
                  
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1xtg", 
                                    (WF_PROCESSOR)wg_rf1xtg);

    /* Modify resolution if scaling required */
    temp_res_rf1xtg = res_rf1xtg;
    if (rfpulseInfo[RF1_XTG_SLOT].change==PSD_ON)
       res_rf1xtg = rfpulseInfo[RF1_XTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1xtga,"gzrf1xtga");
    pulsename(&gzrf1xtg,"gzrf1xtg");
    pulsename(&gzrf1xtgd,"gzrf1xtgd");
    pulsename(&rf1xtg,"rf1xtg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf1xtga,ZGRAD,pw_gzrf1xtga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1xtga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1xtga,(LONG)(prescan_start-pw_gzrf1xtga),
		pw_gzrf1xtga,ia_gzrf1xtg);
    createconst(&gzrf1xtg,ZGRAD,pw_gzrf1xtg,MAX_PG_WAMP);
    createinstr( &gzrf1xtg,(LONG)(prescan_start),
		pw_gzrf1xtg,ia_gzrf1xtg);
    createramp(&gzrf1xtgd,ZGRAD,pw_gzrf1xtgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1xtgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1xtgd,(LONG)(prescan_start+pw_gzrf1xtg),
		pw_gzrf1xtgd,ia_gzrf1xtg);
    
    /* Now create the rf pulse */
    createsinc(&rf1xtg,(WF_PROCESSOR)wg_rf1xtg,res_rf1xtg,
	       MAX_PG_WAMP,cyc_rf1xtg, alpha_rf1xtg);
    createinstr( &rf1xtg,(LONG)(prescan_start) + psd_rf_wait,
		pw_rf1xtg,ia_rf1xtg);
    linkpulses(4,&rf1xtg,&gzrf1xtg,&gzrf1xtga,
	       &gzrf1xtgd);
    addrfbits(&rf1xtg,off_rf1xtg,(LONG)(prescan_start) + psd_rf_wait, 
	      pw_rf1xtg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_XTG_SLOT].change==PSD_ON)
       res_rf1xtg = temp_res_rf1xtg;
  }


    /* Theta1 rephaser - split into two parts, 2nd part after rf2tg */
    /*                   is defined.                                */
    postemp = RUP_GRD(pend(&rf1xtg,"rf1xtg",0)+pw_gykxtgla);
           

  trapezoid((WF_PROCESSOR)wg_gykxtgl, "gykxtgl", &gykxtgl, &gykxtgla,
                        &gykxtgld, pw_gykxtgl, pw_gykxtgla, pw_gykxtgld,
                        ia_gykxtgl, 0, 0, 0, 0, postemp-pw_gykxtgla, TRAP_ALL,
                        &ps1loggrd);

    
    postemp = RUP_GRD(pendall(&gykxtgl,0));
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf3xtg", 
                                        (WF_PROCESSOR)wg_rf3xtg);

       pulsename(&rf3xtg,"rf3xtg");
       pulsename(&phs_rf3xtg,"phs_rf3xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf3xtg, (WF_PROCESSOR)wg_rf3xtg, res_rf3xtg, ext_filename);
       createinstr( &rf3xtg,(long)(postemp) + psd_rf_wait, pw_rf3xtg,ia_rf3xtg);

       createconst( &phs_rf3xtg,THETA,pw_rf3xtg,MAX_PG_WAMP);
       createinstr( &phs_rf3xtg,(long)(postemp) + psd_rf_wait, pw_rf3xtg,ia_phs_rf3xtg);


       addrfbits(&rf3xtg,off_rf3xtg,(long)(postemp) + 
                 psd_rf_wait, pw_rf3xtg);
   }


    PosGz1XTG = RUP_GRD(pend(&rf1xtg,"gzrf1xtg",0)-pw_rf1xtg/2+XTGtau1-
                        pw_rf2xtg/2-pw_gzrf2xtga-pw_gz1xtgd-pw_gz1xtg);
           

  trapezoid((WF_PROCESSOR)wg_gz1xtg, "gz1xtg", &gz1xtg, &gz1xtga,
                        &gz1xtgd, pw_gz1xtg, pw_gz1xtga, pw_gz1xtgd,
                        ia_gz1xtg, 0, 0, 0, 0, PosGz1XTG-pw_gz1xtga, TRAP_ALL,
                        &ps1loggrd);


    /* Theta2 selective pulse */
    postemp = (int) (pend(&rf1xtg,"gzrf1xtg",0)-pw_rf1xtg/2+XTGtau1-
                     pw_rf2xtg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2xtg", 
                                    (WF_PROCESSOR)wg_rf2xtg);

    /* Modify resolution if scaling required */
    temp_res_rf2xtg = res_rf2xtg;
    if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
       res_rf2xtg = rfpulseInfo[RF2_XTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2xtga,"gzrf2xtga");
    pulsename(&gzrf2xtg,"gzrf2xtg");
    pulsename(&gzrf2xtgd,"gzrf2xtgd");
    pulsename(&rf2xtg,"rf2xtg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf2xtga,ZGRAD,pw_gzrf2xtga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2xtga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2xtga,(LONG)(RUP_GRD(postemp)-pw_gzrf2xtga),
		pw_gzrf2xtga,ia_gzrf2xtg);
    createconst(&gzrf2xtg,ZGRAD,pw_gzrf2xtg,MAX_PG_WAMP);
    createinstr( &gzrf2xtg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf2xtg,ia_gzrf2xtg);
    createramp(&gzrf2xtgd,ZGRAD,pw_gzrf2xtgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2xtgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2xtgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2xtg),
		pw_gzrf2xtgd,ia_gzrf2xtg);
    
    /* Now create the rf pulse */
    createsinc(&rf2xtg,(WF_PROCESSOR)wg_rf2xtg,res_rf2xtg,
	       MAX_PG_WAMP,cyc_rf2xtg, alpha_rf2xtg);
    createinstr( &rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf2xtg,ia_rf2xtg);
    linkpulses(4,&rf2xtg,&gzrf2xtg,&gzrf2xtga,
	       &gzrf2xtgd);
    addrfbits(&rf2xtg,off_rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf2xtg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
       res_rf2xtg = temp_res_rf2xtg;
  }


    /* Theta2 rephaser - split into two parts: gz2tg and gz2btg (below) */
    PosGz1XTG = pendall(&gzrf2xtg, 0)+pw_gz2xtga;

           

  trapezoid((WF_PROCESSOR)wg_gz2xtg, "gz2xtg", &gz2xtg, &gz2xtga,
                        &gz2xtgd, pw_gz2xtg, pw_gz2xtga, pw_gz2xtgd,
                        ia_gz2xtg, 0, 0, 0, 0, PosGz1XTG-pw_gz2xtga, TRAP_ALL,
                        &ps1loggrd);


    postemp = RUP_GRD(pendall(&gz2xtg, 0));
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf4xtg", 
                                        (WF_PROCESSOR)wg_rf4xtg);

       pulsename(&rf4xtg,"rf4xtg");
       pulsename(&phs_rf4xtg,"phs_rf4xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf4xtg, (WF_PROCESSOR)wg_rf4xtg, res_rf4xtg, ext_filename);
       createinstr( &rf4xtg,(long)(postemp) + psd_rf_wait, pw_rf4xtg,ia_rf4xtg);

       createconst( &phs_rf4xtg,THETA,pw_rf4xtg,MAX_PG_WAMP);
       createinstr( &phs_rf4xtg,(long)(postemp) + psd_rf_wait, pw_rf4xtg,ia_phs_rf4xtg);


       addrfbits(&rf4xtg,off_rf4xtg,(long)(postemp) + 
                 psd_rf_wait, pw_rf4xtg);
   }


    postemp = RUP_GRD(pendall(&rf4xtg, 0)+pw_gykxtgra);
         

  trapezoid((WF_PROCESSOR)wg_gykxtgr, "gykxtgr", &gykxtgr, &gykxtgra,
                        &gykxtgrd, pw_gykxtgr, pw_gykxtgra, pw_gykxtgrd,
                        ia_gykxtgr, 0, 0, 0, 0, postemp-pw_gykxtgra, TRAP_ALL,
                        &ps1loggrd);

    
    postemp = RUP_GRD(pendall(&rf2xtg,0)-pw_rf2xtg/2+XTGtau1-pw_gxw1xtg/2
                      -pw_gxw1xtga-pw_gx1bxtgd-pw_gx1bxtg);
          

  trapezoid((WF_PROCESSOR)wg_gx1bxtg, "gx1bxtg", &gx1bxtg, &gx1bxtga,
                        &gx1bxtgd, pw_gx1bxtg, pw_gx1bxtga, pw_gx1bxtgd,
                        ia_gx1bxtg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bxtga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&rf1xtg,"gzrf1xtg",0) - pw_rf1xtg/2 + 
                                   2*XTGtau1 - pw_gxw1xtg/2));

    /* HD--Error Check For Gradient Overlapp. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg 
     */
    if ( pendall(&gx1bxtg,0) >= (PosReadoutWindow - pw_gxw1xtga)){
        PosReadoutWindow = pendall(&gx1bxtg,0) + pw_gxw1xtga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw1xtg, "gxw1xtg", &gxw1xtg, &gxw1xtga,
                        &gxw1xtgd, pw_gxw1xtg, pw_gxw1xtga, pw_gxw1xtgd,
                        ia_gxw1xtg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1xtga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1xtg, "gxw1xtga", 0)));

         
  {
    pulsename(&echo1xtg,"echo1xtg");
    acqq(&echo1xtg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1xtg,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* position for ATTENUATOR */
    postemp = RUP_GRD(pbegall(&gxw1xtg,0) + 1000 + pw_gxw1xtg);

     
  {
  pulsename(&xtg_attenkey,"xtg_attenkey");
  createatten(&xtg_attenkey, (long)(postemp));
}


      
  {
    pulsename(&seqxtg,"seqxtg");
    createseq(&seqxtg,xtgl_tr, off_seqxtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqxtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqxtg = %d\n", idx_seqxtg );
#endif
  }


    return SUCCESS;
}   /* end XTGpulsegen() */


/*
 *  ASpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASpulsegen( void )
{
    INT PosTemp;

    /***************************************
     * Z board
     ***************************************/
    /* Z gradient slice select */
    PosTemp = RUP_GRD(td0as + tleadas - rfupa + pw_gzrf1asa);
          
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1as", 
                                    (WF_PROCESSOR)wg_rf1as);

    /* Modify resolution if scaling required */
    temp_res_rf1as = res_rf1as;
    if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
       res_rf1as = rfpulseInfo[RF1_AUTOSHIM].newres;
    /* First create the pulses */
    pulsename(&gzrf1asa,"gzrf1asa");
    pulsename(&gzrf1as,"gzrf1as");
    pulsename(&gzrf1asd,"gzrf1asd");
    pulsename(&rf1as,"rf1as");
    
    /*  Now create the slice select trapezoid */
	pg_beta = asloggrd.zbeta;
    createramp(&gzrf1asa,ZGRAD,pw_gzrf1asa,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1asa/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1asa,(LONG)(PosTemp-pw_gzrf1asa),
		pw_gzrf1asa,ia_gzrf1as);
    createconst(&gzrf1as,ZGRAD,pw_gzrf1as,MAX_PG_WAMP);
    createinstr( &gzrf1as,(LONG)(PosTemp),
		pw_gzrf1as,ia_gzrf1as);
    createramp(&gzrf1asd,ZGRAD,pw_gzrf1asd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1asd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1asd,(LONG)(PosTemp+pw_gzrf1as),
		pw_gzrf1asd,ia_gzrf1as);
    
    /* Now create the rf pulse */
    createsinc(&rf1as,(WF_PROCESSOR)wg_rf1as,res_rf1as,
	       MAX_PG_WAMP,cyc_rf1as, alpha_rf1as);
    createinstr( &rf1as,(LONG)(PosTemp) + psd_rf_wait,
		pw_rf1as,ia_rf1as);
    linkpulses(4,&rf1as,&gzrf1as,&gzrf1asa,
	       &gzrf1asd);
    addrfbits(&rf1as,off_rf1as,(LONG)(PosTemp) + psd_rf_wait, 
	      pw_rf1as);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
       res_rf1as = temp_res_rf1as;
  }
 

    /* Assert the ESSP flag on the rf1as pulse */
    attenflagon(&rf1as, 0);

    /* Z gradient rephaser */
    PosTemp = pendall(&gzrf1as, 0) + pw_gz1asa;
          
                

  trapezoid((WF_PROCESSOR)wg_gz1as, "gz1as", &gz1as, &gz1asa,
                        &gz1asd, pw_gz1as, pw_gz1asa, pw_gz1asd,
                        ia_gz1as, 0, 0, 0, 0, pendall(&gzrf1as,0)+pw_gz1asa-pw_gz1asa, TRAP_ALL,
                        &asloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pmid(&gzrf1as,"gzrf1as",0)-off90as+te_as-pw_gxwas/2);
           

  trapezoid((WF_PROCESSOR)wg_gxwas, "gxwas", &gxwas, &gxwasa,
                        &gxwasd, pw_gxwas, pw_gxwasa, pw_gxwasd,
                        ia_gxwas, 0, 0, 0, 0, PosTemp-pw_gxwasa, TRAP_ALL,
                        &asloggrd);


    PosTemp = RUP_GRD(PosTemp+psd_grd_wait);
        
  {
    pulsename(&echo1as,"echo1as");
    acqq(&echo1as, (long)(PosTemp),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1as,
        (TYPDAB_PACKETS)DABNORM);
  }

    attenflagon(&echo1as,0);

    /* frequency dephaser */
    PosTemp = RUP_GRD(pbegall(&gxwas,0) - (pw_gx1as+pw_gx1asd));
           

  trapezoid((WF_PROCESSOR)wg_gx1as, "gx1as", &gx1as, &gx1asa,
                        &gx1asd, pw_gx1as, pw_gx1asa, pw_gx1asd,
                        ia_gx1as, 0, 0, 0, 0, PosTemp-pw_gx1asa, TRAP_ALL,
                        &asloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
    PosTemp = RUP_GRD( pend(&gxwas, "gxwas",0) );
     
  {
  pulsename(&attenuator_keyas,"attenuator_keyas");
  createatten(&attenuator_keyas, (long)(PosTemp));
}


    /*****************************************
     * Y board
     *****************************************/
    /* HSI - changed SINUSOID to TRAPEZOID2 */
    /* encode */
    PosTemp = RUP_GRD(pend(&gz1asd,"gz1asd",0));
           
    trapezoid((WF_PROCESSOR)wg_gy1as,"gy1as",
              &gy1as,&gy1asa,&gy1asd,
              pw_gy1as,pw_gy1asa,pw_gy1asd,
              ia_gy1as,ia_gy1aswa,ia_gy1aswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);


    /* rewind */
    PosTemp= RUP_GRD(pend(&gxwas,"gxwas",0));
           
    trapezoid((WF_PROCESSOR)wg_gy1ras,"gy1ras",
              &gy1ras,&gy1rasa,&gy1rasd,
              pw_gy1ras,pw_gy1rasa,pw_gy1rasd,
              ia_gy1ras,ia_gy1raswa,ia_gy1raswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);



    /*******************
     * X and Z Killers
     *******************/
    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gxkasa);
         

  trapezoid((WF_PROCESSOR)wg_gxkas, "gxkas", &gxkas, &gxkasa,
                        &gxkasd, pw_gxkas, pw_gxkasa, pw_gxkasd,
                        ia_gxkas, 0, 0, 0, 0, PosTemp-pw_gxkasa, TRAP_ALL,
                        &asloggrd);


    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gzkasa);
         

  trapezoid((WF_PROCESSOR)wg_gzkas, "gzkas", &gzkas, &gzkasa,
                        &gzkasd, pw_gzkas, pw_gzkasa, pw_gzkasd,
                        ia_gzkas, 0, 0, 0, 0, PosTemp-pw_gzkasa, TRAP_ALL,
                        &asloggrd);


    /**************
     * dixon shifts
     **************/
    PosTemp = RUP_GRD(td0as + tleadas - rfupa);
         
  {
    pulsename(&xdixon,"xdixon");
    createconst(&xdixon,(WF_PROCESSOR)wg_xdixon,
                pw_xdixon,MAX_PG_WAMP);
    createinstr( &xdixon,(long)(PosTemp),
		pw_xdixon,ia_xdixon);
    if ((wg_xdixon==TYPRHO1)||(wg_xdixon==TYPRHO2))
      {
	addrfbits(&xdixon,0,(long)(PosTemp),pw_xdixon);
      }
  }

         
  {
    pulsename(&ydixon,"ydixon");
    createconst(&ydixon,(WF_PROCESSOR)wg_ydixon,
                pw_ydixon,MAX_PG_WAMP);
    createinstr( &ydixon,(long)(PosTemp),
		pw_ydixon,ia_ydixon);
    if ((wg_ydixon==TYPRHO1)||(wg_ydixon==TYPRHO2))
      {
	addrfbits(&ydixon,0,(long)(PosTemp),pw_ydixon);
      }
  }


    PosTemp = pend(&gz1asd,"gz1asd",0);
         
  {
    pulsename(&zdixon,"zdixon");
    createconst(&zdixon,(WF_PROCESSOR)wg_zdixon,
                pw_zdixon,MAX_PG_WAMP);
    createinstr( &zdixon,(long)(PosTemp),
		pw_zdixon,ia_zdixon);
    if ((wg_zdixon==TYPRHO1)||(wg_zdixon==TYPRHO2))
      {
	addrfbits(&zdixon,0,(long)(PosTemp),pw_zdixon);
      }
  }


    /* just pad the ssp somewhere beyond the rf unblank */
    rfdisable_add = YES;
    PosTemp = RUP_RF(pend(&rf1as,"rf1as",0) + rfupd + 12);
         
  {
    pulsename(&sdixon,"sdixon");
    createconst(&sdixon,(WF_PROCESSOR)wg_sdixon,
                pw_sdixon,MAX_PG_WAMP);
    createinstr( &sdixon,(long)(PosTemp),
		pw_sdixon,ia_sdixon);
    if ((wg_sdixon==TYPRHO1)||(wg_sdixon==TYPRHO2))
      {
	addrfbits(&sdixon,0,(long)(PosTemp),pw_sdixon);
      }
  }


    PosTemp = RUP_RF(pbeg(&gzkas,"gzkas",0));
         
  {
    pulsename(&sdixon2,"sdixon2");
    createconst(&sdixon2,(WF_PROCESSOR)wg_sdixon2,
                pw_sdixon2,MAX_PG_WAMP);
    createinstr( &sdixon2,(long)(PosTemp),
		pw_sdixon2,ia_sdixon2);
    if ((wg_sdixon2==TYPRHO1)||(wg_sdixon2==TYPRHO2))
      {
	addrfbits(&sdixon2,0,(long)(PosTemp),pw_sdixon2);
      }
  }


    rfdisable_add = NO;
        
  {
    pulsename(&seqaushim,"seqaushim");
    createseq(&seqaushim,RUP_GRD((int)(tr_as-time_ssias)), off_seqaushim);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqaushim );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqaushim = %d\n", idx_seqaushim );
#endif
  }

    attenflagon(&seqaushim, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_aushim,"pass_aushim");
    createpass(&pass_aushim,(long)(RUP_GRD(TR_PASS3D-1000)));
  }

      
  {
    pulsename(&seqpassas,"seqpassas");
    createseq(&seqpassas,RUP_GRD(TR_PASS3D), off_seqpassas);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassas );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassas = %d\n", idx_seqpassas );
#endif
  }


    return SUCCESS;
}   /* end ASpulsegen() */



/*********************************************************************
 *                        EPI.E RSP SECTION                          *
 *                                                                   *
 * Write here the functional code for the real time processing (Tgt  *
 * side). You may declare standard C variables, but of limited types *
 * short, int, long, float, double, and 1D arrays of those types.    *
 *********************************************************************/
#include "pgen_tmpl.h" 
#include "epic_loadcvs.h"
#include "pgen_errstruct.h"




/* MRIge54172 - maxwell correction */
float delta_fre_MAX[SLTAB_MAX]; /* Maxwell frequency offset */ /* YMSmr06515 */
float delta_phase_MAX_l[SLTAB_MAX]; /* Maxwell phase offset for thefirst echo */
float delta_phase_MAX[SLTAB_MAX]; /* Maxwell phase offset for all echoes */

/* Function Declaration */
STATUS epiMaxwellCorrection(void);

/* BJM - correct receiver phase to account for maxwell terms - see Tech Note by Joe Zhou 97-08    */
/*       Most of this code taken from epi2.e.  However, Ive added the phase encode blip term and  */
/*       and removed the g2z2_delta factor which was an empirical test factor for the phase blips */
/*       It was set = 2.0 which was way too large since the phase blip contribution is small      */

STATUS epiMaxwellCorrection(void) {
 
  int ii, jj, kk;  /* Maxwell comp: index to set the receiver frequency array */
  
  if((maxwell_flag==PSD_ON)&&(opplane==PSD_AXIAL)&&((rspent==L_SCAN) || (rspent==L_REF))) {
      
      float Gx2 = 0.0;                    /* readout gradient squared */
      float Gy2 = 0.0;                    /* phase gradient squared */
      float Z2 = 0.0;                     /* z location squared */
      float field_fact = 0.0;             /* constant term that includes B field */
      float mxwtmp1,mxwtmp2;
      float mxwtmp_gxw1,mxwtmp_gxw2;      /* tmp variables for maxwell offset computation */
      float mxwtmp_gyb1,mxwtmp_gyb2;
      
      /* BJM: readout gradient timing */
      pw_gxw_MAX_l = (1.0/3.0*(float)pw_gxwad+0.5*(float)pw_gxw+(float)pw_gxwl)/1.0e6;
      /* timing for the left half of readout trapezoid; unit: sec. */
      pw_gxw_MAX_r = (1.0/3.0*(float)pw_gxwad+0.5*(float)pw_gxw+(float)pw_gxwr)/1.0e6;
      /* timing for the right half of readout trapezoid; unit: sec. */
      
      /* BJM: account for phase blips also */
      pw_gyb_MAX_l = (1.0/3.0*(float)pw_gyba+0.5*(float)pw_gyb)/1.0e6;
      /* timing for the left half of phase trapezoid; unit: sec. */
      pw_gyb_MAX_r = (1.0/3.0*(float)pw_gybd+0.5*(float)pw_gyb)/1.0e6;
      /* timing for the right half of phase trapezoid; unit: sec. */
      
      if(max_debug==1)
          printf("left Maxwell width = %f s\nright Maxwell width = %f s\n", 
                 pw_gxw_MAX_l, pw_gxw_MAX_r);
      
      field_fact = 2.0*PI*GAM/(2.0*B0_field);      /* Field dependance */
      Gx2 =a_gxw*a_gxw/100.0;                      /* Readout Gx^2 term */
      mxwtmp_gxw1 = pw_gxw_MAX_l;
      mxwtmp_gxw2 = (pw_gxw_MAX_l+pw_gxw_MAX_r);
      
      Gy2 = a_gyb*a_gyb/100.0;                   /* Phase encode term */
      mxwtmp_gyb1 = pw_gyb_MAX_l;
      mxwtmp_gyb2 = (pw_gyb_MAX_r+pw_gyb_MAX_l);
      
      for (kk=0; kk<opslquant; kk++) {
          
          Z2 = rsp_info[kk].rsptloc*rsp_info[kk].rsptloc;  
          
          /* BJM: this code accounts for the readout term */       
          delta_fre_MAX[kk] = field_fact*Gx2*Z2;           /* purely for debugging */
          delta_phase_MAX_l[kk] = field_fact*Gx2*Z2*(mxwtmp_gxw1);    /* unit: radians */
          delta_phase_MAX[kk] = field_fact*Gx2*Z2*(mxwtmp_gxw2);      /* unit: radians */
          
          if(max_debug==1) /* readout comp. */
              printf("%d freq offset: %f phase: %f loc: %f  \n",
                     kk,delta_fre_MAX[kk],delta_phase_MAX[kk],rsp_info[kk].rsptloc);
          
          if(maxwell_blip == PSD_ON) {
              /* BJM: now account for the phase encode blips... */

              delta_phase_MAX_l[kk] += field_fact*Gy2*Z2*(mxwtmp_gyb1);    /* unit: radians */
              delta_phase_MAX[kk] += field_fact*Gy2*Z2*(mxwtmp_gyb2);      /* unit: radians */
              
              if(max_debug==1) /* phase comp */ 
                  printf("%d phase w/ blip: %f loc: %f  \n",
                         kk,delta_phase_MAX[kk],rsp_info[kk].rsptloc);
          }
          
      } /* end opslquant loop */ 
      
      /* Now loop over each slice, echo, etc and reset the receiver phase */
      for (ii=0; ii<opslquant; ii++) {

          mxwtmp1=((double)(delta_phase_MAX_l[ii]));   /* The constant phase term -> BJM: not really needed*/
	  mxwtmp2=((double)(delta_phase_MAX[ii]));     /* Phase term accumlates with each echo */

          for(jj=0; jj<intleaves; jj++) {
              for(kk=0; kk<etl+iref_etl; kk++) {

                  recv_phase_angle[ii][jj][kk] += (mxwtmp1 + mxwtmp2*(float)kk);
                  recv_phase[ii][jj][kk] = calciphase(recv_phase_angle[ii][jj][kk]);
                  
                  if(max_debug==1)
                      printf("%d freq offset: %d \n",kk, recv_freq[ii][jj][kk]);             

              } /* echo */

          } /* interleave */

      } /* slice */

  } /* end Maxwell compensation */
  
  return SUCCESS;
} 
STATUS epiRTD(void);

STATUS epiRTD (void) {
    
    int loopcnt;

    if(rtd_on == PSD_ON){
        
        attenlockoff(&atten);
        
        /* Modify rotation matrices if necessary */
        if (resrot == PSD_ON) {
            setrotatearray((short)(opslquant*opphases),origrot[0]);
            resrot = modrot = rotx = roty = rotz = 0;
        }
        
        if (modrot == PSD_ON) {
            modrotmats(origrot,rsprot,rotx,roty,rotz,(opslquant*opphases),
                                 debugstate);
            setrotatearray((short)(opslquant*opphases),rsprot[0]);
        }
        
        /* Modify slice location if necessary */
        if (resloc == PSD_ON) {
            setupslices(rf1_freq, orig_rsp_info, opslquant, a_gzrf1,
                        (float)1, (opfov*freq_scale), TYPTRANSMIT);
            setupslices(theta_freq, orig_rsp_info, opslquant, a_gzrf1/4.0,
                        (float)1, (opfov*freq_scale), TYPTRANSMIT);
            if (oppseq == PSD_SE)
            setupslices(rf2_freq, orig_rsp_info, opslquant, a_gzrf2,
                        (float)1, (opfov*freq_scale), TYPTRANSMIT);
            
            resloc = modloc = dso = dro = dpo = 0;
            xtr = xtr_rba_time;
            frt = frtime;
            ref_switch = 0;

            b0Dither_ifile(b0ditherval, ditheron, rdx, rdy, rdz, 
                           a_gxw, esp, opslquant,
                           debugdither, rsprot_unscaled, ccinx, cciny, ccinz, 
                           esp_in, fesp_in, &g0, &num_elements, &file_exist);
            
            calcdelayfile(delayval, delayon, dlyx, dlyy, dlyz,
                          &defaultdelay, opslquant, debugdelay, rsprot_unscaled, delay_buffer);
            
            
            for (slice = 0; slice < opslquant; slice++)
            {
                delayval[slice] += dacq_adjust;

                if (delayval[slice] < 0.0)
                    gldelaycval[slice] = (int)(delayval[slice] - 0.5);
                else
                    gldelaycval[slice] = (int)(delayval[slice] + 0.5);
            }
            /* MRIge89403: Added iref_etl for internal ref scan */ 
            epiRecvFrqPhs( opslquant, intleaves, etl, xtr-timedelta,
                           refdattime, frt, opfov, opyres, opphasefov,
                           b0ditherval, rf_phase_spgr, dro, dpo, orig_rsp_info,
                           view1st, viewskip, gradpol, ref_switch, ky_dir,
                           dc_chop, pepolar, recv_freq, recv_phase_angle,
                           recv_phase, gldelayfval, a_gxw, debugepc,
                           ref_with_xoffset, 1.0, iref_etl );
        }
        
        if (modloc == PSD_ON) {
            for (loopcnt=0; loopcnt< opslquant; loopcnt++){
                rsp_info[loopcnt].rsptloc = orig_rsp_info[loopcnt].rsptloc +
                    (float)dso;
                rsp_info[loopcnt].rsprloc = orig_rsp_info[loopcnt].rsprloc +
                    (float)dro;
                rsp_info[loopcnt].rspphasoff = orig_rsp_info[loopcnt].rspphasoff +
                    (float)dpo;
            }

            setupslices(rf1_freq, rsp_info, opslquant, a_gzrf1,
                        (float)1, (opfov*freq_scale), TYPTRANSMIT);
            setupslices(theta_freq, rsp_info, opslquant, a_gzrf1/4.0,
                        (float)1, (opfov*freq_scale), TYPTRANSMIT);

            if (oppseq == PSD_SE)
                setupslices(rf2_freq, rsp_info, opslquant, a_gzrf2,
                            (float)1, (opfov*freq_scale), TYPTRANSMIT);
            
            b0Dither_ifile(b0ditherval, ditheron, rdx, rdy, rdz, 
                           a_gxw, esp, opslquant,
                           debugdither, rsprot_unscaled, ccinx, cciny, ccinz, 
                           esp_in, fesp_in, &g0, &num_elements, &file_exist);
            
            calcdelayfile(delayval, delayon, dlyx, dlyy, dlyz,
                          &defaultdelay, opslquant, debugdelay, rsprot_unscaled, delay_buffer);         
            
            for (slice = 0; slice < opslquant; slice++)
            {

                delayval[slice] += dacq_adjust;

                if (delayval[slice] < 0.0)
                    gldelaycval[slice] = (int)(delayval[slice] - 0.5);
                else
                    gldelaycval[slice] = (int)(delayval[slice] + 0.5);
            }
            
            
            ref_switch = 0;
            /* MRIge89403: Added iref_etl for internal ref scan */ 
            epiRecvFrqPhs( opslquant, intleaves, etl, xtr-timedelta,
                           refdattime, frt, opfov, opyres, opphasefov,
                           b0ditherval, rf_phase_spgr, 0, 0, rsp_info,
                           view1st, viewskip, gradpol, ref_switch, ky_dir,
                           dc_chop, pepolar, recv_freq, recv_phase_angle,
                           recv_phase, gldelayfval, a_gxw, debugepc,
                           ref_with_xoffset, 1.0, iref_etl );
            
        } /* if (modloc == PSD_ON) */

    } /* rtd_on == PSD_ON */
    
    return SUCCESS;
    
} /* end epiRTD() */

#include "RtpPsd.h"
#include "RTB0.h"
#include "rtB0RTP.h"
#include "rtp_feedback_task.h"

int rtb0_processed_index = 0;
float rtb0_cfoffset = 0;

STATUS rtB0ComRspInit( void )
{
#ifdef PSD_HW
    int status;
#endif
    RtpDataValuesPkt rtB0RtpPkt;

    /* Fill RtpDataTransportPkt values */
    strncpy(rtB0RtpPkt.rtpDataVal.path, "/usr/g/bin", sizeof(rtB0RtpPkt.rtpDataVal.path));
    strncpy(rtB0RtpPkt.rtpDataVal.func, "rtB0RTP", sizeof(rtB0RtpPkt.rtpDataVal.func));

    /* BAM Allocations */
    rtB0RtpPkt.rtpDataVal.frameSize = rhfrsize; /* xres */
    rtB0RtpPkt.rtpDataVal.pointSize = rhptsize;  /* EDR */
    rtB0RtpPkt.rtpDataVal.numRtpReceivers = rhdab0e - rhdab0s + 1;
    rtB0RtpPkt.rtpDataVal.acquiredIndex = 0;
    rtB0RtpPkt.rtpDataVal.processedIndex = 0;

    rtB0RtpPkt.rtpDataVal.floatVar_1 = oprbw; /* send BW to RTP for freq calculation */

    rtB0RtpPkt.rtpDataVal.intVar_1 = rtb0_first_skip; /* num of points skipped in the beginning */
    rtB0RtpPkt.rtpDataVal.intVar_2 = rtb0_last_skip; /* num of points skipped in the end */
    rtB0RtpPkt.rtpDataVal.intVar_3 = rtb0_movAvg;  /* num of points for moving average */
    
    rtB0RtpPkt.rtpDataVal.vreDebug = rtb0DebugFlag;
    rtB0RtpPkt.rtpDataVal.writeRawData = rtb0SaveRaw;  /* flag to save nav data */

    memcpy(rtB0RtpPkt.rtpDataVal.RtpCttEntry, cttEntry_tgt, sizeof(cttEntry_tgt));

#ifdef PSD_HW

    status = RtpInit(&rtB0RtpPkt);
    if(status!=SUCCESS) {
        RtpEnd();  /* do this to be safe? */
        psdexit(EM_PSD_ROUTINE_FAILURE, 0, "", "RtpInit failed", PSD_ARG_STRING, "RtpInit:rtB0", 0);
    }

    isrtplaunched = 1;

#endif

    return SUCCESS;
}


/* called by MCT task once the scan stops due to abort, crash, etc */
n32 psdcleanup(void)
{
    n32 rv = EM_PSD_NO_ERROR;
    int rtpendstatus = 0;

    if(rtb0_flag == PSD_ON && isrtplaunched == PSD_ON)
    {
       rtpendstatus = RtpEnd();
       if(rtpendstatus == SUCCESS)
       {
           isrtplaunched = 0;
           rv = EM_PSD_NO_ERROR;
       }
       else
       {
           rv = EM_PSD_RTP_CLEANUP_FAILED;
       }
    }
    return rv;
}

/**
 * gets rtB0 processedIndex and cfoffset from RTP App.  ProcessedIndex and cfoffset are 
 * unchanged if there is no new data available.
 *
 * @param[out] *processedIndex - Pointer to the processedIndex
 * @param[out] *phase - pointer to the cfoffset 
 * @return 1 if new data available.  0 otherwise
 *
 */

int getRTB0Feedback(int * processedIndex, float * cfoffset)
{
    n32 packed;
    rtB0Result rtpResult;
    int nBytes = 0;

#if defined(MGD_TGT) && defined(PSD_HW)
    nBytes = rtp_get_feedback_data(&rtpResult, sizeof(rtpResult), &packed);
#endif    
    if( nBytes > 0 )
    {
        if (0 == packed)
        {
            /* Results are a rtB0Result structure */
            if( nBytes != sizeof(rtpResult) )
            {
                RtpEnd();
                psdexit(EM_PSD_ROUTINE_FAILURE, 0, "", "Failure in reading results", 
                        PSD_ARG_STRING, "rtB0:getRTBOFeedback", 0);
            }

            *processedIndex = rtpResult.processedIndex;
            *cfoffset = rtpResult.cfoffset;
        }
        else
        {
            RtpEnd(); 
            psdexit(EM_PSD_ROUTINE_FAILURE,0,"","Received packed result",PSD_ARG_STRING,"getRTB0Feedback:RTB0",0);  
        }    
        return 1;
    }
    else
    {
        /* No new feedback data */
        return 0;
    }
}

float rtb0_base_cfoffset = 0.0; /* center frequency offste at the first time point */
float rtb0_comp_cfoffset = 0.0; /* center frequency offset for compensation */
int rtb0_comp_cfoffset_TARDIS = 0;
int rtb0_rtp_1streturn = PSD_OFF;
int rtb0_outlier_count = 0;

/* BJM: SE Ref Scan */
STATUS refSpinEcho( void );
STATUS refAsScan( void );
STATUS psdinit_ref( void );
STATUS refloop( void );
STATUS refcore( void );
STATUS dabrbaloadref( void );
STATUS turnOffBlips( INT numblips );


STATUS
#ifdef __STDC__ 
psdinit( void )
#else /* !__STDC__ */
    psdinit() 
#endif /* __STDC__ */
{
 
    strcpy(psdexitarg.text_arg, "psdinit");  /* reset global error variable */

    deltaomega = 0;
    timedelta = 0;
/*jwg bb set up rfconf depending on nucleus selected*/
    setrfconfig((short)rfconf);    
/*jwg end*/    
  
    /* Clear the SSI routine. */
    if (opsat == PSD_ON)
        ssivector(ssisat, (short) FALSE);
    else 
        ssivector(dummyssi, (short) FALSE);
  
    /* turn off dithering */
    setditherrsp(dither_control,dither_value);
  
    /* Set ssi time.  This is time from eos to start of sequence interrupt
       in internal triggering.  The minimum time is 50us plus 2us*(number of
       waveform and instruction words modified in the update queue).
       Needs to be done per entry point. */
    setssitime((LONG)time_ssi/GRAD_UPDATE_TIME);
  
    scopeon(&seqcore);    /* reset all scope triggers */

    scopeoff(&seqblineacq);
  
    syncon(&seqcore);  /* reset all synchronizations, not needed in pass */
  
    /* Set trigger for cf and 1st pass prescan.
       Reset trigger the prescan slice to its scan trigger for 
       scan and second pass prescan entry points. */
    if ((rspent == L_CFL) || (rspent == L_CFH) || 
        (rspent == L_MPS1) || (rspent == L_APS1)) {
        rsptrigger[acq_ptr[pre_pass] + pre_slice] = trig_prescan;
      
        if (ipg_trigtest == 0) 
            /* Remove next line when line gating supported */
            rsptrigger[acq_ptr[pre_pass] + pre_slice] = TRIG_INTERN;
        else 
            rsptrigger[acq_ptr[pre_pass] + pre_slice] = prescan_trigger;

    }

    /* Allow for manual trigger override for testing. */      
    if (((psd_mantrig == PSD_ON) || (opcgate == PSD_ON)) && 
        ((rspent == L_APS2) || (rspent == L_MPS2) || (rspent == L_SCAN) || (rspent == L_REF)) ) {
        for (slice=0; slice < opslquant*opphases; slice++) {
          
            if (rsptrigger[slice] != TRIG_INTERN) {
                switch(rspent){
                case L_MPS2:
                    rsptrigger[slice] = trig_mps2;
                    break;
                case L_APS2:
                    rsptrigger[slice] = trig_aps2;
                    break;
                case L_SCAN:
                case L_REF:
                    rsptrigger[slice] = trig_scan;
                    break;
                default:
                    break;
                }
            }
	}
    }
  
    /* Inform the Tgt of the location of the trigger arrays. */
    settriggerarray((short)(opslquant*opphases), rsptrigger);
  
    /* Inform the Tgt of the rotation matrix array to be used */
    setrotatearray((short)(opslquant*opphases), rsprot[0]);
  
    pass = 0;
    pass_index = 0;
    rspacqb = 0;
    rspacq = acqs;
    rspprp = pass_reps;
    /* Motion encoding gradients not played during prescan or
     * non MR-Touch scans.  Default to 1 and update as needed
     * in scan() */
    rsp_cmndir = 1;
  
    /* DAB initialization */
    dabop = 0;    /* Store data */
    dabecho = 0;  /* first dab packet is for echo 0 */

    /* use the autoincrement echo feature for subsequent echos */
    dabecho_multi = -1;
    BoreOverTempFlag = 0;
 
    CsSatMod(cs_satindex);
    SpSatInitRsp((INT)1, sp_satcard_loc,0);
    
    if (gyctrl == PSD_ON) {
        gyb_amp = blippol[0];
    } else {
        gyb_amp = 0;
    }

    rspgyc = gyctrl;
    rspslqb = 0;
    rspslq = slquant1;
    rspilvb = 0;
    rspilv = intleaves;
    rspbasb = 1;

    /* BJM: for XTR-RBA timing calculation, need to shut off X & Y grad. */
    if (gxctrl == PSD_OFF || xtr_calibration == (PSD_ON + 1)) {

        /* turn off the readout axis */
        setieos((SHORT)EOS_DEAD, &x_td0,0);

    } else {

        /* turn it on */
        setieos((SHORT)EOS_PLAY, &x_td0, 0);

    }

    if (xtr_calibration == (PSD_ON + 1)) {

        /* turn off the phase encode axis */
        setieos((SHORT)EOS_DEAD, &y_td0,0);

    } else {

        /* turn it on */
        setieos((SHORT)EOS_PLAY, &y_td0, 0);

    }

    if (gzctrl == PSD_OFF) {

        /* turn off slice select axis */
        setieos((SHORT)EOS_DEAD, &z_td0,0);

    } else {

        /* turn it on */
        setieos((SHORT)EOS_PLAY, &z_td0, 0);
    }

    /* Update the exciter freq/phase tables */
    if (rspent == L_REF)
        ref_switch = 1;
    else
        ref_switch = 0;
  
    xtr = 0.0;
    frt = frtime;

    /* BJM: refdattime is no longer used to prephase the echoes */
    /* keep it until the epiRecvFrqPhs() interface is modified. */
    {
        int slc;
      
        /* No need to calculate refdattime */
        for( slc = 0; slc < opslquant; slc++ ) {
            refdattime[slc] = 0.0;
        }
    }

    /* BJM: MRIge54033 - refdattime now passed as array (one entry for each slice) */
    /* internref: use tot_etl; added iref_etl */
    /* MRIge92386 */ /*MRIhc00996*/
    epiRecvFrqPhs( opslquant, intleaves, etl, xtr-timedelta, refdattime, frt,
                   opfov, fullk_nframes,
                   opphasefov,  b0ditherval, rf_phase_spgr, dro, dpo,
                   rsp_info, view1st, viewskip, gradpol,
                   ref_switch = (rspent==L_REF ? 1:0), ky_dir, dc_chop,
                   pepolar, recv_freq, recv_phase_angle, recv_phase,
                   gldelayfval, a_gxw, debugRecvFrqPhs, ref_with_xoffset,
                   asset_factor, iref_etl );

    /* Call MaxwellCorrection Function (see epiMaxwellCorrection.e) */
    if( epiMaxwellCorrection() == FAILURE) return FAILURE; 

    ref_switch = 0;

    if ((intleaves > 1) && (ep_alt > 0)) {

        ileave = 0;

        setreadpolarity();  /* make sure readout gradient polarity is set
                               properly */
        /* BJM: SE Ref Scan */
        if(se_ref == PSD_ON) 
            setreadpolarity_ref();

    }
 
    rspe1st = 0;
    rspetot = tot_etl;

    /* phase-encoding blip correction for oblique scan planes */
    blipcorr(rspia_gyboc,da_gyboc,debug_oblcorr,rsprot_unscaled,oc_fact,cvxfull,
             cvyfull,cvzfull,bc_delx,bc_dely,bc_delz,oblcorr_on,opslquant,
             &epiloggrd,pw_gyb,pw_gyba,a_gxw);

    /* Call to set filter in HSDAB packet for EPI */ 
    setEpifilter(scanslot,&hyperdab); 

    /* BJM: SE Ref Scan */
    if(se_ref == PSD_ON)
        setEpifilter(scanslot,&hyperdabref);
 
    return SUCCESS;  

} /* End psdinit */	    

/* *******************************************************************
   CardInit
   RSP Subroutine

   Purpose:
   To create an array of deadtimes for each slice/phase of the first
   pass in a cardiac scan.  For multi-phase scans, this same array can be
   used as the slices are shuffled in each pass to obtain new phases.

   Description: The logic for creating the deadtime array for
   multiphase scans is rather simple.  All of the slices except the last
   slice have the same deadtime.  This deadtime will assure that the
   repetition time between slices equals the inter-sequence delay time.
   The last slice has a deadtime that will run the logic board until the
   beginning of the cardiac trigger window.

   The logic for creating the deadtime for single phase, or cross R-R
   scans, is much more complicated.  In these scans, the operator
   prescribes over how many R-R intervals (1-4) the slices should be
   interleaved over.  The deadtimes for the last slice in each R-R
   interval will be different depending on whether the R-R interval is
   filled, unfilled, or the last R-R interval. For example, lets say 14
   slices are to be interleaved among 4 R-R intervals.  4 slices will be
   placed in the first R-R, 4 in the second, 3 in the third, and 3 in the
   fourth.  This prescription has 2 filled R-R intervals, 1 unfilled R-R
   interval, and a final R-R interval.  The deadtimes for slices which
   are not the last slice in a R-R interval is the same deadtime that
   assures that the inter-sequence delay time is met.

   Parameters:
   (O) int ctlend_tab[]  table of deadtimes
   (I) int ctlend_intern deadtime needed to maintain intersequence delay time.
   Delay when next slice will be internally gated.
   (I) int ctlend_last   Delay time for last slice in ophrep beats.  Deadtime needed
   to get proper trigger delay for next heart beat. 
   (I) int ctlend_fill   Dead time for filled R-R interval.  Not used in multi-phase
   scans. 
   (I) int ctlend_unfill Deadtime of last slice in an unfilled R-R interval.  Not used in
   multi-phase scans.
   *********************************************************************** */

/**************************  CardInit  *********************************/
STATUS CardInit( INT ctlend_tab[], INT ctlend_intern, INT ctlend_last, INT ctlend_fill, INT ctlend_unfill)
{
    int rr = 0;  /* index for current R-R interval - 1 */
    int rr_end;  /* index for last slice in a R-R interval */
    int slice_cnt;       /* counter */
    int slice_quant; /* number of sequences within the pass */

    /* Check for negative deadtimes and deadtimes that don't fall
       on GRAD_UPDATE_TIME boundaries */
    if ((ctlend_intern < 0) || (ctlend_last < 0) || (ctlend_fill < 0) ||
        (ctlend_unfill < 0)) 
        psdexit(EM_PSD_SUPPORT_FAILURE, 0, "","CardInit", 0);

    ctlend_intern = RUP_GRD(ctlend_intern);
    ctlend_fill = RUP_GRD(ctlend_fill);
    ctlend_unfill = RUP_GRD(ctlend_unfill);
    ctlend_last = RUP_GRD(ctlend_last);

    /* rr_end is only used in cross R-R, single phase  scans.
       Initialize rr_end as the number of slices in the first R-R - 1 */
    rr_end = opslquant/ophrep + ((opslquant%ophrep) ? 1:0) - 1;

    if (opphases > 1)
        slice_quant = opphases;
    else
	slice_quant = opslquant;

    for (slice_cnt=0; slice_cnt < slice_quant; slice_cnt++) {
        if (opphases > 1) {
	    /* Multiphase */
	    if (slice_cnt == (slice_quant - 1))
	        /* next slice will be cardiac gated */
	        ctlend_tab[slice_cnt] = ctlend_last;
            else
		/* next slice will be internally gated */
		ctlend_tab[slice_cnt] = ctlend_intern;
        } else {
	    /* Single phase, cross R-R */
	    /* Initialize as if slice is NOT the last in a R-R */
	    ctlend_tab[slice_cnt] = ctlend_intern; 
	  
	    if (slice_cnt == (opslquant - 1)) /* last slice */
	        ctlend_tab[slice_cnt] = ctlend_last;
            else if (opslquant <= ophrep) 
		/* At most 1 slice in each R-R. Each
		   slice is the first and last in an R-R */
		ctlend_tab[slice_cnt] = ctlend_fill;
            else {
		if (slice_cnt == rr_end) {
		    /* This is the last slice in an R-R */
		    rr += 1; /* up the rr counter */
		    /* Decide whether to use filled deadtime or
		       unfilled deadtime. Also recalculate rr_end,
		       the index of last slice of the next R-R interval */
		    if (rr < (opslquant%ophrep)) {
		        /* This is a filled R-R interval and the next
			   will be filled also. */
		        ctlend_tab[slice_cnt] = ctlend_fill;
			rr_end += (int)(opslquant/ophrep) + 1;
                    }
		    if (rr == (opslquant%ophrep)) {
		        /* This R-R is filled but the next is not */
		        ctlend_tab[slice_cnt] = ctlend_fill;
			rr_end += (int)(opslquant/ophrep);
                    }
		    if (rr > (opslquant%ophrep)) {
		        /* This is an unfilled R-R interval */
		        ctlend_tab[slice_cnt] = ctlend_unfill;
			rr_end += (int)(opslquant/ophrep);
                    }
                } 
            } 
        } 
    } 
    return SUCCESS;
}

/*******************************   PS   ***************************/
/*********************************************************************
 *                    PRESCAN.E RSP SECTION                          *
 *                            PScore                                 *
 *                                                                   *
 * Write here the functional code for the real time processing (Tgt  *
 * side). You may declare standard C variables, but of limited types *
 * short, int, long, float, double, and 1D arrays of those types.    *
 *********************************************************************/

long PSrsptrigger[MAX_PSC_VQUANT]={0};   /* prescan trigger */ /* vmx 10/13/94 YI */
long finalpscrot[MAX_PSC_VQUANT][9]={{0}};

/*
 *  mps1
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
mps1( void )
{
    rspent = L_MPS1;
    strcpy(psdexitarg.text_arg, "MPS1");

/* begin aps1_mod changes (GE) */
    PSinit(PSrot_mod);
    PSmps1(2);
    rspexit();

    return SUCCESS;
}   /* end mps1() */


/*
 *  aps1
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
aps1( void )
{
    rspent=L_APS1;
    strcpy(psdexitarg.text_arg, "APS1");

/* begin aps1_mod changes (GE) */
    PSinit(PSrot_mod);
    PSmps1(1);
    rspexit();

    return SUCCESS;
}   /* end aps1() */


/*
 *  cfl
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
cfl( void )
{
    rspent=L_CFL;
    strcpy(psdexitarg.text_arg, "CFL");

    PSinit(PSrot);
    PScfl();
    rspexit();

    return SUCCESS;
}   /* end cfl() */


/*
 *  rcvn
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
rcvn( void )
{
    rspent=L_RCVN;
    strcpy(psdexitarg.text_arg, "RCVN");

    PSinit(PSrot);
    PSrcvn();
    rspexit();

    return SUCCESS;
}   /* end rcvn() */


/*
 *  cfh
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
cfh( void )
{
    rspent=L_CFH;
    strcpy(psdexitarg.text_arg, "CFH");

    PSinit(rsp_PSrot);
    PScfh();
    rspexit();

    return SUCCESS;
}   /* end cfh() */

/*
 *  fasttg
 *
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
fasttg( void )
{
    rspent=L_FTG;
    PSinit(PSrot_mod);
    PSfasttg();
    rspexit();

    return SUCCESS;
}   /* end fasttg() */

/*
 *  expresstg
 *
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
expresstg( void )
{
    rspent=L_XTG;
    PSinit(PSrot_mod);
    PSexpresstg();
    rspexit();

    return SUCCESS;    
}   /* end expresstg() */

/*
 *  autoshim
 *
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
autoshim( void )
{
    rspent=L_AUTOSHIM;
    strcpy(psdexitarg.text_arg, "Autoshim");

    ASautoshim();
    rspexit();

    return SUCCESS;
}   /* end autoshim() */


/*
 *  PSmps1
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSmps1( INT mps1nex )
{
    INT acq_type;
    SHORT temp_short;
    INT slice_freq;
    FLOAT receive_freq;
    float rsp_PStloc=0;
    float rsp_PSrloc=0;
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    printdbg("Starting PSmps1",PSdebugstate);
    boffset(off_seqmps1);

    scopeon(&seqmps1);	/* Activate scope for core */
    syncon(&seqmps1);	/* Activate sync for core */

    rsp_PStloc = PStloc_mod;
    rsp_PSrloc = PSrloc_mod;
    /* begin aps1_mod changes (GE) */

    slice_freq = ( GAM * a_gzrf1mps1 * rsp_PStloc/
                   (10* TARDIS_FREQ_RES) );
    /* factor 10 is because rsptloc is in mm */
    setfrequency(slice_freq, &rf1mps1,0);

    slice_freq = ( GAM * a_gzrf2mps1 * rsp_PStloc
/ (10* TARDIS_FREQ_RES) );
    /* factor 10 is because rsptloc is in mm */
    setfrequency(slice_freq, &rf2mps1,0);

    receive_freq = 2 * 16000 * rsp_PSrloc/ mpsfov;

    /* end aps1_mod changes (GE) */ 

    setfrequency((int)((PSfreq_offset[rspent] + receive_freq)/TARDIS_FREQ_RES),
		 &echo1mps1, 0);

    if(PSdebugstate)
    {
        printf("\nAPS1/MPS1 Slthick = %f FOV = %f Xmit location = %f, Rcv location  = %f\n", 
                thickPS_mod,mpsfov, PStloc_mod, PSrloc_mod);
        printf("\nAPS1/MPS1 Xmit Freq = %i, Rcv Freq  = %f\n", slice_freq, receive_freq);
        printf("%s\n","APS1/MPS1 Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][0], PSrot_mod[0][1], PSrot_mod[0][2]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][3], PSrot_mod[0][4], PSrot_mod[0][5]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][6], PSrot_mod[0][7], PSrot_mod[0][8]);
        fflush(stdout);
    }

    if( PSdebugstate )
    {
        printf("PSmps1: psc_vol_index = %d\n",psc_vol_index );
    }


    
    for (view = -1; view <= 30000; view++)
    {
        for (excitation = 1; excitation <= mps1nex; excitation++)
    	{
            if (view > 0)

      	    {
                if (excitation == mps1nex)
      	      	{
                    attenlockoff(&attenuator_keymps1);
      	      	}
                else
      	      	{
                    attenlockon(&attenuator_keymps1);
      	      	}
      	    }

            if ((view > 0) && (excitation >= 1))
      	    {
                acq_type = (int)DABON;
      	    }
            else
      	    {
                acq_type = (int)DABOFF;
      	    }

            loaddab(&echo1mps1, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL); 

            /* For SWIFT(PSmps1): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
               */
            if( (psc_vol_index > 0) && (opvquant > 1))
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                        rsp_PSrloc = rsp_info[psc_vol_index-1].rsprloc;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                        rsp_PSrloc = rsp_info[PStest_slab-1].rsprloc;
                    }

                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqmps1);
                    }
                        
                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PSmps1: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            slice_freq = ( GAM * a_gzrf1mps1 * rsp_PStloc/
                    (10* TARDIS_FREQ_RES) );
            /* factor 10 is because rsptloc is in mm */
            setfrequency(slice_freq, &rf1mps1,0);

            slice_freq = ( GAM * a_gzrf2mps1 * rsp_PStloc
/ (10* TARDIS_FREQ_RES) );
            /* factor 10 is because rsptloc is in mm */
            setfrequency(slice_freq, &rf2mps1,0);

            receive_freq = 2 * 16000 * rsp_PSrloc/ mpsfov;

            /* end aps1_mod changes (GE) */

            setfrequency((int)((PSfreq_offset[rspent] + receive_freq)/TARDIS_FREQ_RES),
                    &echo1mps1, 0);

            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            syncoff(&seqmps1);

            /* Chopper logic */
            getiamp(&temp_short, &rf1mps1,0);
            setiamp((-temp_short),&rf1mps1,0);
	}
    }

    printdbg("Returning from PSmps1",PSdebugstate);

    return SUCCESS;
}   /* end PSmps1() */


/*
 *  PScfl
 *  
 *  Type: 
 *  
 *  Description:
 *  
 */
STATUS
PScfl( void )
{
    INT acq_type; /* enable or disable data acquisiton */
    INT slice_freq; /* transmit frequency for the prescan slice */
    SHORT temp_short; /* temp variable */
    float rsp_PStloc;
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    printdbg("Entering PScfl", PSdebugstate);
    boffset(off_seqcfl); 
    scopeon(&seqcfl);
    syncon(&seqcfl); 
    attenlockoff(&cfl_attenkey);
  
    rsp_PStloc = PStloc;
    slice_freq = GAM * a_gzrf1cfl * PStloc/
        (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
  
    setfrequency(slice_freq, &rf1cfl,0);
    setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES),
                 &cfl_fid, 0);

    if( PSdebugstate )
    {
        printf("PScfl: psc_vol_index = %d\n",psc_vol_index );
    }

    for (view = -cfl_dda+1 ; view <= 30000; view ++)
    {
        for (excitation = 1; excitation <= cfl_nex; excitation ++)
        {
            if (view > 0) 
            {
                acq_type = (int)DABON;

                if(excitation == cfl_nex)
                    attenlockoff(&cfl_attenkey);
                else
                    attenlockon(&cfl_attenkey);
            } 
            else
            {
                acq_type = (int)DABOFF;
            }

            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */

            loaddab(&cfl_fid, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL);

            /* For SWIFT(PScfl): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
             */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                    }

                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqcfl); 
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PScfl: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            slice_freq = GAM * a_gzrf1cfl * rsp_PStloc/
                (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */

            setfrequency(slice_freq, &rf1cfl,0);

            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            /*printdbg("S", PSdebugstate);*/
            syncoff(&seqcfl);

            if(PSdebugstate && view == 0)
            {
                printf("\n CFL:  Xmit Location = %f Receive Location = %f\n ", PStloc, 0.0 );
                printf ("%s\n","CFL : Rotation Matrix");
                printf("\t %6ld %6ld %6ld \n", PSrot[0][0], PSrot[0][1], PSrot[0][2]);
                printf("\t %6ld %6ld %6ld \n", PSrot[0][3], PSrot[0][4], PSrot[0][5]);
                printf("\t %6ld %6ld %6ld \n", PSrot[0][6], PSrot[0][7], PSrot[0][8]);
                fflush(stdout);
            }

            getiamp(&temp_short, &rf1cfl, 0);
            setiamp(-temp_short, &rf1cfl, 0);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }

        }  /* end excitation */
    }  /* end view */

    return SUCCESS;
}   /* end PScfl() */


/*
 *  PSrcvn
 *  
 *  Type: 
 *  
 *  Description:
 *  
 */
STATUS
PSrcvn( void )
{
    INT acq_type; /* enable or disable data acquisiton */
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    printdbg("Entering PSrcvn", PSdebugstate);

    /* GEHmr03545 */
    if ( rcvn_flag != PSD_OFF )
    {
        boffset( off_pre_rcvn );
        startseq((SHORT)0, (SHORT)MAY_PAUSE);
    }

    boffset(off_seqrcvn); 
    scopeon(&seqrcvn);
    syncon(&seqrcvn); 
    attenlockoff(&rcvn_attenkey);
  
    setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES),
                 &rcvn_fid, 0);

    if( PSdebugstate )
    {
        printf("PSrcvn: psc_vol_index = %d\n",psc_vol_index );
    }

    for (view = -rcvn_dda+1 ; view <= rcvn_loops ; view ++)
    {
        for (excitation = 1; excitation <= rcvn_nex; excitation ++)
        {
            if (view > 0) 
            {
                acq_type = (int)DABON;

                if(excitation == rcvn_nex)
                    attenlockoff(&rcvn_attenkey);
                else
                    attenlockon(&rcvn_attenkey);
            } 
            else
            {
                acq_type = (int)DABOFF;
            }

            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */

            loaddab(&rcvn_fid, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL);

            /* For SWIFT(PSrcvn): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
             */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    /* No need to switch slab*/
                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqrcvn); 
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PSrcvn: psc_vol_index=%d\n",psc_vol_index);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }
            startseq((short)0,(short)MAY_PAUSE);

            syncoff(&seqrcvn);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }

        }  /* end excitation */
    }  /* end view */

    return SUCCESS;
}   /* end PSrcvn() */


/*
 *  PScfh
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PScfh( void )
{
    INT acq_type;      /* enable or disable data acquisiton */
    INT slice_freq;    /* transmit frequency for the prescan slice */
    INT slice2_freq;   /* transmit frequency for the prescan slice */
    INT slice3_freq;   /* presscfh: transmit frequency for the prescan slice */
    INT ir_slice_freq; /* IR sequence transmit freq. for the prescan slice */
    SHORT temp_short;  /* temp variable */
    long init_cfh_deadtime; /* initial deadtime of the seqcfh sequence */
    long new_cfh_deadtime;  /* updated cfh deadtime */

    float rsp_PStloc;    /* RSP transmit location */
    float rsp_PSrloc;    /* RSP receive location */
    float rsp_PSphasoff; /* RSP phase off location */
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */
    
    showfp = 0;
    slice3_freq = 0; /* initialize */

    printdbg("Entering PScfh", PSdebugstate);
    boffset(off_seqcfh); 
    scopeon(&seqcfh);
    syncon(&seqcfh); 
    attenlockoff(&cfh_attenkey);

    if (psc_vol_index == 0) {

        slice_freq = cfh_rf1freq;
        setfrequency(slice_freq, &rf1cfh,0);

        slice2_freq = cfh_rf2freq;
        setfrequency((int)slice2_freq, &rf2cfh,0);
        setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES), &cfh_fid, 0);
    }

#ifdef PSD_CFH_CHEMSAT

    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        if (PSir != PSD_ON)
        {
            setiamp(ia_rfcssatcfh, &rfcssat, cscfh_satindex);
        }
        else
        {
            setiamp(0, &rfcssat, cscfh_satindex);
        }
    }
    cstun = 0;

#endif


    if (PSD_ON == PSir)
    {
        /* Inversion */
        /* factor 10 is because rsptloc is in mm */
        ir_slice_freq = GAM * a_gzrf0cfh * PStloc/(10 * 
                                                   TARDIS_FREQ_RES); 
        setfrequency(ir_slice_freq, &rf0cfh,0);
    }

    /* Setting tislice to PSslice_num+1 so user sees slices start at 1*/
    tislice=PSslice_num+1;
    tislice_start=PSslice_num+1;

    /* Setting titime to opti; results in every entry into CFH having 
       titime=opti*/
    titime = cfh_ti/1000;
    noir = 0;

    /* Finding initial deadtime (titime = opti) of seqcfh */
    getperiod( &init_cfh_deadtime, &seqcfh, 0 );

    if( PSdebugstate )
    {
        printf("PScfh: psc_vol_index = %d\n",psc_vol_index );
    }


    for (view = -cfh_dda+1 ; view <= 30000; view ++)
    {
        /* Modified for MULTI VOLUME Prescan - AP */
        if( presscfh_ctrl != PRESSCFH_NONE )
        {
            int cfh_slab_index = 0;

            if (oppscvquant == 1){
                cfh_slab_index = 0;
            }else{
                cfh_slab_index = noswitch_slab_psc ? PStest_slab : psc_vol_index;
                cfh_slab_index = IMax(2, 0, cfh_slab_index-1);
            }
            if( presscfh_ctrl != PRESSCFH_SHIMVOL ){
                rsp_PStloc = presscfh_info[cfh_slab_index].oppsctloc;
                rsp_PSrloc = presscfh_info[cfh_slab_index].oppscrloc;
                rsp_PSphasoff = presscfh_info[cfh_slab_index].oppscphasoff;
            }else{
                rsp_PStloc = rsp_psc_info[cfh_slab_index].rsppsctloc;
                rsp_PSrloc = rsp_psc_info[cfh_slab_index].rsppscrloc;
                rsp_PSphasoff = rsp_psc_info[cfh_slab_index].rsppscphasoff;
            }

            slice_freq = GAM * a_gzrf1cfh * rsp_PStloc/ (10 * TARDIS_FREQ_RES);
            slice2_freq = GAM * rsp_PSrloc * a_gxrf2cfh/ (10 * TARDIS_FREQ_RES);
            slice3_freq = GAM * rsp_PSphasoff * a_gyrf3cfh/ (10 * TARDIS_FREQ_RES);

            if( PSD_ON == PSir ) {
                ir_slice_freq = ( GAM * a_gzrf0cfh * rsp_PStloc
/ (10 * TARDIS_FREQ_RES) );
                setfrequency(ir_slice_freq, &rf0cfh,0);
            }
        }  else if ( psc_vol_index > 0 ) {
            /* Only for Vibrant and Swift with PRESSCFH_NONE*/

            int cfh_slab_index=0;
            int cfh_switch_coil=0;
            /* First check for shim, then slab */
            if( oppscvquant >= 1 )
            {
                /*1 shim vol: No coil switch. Disregard psc_vol_index*/
                /*2 shim vol: No coil switch.*/
                cfh_switch_coil = 0;

                if (oppscvquant == 1) 
                    cfh_slab_index = 0;
                else 
                    cfh_slab_index = noswitch_slab_psc ? (PStest_slab-1):(psc_vol_index-1);

                rsp_PStloc = rsp_psc_info[cfh_slab_index].rsppsctloc;
                rsp_PSrloc = rsp_psc_info[cfh_slab_index].rsppscrloc;
                rsp_PSphasoff = rsp_psc_info[cfh_slab_index].rsppscphasoff;
            } else { /*No shim vol */ 
                cfh_slab_index = psc_vol_index - 1;
                if ( opswift == PSD_ON ) {
                    cfh_switch_coil = 1;
                    cfh_slab_index = noswitch_slab_psc ? (PStest_slab-1):(psc_vol_index-1);
                }
                rsp_PStloc = rsp_info[cfh_slab_index].rsptloc;
                rsp_PSrloc = rsp_info[cfh_slab_index].rsprloc;
                rsp_PSphasoff = rsp_info[cfh_slab_index].rspphasoff;
            }

            if( cfh_switch_coil )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqcfh); 
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PScfh: psc_vol_index=%d, cfh_slab_index=%d\n",psc_vol_index,cfh_slab_index);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }
            slice_freq = ( GAM * a_gzrf1cfh * rsp_PStloc
/ (10 * TARDIS_FREQ_RES) );
            if((opcoax != 0) && cfh_newmode) {
                slice2_freq = ( GAM * (opspf ? rsp_PSphasoff * a_gyrf2cfh
                                       : rsp_PSrloc * a_gxrf2cfh )
/ (10 * TARDIS_FREQ_RES) );
            } else {
                slice2_freq = 0;
            }

            if( PSD_ON == PSir ) {
                ir_slice_freq = ( GAM * a_gzrf0cfh * rsp_PStloc
/ (10 * TARDIS_FREQ_RES) );
                setfrequency(ir_slice_freq, &rf0cfh,0);
            }
        } else {

            /* This is for the 3D scan volume - psc_vol_index = 0 */
            rsp_PStloc = PStloc;
            rsp_PSrloc = PSrloc;
            rsp_PSphasoff = PSphasoff;

            slice_freq = cfh_rf1freq;
            slice2_freq = cfh_rf2freq;
            if( PSD_ON == PSir ) {
                ir_slice_freq = GAM * a_gzrf0cfh * PStloc/(10 * 
                                                           TARDIS_FREQ_RES); 
                setfrequency(ir_slice_freq, &rf0cfh,0);
            }
        }  /* end of psc_vol_index */

        setfrequency(slice_freq, &rf1cfh,0);
        setfrequency((int)slice2_freq, &rf2cfh,0);
        if( presscfh_ctrl != PRESSCFH_NONE )
        {
            setfrequency((int)slice3_freq, &rf3cfh,0); /* for presscfh_ctrl */
        }

        setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES), &cfh_fid, 0);

        if(PSdebugstate)
        {
            INT pscrot_idx;

            pscrot_idx = psc_vol_index;
            if (psc_vol_index > 0)
            {
                pscrot_idx = psc_vol_index-1;
            }
            printf("\n %d rsp_PStloc (tx, rec, phase) -> %0f %0f %0f\n",
                   psc_vol_index, rsp_PStloc, rsp_PSrloc, rsp_PSphasoff);
            printf ("CFH : Rotation Matrix for Prescan Volume Index %d\n", psc_vol_index);
            printf("\t %6ld %6ld %6ld \n", rsp_PSrot[pscrot_idx][0], rsp_PSrot[pscrot_idx][1], rsp_PSrot[pscrot_idx][2]);
            printf("\t %6ld %6ld %6ld \n", rsp_PSrot[pscrot_idx][3], rsp_PSrot[pscrot_idx][4], rsp_PSrot[pscrot_idx][5]);
            printf("\t %6ld %6ld %6ld \n", rsp_PSrot[pscrot_idx][6], rsp_PSrot[pscrot_idx][7], rsp_PSrot[pscrot_idx][8]);

            fflush(stdout);
        }


        /* INVERSION RECOVERY CODE */
        if (PSD_ON == PSir)
        {
            /* Check for IR pulse being turned off */
            if (noir==1)
            {
                setiamp(0,&rf0cfh,0);
            }
            else
            {
                setiamp(ia_rf0cfh,&rf0cfh,0);
            }
            /* End check for IR pulse being on/off */

            if (tislice != (PSslice_num+1))
            {
                /* user has changed slice, so change frequencies */
                /* Check for proper range */
                if ((tislice < 1) || (tislice > opslquant)) 
                {
                    tislice=tislice_start;
                    PSslice_num=tislice-1;
                } 
                else
                {
                    PSslice_num=tislice-1;
                    /* changing the slice */

                    /* Calculation of new slice loc */
                    new_slice_loc = PStloc - ((opslspace + opslthick) *
                                              (tislice_start - tislice));
                    /* Inversion */
                    /* factor 10 is because rsptloc is in mm */
                    ir_slice_freq = GAM * a_gzrf0cfh * new_slice_loc/(10 * 
                                                                      TARDIS_FREQ_RES); 

                    setfrequency(ir_slice_freq, &rf0cfh,0);

                    /* Spin Echo */
                    /* factor 10 is because rsptloc is in mm */
                    slice_freq = GAM * a_gzrf1cfh * new_slice_loc/(10 * 
                                                                   TARDIS_FREQ_RES); 

                    setfrequency(slice_freq, &rf1cfh,0);
                    /* end of changing the slice */
                }
            }

            /* Changing the inversion time realtime */
            if (titime<50)
            {
                titime=50;
            }

            /* Need this check to reset titime to opti. Download error were
               happening because of invalid titimes */
            if(titime > 300)
            {
                titime = cfh_ti/1000;
            }

            titime_us = (titime*1000);
            new_dur=dur_invse + (titime_us - cfh_ti);
            new_dur = RUP_GRD(new_dur);
            setperiod(new_dur,&zticfh,0);
            setperiod(new_dur,&xticfh,0);
            setperiod(new_dur,&yticfh,0);
            setperiod(new_dur,&rticfh,0);
            setperiod(new_dur,&sticfh,0);

            /* Change the deadtime of seqcfh to preserve the cfh_tr value */
            /* If the seqcfh deadtime < 5 then set to the minimum of 4us */
            new_cfh_deadtime = init_cfh_deadtime + (cfh_ti - titime_us);
            if (new_cfh_deadtime < 5)
            {
                new_cfh_deadtime = 4;
            }

            setperiod( new_cfh_deadtime, &seqcfh, 0 );
            /* End deadtime change */

            /* End inversion time change */

            /* END INVERSION CORE CODE */
        } 
#ifdef PSD_CFH_CHEMSAT
        if( (cs_sat == PSD_ON) && PScs_sat )
        {
            CsSatMod((int)(cscfh_satindex+1));
        }
#endif
        /* Check should play cs/mt or stir for manual cfh */
        if( PSir )
        {
            StIRMod();
        }

        for( excitation = 1; excitation <= cfh_nex; excitation ++ )
        {
            if( view > 0 ) 
            {
                acq_type = (int)DABON;

                if( excitation == cfh_nex )
                {
                    attenlockoff(&cfh_attenkey);
                }
                else
                {
                    attenlockon(&cfh_attenkey);
                }
            } 
            else
            {
                acq_type = (int)DABOFF;
            }

            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */
            loaddab(&cfh_fid, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL);

            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            /*printdbg("S", PSdebugstate);*/
            syncoff(&seqcfh); 

            getiamp(&temp_short, &rf1cfh, 0);
            setiamp(-temp_short, &rf1cfh, 0);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }
        }  /* end excitation */
    }  /* end view */

    return SUCCESS;
}   /* end PScfh() */


/* disable STIR cfh if cs/mttun is on */
void
StIRMod(void)
{
    int do_mttun = 0;
    int do_cstun = 0;


#ifdef PSD_CFH_CHEMSAT
    if(PSD_ON == PScs_sat)
    {
        do_cstun = cstun;
    }
    else
    {
        do_cstun = PSD_OFF;
    }
#endif /* PSD_CFH_CHEMSAT */

    if( do_cstun || do_mttun || showfp ) 
    {
        /* disable stir cfh pulse */
        rfoff(&rf0cfh, 0);
        setiampt(0, &gyrf0kcfh, 0);
    }
    else {
        rfon(&rf0cfh, 0);
        setiampt(amp_gyrf0kcfh, &gyrf0kcfh, 0);
    }
    return;
}

/*  begin aps1_mod changes (GE) */
/*
 *  PSinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSinit( long (*PSrotmat)[9] )
{   
    /* Range check for psc_vol_index */
    if ( psc_vol_index < 0 )
    {
        if(PSdebugstate)
            printf("WRONG psc_vol_index =%d\n",psc_vol_index);
        psc_vol_index = 0;
    }

    setrfconfig((short) 5);	/* only activate rho1 */
    setssitime(100);	/* set ssi counter to 400 us. */
    rspqueueinit(200);	/* initialize to 200 entries */

    if( presscfh_cgate && rspent == L_CFH ){
        PSrsptrigger[0] = TRIG_ECG;
    } else{
        PSrsptrigger[0] = PStrigger;
    }
    setrotatearray((short)1, *PSrotmat);
    settriggerarray((short)1, PSrsptrigger);
    
    /* Always use scan rot matrix for SWIFT*/
    if(opswift == PSD_ON)
    {
        int i=0;
        setrotatearray((short)opvquant,rsprot[0]);
        for(i=0;i<opvquant;i++)
            PSrsptrigger[i] = PStrigger;

        settriggerarray((short)opvquant,PSrsptrigger);
    }

    return SUCCESS;
}   /* end PSinit() */

/* end aps1_mod changes (GE) */

/*
 *  PSfasttg
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSfasttg( void )
{
    printdbg("Greetings from FastTG", debugstate);
    rspent = L_FTG;
    rspdda = ftg_dda;
    rspbas = 0;
    rspvus = 30000;
    rspgy1 = 0;
    rspnex = 1;
    rspesl = pre_slice;
    rspasl = 0;
    rspslq = 1;
    rspsct = -1;

    strcpy(psdexitarg.text_arg, "FastTG");
    
    FastTGCore( PStloc_mod,
                (int)rspdda,
                (int)rspvus,
                (int)rspnex,
                (int)debugstate);
 
    printdbg("Normal End of FastTG", debugstate);
    rspexit();

    return SUCCESS;
}   /* end PSfasttg() */


/*
 *  PSexpresstg
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSexpresstg( void )
{
    printdbg("Greetings from eXpress TG", debugstate);
    rspent = L_XTG;
    rspdda = xtg_dda;
    rspbas = 0;
    rspvus = 30000;
    rspgy1 = 0;
    rspnex = 1;
    rspesl = pre_slice;
    rspasl = 0;
    rspslq = 1;
    rspsct = -1;

    strcpy(psdexitarg.text_arg, "eXpressTG");
    
    eXpressTGCore( PStloc_mod,
                   (int)rspdda,
                   (int)rspvus,
                   (int)rspnex,
                   (int)debugstate);
 
    printdbg("Normal End of eXpressTG", debugstate);
    rspexit();

    return SUCCESS;
}   /* end PSexpresstg() */


/*
 *  FastTGCore
 *  
 *  Type: Public Function
 *  
 *  Description:
 *    slice_loc: location of prescan slice  in mm
 *    slice_num: slice number to be excited
 *    ftg_disdaqs: number of disdaq pairs
 *    ftg_views: # of max views to be executed in ftg
 *    ftg_nex: # of excitations in ftg
 *    ftg_chop: No chop if = 2
 *    ftg_debug: debug state
 */
STATUS
FastTGCore( DOUBLE slice_loc,
            INT ftg_disdaqs,
            INT ftg_views,
            INT ftg_nex,
            INT ftg_debug )
{
    INT slice_freq1;    /* transmit frequency for the prescan slices */
    INT slice_freq2;
    INT slice_freq3;
    INT rcv_freq;
    float rsp_PStloc=0;
    float rsp_PSrloc=0;
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    if (FTGacq1 == 1)
    {
        ftg_acq1 = (int)DABON;
    }
    else
    {
        ftg_acq1 = (int)DABOFF;
    }
      
    if (FTGacq2 == 1)
    {
        ftg_acq2 = (int)DABON;
    }
    else
    {
        ftg_acq2 = (int)DABOFF;
    }
      
    printdbg("Entering FastTGCORE", (SHORT)ftg_debug);
    boffset(off_seqftg);
    scopeon(&seqftg);
    syncon(&seqftg);
 
    /* Initialize */
    rsp_PStloc = slice_loc;
    rsp_PSrloc = PSrloc_mod;

    attenlockoff(&ftg_attenkey);
    slice_freq1 = GAM * a_gzrf1ftg * rsp_PStloc/
        (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
    slice_freq2 = GAM * a_gzrf2ftg * rsp_PStloc/
        (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
    slice_freq3 = GAM * a_gzrf3ftg * rsp_PStloc/
        (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
    rcv_freq = 2*1000*FTGecho1bw*rsp_PSrloc/ FTGfov;

    setfrequency(slice_freq1, &rf1ftg,0);
    setfrequency(slice_freq2, &rf2ftg,0);
    setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                 &echo1ftg, 0);
    setfrequency(slice_freq3, &rf3ftg,0);
    setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                 &echo2ftg, 0);
 
    if(PSdebugstate)
    {
        printf("\nFTG Slthick = %f FOV = %f Xmit location = %f, Rcv location  = %f\n", 
                FTGslthk,FTGfov, slice_loc, PSrloc_mod);
        printf("\nFTG Xmit Freq = %f, Rcv Freq  = %f\n", (float)slice_freq1, (float)rcv_freq);
        printf("%s\n","FTG Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][0], PSrot_mod[0][1], PSrot_mod[0][2]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][3], PSrot_mod[0][4], PSrot_mod[0][5]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][6], PSrot_mod[0][7], PSrot_mod[0][8]);
        fflush(stdout);
    }

    if( PSdebugstate )
    {
        printf("FTG: psc_vol_index = %d\n",psc_vol_index );
    }

    for (view = (-ftg_disdaqs + 1) ; view <= ftg_views; view ++)
    {
        for (excitation = 1; excitation <= ftg_nex; excitation ++)
        {
            if (view > 0)
            {
                if (excitation == 1)
                    attenlockon(&ftg_attenkey);
                if (excitation == ftg_nex)
                    attenlockoff(&ftg_attenkey);
                ftg_acq2 = (int)DABON;
            }
            else
            {
                ftg_acq2 = (int)DABOFF;
            }
 
            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */
            loaddab(&echo1ftg, (INT)1,(INT)1,(INT)1,(INT)1,
                    (TYPDAB_PACKETS)ftg_acq1, PSD_LOAD_DAB_ALL);
            loaddab(&echo2ftg, (INT)1,(INT)1,(INT)1,(INT)1,
                    (TYPDAB_PACKETS)ftg_acq2, PSD_LOAD_DAB_ALL);

            /* For SWIFT(fasttg): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
               */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    /* No need to switch coil*/
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                        rsp_PSrloc = rsp_info[psc_vol_index-1].rsprloc;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                        rsp_PSrloc = rsp_info[PStest_slab-1].rsprloc;
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"fasttgcore: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            slice_freq1 = GAM * a_gzrf1ftg * rsp_PStloc/
                (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
            slice_freq2 = GAM * a_gzrf2ftg * rsp_PStloc/
                (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
            slice_freq3 = GAM * a_gzrf3ftg * rsp_PStloc/
                (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
            rcv_freq = 2*1000*FTGecho1bw*rsp_PSrloc/ FTGfov;

            setfrequency(slice_freq1, &rf1ftg,0);
            setfrequency(slice_freq2, &rf2ftg,0);
            setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                    &echo1ftg, 0);
            setfrequency(slice_freq3, &rf3ftg,0);
            setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                    &echo2ftg, 0);


            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            printdbg("S", (SHORT)ftg_debug);
            syncoff(&seqftg);
 
 
            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }
 
        }  /* end excitation */
 
    }  /* end view */

    return SUCCESS;
}   /* end FastTGCore() */


/*
 *  eXpressTGCore
 *  
 *  Type: Public Function
 *  
 *  Description:
 *    slice_loc: location of prescan slice  in mm
 *    slice_num: slice number to be excited
 *    xtg_disdaqs: number of disdaq pairs
 *    xtg_views: # of max views to be executed in xtg
 *    xtg_nex: # of excitations in xtg
 *    xtg_chop: No chop if = 2
 *    xtg_debug: debug state
 */
STATUS
eXpressTGCore( DOUBLE slice_loc,
            INT xtg_disdaqs,
            INT xtg_views,
            INT xtg_nex,
            INT xtg_debug )
{
    INT slice_freq1;    /* transmit frequency for the prescan slices */
    INT slice_freq2;
    INT rcv_freq;
    SHORT temp_short;
    INT rf3xtg_freq, rf4xtg_freq;
    float rsp_PStloc=0;
    float rsp_PSrloc=0;
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    if (XTGacq1 == PSD_ON)
    {
        xtg_acq1 = (int)DABON;
    }
    else
    {
        xtg_acq1 = (int)DABOFF;
    }
            
    printdbg("Entering eXpressTGCORE", (SHORT)xtg_debug);
    boffset(off_seqxtg);
    scopeon(&seqxtg);
    syncon(&seqxtg);
 
    /* Initialize */
    rsp_PStloc = slice_loc;
    rsp_PSrloc = PSrloc_mod;

    attenlockoff(&xtg_attenkey);
    slice_freq1 = GAM * a_gzrf1xtg * rsp_PStloc/
        (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
    slice_freq2 = GAM * a_gzrf2xtg * rsp_PStloc/
        (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
    rcv_freq = 2*1000*XTGecho1bw*rsp_PSrloc/ XTGfov;

    setfrequency(slice_freq1, &rf1xtg,0);
    setfrequency(slice_freq2, &rf2xtg,0);
    setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                 &echo1xtg, 0);
 
    if(PSdebugstate)
    {
        printf("\nXTG Slthick = %f FOV = %f Xmit location = %f, Rcv location  = %f\n", 
                XTGopslthick, XTGfov, slice_loc, PSrloc_mod);
        printf("\nXTG Xmit Freq = %f, Rcv Freq  = %f\n", (float)slice_freq1, (float)rcv_freq);
        printf("%s\n","XTG Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][0], PSrot_mod[0][1], PSrot_mod[0][2]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][3], PSrot_mod[0][4], PSrot_mod[0][5]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][6], PSrot_mod[0][7], PSrot_mod[0][8]);
        fflush(stdout);
        printf("XTG: psc_vol_index = %d\n",psc_vol_index );
    }

    rf4xtg_freq = (int)(xtg_offres_freq/TARDIS_FREQ_RES);
    rf3xtg_freq = rf4xtg_freq;

    for (view = (-xtg_disdaqs + 1) ; view <= xtg_views; view ++)
    {
        if( PSdebugstate )
        {
            printf("XTG: view = %d\n",view);
        }

        if(view == 1)
        {
            getiamp(&temp_short, &rf4xtg, 0);
            if(temp_short < 0.0)
            {
                setiamp(-1.0*temp_short, &rf4xtg, 0);
                getiamp(&temp_short, &rf3xtg, 0);
                setiamp(-1.0*temp_short, &rf3xtg, 0);
            }
            getiamp(&temp_short, &rf1xtg, 0);
            if(temp_short < 0.0)
            {
                setiamp(-1.0*temp_short, &rf1xtg, 0);
            }
        }

        for (excitation = 1; excitation <= xtg_nex; excitation ++)
        {
            if (view > 0)
            {
                if (excitation == 1)
                    attenlockon(&xtg_attenkey);
                if (excitation == xtg_nex)
                    attenlockoff(&xtg_attenkey);
                if(XTGacq1 == PSD_ON)
                {
                    xtg_acq1 = (int)DABON;
                }
            }
            else
            {
                xtg_acq1 = (int)DABOFF;
            }
 
            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */
            loaddab(&echo1xtg, (INT)1,(INT)1,(INT)1,(INT)1,
                    (TYPDAB_PACKETS)xtg_acq1, PSD_LOAD_DAB_ALL);

            /* For SWIFT(expresstg): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
               */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    /* No need to switch coil*/
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                        rsp_PSrloc = rsp_info[psc_vol_index-1].rsprloc;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                        rsp_PSrloc = rsp_info[PStest_slab-1].rsprloc;
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"eXpresstgcore: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            slice_freq1 = GAM * a_gzrf1xtg * rsp_PStloc/
                (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
            slice_freq2 = GAM * a_gzrf2xtg * rsp_PStloc/
                (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
            rcv_freq = 2*1000*XTGecho1bw*rsp_PSrloc/ XTGfov;
            
            setfrequency(slice_freq1, &rf1xtg,0);
            setfrequency(slice_freq2, &rf2xtg,0);
            setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                         &echo1xtg, 0);

            /* phase and freq cycling  */
            if((view > 0) && (view%2 == 1)) /* freq cycling */
            {
                setfrequency(rf4xtg_freq, &rf4xtg, 0);
                setfrequency((-1.0*rf3xtg_freq), &rf3xtg, 0);
            }
            else
            {
                setfrequency((-1.0*rf4xtg_freq), &rf4xtg, 0);
                setfrequency(rf3xtg_freq, &rf3xtg, 0);
            }
            
            if((view > 1) && (view%2 == 1)) /* phase cycling */
            {
                getiamp(&temp_short, &rf4xtg, 0);
                setiamp(-1.0*temp_short, &rf4xtg, 0);
                getiamp(&temp_short, &rf3xtg, 0);
                setiamp(-1.0*temp_short, &rf3xtg, 0);
            }

            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            printdbg("S", (SHORT)xtg_debug);
            syncoff(&seqxtg);
 
            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }
 
            /* Chopper logic */
            getiamp(&temp_short, &rf1xtg,0);
            setiamp((-temp_short),&rf1xtg,0);

        }  /* end excitation */
 
    }  /* end view */

    return SUCCESS;
}   /* end eXpressTGCore() */


/*
 *  ASautoshim
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASautoshim( void )
{
    SHORT temp_short;
    INT dix_shift;

#ifdef OFFSET_AS
    INT phase_step[3];
    INT phase_sign[3];
    INT yres_phase;
#endif /* OFFSET_AS */

    long asrottemp[3][9]; /* vmx 3/6/95 YI */
    INT *rf1_freq;
    INT *receive_freq1;
    SHORT viewtable[513];
    long trigger_temp[3]; /* vmx 10/13/94 YI */
    INT acquire_echo1;
    INT dab_view,dab_op;
    SHORT disdaqs;
    FLOAT tempGAM;

    printdbg("Greetings from autoshim", debugstate);
    boffset(off_seqaushim);

    disdaqs = as_dda;
    tempGAM = GAM;
    GAM = GAMMA_PROTON; /*only shim on proton*/

    /**************************************************************
      so here's how we loop through this entry point:

        pass = rspslq;               each slice is a pass
        for all slices
           for all views              
             (first echo)           note: these aren't really 2echos,
             reset dixon shift to 0       we just pretend they are.
             do the disdaqs               there's really a separate
             do the baselines             excitation for each 'echo'.
             collect the data 'echo'
             (second echo)
             do dixon shift
             do the disdaqs
             do the baselines
             collect the data 'echo'
           next view
           decrement pass
           send pass packet
        next slice
        send end of scan packet
     ******************************************************************/

    setrfconfig((short) 5);

    /* Allocate memory for various arrays.
     * An extra 2 locations are saved in case the user wants to do
     * some tricks. */
    rf1_freq = (int *)AllocNode((as_slquant + 2)*sizeof(int));
    receive_freq1 = (int *)AllocNode((as_slquant + 2)*sizeof(int));

    rf1_freq[0] = astloc1*GAM * a_gzrf1as/(10 * TARDIS_FREQ_RES);
    rf1_freq[1] = astloc2*GAM * a_gzrf1as/(10 * TARDIS_FREQ_RES);
    rf1_freq[2] = astloc3*GAM * a_gzrf1as/(10 * TARDIS_FREQ_RES);

    asrottemp[0][0] = hostToRspRotMat( asrot0 );  asrottemp[0][1] = hostToRspRotMat( asrot1 ); asrottemp[0][2] = hostToRspRotMat( asrot2 );  
    asrottemp[0][3] = hostToRspRotMat( asrot3 );  asrottemp[0][4] = hostToRspRotMat( asrot4 ); asrottemp[0][5] = hostToRspRotMat( asrot5 );
    asrottemp[0][6] = hostToRspRotMat( asrot6 );  asrottemp[0][7] = hostToRspRotMat( asrot7 ); asrottemp[0][8] = hostToRspRotMat( asrot8 );

    asrottemp[1][0] = hostToRspRotMat( asrot9 );  asrottemp[1][1] = hostToRspRotMat( asrot10 ); asrottemp[1][2] = hostToRspRotMat( asrot11 ); 
    asrottemp[1][3] = hostToRspRotMat( asrot12 ); asrottemp[1][4] = hostToRspRotMat( asrot13 ); asrottemp[1][5] = hostToRspRotMat( asrot14 );
    asrottemp[1][6] = hostToRspRotMat( asrot15 ); asrottemp[1][7] = hostToRspRotMat( asrot16 ); asrottemp[1][8] = hostToRspRotMat( asrot17 );

    asrottemp[2][0] = hostToRspRotMat( asrot18 ); asrottemp[2][1] = hostToRspRotMat( asrot19 ); asrottemp[2][2] = hostToRspRotMat( asrot20 ); 
    asrottemp[2][3] = hostToRspRotMat( asrot21 ); asrottemp[2][4] = hostToRspRotMat( asrot22 ); asrottemp[2][5] = hostToRspRotMat( asrot23 );
    asrottemp[2][6] = hostToRspRotMat( asrot24 ); asrottemp[2][7] = hostToRspRotMat( asrot25 ); asrottemp[2][8] = hostToRspRotMat( asrot26 );

    scalerotmats(asrottemp, &asloggrd, &phygrd, 3, asobl_debug);

    if(PSdebugstate)
    {
        printf("\n%d astlocs (1,2,3) -> %0f %0f %0f\n",
               as_slquant, astloc1, astloc2, astloc3);
        printf("\nrf1_freq (1,2,3) -> %d %d %d\n",
               rf1_freq[0], rf1_freq[1], rf1_freq[2]);
    }

    /* AutoShim Changes to Center Image always - HH- Sept 21, 2004 */
    /* Use asrot0 , asrot11 and asrot20 to decide on read and phase directions on the 3 planes */
    /* Slice 1 = Axial    - Z slice (astloc1) - X/Y read (astloc2/astloc3) - Y/X Phase (astloc3/astloc2) */
    /* Slice 2 = Sagittal - X slice (astloc2) - Z/Y read (astloc1/astloc3) - Y/Z Phase (astloc3/astloc1) */
    /* Slice 3 = Coronal  - Y slice (astloc3) - Z/X read (astloc1/astloc2) - X/Z Phase (astloc2/astloc1) */

/* Old Code */
    receive_freq1[0] = (PSfreq_offset[rspent] +
                        ((2 * echo1bwas*1000/ (asfov))
                         * asrloc1))/ TARDIS_FREQ_RES;
    receive_freq1[1] = (PSfreq_offset[rspent] +
                        ((2 * echo1bwas*1000/ (asfov))
                         * asrloc2))/ TARDIS_FREQ_RES;
    receive_freq1[2] = (PSfreq_offset[rspent] +
                        ((2 * echo1bwas*1000/ (asfov))
                         * asrloc3))/ TARDIS_FREQ_RES;

#ifdef OFFSET_AS
    /* New code Begin */

    receive_freq1[0] = (PSfreq_offset[rspent]
                        + ((2 * echo1bwas*1000/ (asfov)) * 
                           (asrottemp[0][0] != 0) ? astloc2 : astloc3))/ TARDIS_FREQ_RES;
    receive_freq1[1] = (PSfreq_offset[rspent]
                        + ((2 * echo1bwas*1000/ (asfov)) * 
                           (asrottemp[1][2] != 0) ? astloc1 : astloc3))/ TARDIS_FREQ_RES;
    receive_freq1[2] = (PSfreq_offset[rspent]
                        + ((2 * echo1bwas*1000/ (asfov)) * 
                           (asrottemp[2][2] != 0) ? astloc1 : astloc2))/ TARDIS_FREQ_RES;

    phase_step[0] = .5 + fabs(FS_2PI*(asrottemp[0][0] != 0)? astloc3 : astloc2/ asfov);
    phase_step[1] = .5 + fabs(FS_2PI*(asrottemp[1][2] != 0)? astloc3 : astloc1/ asfov);
    phase_step[2] = .5 + fabs(FS_2PI*(asrottemp[2][2] != 0)? astloc2 : astloc1/ asfov);
 
    if ( ((asrottemp[0][0] != 0) ? astloc3 : astloc2) >= 0.0 )
    {
        phase_sign[0] = 1.0;
    }
    else
    {
        phase_sign[0] = -1.0;
    }

    if ( ((asrot[1][2] != 0) ? astloc3 : astloc1) >= 0.0 )
    {
        phase_sign[1] = 1.0;
    }
    else
    {
        phase_sign[1] = -1.0;
    }

    if ( ((asrottemp[2][2] != 0) ? astloc2 : astloc1) >= 0.0 )
    {
        phase_sign[2] = 1.0;
    }
    else
    {
        phase_sign[2] = -1.0;
    }

    /* New code End */
#endif /* OFFSET_AS */

    trigger_temp[0] = TRIG_INTERN;
    trigger_temp[1] = TRIG_INTERN;
    trigger_temp[2] = TRIG_INTERN;

    setupphasetable(viewtable, TYPNORM,(int)asyres);


    /* Set ssi time.  This is time from eos to start of sequence   */
    /* interrupt in internal triggering.  The minimum time is 50us */
    /* plus 2us*(number of waveform and instruction words modified */
    /* in the update queue).                                       */
    setssitime((LONG)time_ssias/HW_GRAD_UPDATE_TIME);

    settriggerarray(as_slquant, trigger_temp);

    if(PSdebugstate)
    {
        printf("\n AUTOSHIM:  FOV = %f astloc1 = %f, astloc2 = %f  astloc3  = %f\n", asfov, astloc1,astloc2,astloc3); 
        printf("\n AUTOSHIM:  asrloc1 = %f, asrloc2 = %f  asrloc3  = %f\n", asrloc1,asrloc2,asrloc3); 
        printf("%s\n", "AUTOSHIM:  Slice 1 Rotation Matrix");
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[0][0],asrottemp[0][1],asrottemp[0][2]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[0][3],asrottemp[0][4],asrottemp[0][5]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[0][6],asrottemp[0][7],asrottemp[0][8]);
        printf("%s\n", "AUTOSHIM:  Slice 2 Rotation Matrix");
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[1][0],asrottemp[1][1],asrottemp[1][2]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[1][3],asrottemp[1][4],asrottemp[1][5]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[1][6],asrottemp[1][7],asrottemp[1][8]);
        printf("%s\n", "AUTOSHIM:  Slice 3 Rotation Matrix");
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[2][0],asrottemp[2][1],asrottemp[2][2]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[2][3],asrottemp[2][4],asrottemp[2][5]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[2][6],asrottemp[2][7],asrottemp[2][8]);

#ifdef OFFSET_AS
        printf("\n AUTOSHIM SLICE1:   slice loc= %f read loc= %f phase loc= %f \n", 
               astloc1, (asrottemp[0][0] != 0)   astloc2 : astloc3,
               (asrottemp[0][0] != 0) ? astloc3 : astloc2); 
        printf("\n AUTOSHIM SLICE2:   slice loc= %f read loc= %f phase loc= %f \n", 
               astloc1, (asrottemp[1][2] != 0) ? astloc1 : astloc3,
               (asrottemp[1][2] != 0) ? astloc3 : astloc1); 
        printf("\n AUTOSHIM SLICE3:   slice loc= %f read loc= %f phase loc= %f \n", 
               astloc1, (asrottemp[2][2] != 0) ? astloc1 : astloc2,
               (asrottemp[2][2] != 0) ? astloc2 : astloc1); 
#endif /* OFFSET_AS */
        fflush(stdout);
    }

    setrotatearray(as_slquant,asrottemp[0]);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keyas);
    scopeon(&seqaushim);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqaushim);
    syncoff(&seqpassas);


    for (slice = 0; slice < as_slquant; slice++)
    {
        dab_op = DABSTORE;

        setiamp((short)(ia_rf1as*flip_pctas), &rf1as, 0);

        for (view=(-(disdaqs+asbaseline)+1); view<= asyres; view++)
        {
            if (view<=0)
            {
                /* for the baselines in each slice, set the phase encode
                   amplitude to the first view */
                /* HSI change to setiampt from setiamp */
                setiampt(-viewtable[1], &gy1as, 0);
                setiampt(viewtable[1], &gy1ras, 0);
#ifdef OFFSET_AS
                /* New code Begin */

                setiphase(0,&echo1as,0);

                /* New code End */
#endif /* OFFSET_AS */
            }
            else
            {
                if (view > 0) 
                {
                    /* HSI change to setiampt from setiamp */
                    setiampt(-viewtable[view], &gy1as, 0);
                    setiampt(viewtable[view], &gy1ras, 0);
#ifdef OFFSET_AS

                    /* New code Begin */

                    yres_phase = -phase_sign[slice]*(((view-1)* phase_step[slice] + 3L*FS_PI)%FS_2PI-FS_PI);
                    setiphase(yres_phase, &echo1as, 0);

                    /* New code End */
#endif /* OFFSET_AS */
                }
            }
            for (excitation=1; excitation <= 1; excitation++)
            {
                /* Scope Trigger */
                if ((rspsct == slice) || (rspsct == -1))
                {
                    scopeon(&seqaushim);
                }
                else
                {
                    scopeoff(&seqaushim);
                }
                /*MRIge33520 - VB*/
                if ((view > -asbaseline)&&(excitation > 0))
                {
                    acquire_echo1 = (int)DABON;
                }
                else
                {
                    acquire_echo1 = (int)DABOFF;
                }

                /* Load Transmit and Receive frequencies */
                setfrequency(rf1_freq[slice], &rf1as, 0);
                setfrequency(receive_freq1[slice], &echo1as, 0);

                if (view > 0)
                {
                    dab_view = view;
                    if (excitation == 1)
                    {
                        dab_op = 0;
                    }
                    else
                    {
                        dab_op = 3 - 2*(excitation % 2);
                    }
                }
                else
                {
                    dab_view = 0;
                }

                /* set up the dixon shift for every other seq */
                for(dixon=0;dixon<=1;++dixon)
                {
                    dix_shift = (dixon % 2)*RUP_GRD((dix_timeas))+GRAD_UPDATE_TIME;
                    setperiod(dix_shift,&xdixon,0);
                    setperiod(dix_shift,&ydixon,0);
                    setperiod(dix_shift,&zdixon,0);
                    setperiod(dix_shift,&sdixon,0);
                    setperiod((int)(dix_shift - dixon*dix_timeas),&sdixon2,0);
                    /* All DAB Info is Set. Pretend even views are 2nd echo. */
                    /* Load up dab packet!                                   */
                    loaddab(&echo1as,(short)0,dixon,dab_op,dab_view,(TYPDAB_PACKETS)acquire_echo1, PSD_LOAD_DAB_ALL);

                    /*printdbg("S", debugstate);*/
                    startseq((short)slice, (short)MAY_PAUSE);

                    syncoff(&seqaushim);
                }

                if (view == (-asbaseline+1))
                    dab_op = 1; /* add baseviews */

                getiamp(&temp_short, &rf1as, 0);
                setiamp(-temp_short, &rf1as, 0);

            } /* excitation */

        }  /* view */


        boffset(off_seqpassas);
        if (slice == (as_slquant-1)  ) /* Last pass */
        {
            /* Set DAB pass packet to end of scan */
            setwamp(SSPD + DABPASS + DABSCAN, &pass_aushim, 2);
            printdbg("End of Scan and Pass", debugstate);
        }
        else
        {
            /* Set DAB pass packet to end of pass */
            setwamp(SSPD + DABPASS, &pass_aushim, 2);
            printdbg("End of Pass", debugstate);
        }


        startseq((short)0, (short)MAY_PAUSE);
        boffset(off_seqaushim);

    }

    /* Reset the rotation matrix */
    setrotatearray((short)opslquant,rsprot[0]);

    GAM = tempGAM;

    printdbg("Normal End of autoshim", debugstate);

    return SUCCESS;
} /* End of ASautoshim */

/* CoilSwitchSetCoil
 *
 *  Description: MRIhc15304
 *    This sets the RF HUB index for the coil by changing the data on an ssp
 *    pulse and/or with the sethubindeximm function.  Also calls
 *    setrcvportimm, if requested.
 *
 *  Parameters:
 *  (I: for input parameters, O: for output parameters)
 *  
 *  (O) STATUS return variable - Did function complete successfully.
 *  (I) const COIL_INFO - coil info structure of coil to switch to
 *  (I) const INT setRcvPortFlag - Flag indicating that setrcvportimm needs
 *        to be executed.  This needs to be set whenever switching to or
 *        from the BODY coil.
 *  
 *  Globals:
 *  (I) txCoilInfo
 *
 */

STATUS
CoilSwitchSetCoil( const COIL_INFO coil,
                   const INT setRcvPortFlag)
{
    SHORT device = 0;

    if( setRcvPortFlag || (COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod) )
    {
        int wait_rspimm = 0;

        /* MRIhc14300: When switching coils, play a delay sequence to
           wait for scan prep to complete and scanning to start before the
           first setrcvportimm() & sethubindeximm().  These functions may not
           be called until scanning starts and the first startseq will not
           return until scanning starts. After scanning has started this will
           merely add an additional short delay to the switch time */

        boffset(off_seqcswWaitBefore);
        startseq((short)0, (SHORT)MAY_PAUSE);

        /* Need additional delay for setrcvpowerimm & sethubindeximm
         * to take effect.  The delay time must be set to guarantee
         * the completion of both setrcvportimm and sethubindeximm */

        if( COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod )
        {
            wait_rspimm = csw_wait_sethubindeximm;
        }

        if( setRcvPortFlag )
        {
            wait_rspimm = IMax(2, wait_rspimm, csw_wait_setrcvportimm);
        }

        setperiod(wait_rspimm, &csw_wait, 0);
    }
    else
    {
        /* No additional delay needed when not calling setrcvportimm */
        setperiod(SSP_UPDATE_TIME, &csw_wait, 0);
    }

    /* Setup hub index switching packet */
    device = 0;
    if( COIL_SWITCH_SSP_HUB_INDEX & cfcoilswitchmethod )
    {
        device = RDC;
        /* Set hub index on SSP packet */
        setwamp( (SHORT)(SSPD | (HUBIND + coil.hubIndex)), &contrfhubsel, (LONG)2 );
    }
    setwamp( (SHORT)(SSPDS | device), &contrfhubsel, (LONG)0 );

    /* Set receiver port & receiver input */
    if( setRcvPortFlag || (COIL_SWITCH_SSP_RECEIVER_INPUT & cfcoilswitchmethod) )
    {
        SHORT coil_port = PSD_RP_BODY;
        SHORT rcv_input = RFBODYI;

        /* Calculate coil port & receiver input */
        switch (coil.rxCoilType) 
        {
        case RX_COIL_BODY:
        default:
            /* Transmit & receive with body coil */
            coil_port = PSD_RP_BODY;
            rcv_input = RFBODYI;
            break;
        case RX_COIL_LOCAL:
            {
                /* Assume there is only one transmit coil.  If two transmit
                   coils, the primary will be used */
                n32 txCoilType = TX_INDEX_NONE; 
                if (TX_INDEX_NONE != coil.txIndexPri)
                {
                    txCoilType = txCoilInfo_tgt[coil.txIndexPri].txCoilType;
                }
                else if (TX_INDEX_NONE != coil.txIndexSec)
                {
                    txCoilType = txCoilInfo_tgt[coil.txIndexSec].txCoilType;
                }
                else
                {
                    printf("CoilSwitchSetCoil: No transmit coil defined!\n");
                    return FAILURE;
                }

                if (TX_COIL_LOCAL == txCoilType)
                {
                    /* Local transmit coil */
                    coil_port = PSD_RP_HEAD;
                    rcv_input = RHEADI;
                }
                else
                {
                    /* Surface coil */
                    coil_port = PSD_RP_SURFACE;
                    rcv_input = RFAUX;
                }
            }
            break;
        }

        /* Setup receiver input switching packet */
        device = 0;
        if( COIL_SWITCH_SSP_RECEIVER_INPUT & cfcoilswitchmethod )
        {
            device = RDC;
            setwamp( (SHORT)(SSPD | rcv_input), &contrfsel, (LONG)2 );
        }
        setwamp( (SHORT)(SSPDS | device), &contrfsel, (LONG)0 );

        /* Set receiver port using RSP function call when switching to/from 
         * body coil */
        if (setRcvPortFlag) 
        {
#ifdef PSD_HW
            setrcvportimm( (SHORT)coil_port );
#endif /* PSD_HW */
        }
    }

    /* Select coil using RSP function on MGD Rx chain */
    if(COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod)
    {
        sethubindeximm( coil.hubIndex );
    }
   
    boffset( off_seqcsw );
    startseq( (short)0, (SHORT)MAY_PAUSE );
    return SUCCESS;
}


/*******************************  MPS2  ***************************/
STATUS mps2( void )
{
    printdbg("Greetings from MPS2", debugstate);
    boffset(off_seqcore);
    rspent = L_MPS2;  
    rspdda = ps2_dda;

    if (cs_sat ==1)	/* Turn on Chemsat Y crusher */
        cstun=1;
    psdinit();
    strcpy(psdexitarg.text_arg, "mps2");
  
    rspent = L_MPS2;
    rspbas = 0;

    rspasl = pre_slice;
    rsprep = 30000;
    rspilv = 1;
    rspgy1 = 0;
    rspnex = 2;

    rspesl = -1;
    rspslq = slquant1;
    rspe1st = e1st;
    rspetot = etot;
    pass = pre_pass;

    if (ir_on == PSD_ON)  /* IR..MHN */
        setiamp(ia_rf0, &rf0, 0);

    rspgyc = 0;
    gyb_amp = 0;
    ygradctrl(rspgyc, gyb_amp, etl);

    scanloop();

    printdbg("Normal End of MPS2", debugstate);
    rspexit();

    return SUCCESS;
  
} /* End MPS2 */

/*******************************  APS2  **************************/
STATUS aps2( void )
{
    printdbg("Greetings from APS2", debugstate);
    boffset(off_seqcore);
  
    rspent = L_APS2;
    rspdda = ps2_dda;
    if (cs_sat ==1)	/* Turn on ChemSat Y crusher */
	cstun = 1;
    psdinit();
    strcpy(psdexitarg.text_arg, "aps2");
  
    rspent = L_APS2;                   
    rspbas = 0;

    rspasl = -1;
    rsprep = 30000;
    rspilv = 1;
    rspgy1 = 0;
    rspnex = 2;

    rspesl = -1;
    rspslq = slquant1;
    rspe1st = e1st;
    rspetot = etot;
  
    rspacqb = pre_pass;
    rspacq  = pre_pass + 1;
  
    if (ir_on == PSD_ON)
        setiamp(ia_rf0, &rf0, 0);

    rspgyc = 0;
    gyb_amp = 0;
    ygradctrl(rspgyc, gyb_amp, etl);
    scanloop();
    printdbg("Normal End of APS2", debugstate);
    rspexit();

    return SUCCESS;
  
} /* End APS2 */

/***************************  SCAN  *******************************/
STATUS scan( void )
{
    printdbg("Greetings from SCAN", debugstate);
    rspent = L_SCAN;

    rspdda = dda;


    if (cs_sat == 1)	/* Turn on ChemSat Y crusher */
        cstun =1;

    psdinit();

    rspbas = rhbline;     /* used on blineacq only */

    rspasl = -1;
    rsprep = reps;
    rspgy1 = 1;
    rspnex = nex;

    rspesl = -1;
    rspslq = slquant1;
    rspilv = intleaves;
    rspgyc = 0;

    if (touch_flag)
    {
        /* Use the full number of MEG directions during MR-Touch scan */
        rsp_cmndir = touch_ndir;
    }
    else
    {
        rsp_cmndir = 1;
    }

    if (ir_on == PSD_ON)
        setiamp(ia_rf0, &rf0, 0);

    if (rawdata == PSD_ON && baseline > 0) {  /* collect reference scan for rawdata */
        ygradctrl(rspgyc, gyb_amp, etl);
        scanloop();
    }
  
    /* turn on or off phase encode blips */
    if (gyctrl == PSD_ON)
        rspgyc = 1;
    else
        rspgyc = 0;
  
    ygradctrl(rspgyc, gyb_amp, etl);

    if(rtb0_flag)
    {
        rtb0_base_cfoffset = 0.0;
        rtb0_comp_cfoffset = 0.0;
        rtb0_comp_cfoffset_TARDIS = 0;
        rtb0_rtp_1streturn = PSD_OFF;
        rtb0_cfoffset = 0.0;
        rtb0_outlier_count = 0;

        rtB0ComRspInit();

        routeDataFrameDab(&rtb0echo, ROUTE_TO_RTP, cfcoilswitchmethod);
    }

    scanloop();

    if(rtb0_flag)
    {
        RtpEnd();
    }

    rspexit();

    return SUCCESS;
}

/*************************** SCANLOOP *******************************/
STATUS scanloop( void )
{
    int pause; /* pause attribute storage loc */
    int i;

    printdbg("Greetings from scanloop", debugstate);
  
    if (cs_sat == PSD_ON) 
	cstun = 1;
  
    setiamp(ia_rf1, &rf1, 0);   /* Reset amplitudes */
    if (oppseq == PSD_SE)
	setiamp(ia_rf2, &rf2, 0);
  
    /* turning spatial & chem SAT on */ 
    SpSat_Saton(0);

    if (cs_sat > 0)  
	setiamp(ia_rfcssat, &rfcssat, 0);
  
    strcpy(psdexitarg.text_arg, "scan");
  
    if (opcgate==PSD_ON) {

#ifdef ERMES_DEBUG
	/* Don't check ecg rate in simulator mode. */
#else
	if (test_getecg == PSD_ON) {
            getecgrate(&rsp_hrate);
            if (rsp_hrate == 0)
		psdexit(EM_PSD_NO_HRATE,0,"","psd scan entry point",0);
	}
#endif
	rsp_card_intern = ctlend + scan_deadtime;
	rsp_card_last   = ctlend_last + scan_deadtime;
	rsp_card_fill   = ctlend_fill + scan_deadtime;
	rsp_card_unfill = ctlend_unfill + scan_deadtime;
	CardInit(ctlend_tab, rsp_card_intern, rsp_card_last,
                 rsp_card_fill, rsp_card_unfill);
    } else {
        setperiod(scan_deadtime, &seqcore, 0);
    }

       /* set trigger to aux if desired */
       if (ext_trig == PSD_ON  && rspent == L_SCAN) {
 
           settrigger((SHORT)TRIG_AUX,0);
       }

    pass_cnt = 0;  /* Reset pass counter */
    freq_ctr = 1;  /* jwg frequency counter for delays */
    
    /*jwg bb here is the top loop*/
    /*in english, this goes from 0 to pass_reps, which is equal to opfphases*/    
    for (pass_rep = 0; pass_rep < rspprp; pass_rep++) {

        if(rtd_on == PSD_ON) attenlockon(&atten);


        for (pass = rspacqb; pass < rspacq; pass++) {

            /* fMRI - pass_index does not depend on pass_rep */
            /*        since its not a true multi-phase scan  */
            /*        but this loop is used...               */
            if(opfmri == PSD_ON) {
                pass_index = pass;
            } else {
                pass_index = pass + pass_rep*rspacq;
            }

            if (pass_index < rspacq) { /* MRIge57362 - acquire baselines on first rep of each pass */
                if (baseline > 0) {                     /* acquire the baseline */
                    if (baseline > 1)  /* play first n-1 baselines at fast rate */
                        setperiod(bl_acq_tr1, &seqblineacq, 0);
                    else
                        setperiod(bl_acq_tr2, &seqblineacq, 0);
                    blineacq();
                }
            }
        
            boffset(off_seqcore);
        
            /* MRIge53529: initialize wait time and pass packet for disdacqs, etc.*/
            setwamp(SSPDS, &pass_pulse, 0);
            setwamp(SSPD, &pass_pulse, 2);
            setwamp(SSPDS, &pass_pulse, 4);
            for (i=0; i<num_passdelay; i++) 
                setperiod(100, &ssp_pass_delay, i);
            pause = MAY_PAUSE;
            printdbg("Pre core(): Null ssp pass packet", debugstate);

            if (touch_flag)
            {
                SlideTouchTrig();  /* Set MRE motion triggers */
            }

            /*jwg bb OK THE ACTUAL SCANCORE IS WITHIN THIS WHOLE LOOP FUCK*/
	    /*As coded, will loop through all slices one frequency at a time*/
            core();                                 /* acquire the data */
	    freq_ctr++;	    
	
            /* Return to standard trigger array and core offset */
            settriggerarray((SHORT)(opslquant*opphases), rsptrigger);
	
            /* BJM: 825 -> 83 MERGE */
            /* If this isn't the last pass and we are doing relaxers  */
            if ((SatRelaxers)&&( (pass!=(rspacq-1)) && (pass_rep!=(rspprp-1)) ) )
            {
                SpSatPlayRelaxers();  /* BJM: need the next condition for concat seq MPH */
            }
            else if ((SatRelaxers) && (pass!=(rspacq-1)) && (acqmode == 1) )
            {
                SpSatPlayRelaxers();
            }
        } /* end pass loop */
    
        /* This function is for EPI calibration and is not used during normal imaging */
        epiRTD();
    
        /* This is used for fMRI and long rep EPI scans */
        /* if the bore temp is exceeded, break the looping... */
        if(BoreOverTempFlag == TRUE) {
            /*MRIhc01021 log error into GEsyslog before abort scan*/
            pgen_err_msg_struct.ab_code = 0;
            pgen_err_msg_struct.text_string[ 0 ] = '\0';
            pgen_err_msg_struct.error_or_text_flag = 1;
            strncpy( &pgen_err_msg_struct.proc_name[ 0 ], "BORETEMP\0", 8 ); 
            pgen_err_msg_struct.error_code = EM_PSD_BORETEMP_OVER;
            rsp_error_abort();

        }
    
    } /* end pass_rep loop */

    printdbg("Normal End of SCAN", debugstate);
    fprintf(stderr,"SCAN loop is complete \n");

    return SUCCESS;

} /* End SCANLOOP */

/*****************************  CORE  *************************/
STATUS core( void )
{
    int pause = MAY_PAUSE;
    int passDoneFlag = 0;
    int InterPassDoneFlag = 0;
    int i;
#ifdef PRINTRSP
    printdbg("Starting Core", debugstate);
#endif  
  
    /******* disdaq block ***********************************/

    if (touch_flag)
    {
        NullTouchAmp();  /* Null the MRE MEG initially */
    }

    if( rspdda > 0
        )
    {
        acq_data = (int)DABOFF;
        /* mod_rba = FALSE; */

        cmdir_rep = 0;

        if(rtb0_flag)
        {
            loaddab(&(rtb0echo), 0, 0, DABSTORE, 1, DABOFF, PSD_LOAD_DAB_ALL);
        }
        dabrbaload();   

        setperiod((int)tf[0], &wgx, 0);
        setperiod((int)tf[0], &wgy, 0);
        setperiod((int)tf[0], &wgz, 0);
        setperiod((int)tf[0], &wssp, 0);
        setperiod((int)tf[0], &womega, 0);

        if (touch_flag)
        {
            /* Adjust SSP WAIT pulse to match other boards while
             * not shifting the trigger pulses */
            setperiod(pw_touch_wssp, &touch_wssp, 0);
        }

        if ( (gyctrl == PSD_ON) && (rspent != L_REF) &&
             (rspent != L_MPS2) && (rspent != L_APS2) ) {

            setiampt(gy1f[0], &gy1, 0);

            if (ygmn_type == CALC_GMN1) {
                setiampt(gymn[0], &gymn1, 0);
                setiampt(-gymn[0], &gymn2, 0);
            }

        }
	
        acq_sl = 0;
        attenlockon(&atten);
		
        for (ileave = rspdda - 1; ileave >= 0; ileave--) {

            /* The % accounts for the case when dda > intleaves */
            if (!touch_flag)
            {
                /* Don't RF chop for MRE because it interferes with the alternating +/- MEG */
                if (rf_chop == PSD_ON && rspnex <= 1
                    )
                {
                    setiamp(-rfpol[ileave % intleaves], &rf1, 0);
                }
                else
                {
                    setiamp(rfpol[ileave % intleaves], &rf1, 0);
                }
            }

	    /*jwg bb it looks like the DISDAQ slice loop begins here*/
            for (slice = rspslqb; slice < rspslq; slice++) {    

                if (rspesl == -1) {    

                    if (acqmode==0) /* interleaved */
                        sliceindex = (acq_ptr[pass_index] + slice)%opslquant;

                    if (acqmode==1) /* sequential */
                        sliceindex = acq_ptr[pass_index];

                } else {

                    sliceindex = acq_ptr[pass_index] + rspesl;
                }

                /* Set rho, data acquisition flags */
                if (slice >= slc_in_acq[pass_index]) {

                    /* Dummy slice - turn off RHO board */
                    setieos((SHORT)EOS_DEAD, &rho_td0,0);

                } else {  /* live slice */

                    /* turn on RHO BOARD */
                    setieos((SHORT)EOS_PLAY, &rho_td0, 0);

                }

                /* Set cardiac delays and end times */
                if (opcgate) {
                  
                    /* Build the trigger for multi-slice, multi-phase cardiac */
                    msmpTrig();
                  
                    if ((rspent == L_SCAN)||(rspent == L_MPS2) 
                        ||(rspent == L_APS2)||(rspent == L_REF))

                        setperiod(ctlend_tab[slice],&seqcore ,0);
		  
                    /*  first slice in RR */
                    if (rsptrigger[slice] != TRIG_INTERN) {	
                        if ((rspent == L_SCAN)||(rspent == L_MPS2) ||
                            (rspent == L_APS2)||(rspent == L_REF)) {

                            /* Use cardiac trigger delay */
                            setperiod(td0, &x_td0, 0);
                            setperiod(td0, &y_td0, 0);
                            setperiod(td0, &z_td0, 0);
                            setperiod(td0, &rho_td0, 0);
                            setperiod(td0, &theta_td0, 0);
                            setperiod(td0, &omega_td0, 0);
                            setperiod(td0, &ssp_td0, 0);
                        }

                    } else {

                        /* Bypass cardiac trigger delay */
                        setperiod((int)GRAD_UPDATE_TIME, &x_td0, 0);
                        setperiod((int)GRAD_UPDATE_TIME, &y_td0, 0);
                        setperiod((int)GRAD_UPDATE_TIME, &z_td0, 0);
                        setperiod((int)GRAD_UPDATE_TIME, &rho_td0, 0);
                        setperiod((int)GRAD_UPDATE_TIME, &theta_td0, 0);
                        setperiod((int)GRAD_UPDATE_TIME, &omega_td0, 0);
                        setperiod((int)GRAD_UPDATE_TIME, &ssp_td0, 0);
                    }

                } /* if opcgate */
                else
                {
                    setperiod(scan_deadtime_correct[slice], &seqcore, 0);
                }
                    
                /* SPSP fat sat pulse */ 
                if (SpSpFatSatRsp() == FAILURE) return FAILURE;

                SpSatUpdateRsp(1, pass_index, opccsat);

                if (ssRsp() == FAILURE) return FAILURE;

                setfrequency(rf1_freq[sliceindex], &rf1, 0);

                if (oppseq == PSD_SE) {
                    setfrequency(rf2_freq[sliceindex], &rf2, 0);
                }

                sp_sat_index = sliceindex;
                startseq((short)sliceindex, (SHORT)MAY_PAUSE);

/* ++++++++++++++  in case scan starts with external trigger, set internal trigger for the rest of the scan. ++++++++++++++++ */
                if ((pass == rspacqb) && (pass_rep == 0) && (slice == rspslqb) && (ileave == rspdda - 1) && (rspdda > 0)) {
                  
                    if((ext_trig == PSD_ON) && (rspent == L_SCAN))
                                   settrigger((short)TRIG_INTERN,0);
                }
 
   /* ++++++++++++++  in case scan starts with external trigger, set internal trigger for the rest of the scan. ++++++++++++++++ */

		
            } /* for slice= 0 */

        } /* for ileave = 0 */

    }	/* if rspdda > 0 */
  
    /******* end disdaq block ***********************************/
  
    if (rspent != L_SCAN)
        attenlockoff(&atten);
    else
        attenlockon(&atten);
  
    /* Loop through the MEG directions */
    for (cmdir_rep = 0; cmdir_rep < rsp_cmndir; cmdir_rep++)
    { 
        if (rspent != L_REF)
        {
            SetTouchAmp(cmdir_rep);
        }

        /*jwg bb this set to 1 for interleave, not relevent to us*/
        for (core_rep = 0; core_rep < rsprep; core_rep++) {
            /* baselines are done seperately in blineacq routine */

            for (ileave = rspilvb; ileave < rspilv; ileave++) {

                if (ileave>0) { 
                    if ((ep_alt > 0) && (gradpol[ileave] != gradpol[ileave-1]))
                        setreadpolarity();
                    if(se_ref==1) setreadpolarity_ref();
                }

                if ((cs_sat == PSD_ON) && (rspent == L_MPS2))
                    CsSatMod(cs_satindex);

                /* set sliding ssp/readout/phase/slice */

                setperiod((int)tf[ileave], &wgx, 0);
                setperiod((int)tf[ileave], &wgy, 0);
                setperiod((int)tf[ileave], &wgz, 0);
                setperiod((int)tf[ileave], &wssp, 0);
                setperiod((int)tf[ileave], &womega, 0);

                if (touch_flag)
                {
                    /* Adjust SSP WAIT pulse to match other boards while
                     * not shifting the trigger pulses */
                    setperiod(pw_touch_wssp - tf[ileave], &touch_wssp, 0);
                }

                /* Set blip and gy1 pulse amplitudes */
                ygradctrl(rspgyc, blippol[ileave], etl);

                if ( (gyctrl == PSD_ON) && (rspent != L_REF) &&
                     (rspent != L_MPS2) && (rspent != L_APS2) ) {

                    setiampt(gy1f[ileave], &gy1, 0);

                    if (ygmn_type == CALC_GMN1) {
                        setiampt(gymn[ileave], &gymn1, 0);
                        setiampt(-gymn[ileave], &gymn2, 0);
                    }
                }

		/*jwg bb here is where the actual excitation loop is*/
                for (excitation=1-rspdex; excitation <= rspnex; excitation++) {

                    if (rf_chop == PSD_ON && excitation % 2 == 0)
                        setiamp(-rfpol[ileave], &rf1, 0);  /* even excitation */
                    else
                        setiamp(rfpol[ileave], &rf1, 0);   /* odd excitation */

		    /*jwg bb and here is where the actual slice loop is*/
                    for (slice = rspslqb; slice < rspslq; slice++) {    


                        if ((slice == rspasl) || (rspasl == -1))
                            acq_sl = 1;
                        else 
                            acq_sl = 0;

                        /* Determine which slice(s) to excite (find spot in 
                           rspinfo table) */
                        /* Remember slices & passes start at 0 */
                        if (rspesl == -1) {
                            if (acqmode==0) /* interleaved */
                                sliceindex = (acq_ptr[pass_index] + slice)%opslquant;

                            if (acqmode==1) /* sequential */
                                sliceindex = acq_ptr[pass_index];

                        } else {

                            sliceindex = acq_ptr[pass_index] + rspesl;

                        }

                        if ((rspent == L_MPS1) || (rspent == L_MPS2)) {

                            if ((excitation == rspnex) && (acq_sl == 1)) {
                                attenlockoff(&atten);
                            } else {
                                attenlockon(&atten);
                            }

                        }

                        /* Set cardiac delays and end times */
                        if (opcgate) {


                            /* Build the trigger for multi-slice, multi-phase cardiac */
                            msmpTrig();

                            if ((rspent == L_SCAN)||(rspent == L_MPS2) 
                                ||(rspent == L_APS2)||(rspent == L_REF))

                                setperiod(ctlend_tab[slice],&seqcore ,0);


                            /*  first slice in RR */
                            if (rsptrigger[slice] != TRIG_INTERN) {	
                                if ((rspent == L_SCAN)||(rspent == L_MPS2)||(rspent == L_APS2)||
                                    (rspent == L_REF)) {
                                    /* Use cardiac trigger delay */
                                    setperiod(td0, &x_td0, 0);
                                    setperiod(td0, &y_td0, 0);
                                    setperiod(td0, &z_td0, 0);
                                    setperiod(td0, &rho_td0, 0);
                                    setperiod(td0, &theta_td0, 0);
                                    setperiod(td0, &omega_td0, 0);
                                    setperiod(td0, &ssp_td0, 0);
                                }
                            } else {
                                /* Bypass cardiac trigger delay */
                                setperiod((int)GRAD_UPDATE_TIME, &x_td0, 0);
                                setperiod((int)GRAD_UPDATE_TIME, &y_td0, 0);
                                setperiod((int)GRAD_UPDATE_TIME, &z_td0, 0);
                                setperiod((int)GRAD_UPDATE_TIME, &rho_td0, 0);
                                setperiod((int)GRAD_UPDATE_TIME, &theta_td0, 0);
                                setperiod((int)GRAD_UPDATE_TIME, &omega_td0, 0);
                                setperiod((int)GRAD_UPDATE_TIME, &ssp_td0, 0);

                            }

                        } 
                        else
                        {
                            setperiod(scan_deadtime_correct[slice], &seqcore, 0);
                        }

                        /* Set rho, data acquisition flags */
                        if (slice >= slc_in_acq[pass_index]) {
                            /* Dummy slice */
                            acq_data = (int)DABOFF;
                            /* turn off RHO BOARD */
                            setieos((SHORT)EOS_DEAD, &rho_td0,0);

                            if (rspesl == -1)
                                sliceindex = (acq_ptr[0] + slice)%opslquant;

                        } else {  /* live slice */

                            /* turn on RHO BOARD */
                            setieos((SHORT)EOS_PLAY, &rho_td0, 0);

                            if ((acq_sl == PSD_ON)&&(excitation > 0))
                                acq_data = (int)DABON;
                            else
                                acq_data = (int)DABOFF;
                        }

                        /* SPSP fat sat pulse */
                        if (SpSpFatSatRsp() == FAILURE) return FAILURE;

                        /* update Sat Move CATSAT Pulse */
                        SpSatUpdateRsp(1, pass_index, opccsat);

    { /* Start of code inlined from Inversion.e InversionRSPcore */
        if (ir_on == PSD_ON)
        {
            /* Load Transmit Frequency */
            setfrequency(rf0_freq[sliceindex], &rf0, 0);
            setiphase(rf0_pha[sliceindex], &rf0, 0);
        }
    } /* End of code inlined from Inversion.e InversionRSPcore */


                        /* Set the rf pulse transmit frequencies */
                        if (ssRsp() == FAILURE) return FAILURE;

                        if(rspent == L_SCAN && rtb0_flag && rtb0_comp_flag)
                        {
                            setfrequency(rf1_freq[sliceindex]+rtb0_comp_cfoffset_TARDIS, &rf1, 0);
                            if (oppseq == PSD_SE)
                            {
                                setfrequency(rf2_freq[sliceindex]+rtb0_comp_cfoffset_TARDIS, &rf2, 0);
                            }
                        }
                        else
                        {   
			    /*jwg bb this is where we will change the tx frq for spsp excitation*/
			    /*is it pretty? Nope. But it works. */
			    if (num_freqs == 1)
			    {
			    	met_freq = df1/ TARDIS_FREQ_RES;
			    }
			    else if (num_freqs == 2)
			    {
				    if((freq_ctr % num_freqs) == 1) /*df1*/
				    {
				    	met_freq = df1/ TARDIS_FREQ_RES;
				    } 
				    else /*df2*/
				    { 
				    	met_freq = df2/ TARDIS_FREQ_RES;			    
				    }
		 	    }
			    else if (num_freqs == 3)			    
			    {
			    	if((freq_ctr % num_freqs) == 1) /*df1*/
			    	{
			    		met_freq = df1/ TARDIS_FREQ_RES;
			    	} 
			    	else if((freq_ctr % num_freqs) == 2) /*df2*/
			    	{ 
			    		met_freq = df2/ TARDIS_FREQ_RES;			    
			    	}	 
			    	else /*df3*/
			    	{ 
			    		met_freq = df3/ TARDIS_FREQ_RES;			    
			    	}
			    }			    
			    else if (num_freqs == 4)			    
			    {
			    	if((freq_ctr % num_freqs) == 1) /*df1*/
			    	{
			    		met_freq = df1/ TARDIS_FREQ_RES;
			    	} 
			    	else if((freq_ctr % num_freqs) == 2) /*df2*/
			    	{ 
			    		met_freq = df2/ TARDIS_FREQ_RES;			    
			    	}	 
			    	else if((freq_ctr % num_freqs) == 3) /*df3*/
			    	{ 
			    		met_freq = df3/ TARDIS_FREQ_RES;			    
			    	}	 				
			    	else /*df4*/
			    	{ 
			    		met_freq = df4/ TARDIS_FREQ_RES;			    
			    	}
			    }			    
			    else if (num_freqs == 5)			    
			    {
			    	if((freq_ctr % num_freqs) == 1) /*df1*/
			    	{
			    		met_freq = df1/ TARDIS_FREQ_RES;
			    	} 
			    	else if((freq_ctr % num_freqs) == 2) /*df2*/
			    	{ 
			    		met_freq = df2/ TARDIS_FREQ_RES;			    
			    	}	 
			    	else if((freq_ctr % num_freqs) == 3) /*df3*/
			    	{ 
			    		met_freq = df3/ TARDIS_FREQ_RES;			    
			    	}	 				
			    	else if((freq_ctr % num_freqs) == 4) /*df4*/
			    	{ 
			    		met_freq = df4/ TARDIS_FREQ_RES;			    
			    	}	 						
			    	else /*df5*/
			    	{ 
			    		met_freq = df5/ TARDIS_FREQ_RES;			    
			    	}
			    }			    
			    
			   /* fprintf(stderr,"RF Tx freq is %f \n",(rf1_freq[sliceindex] + met_freq)); */
			   /*jwg bb testing passband shifting for true null design*/
			   /*we shouldn't have to make any changes for rcv...*/
			   if (sw != 0  && (rspent == L_SCAN))
			   {
				   if(met_freq < (sw/2) )
				   {
                	           	setfrequency((rf1_freq[sliceindex] + met_freq), &rf1, 0);
				   } else {
			   		setfrequency((rf1_freq[sliceindex] - (sw - met_freq)), &rf1, 0);
				   }
			   } else {
                           	setfrequency((rf1_freq[sliceindex] + met_freq), &rf1, 0);
				fprintf(stderr,"RF Tx freq is %f \n",(rf1_freq[sliceindex] + met_freq));
			   }
			    
			    /*jwg bb update flip angle depending on RF table, but only for actual scan entry point*/
			    if((vfa_flag != 0) && (rspent == L_SCAN))
			    {
			    	/*freq_ctr starts at 1, so account for this!*/
				vfa_flip_angle = vfa_flips[(freq_ctr-1)];
				vfa_flip_ia =  (int)(vfa_flip_angle/ 90 * ia_rf1); /*Not always 32767 with long, low power SPSP*/
				fprintf(stderr,"VFA flip is %f, ia is %f\n",vfa_flip_angle, vfa_flip_ia);
			    	setiamp(vfa_flip_ia, &rf1, 0);
			    }
			    
                            if (oppseq == PSD_SE)
                            {
                                setfrequency(rf2_freq[sliceindex], &rf2, 0);
                            }
                        }

                        if (excitation == 1)
                        {
                            dabop = 0;
                        }
                        else if (rf_chop == PSD_OFF)
                        {
                            dabop = 1;
                        }
                        else
                        {
                            dabop = 3 - 2*(excitation % 2);
                        }

                        slicerep = slice + core_rep*rspslq;

                        if(setDataAcqDelays == PSD_ON) {
                            /* Update the delay on the SSP and Omega boards */
                            setperiod((int)((float)gldelaycval[sliceindex] + pw_sspdelay),
                                      &sspdelay, 0);

                            setperiod(RUP_RF((int)((float)gldelaycval[sliceindex] +
                                                   pw_omegadelay + deltaomega)), &omegadelay, 0);

                            setperiod((int)((float)(pw_sspshift - gldelaycval[sliceindex])),
                                      &sspshift, 0);
                        }

                        if(rtb0_flag)
                        {
                            if(rspent == L_SCAN && rtb0_comp_flag)
                            {
                                setfreqphase((int)sl_rcvcf+rtb0_comp_cfoffset_TARDIS, 0, rtb0echoxtr);
                            }
                            if(rspent == L_SCAN && (rtb0_midsliceindex == sliceindex || rtb0_midsliceindex < 0) )
                            {
                                /* need to turn DAB off but RBA on for routing the frame to RTP */
                                loaddab(&(rtb0echo), 0, 0, DABSTORE, 1, DABOFF, PSD_LOAD_DAB_ACQON);
                                loaddab(&(rtb0echo), 0, 0, DABSTORE, 1, DABON, PSD_LOAD_DAB_ACQON_RBA);
                            }
                            else
                            {
                                loaddab(&(rtb0echo), 0, 0, DABSTORE, 1, DABOFF, PSD_LOAD_DAB_ALL);
                            }
                        }

                        /* mod_rba = FALSE; */
			
			/*fprintf(stderr,"temporal phase is %d\n",pass_rep);
			fprintf(stderr,"slice index is %d\n",sliceindex);
			fprintf(stderr,"freq ctr is %d\n",freq_ctr);			*/
                        dabrbaload();

                        /* Play out pass delay and send proper pass packet within seqcore.  We do
                           this to avoid having to play out a seperate pass sequence as is usually
                           done */

                        if ( (BoreOverTempFlag == PSD_ON) || ( (pass == (rspacq - 1)) && 
                                                               (pass_rep == (rspprp - 1) ) &&
                                                               (cmdir_rep == rsp_cmndir-1) &&
                                                               (slice == rspslq-1) && 
                                                               (excitation == rspnex) &&
                                                               (ileave == rspilv-1) &&
                                                               (core_rep == rsprep-1) ) )
                        { 
                            /* Set DAB pass packet to end of scan */
                            setwamp(SSPDS + DABDC, &pass_pulse, 0);
                            setwamp(SSPD + DABPASS + DABSCAN, &pass_pulse, 2);
                            setwamp(SSPDS + DABDC, &pass_pulse, 4);
                            /*MRIhc08588 at end of scan, no need to send the
                             * delay pass to pass_delay*/
                            for (i=0; i<num_passdelay; i++) {
                                setperiod(100, &ssp_pass_delay, i);
                            }
                            pause = MAY_PAUSE;
                            printdbg("End of Scan and Pass", debugstate);

                            passDoneFlag = 1;
                            InterPassDoneFlag = 0;

                        }
                        else if ( (cmdir_rep == rsp_cmndir-1) && 
                                  (slice == rspslq-1) &&
                                  (excitation == rspnex) &&
                                  (ileave == rspilv-1) &&
                                  (core_rep == rsprep-1) )
                        {
                            /* Set DAB pass packet to end of pass */
                            setwamp(SSPDS + DABDC, &pass_pulse, 0);
                            setwamp(SSPD + DABPASS, &pass_pulse, 2);
                            setwamp(SSPDS + DABDC, &pass_pulse, 4);
			    
			    /*jwg this is where the opsldelay for delay between temporal phases is used!*/
			    /*will use freq_ctr to tell when to pause things*/
                            for (i=0; i<num_passdelay; i++) { 
			        /*jwg this changed from just rspent to all this crap*/
                                if (rspent == L_REF &&
                                     !((mph_flag == PSD_ON) && (touch_flag == PSD_OFF) && (avminsldelay > 0))) 
				{
                                    setperiod(100, &ssp_pass_delay, i);
                                } else {
				    /*jwg bb only want the delay on the LAST slice of this frequency!!!*/
				    if( (freq_ctr % num_freqs) == 0)
				    {
                                       setperiod(100, &ssp_pass_delay, i);
				       setperiod(pass_delay, &jwg_delay, 0);				       
				       fprintf(stderr,"delaying now!\n");
				    } else {
                                       setperiod(100, &ssp_pass_delay, i);
				       setperiod(1, &jwg_delay, 0);
				      /* fprintf(stderr,"going through frequencies, no delay!\n");*/
				    }
                                }
                            }
			    

                            if (touch_flag)
                            {
                                /* Adjust how pausing is done for MRE */
                                pass_cnt++;

                                if( (opslicecnt != 0) && ( (pass_cnt % opslicecnt) == 0 ) )
                                {
                                    pause = MUST_PAUSE;
                                }
                                else
                                {
                                    pause = AUTO_PAUSE;
                                }
                            }
                            else
                            {
                                pause = AUTO_PAUSE;
                            }

                            printdbg("End of Pass", debugstate);

                            passDoneFlag = 1;
                            if (PSD_OFF == touch_flag){
                                InterPassDoneFlag = 1;
                            }
                        } else {
                            /* send null pass packet and use the minimum delay for pass_delay */
                            setwamp(SSPDS, &pass_pulse, 0);
                            setwamp(SSPD, &pass_pulse, 2);
                            setwamp(SSPDS, &pass_pulse, 4);
                            for (i=0; i<num_passdelay; i++) 
                                setperiod(100, &ssp_pass_delay, i);
                            pause = MAY_PAUSE;
                            printdbg("Null ssp pass packet", debugstate);
                            passDoneFlag = 0;
                            InterPassDoneFlag = 0;
			    /*jwg bb add this so that the interframe delay isn't present for all slices*/
     			    setperiod(1, &jwg_delay, 0);			    
                        }

                        printdbg("S", debugstate);
                        sp_sat_index = sliceindex;


                        startseq((short)sliceindex, (SHORT)pause);


#ifdef PSD_HW       /* Auto Voice  04/19/2005 YI */
                        if (mph_flag && InterPassDoneFlag) { 
                            broadcast_autovoice_timing((int)(act_tr/slquant1)/1000, pass_delay*num_passdelay/1000, TRUE, TRUE);
                        }
#endif		  

                        syncoff(&seqcore); 

                        /* ++++++++++++++++  In case scan starts with external trigger, set internal trigger for the rest of the scan. ++++++++++++++++ */
                        if ((pass == rspacqb) && (pass_rep == 0) && (slice == rspslqb) &&
                            (excitation == 1 - rspdex) && (ileave == rspilvb) && (core_rep == 0)) {

                            if((ext_trig == PSD_ON) && (rspent == L_SCAN))
                                settrigger((short)TRIG_INTERN,0);
                        }
                        /* ++++++++++++++++  In case scan starts with external trigger, set internal trigger for the rest of the scan. ++++++++++++++++ */


                    }  /* slice */

                    if(rtb0_flag && rspent == L_SCAN)
                    {
                        if(rtb0_comp_flag)
                        {
                            if(excitation == rspnex && ileave == rspilv-1)
                            {
                                if ( 1 == getRTB0Feedback(&rtb0_processed_index, &rtb0_cfoffset) )
                                { 
                                    if (rtb0DebugFlag == PSD_ON)
                                    {
                                        printf("Processed Index = %d\t CF offset = %f\n", rtb0_processed_index,rtb0_cfoffset);
                                    }
                                    if(rtb0_rtp_1streturn == PSD_OFF)
                                    {
                                        /* set base CF offset for the first return from RTP */
                                        rtb0_base_cfoffset = rtb0_cfoffset;
                                        rtb0_comp_cfoffset = 0.0;
                                        rtb0_outlier_count = 0;
                                        rtb0_rtp_1streturn = PSD_ON;
                                    }
                                    else 
                                    {
                                        float rtb0_temp;
                                        /* If CF change is bigger than rtb0_outlier_threshold  and lasts shorter than   */
                                        /* rtb0_outlier_duration, it is a outlier and will be ignored for compensation. */

                                        rtb0_temp = rtb0_cfoffset-rtb0_base_cfoffset;
                                        if(fabs(rtb0_temp) > rtb0_outlier_threshold)
                                        {
                                            rtb0_outlier_count++;
                                            if(rtb0_outlier_count > rtb0_outlier_nTRs)
                                            {
                                                rtb0_outlier_count = 0;
                                                rtb0_comp_cfoffset += rtb0_temp;
                                            }
                                        }
                                        else
                                        {
                                            rtb0_outlier_count = 0;
                                            rtb0_comp_cfoffset += rtb0_temp;
                                        }
                                    }
                                    rtb0_comp_cfoffset_TARDIS = (int)(rtb0_comp_cfoffset/TARDIS_FREQ_RES);
                                    if(rtb0DebugFlag == PSD_ON) 
                                    {
                                        printf("CF compensation = %.2f\n", rtb0_comp_cfoffset);
                                    }
                                }
                            }
                        }
                    }

                    if (rspchp == CHOP_NONE) 
                        SpSatChop();

                } /* excitation */

            } /* ileave */

        } /* core_rep */	
    } /* cmdir_rep */

    fflush(stdout);

    return SUCCESS;
  

} /* End Core */

/***************************** blineacq  *************************/
STATUS blineacq( void )
{
    int bcnt;
    int nslice;
    int rcnt;
    int rcnt_end;
    int slindex;
    int bl_slice_end;

    /* For ref entry point, play baselines for all slices */
    if (rspent == L_REF) {

        bl_slice_end = rspslq;

    } else {

        /* Otherwise, play baselines for first slice only */
        bl_slice_end = rspslqb + 1;
    }

    /* BJM: MRIge51381 - fix for redundant baseline with seq. scans */
    if(rspent == L_SCAN && acqmode == 1) {
        rcnt_end = 1;
    } else {
        rcnt_end = rsprep;
    }

    /* Offset to baseline sequence in memory */
    boffset(off_seqblineacq);

    /* Set filter slot for XTR packet for baseline */  
    setrfltrs((int)scanslot, &blineacq1);

    settriggerarray((SHORT)1, rsptrigger_temp);

    if (baseline > 0 && rawdata == PSD_ON) {    /* collect single frame */

        sp_sat_index = 0;
        startseq((short)0, (SHORT)MAY_PAUSE);

    } else {

        dabop = 0; /* Store data */

        for (bcnt = rspbasb;bcnt <= rspbas; bcnt++) {
            for (rcnt = 0;rcnt < rcnt_end; rcnt++) {
                for (nslice = rspslqb;nslice < bl_slice_end; nslice++) {

                    /* play last baseline at longer TR */
                    if ( (rspbas > 1) && (bcnt == rspbas) && 
                         (nslice == bl_slice_end - 1) && (rcnt == rsprep - 1)  )

                        setperiod(bl_acq_tr2, &seqblineacq, 0);

                    if (nslice < slc_in_acq[pass_index]) {
                        slindex = nslice + rcnt*rspslq;

                        loadhsdab(&hyperdabbl,		/* load hyperdab */
                                  (LONG)slindex,
                                  (LONG)0,
                                  (LONG)dabop,
                                  (LONG)0,
                                  (LONG)1,
                                  (LONG)1,
                                  (LONG)1,
                                  (LONG)1,
                                  (TYPDAB_PACKETS)DABON,
                                  (LONG)hsdabmask);

                        sp_sat_index = 0;
                        startseq((short)0, (SHORT)MAY_PAUSE);

   /* +++++++  In case scan starts with external trigger, set internal trigger for baseline and the rest of the scan. ++++++++++++++++ */
                   if ((pass == rspacqb) && (pass_rep == 0) && (nslice == rspslqb) && (rcnt == 0) && (bcnt == rspbasb)) {
                  
                       if((ext_trig == PSD_ON) && (rspent == L_SCAN))
                                   settrigger((short)TRIG_INTERN,0);
                   }
   /* +++++++  In case scan starts with external trigger, set internal trigger for baseline and the rest of the scan. ++++++++++++++++ */
 

                    }		  
		
                } /* for (nslice = rspslqb;nslice <= rspslq; nslice++) */
            } /* reps loop */
            dabop = 1;       /* add baseviews */
        } /* for (bcnt = 1;bcnt <= rspbas; bcnt++)  */
    } /* if (baseline > 0 && rawdata == PSD_ON) */
  
    /* Return to standard trigger array and core offset */
    settriggerarray((SHORT)(opslquant*opphases), rsptrigger);

    return SUCCESS;
  
} /* end blineacq */


/***************************** dabrbaload *************************/
STATUS dabrbaload(void)
{
    TYPDAB_PACKETS dabacqctrl;
    int echo;  /* loop counter */
    int ii; /*jwg bb phase mod counter, need this to debug shift in PE direction*/
    int freq_ctrl = 0;
    int phase_ctrl = 0;

    dabacqctrl = (TYPDAB_PACKETS)acq_data;
    loadhsdab(&hyperdab,		/* load hyperdab */
              (LONG)slicerep,
              (LONG)cmdir_rep,  /* Changed from 0 to account for MEG directions */
              (LONG)dabop,
              (LONG)view1st[ileave],
              (LONG)viewskip[ileave],
              (LONG)tot_etl,
              (LONG)1,
              (LONG)1,
              dabacqctrl,
              (LONG)hsdabmask);

    ii = 0; /*jwg bb*/
    /*jwg bb need phase increment to fix unaccounted phase in PE direction*/
    phase_incr = (eesp * met_freq * TARDIS_FREQ_RES * 2 * 3.1415/ 1000);    

    /* Load the receive frequency/phase and dab packets */
    for (echo=0; echo<tot_etl; echo++) {
      
        /* MRIge56894 - only set this stuff during real data acq */
        if(acq_data != DABOFF) { 
            /* BJM: we set the demod freq (sl_rcvcf) in the freq offset */
            /* register and then use omega to offset the slice along */
            /* the read axis.  For non-ramp sampled cases, the offset */
            /* waveform is a constant pulse.  For ramp sampled waveforms */
            /* the offset freq wavefrom is a trapezoid (freq mod on ramps */
            /* This simplifies the phase accumulation across the echo since */
            /* we no longer have to worry about the time it takes to latch */
            /* a freq. offset which leads to an uncertainty in how long we */
            /* accumulate phase across each echo in the train */
            if(rspent == L_SCAN && rtb0_flag && rtb0_comp_flag)
                freq_ctrl = sl_rcvcf + rtb0_comp_cfoffset_TARDIS;
            else 
            
	    /*jwg bb account for metabolite frequency shifting*/	
            freq_ctrl = sl_rcvcf + met_freq;
            phase_ctrl = recv_phase[sliceindex][ileave][echo];
          
            /* load demod. frequnecy in packet xtr packet */
	    /*jwg bb put linear phase ramp to try and fix PE shift*/
            setfreqphase((long)freq_ctrl,
                         (long)(phase_ctrl + phase_mod*phase_incr*ii),
                         echotrainxtr[echo]);

            /* frequency offset */ 
	    /*jwg bb this is just for off isocenter, no need to change for each metabolite!*/
            tempamp=(short)((recv_freq[sliceindex][ileave][echo]-sl_rcvcf)/omega_scale);
        
            if(vrgfsamp){

                /* Attack Ramp Offset */
                *(echotrainrampamp1[echo]) = tempamp;
                setamprsp((short)rs_omega_attack.wavegen_type,
                          tempamp,
                          (short)TYPINSTRMEM,
                          (int)echotrainramp1[echo]);
              
                /* Freq Offset on Flattop */
                *(echotrainrampamp[echo]) = tempamp;
                setamprsp((short)omega_flat.wavegen_type,
                          tempamp,
                          (short)TYPINSTRMEM,
                          (int)echotrainramp[echo]);

                /* Decay Ramp Offset */
                *(echotrainrampamp2[echo]) = tempamp;
                setamprsp((short)rs_omega_decay.wavegen_type,
                          tempamp,
                          (short)TYPINSTRMEM,
                          (int)echotrainramp2[echo]);          

            } else {
                            
               
                /* Freq Offset on Flattop */
                *(echotrainrampamp[echo]) = tempamp;
                setamprsp((short)omega_flat.wavegen_type,
                          tempamp,
                          (short)TYPINSTRMEM,
                          (int)echotrainramp[echo]);

            }
	    
	/*jwg bb increment counter*/
	ii = ii + 1;        

        } /* end acq_data condition */
      
        /* determine which echos will be collected */
        if ((echo >= rspe1st) && (echo < rspe1st + rspetot))
            dabacqctrl = (TYPDAB_PACKETS)acq_data;
        else
            dabacqctrl = DABOFF;
      
        /* set RBA bit for echos to acquire */
        acqctrl(dabacqctrl, fast_rec, echotrainrba[echo]);
      
    } /* end echo loop for setting up xtr & rba packets */  
  
    return SUCCESS;

} /* End dabrbaload */


/***************************** msmpTrig *************************/
/* Build the trigger for multi-slice, multi-phase cardiac */
STATUS msmpTrig(void )
{
    if ((opcgate == PSD_ON) && (opphases > 1) &&
        ((rspent == L_MPS2)||(rspent == L_APS2)||
         (rspent == L_SCAN)||(rspent == L_REF))) 
    {
        if (slice == 0) {
            switch(rspent) {
            case L_MPS2:
                settrigger((short)trig_mps2, (short)sliceindex);
                break;
            case L_APS2:
                settrigger((short)trig_aps2, (short)sliceindex);
                break;
            case L_SCAN:
            case L_REF:
                settrigger((short)trig_scan, (short)sliceindex);
                break;
            default:
                break;
            }
        }
        else
            settrigger((short)TRIG_INTERN, (short)sliceindex);
    }
    return SUCCESS;
}

/***************************** ygradctrl  *************************/
STATUS ygradctrl( INT blipsw,
                  INT blipwamp,
                  INT numblips )
{
    int bcnt;
    int dephaser_amp;
    int gmn_amp;
    int parity;
    int deltaAmp = 0;

    parity = gradpol[ileave];
    deltaAmp = blipwamp*percentBlipMod;  

    if (blipsw == 0) {
        dephaser_amp = 0;
        gmn_amp = 0;
        for (bcnt=0;bcnt<numblips-1;bcnt++) {
            if(bcnt%2 == 0) {
                setiampt((short)(-deltaAmp/2.0), &gyb, bcnt);
            } else {
                setiampt((short)(deltaAmp/2.0), &gyb, bcnt);
            }
        }

    } else {
        gmn_amp = ia_gymn2;
        if (pepolar == PSD_OFF) {
            dephaser_amp = -gy1f[0];
            for (bcnt=0;bcnt<numblips-1;bcnt++) {
                if (oblcorr_perslice == 1) {
		
		if(opuser26 ==0)
		{
                    if(bcnt%2 == 0)
                        setiampt((short)(-blipwamp - (deltaAmp/2.0) + parity*rspia_gyboc[slice]), &gyb, bcnt);
                    else
                        setiampt((short)(-blipwamp + (deltaAmp/2.0) + parity*rspia_gyboc[slice]), &gyb, bcnt);
		} else {
			/*setiampt((short)(-blipwamp - (deltaAmp/2.0*(int)opuser26) + parity*rspia_gyboc[slice]), &gyb, bcnt);*/
			setiampt((short)(-blipwamp * (int)sake_blips[bcnt] + parity*rspia_gyboc[slice]), &gyb, bcnt);			
		}
			
                }
                else {
                    setiampt((short)(-blipwamp + parity*rspia_gyboc[slice]), &gyb, bcnt);
                }
                parity *= -1;
            }

        } else {
            dephaser_amp = gy1f[0];
            for (bcnt=0;bcnt<numblips-1;bcnt++) {
                if (oblcorr_perslice == 1) {
                    if(bcnt%2 == 0) 
                        setiampt((short)(blipwamp + (deltaAmp/2.0) + parity*rspia_gyboc[slice]), &gyb, bcnt);
                    else
                        setiampt((short)(blipwamp - (deltaAmp/2.0) + parity*rspia_gyboc[slice]), &gyb, bcnt);
                    
                }
                else {
                    setiampt((short)(blipwamp + parity*rspia_gyboc[slice]), &gyb, bcnt);
                }
                parity *= -1;
            }
	}
    }	 

    setiampt((short)dephaser_amp, &gy1, 0);
    if (ygmn_type == CALC_GMN1) {
	setiampt((short)-gmn_amp, &gymn1, 0);
	setiampt((short)gmn_amp, &gymn2, 0);
    }


    return SUCCESS;

} /* End ygradctrl */

STATUS
SpSatChop( void )
{
    extern short rspchp;
    INT skip_next_sat;
    SHORT satamp;
  
    /* If SAT is on in the slice direction, we need to chop if the scan
       does not. The slice gradient always comes from the Z 
       generator; any rotation gets handled by WARP afterwards.*/    
  
    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return SUCCESS;
  
    if (rspchp == CHOP_NONE) 
    {
        if (opsatz !=  PSD_OFF) 
        {
            if ((opplane == PSD_AXIAL) || 
                ((opplane == PSD_OBL) && (opobplane == PSD_AXIAL )) ) 
            {
                getiamp(&satamp, &rfsz1, 0);
                setiamp(-satamp, &rfsz1, 0);
	      
                if (opsatz == PSD_SATPARA)
                {
                    getiamp(&satamp, &rfsz2, 0);
                    setiamp(-satamp, &rfsz2, 0);
                }
            }
	}
      
        /* Chop all the explicit sat pulses. The psd does not know which
           explicit sat bands are in the select direction unless you 
           perform some matrix magic on the rotation matrix. So, we
           are chopping all explicit sat pulses. It should not hurt. */
      
        skip_next_sat = 0;
        if ((opexsatmask & PSD_EXPLICIT_1) != 0)
        {
            getiamp(&satamp, &rfse1, 0);
            setiamp(-satamp, &rfse1, 0);
	  
            if ((opexsatparal & PSD_1_PARALLEL) != 0)
                skip_next_sat = 1;
        }
      
        if (((opexsatmask & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0))
        {
            getiamp(&satamp, &rfse2, 0);
            setiamp(-satamp, &rfse2, 0);
        }
      
        skip_next_sat = 0;
        if ((opexsatmask & PSD_EXPLICIT_3) != 0)
        {
            getiamp(&satamp, &rfse3, 0);
            setiamp(-satamp, &rfse3, 0);
	  
            if ((opexsatparal & PSD_2_PARALLEL) != 0)
                skip_next_sat = 1;
        }
        if (((opexsatmask & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0))
        {
            getiamp(&satamp, &rfse4, 0);
            setiamp(-satamp, &rfse4, 0);
        }
        skip_next_sat = 0;
        if ((opexsatmask & PSD_EXPLICIT_5) != 0)
        {
            getiamp(&satamp, &rfse5, 0);
            setiamp(-satamp, &rfse5, 0);
	  
            if ((opexsatparal & PSD_3_PARALLEL) != 0)
                skip_next_sat = 1;
        }
        if (((opexsatmask & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0))
        {
            getiamp(&satamp, &rfse6, 0);
            setiamp(-satamp, &rfse6, 0);
        }
    }
    return SUCCESS;
}

STATUS
SpSatChopKiller( void )
{
    INT skip_next_sat;
  
    if (opsat == PSD_OFF) 
        return SUCCESS;
  
    if (opsatx !=  PSD_OFF) 
    {
        setiampt(-amp_gyksx1, &gyksx1, 0);
      
        if (opsatx == PSD_SATPARA)
        {
            setiampt(-amp_gyksx2, &gyksx2, 0);
        }
    }
  
    if (opsaty !=  PSD_OFF) 
    {
        setiampt(-amp_gyksy1, &gyksy1, 0);
      
        if (opsaty == PSD_SATPARA)
	{
            setiampt(-amp_gyksy2, &gyksy2, 0);
	}
    }
  
    if (opsatz !=  PSD_OFF) 
    {
        setiampt(-amp_gyksz1, &gyksz1, 0);
      
        if (opsatz == PSD_SATPARA)
	{
            setiampt(-amp_gyksz2, &gyksz2, 0);
	}
    }
  
    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_1) != 0)
    {
        setiampt(-amp_gykse1, &gykse1, 0);
      
        if ((opexsatparal & PSD_1_PARALLEL) != 0)
            skip_next_sat = 1;
    }
  
    if (((opexsatmask & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0))
    {
        setiampt(-amp_gykse2, &gykse2, 0);
    }
  
    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_3) != 0)
    {
        setiampt(-amp_gykse3, &gykse3, 0);
      
        if ((opexsatparal & PSD_2_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0))
    {
        setiampt(-amp_gykse4, &gykse4, 0);
    }
    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_5) != 0)
    {
        setiampt(-amp_gykse5, &gykse5, 0);
      
        if ((opexsatparal & PSD_3_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0))
    {
        setiampt(-amp_gykse6, &gykse6, 0);
    }
  
    return SUCCESS;
}

STATUS
CsSatMod( INT num_chemsats )
{
    SHORT ampcssat;
    INT i; /* counter */
  
    /* MRIge51368 */
    if ( csa > max_csa ) 
        csa = max_csa;

    csflip = flip_rfcssat * (csa/1000.0)/a_rfcssat;
    if (cs_sat == 1) {
        /* ensure that inferior slabs have a positive offset frequency
         * */ 
        if (selectiveChemsat == PSD_ON)
        {
             ia_gzrfcs =  -1 * abs(ia_gzrfcs); /* Superior SAT */
        }
    
        if (cstun == 1) {
            /* Activate ChemSat and update parameters to current rspvars */
            for (i=0; i<num_chemsats; i++) {
                setfrequency((int)(csf/TARDIS_FREQ_RES), &rfcssat, i);
                ampcssat = csa/1000*max_pg_iamp;
                if (rspent == L_CFH)
                    ampcssat *= a_rfcssatcfh/a_rfcssat;
                rfon(&rfcssat,i);
                setiamp(ampcssat, &rfcssat, i);
                /* adjust bandwidth to minimize IQ issue with
                 * off-resonant excitation */ 
                if ( PSD_ON  == selectiveChemsat)  
                  setiampt(((int)selectiveChemsatBWscaler*ia_gzrfcs), &gzrfcs, i);
                setiampt(amp_gykcs, &gykcs, i);
#ifdef CSXKILLER
                setiampt(amp_gxkcs, &gxkcs, i);
#endif
#ifdef CSZKILLER
                setiampt(amp_gzkcs, &gzkcs, i);
#endif
            }
	} else {
            for (i=0; i<num_chemsats; i++) {
                rfoff(&rfcssat,i);
                setiampt(0, &gykcs, i);
#ifdef CSXKILLER
                setiampt(0, &gxkcs, i);
#endif
#ifdef CSZKILLER
                setiampt(0, &gzkcs, i);
#endif
	    }
	}
    }
   
    
    return SUCCESS;
}




STATUS SpSpFatSatRsp(void)
{
    if (PSD_ON == use_spsp_fatsat)
    {
        rfcssat_freq[sliceindex] = fat_offset;
        setiampall((int)(theta_cssat_freq[sliceindex]), &thetarfcssat, 0);
        setfrequency(rfcssat_freq[sliceindex], &rfcssat, 0);   /* fat offset if necessary */        
    }
    return(SUCCESS);
}


int rspsatx1, 
    rspsatx2,
    rspsaty1, 
    rspsaty2,
    rspsatz1, 
    rspsatz2,
    rspsate1, 
    rspsate2,
    rspsate3,
    rspsate4,
    rspsate5,
    rspsate6;

int rsp_sat_rindex;
int rsp_max_rindex;


void
sp_dump_rsp_rot( INT ir_mode )
{
    INT  i ;
    printf("\nPSD-> Dump of RSP \t\t\tRotation Matrix\n");

    for (i=0;i<opslquant*opphases; ++i) 
    {
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsprot[i][0], rsprot[i][1], rsprot[i][2]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsprot[i][3], rsprot[i][4], rsprot[i][5]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsprot[i][6], rsprot[i][7], rsprot[i][8]);
    }

    if (ir_mode == 1)
    {
        for (i=opslquant*opphases; i <(opslquant*opphases *2); i++) 
        {
            printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
                   i, rsprot[i][0], rsprot[i][1], rsprot[i][2]);
            printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
                   i, rsprot[i][3], rsprot[i][4], rsprot[i][5]);
            printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
                   i, rsprot[i][6], rsprot[i][7], rsprot[i][8]);
        }
    }
   
    for (i=0; i< opslquant*opphases; ++i)
    {
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsprot_orig[i][0], rsprot_orig[i][1], rsprot_orig[i][2]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsprot_orig[i][3], rsprot_orig[i][4], rsprot_orig[i][5]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsprot_orig[i][6], rsprot_orig[i][7], rsprot_orig[i][8]);
    }
    return;
}


void
sp_dump_sat_rot( void )
{
    INT i ;
    printf("\nPSD-> Dump of Explicit Sat rotation info\t\t\tRotation Matrix\n");

    for (i=0;i<sat_rot_ex_num*2; i=i+2) 
    {
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, sat_rot_matrices[i][0], sat_rot_matrices[i][1], 
               sat_rot_matrices[i][2]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, sat_rot_matrices[i][3], sat_rot_matrices[i][4], 
               sat_rot_matrices[i][5]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, sat_rot_matrices[i][6], sat_rot_matrices[i][7], 
               sat_rot_matrices[i][8]);

        printf("\n Slice rotation matrix\n");
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i+1, sat_rot_matrices[i+1][0], sat_rot_matrices[i+1][1], 
               sat_rot_matrices[i+1][2]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i+1, sat_rot_matrices[i+1][3], sat_rot_matrices[i+1][4], 
               sat_rot_matrices[i+1][5]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i+1, sat_rot_matrices[i+1][6], sat_rot_matrices[i+1][7], 
               sat_rot_matrices[i+1][8]);
    }

    printf("\nPSD-> Dump of Default Sat rotation info\t\t\tRotation Matrix\n");
    for (i=sat_rot_ex_num*2;i<(sat_rot_df_num +sat_rot_ex_num)*2; i= i+2) 
    {
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, sat_rot_matrices[i][0], sat_rot_matrices[i][1], 
               sat_rot_matrices[i][2]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, sat_rot_matrices[i][3], sat_rot_matrices[i][4], 
               sat_rot_matrices[i][5]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, sat_rot_matrices[i][6], sat_rot_matrices[i][7], 
               sat_rot_matrices[i][8]);

        printf("\n Slice rotation matrix\n");
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i+1, sat_rot_matrices[i+1][0], sat_rot_matrices[i+1][1], 
               sat_rot_matrices[i+1][2]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i+1, sat_rot_matrices[i+1][3], sat_rot_matrices[i+1][4], 
               sat_rot_matrices[i+1][5]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i+1, sat_rot_matrices[i+1][6], sat_rot_matrices[i+1][7], 
               sat_rot_matrices[i+1][8]);
    }
   
    printf("\nPSD-> Dump of Slice Sat rotation info\t\t\tRotation Matrix\n");
    i = (sat_rot_ex_num + sat_rot_df_num)*2;
    printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
           i, sat_rot_matrices[i][0], sat_rot_matrices[i][1], 
           sat_rot_matrices[i][2]);
    printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
           i, sat_rot_matrices[i][3], sat_rot_matrices[i][4], 
           sat_rot_matrices[i][5]);
    printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
           i, sat_rot_matrices[i][6], sat_rot_matrices[i][7], 
           sat_rot_matrices[i][8]);
    return;
}


/* THIS IS USED AS AN ISI SUBROUTINE VECTOR */

/* This assumes that the first SAT rotation matrix has
   been loaded by the psd; so the index is incremented first to
   bypass the first matrix.  */
void
sp_set_rot_matrix( void )
{
    sp_array_index = sp_array_index + 1;

    ++isi_vector_count;
    setrotateimm(sat_rot_matrices[sp_array_index],WARP_UPDATE_ON_SSP_INT);

    if (sp_array_index == (sat_rot_ex_num+sat_rot_df_num)*2)
        sp_array_index = 0;


    return;
}

/* For cardiac scans if the sat pulses are not at the beginning then
   the following ISI interrupt is used. The difference between the two
   interrupts is that the first entry in the sat_rot_matrices is used
   for the cardiac case. It is skipped in the case where the sat appear
   at the beginning of the sequence. (The psd loads first matrix in this
   case. ) */
void
sp_set_rot_matrix_card( void )
{

    ++isi_vector_count_card;
    setrotateimm(sat_rot_matrices[sp_array_index],WARP_UPDATE_ON_SSP_INT);
    sp_array_index = sp_array_index + 1;

    if (sp_array_index == (sat_rot_ex_num+sat_rot_df_num)*2 + 1)
        sp_array_index = 0;

    return;
}


/* Inversion recovery description:
   sat 1 == a whole sat sequence that occurs before inversion pulse
   sat 2 == a whole sat sequence that occurs before the 90 pulse
   sat 3 == a whole sat sequence that occurs after inversion pulse

   sat 1 and sat 3 belong to the same boffset
   sat 2 belongs to a differenct boffset
*/

/* ISI vector for sequential inversion recovery sequences with sat 1, sat 2
   and sat 3 on. During  sat 1 and sat 3, the slice is never updated. 
   The first rotation matrix of sat 1 is loaded via the psd startseq. 
   The remainder sats in sat 1 use a preincrement to index through 
   the sat_rot_matrices array. Sat3 uses an ISI to load the first sat 
   rotation matrix. A postincrement is needed to index through the 
   sat_rot_matrices array. In addition, between sat 1 execution and 
   sat 2 execution the sat index must be reset to the top of the array.

   Sat 2 uses the psd to load the first rotation matrix and a preincrement 
   to index through the sat_rot_matrices array. */
void
sp_set_rot_matrix_seqir123( void )
{
    ++isi_vector_count_seqir123;

    /* If in the inversion sequence, the first sequence of sat (sat1)
       use preincrement since the psd loaded the first sat rotation matrix
       it must be bypass by the preincrement. The second sequence of
       sat (sat2) is in the same sequence so it has an ISI vector to
       load the first sat2 rotation matrix. A postincrement is needed here.
       Order of incrementing and resetting indices & counter is very
       important--don't skrew with it!!! */

    switch (sp_sat_seq_count)
    {
        /* Sat sequence 1 */
    case 0:
        sp_array_index = sp_array_index + 1;

        setrotateimm(sat_rot_matrices[sp_array_index],
                     WARP_UPDATE_ON_SSP_INT);

        if (sp_array_index == (sat_rot_ex_num+sat_rot_df_num)*2)
        {
            sp_sat_seq_count = sp_sat_seq_count + 1;
            sp_array_index = 0;
        }
        break;

        /* Sat 2 sequence */
    case 1:
        setrotateimm(sat_rot_matrices[sp_array_index],
                     WARP_UPDATE_ON_SSP_INT);

        sp_array_index = sp_array_index + 1;

        if (sp_array_index == (sat_rot_ex_num+sat_rot_df_num)*2 + 1)
        {
            sp_sat_seq_count = sp_sat_seq_count + 1;
            sp_array_index = 0;
        }
        break;
 
        /* 90-180 sequence in IR */

    case 2:
        sp_array_index = sp_array_index + 1; 

        setrotateimm(sat_rot_matrices[sp_array_index],
                     WARP_UPDATE_ON_SSP_INT);

        if (sp_array_index == (sat_rot_ex_num+sat_rot_df_num)*2)
        {
            sp_sat_seq_count = 0;
            sp_array_index = 0;
        }
        break;
    }

    return;
}

/* ISI for inversion recovery with sat 1 and sat 2.  For both sat 1 and 
   sat 2, the psd loads first rotation matrix for the first sat. So
   a preincrement is needed to index through the sat_rot_matrices array. */
void
sp_set_rot_matrix_seqir12( void )
{
    sp_array_index = sp_array_index + 1;

    ++isi_vector_count_seqir12;
    setrotateimm(sat_rot_matrices[sp_array_index],WARP_UPDATE_ON_SSP_INT);

    if (sp_array_index == (sat_rot_ex_num+sat_rot_df_num)*2)
    {
        sp_array_index = 0;
    }

    return;
}


/* ISI vector for inversion recovery with sat 1 and sat 3. 
   The sat 1 sequence requires a preincrement to index through the
   sat_rot_matrices array since the psd loaded the first rotation matrix.
   The sat 3 sequence requires a postincrement since an ISI is used
   to update the first rotation matrix.  */
void
sp_set_rot_matrix_seqir13( void )
{
    ++isi_vector_count_seqir13;

    /* If in the inversion sequence, the first sequence of sat (sat1)
       use preincrement since the psd loaded the first sat rotation matrix
       it must be bypass by the preincrement. The second sequence of
       sat (sat2) is in the same sequence so it has an ISI vector to
       load the first sat2 rotation matrix. A postincrement is needed here.
       Order of incrementing and resetting indices & counter is very
       important--don't screw with it!!! */

    if (sp_sat_seq_count == 0)                /* sat 1 sequence */
    {
        sp_array_index = sp_array_index + 1;

        setrotateimm(sat_rot_matrices[sp_array_index],WARP_UPDATE_ON_SSP_INT);

        if (sp_array_index == (sat_rot_ex_num+sat_rot_df_num)*2)
        {
            sp_array_index = 0;
            sp_sat_seq_count = sp_sat_seq_count + 1;
        }
    }
    else                 /* sat 2 sequence */
    {
        setrotateimm(sat_rot_matrices[sp_array_index],WARP_UPDATE_ON_SSP_INT);
    
        sp_array_index = sp_array_index + 1;

        if (sp_array_index == (sat_rot_ex_num+sat_rot_df_num)*2 + 1)
        {
            sp_array_index = 0;
            sp_sat_seq_count = 0;
        }
    }

    return;
}

/* vmx 4/17/95  YI  changed data type of slice_rot_matrix and sat_rot_array */
STATUS
sp_update_rot_matrix( long *slice_rot_matrix,
                      long (*sat_rot_array)[9],
                      const INT num_explicit_sats,
                      const INT num_default_sats )
{
    INT i, j;
    INT slice_rot_index;

    /* SAT rotation matrix contains the following
       |--------------------|
       |  SAT 1 rot matrix  |    Explicit SATs
       |--------------------|
       |  Slice rot matix   |
       |--------------------|
       |  SAT 2 rot matrix  |
       |--------------------|
       |  Slice rot matix   |
       |--------------------|
       |  SAT 3 rot matrix  |
       |--------------------|    
       |  Slice rot matix   |
       |--------------------|
       |  SAT 4 rot matrix  |   Default Sats
       |--------------------|
       |  Slice rot matix   |
       |--------------------|
       |  SAT 5 rot matrix  |
       |--------------------|
       |  Slice rot matix   |
       |--------------------|
       |  SAT 6 rot matrix  |
       |--------------------|
       |  Slice rot matix   |
       |--------------------|
       |  slice rot matrix  |
       |--------------------|

       sat_rot_ex_num = point where explicit sat change to default sats

       Default sat follow slice rotation matrix. When the slice changes
       the default sat rotations matrices and the slice rotation matrix
       slots must be updated with the new slice rotation matrix. */

    /* Updates default sat & slice rotation matrices */
    slice_rot_index = 1;
    for (i=0; i < num_explicit_sats; ++i)
    {
        for (j=0; j < 9; ++j)
            *( ((long *) sat_rot_array)+(slice_rot_index*9+j))= 
                *(slice_rot_matrix+j);
        slice_rot_index +=2;
    }

    slice_rot_index = num_explicit_sats*2;
    for (i=0; i< num_default_sats*2+1; ++i)
    {
        for (j=0; j < 9; ++j)
            *( ((long *) sat_rot_array)+(slice_rot_index*9+j))= 
                *(slice_rot_matrix+j);
        ++slice_rot_index;
    }

    return SUCCESS;
}


/*
  The theory here is that the rsprot array needs to contain the rotation
  matrix for the first pulse being played out. In the case of explicit
  sats, this is the first explicit sat rotation matrix. In the case of
  no explicit sats but defaults sats, this is the slice rotation matrix.
  To accomplish this the rsprot array needs to be modified. The rsprot
  matrix will only be used for the first pulse--ISI vector will update
  the rotation matrices for the remaining sat pulses and the slice pulses.
  The rsprot array only handles the first pulse in the sequence.

  If Explicit Sats are used the rsprot array looks as follows.
  Note that there will be nslices entries all filled in with
  the first explicit sat rotation matrix.
      
    |------------------------------------|
    |   Explicit Sat1 rotation matrix    |
    |------------------------------------|
    |   Explicit Sat1 rotation matrix    |
    |------------------------------------|
    |   Explicit Sat1 rotation matrix    |
    |------------------------------------|
         ...

    If there are no explicit SATs, only default SAT, the rsprot is not
    changed. It contains the original slices.
  
    |-------------------------------|
    |   slice 1 rotation matrix     |
    |-------------------------------|
    |   slice 2 rotation matrix     |
    |-------------------------------|
    |   slice 3 rotation matrix     |
    |-------------------------------|

    This routine also places the slice rotation matrices into the 
    sat_rot_matrices. The sat_rot_matrices are the working version
    of what rotation matrices need to be played during the current
    sequence. They are updated for every sequence. The explicit sat
    rotation matrices which appear first in the array are filled out
    during cveval. 

    The slice rotation matrix appears after every sat pulse. The slice
    rotation matrix is played out for the killer for the sat. Killers
    are played out after each sat, hence a slice rotation matrix appears
    after each sat rotation matrix (explicit or default).
   
    The slice rotation matrices are provided by scan. The
    default sat rotation matrices are the same as the slice. They
    are filled out now.

               |--------------------|
               |  SAT 1 rot matrix  |    Explicit SATs
               |--------------------|      filled out in cveval
               |  Slice rot matrix  |    Killer for Sat 1
               |--------------------|
               |  SAT 2 rot matrix  |
               |--------------------|
               |  Slice rot matrix  |    Killer for Sat 2
               |--------------------|
               |  SAT 3 rot matrix  |
               |--------------------|
               |  Slice rot matrix  |    Killer for Sat 3
               |--------------------|    Default SATs
               |  SAT 4 rot matrix  |      filled out now
               |--------------------|
               |  Slice rot matrix  |    Killer for Sat 4
               |--------------------|
               |  SAT 5 rot matrix  |
               |--------------------|
               |  Slice rot matrix  |    Killer for Sat 5
               |--------------------|
               |  SAT 6 rot matrix  |
               |--------------------|
               |  slice rot matrix  |    Killer for Sat 6
               |--------------------|
               |  slice rot matrix  |    For Slice
               |--------------------|
*/ 
void
SpSat_set_sat1_matrix( long (*orig_rot_matrix)[9],
                       long (* new_rot_matrix)[9],
                       int entries,
                       long (*sat_array)[9],
                       int num_explicit_sats,
                       int num_default_sats,
                       int cardiacsat_pos,
                       int sequence_flag )
{
    int i, j;
    int slice_rot_index;

    /* Saves original slice rotation matrix array if this is the first
       scan since download. Otherwise, the rotation matrices have
       already been copied over and this code is not repeated. */
    if ( (sp_first_scan == 1) || (opfluorotrigger==1) )
    {
        for (i=0; i < entries; ++i)
        {
            for (j=0; j<9; ++j)
                *( ((int *) orig_rot_matrix)+i*9 + j) 
                    = *( ((int *) new_rot_matrix) +i*9+j);
        }
    }
    sp_first_scan = 0;

    /* Changes slice rotation matrix if explicit sat are used.
       The slice rotation matrix will be filled with the rotation
       matrix for the first explicit SAT band. All entries are
       filled with this same matrix because explicit sat bands
       keep the same matrix throughout the scan.  

       In the case of cardiac where the sat pulses are not at the
       beginning of the sequence, the new rotation matrices are 
       not changed. */

    if ((num_explicit_sats != 0) && (cardiacsat_pos == 0) && 
        (sequence_flag == 0))
    {
        for (i=0; i<entries; ++i)
            for(j=0; j<9; ++j)
                *( ((int *) new_rot_matrix) +i*9+ j) = 
                    *( ((int *) sat_array)+j);
    }
   
    slice_rot_index = 1;
    for (i = 0; i < num_explicit_sats; ++i)
    {
        for (j=0; j<9; ++j)
            *( ((int *) sat_array )+slice_rot_index*9+j) = 
                *( ((int *) orig_rot_matrix)+j);

        slice_rot_index += 2;
    }

    for (i= num_explicit_sats*2; i<(num_explicit_sats + num_default_sats)*2 +1;
         i++)
    {
        for (j=0; j<9; ++j)
            *( ((int *) sat_array )+i*9+j) = 
                *( ((int *) orig_rot_matrix)+j);
    }

    /* If sat is played as a separate sequence as in fgre or mpir (the case
       where sat is only in the inversion sequence), the original slice 
       rotation matrix is maintained. The first sat rotation matrix is
       appended at the end. The sequences switch between the top and 
       bottom of the rotation matrix array to determine what to load. */
    if (sequence_flag == 1)
    {
        for (i=entries; i< entries*2; ++i)
            for(j=0; j<9; ++j)
                *( ((int *) new_rot_matrix) +i*9+ j) = 
                    *( ((int *) sat_array)+j);
    }

    sp_array_index = 0;
    return;
}

STATUS
SpSatInitRsp( INT num_sat_grps,
              INT cardiacsat_pos,
              INT ir_sattype )
{
    INT i = 0; /* counters */
    INT skip_next_sat;

    if ( (opsat != PSD_OFF) && ((opsatx != PSD_OFF)
                                || (opsaty != PSD_OFF)
                                || (opsatz != PSD_OFF)
                                || (opexsatmask != PSD_OFF)) )
    {
        if (cardiacsat_pos == 0)
            isivector((short) 1, sp_set_rot_matrix, (short) FALSE);
        else
            isivector ((short) 1, sp_set_rot_matrix_card, (short) FALSE);

        switch (ir_sattype)
        {
        case 1:
            isivector ((short) 1, sp_set_rot_matrix_seqir13, (short) FALSE);
            break;

        case 2:
            isivector ((short) 1, sp_set_rot_matrix_seqir12, (short) FALSE);
            break;

        case 3:
            isivector ((short) 1, sp_set_rot_matrix_seqir123, (short) FALSE);
            break;

        case 4:
            isivector ((short) 1, sp_set_rot_matrix, (short) FALSE);
            break;

        case 5:
            isivector ((short) 1, sp_set_rot_matrix_card, (short) FALSE);
            break;
        }

        isi_vector_count = 0;
        isi_vector_count_card = 0;
        isi_vector_count_seqir123 = 0;
        isi_vector_count_seqir12 = 0;
        isi_vector_count_seqir13 = 0;
        sp_sat_seq_count = 0;
        rsp_max_rindex = sat_rot_index;	
        /* Turn off SAT in first pass prescan */
        if ((rspent == L_APS1) || (rspent == L_MPS1))
        {
            if (opsatx != PSD_OFF)
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfsx1,i);
            }
            if (opsatx == PSD_SATPARA)
            {
                for (i=0; i < num_sat_grps; i++)
                    rfoff(&rfsx2, i);
            }

            if (opsaty != PSD_OFF)
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfsy1,i);
            }
            if (opsaty == PSD_SATPARA)
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfsy2, i);
            }

            if (opsatz != PSD_OFF)
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfsz1,i);
            }
            if (opsatz == PSD_SATPARA)
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfsz2, i);
            }

            skip_next_sat = 0;
            if ((opexsatmask & PSD_EXPLICIT_1) != 0)
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfse1, i);
            }

            if ((opexsatparal & PSD_1_PARALLEL) == PSD_1_PARALLEL)
                skip_next_sat = 1;
            if (((opexsatmask & PSD_EXPLICIT_2) == PSD_EXPLICIT_2) && 
                (skip_next_sat == 0))
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfse2, i);
            }

            skip_next_sat = 0;
            if ((opexsatmask & PSD_EXPLICIT_3) != 0)
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfse3, i);
            }


            if ((opexsatparal & PSD_2_PARALLEL) == PSD_2_PARALLEL)
                skip_next_sat = 1;
            if (((opexsatmask & PSD_EXPLICIT_4) == PSD_EXPLICIT_4) &&
                (skip_next_sat == 0))
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfse4, i);
            }

            skip_next_sat = 0;
            if ((opexsatmask & PSD_EXPLICIT_5) == PSD_EXPLICIT_5)
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfse5, i);
            }

            if ((opexsatparal & PSD_3_PARALLEL) == PSD_3_PARALLEL)
                skip_next_sat = 1;
            if (((opexsatmask & PSD_EXPLICIT_6) == PSD_EXPLICIT_6) &&
                (skip_next_sat == 0))
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfse6, i);
            }
       	} /* APS1 or MPS1 */
        else
        {
            /* Turn RF on and load frequencies in other entry points */
            if (opsatx != PSD_OFF)
            {
                for (i=0; i<num_sat_grps; i++)
                {
                    rspsatx1 = off_rfsx1/TARDIS_FREQ_RES;
                    rfon(&rfsx1,i);
                    setfrequency(rspsatx1,&rfsx1,i);
                    amp_gyksx1 = ia_gyksx1;
                    setiampt(amp_gyksx1, &gyksx1, 0);
                    if (area_gxksx1!=0.0)
                    {
                        amp_gxksx1 = ia_gxksx1;
                        setiampt(amp_gxksx1, &gxksx1, 0);
                    }

                    if (opsatx == PSD_SATPARA)
                    {
                        rspsatx2 = off_rfsx2/TARDIS_FREQ_RES;
                        rfon(&rfsx2, i);
                        setfrequency(rspsatx2, &rfsx2, i);
                        amp_gyksx2 = ia_gyksx2;
                        setiampt(amp_gyksx2, &gyksx2, 0);
                        if (area_gxksx2!=0.0)
                        {
                            amp_gxksx2 = ia_gxksx2;
                            setiampt(amp_gxksx2, &gxksx2, 0);
                        }
                    }
                }
            }
            if (opsaty != PSD_OFF)
            {
                for (i=0; i<num_sat_grps; i++)
                {
                    rspsaty1 = off_rfsy1/TARDIS_FREQ_RES;
                    rfon(&rfsy1,i);
                    setfrequency(rspsaty1,&rfsy1,i);
                    amp_gyksy1 = ia_gyksy1;
                    setiampt(amp_gyksy1, &gyksy1, 0);
                    if (area_gxksy1!=0.0)
                    {
                        amp_gxksy1 = ia_gxksy1;
                        setiampt(amp_gxksy1, &gxksy1, 0);
                    }

                    if (opsaty == PSD_SATPARA)
                    {
                        rspsaty2 = off_rfsy2/TARDIS_FREQ_RES;
                        rfon(&rfsy2,i);
                        setfrequency(rspsaty2,&rfsy2,i);
                        amp_gyksy2 = ia_gyksy2;
                        setiampt(amp_gyksy2, &gyksy2, 0);
                        if (area_gxksy2!=0.0)
                        {
                            amp_gxksy2 = ia_gxksy2;
                            setiampt(amp_gxksy2, &gxksy2, 0);
                        }
                    }
                }
            }
            if (opsatz != PSD_OFF)
            {
                for (i=0; i<num_sat_grps; i++)
                {
                    rspsatz1 = off_rfsz1/TARDIS_FREQ_RES;
                    rfon(&rfsz1,i);
                    setfrequency(rspsatz1,&rfsz1,i);
                    amp_gyksz1 = ia_gyksz1;
                    setiampt(amp_gyksz1, &gyksz1, 0);
                    if (area_gxksz1!=0.0)
                    {
                        amp_gxksz1 = ia_gxksz1;
                        setiampt(amp_gxksz1, &gxksz1, 0);
                    }

                    if (opsatz == PSD_SATPARA)
                    {
                        rspsatz2 = off_rfsz2/TARDIS_FREQ_RES;
                        rfon(&rfsz2,i);
                        setfrequency(rspsatz2,&rfsz2,i);
                        amp_gyksz2 = ia_gyksz2;
                        setiampt(amp_gyksz2, &gyksz2, 0);
                        if (area_gxksz2!=0.0)
                        {
                            amp_gxksz2 = ia_gxksz2;
                            setiampt(amp_gxksz2, &gxksz2, 0);
                        }
                    }
                }
            }

            skip_next_sat = 0;
            if ((opexsatmask & PSD_EXPLICIT_1) != 0)
            {
                for (i = 0; i<num_sat_grps; i++)
                {
                    rspsate1 = off_rfse1/TARDIS_FREQ_RES;
                    rfon(&rfse1,i);
                    setfrequency(rspsate1, &rfse1, i);
                    amp_gykse1 = ia_gykse1;
                    setiampt(amp_gykse1, &gykse1, 0);
                    if (area_gxkse1!=0.0)
                    {
                        amp_gxkse1 = ia_gxkse1;
                        setiampt(amp_gxkse1, &gxkse1, 0);
                    }
                }
                if ((opexsatparal & PSD_1_PARALLEL))
                    skip_next_sat = 1;
            }

            if (((opexsatmask & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0))
            {
                for (i = 0; i<num_sat_grps; i++)
                {
                    rspsate2 = off_rfse2/TARDIS_FREQ_RES;
                    rfon(&rfse2,i);
                    setfrequency(rspsate2, &rfse2, i);
                    amp_gykse2 = ia_gykse2;
                    setiampt(amp_gykse2, &gykse2, 0);
                    if (area_gxkse2!=0.0)
                    {
                        amp_gxkse2 = ia_gxkse2;
                        setiampt(amp_gxkse2, &gxkse2, 0);
                    }
                }
            }

            skip_next_sat = 0;
            if ((opexsatmask & PSD_EXPLICIT_3) != 0)
            {
                for (i = 0; i<num_sat_grps; i++)
                {
                    rspsate3 = off_rfse3/TARDIS_FREQ_RES;
                    rfon(&rfse3,i);
                    setfrequency(rspsate3, &rfse3, i);
                    amp_gykse3 = ia_gykse3;
                    setiampt(amp_gykse3, &gykse3, 0);
                    if (area_gxkse3!=0.0)
                    {
                        amp_gxkse3 = ia_gxkse3;
                        setiampt(amp_gxkse3, &gxkse3, 0);
                    }
                }
                if ((opexsatparal & PSD_2_PARALLEL))
                    skip_next_sat = 1;
            }

            if (((opexsatmask & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0))
            {
                for (i = 0; i<num_sat_grps; i++)
                {
                    rspsate4 = off_rfse4/TARDIS_FREQ_RES;
                    rfon(&rfse4,i);
                    setfrequency(rspsate4, &rfse4, i);
                    amp_gykse4 = ia_gykse4;
                    setiampt(amp_gykse4, &gykse4, 0);
                    if (area_gxkse4!=0.0)
                    {
                        amp_gxkse4 = ia_gxkse4;
                        setiampt(amp_gxkse4, &gxkse4, 0);
                    }
                }
            }

            skip_next_sat = 0;
            if ((opexsatmask & PSD_EXPLICIT_5) != 0)
            {
                for (i = 0; i<num_sat_grps; i++)
                {
                    rspsate5 = off_rfse5/TARDIS_FREQ_RES;
                    rfon(&rfse5,i);
                    setfrequency(rspsate5, &rfse5, i);
                    amp_gykse5 = ia_gykse5;
                    setiampt(amp_gykse5, &gykse5, 0);
                    if (area_gxkse5!=0.0)
                    {
                        amp_gxkse5 = ia_gxkse5;
                        setiampt(amp_gxkse5, &gxkse5, 0);
                    }
                }
                if ((opexsatparal & PSD_3_PARALLEL))
                    skip_next_sat = 1;
            }

            if (((opexsatmask & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0))
            {
                for (i = 0; i<num_sat_grps; i++)
                {
                    rspsate6 = off_rfse6/TARDIS_FREQ_RES;
                    rfon(&rfse6,i);
                    setfrequency(rspsate6, &rfse6, i);
                    amp_gykse6 = ia_gykse6;
                    setiampt(amp_gykse6, &gykse6, 0);
                    if (area_gxkse6!=0.0)
        	    {
                        amp_gxkse6 = ia_gxkse6;
                        setiampt(amp_gxkse6, &gxkse6, 0);
                    }
                }
            }

        } /* else not APS1 or MPS1 */
    } /* SAT on */
    return SUCCESS;
}

STATUS
SpSatUpdateRsp( INT num_sat_grps,
                INT  pass,
                INT cat_seq_type )
{
    INT grp;
    
    if ((opsatx != PSD_OFF) || (opsaty != PSD_OFF) || (opsatz != PSD_OFF)
        || (opexsatmask != PSD_OFF))
    {
        if ((opsatz != PSD_OFF) && (cat_seq_type ==  PSD_ON)) 
        {
            for (grp=0; grp<num_sat_grps; grp++) 
            {
                rspsatz1 = off_rfcsz[pass]/TARDIS_FREQ_RES;
	        setfrequency(rspsatz1,&rfsz1,grp);
            }
        }
    }
    return SUCCESS;
}

STATUS
SpSatPlayRelaxers( void )
{
    INT i;

    boffset(off_cat_seq);	   /* Switch to Cat Sat relaxer sequence */
  
    for (i=0; i<ccs_relaxers; i++) /* Play the sequence */
        startseq(0,(SHORT)MAY_PAUSE);

    /* Should switch back boffset in scan core */
    return SUCCESS;
}

void
SpSat_Satoff( INT sat_index )
{
    INT skip_next_sat;

    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return;

    if (opsatx != 0)
    {
        setiamp(0, &rfsx1, sat_index);
        if (opsatx == PSD_SATPARA)
            setiamp(0, &rfsx2, sat_index);
    }
    if (opsaty != 0)
    {
        setiamp(0, &rfsy1, sat_index);
        if (opsaty == PSD_SATPARA)
            setiamp(0, &rfsy2, sat_index);
    }
    if (opsatz != 0)
    {
        setiamp(0, &rfsz1, sat_index);
        if (opsatz == PSD_SATPARA)
            setiamp(0, &rfsz2, sat_index);
    }

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_1) !=0)
    {
        setiamp(0, &rfse1, sat_index);
        if ((opexsatparal & PSD_1_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_2) !=0) && (skip_next_sat ==0))
        setiamp(0, &rfse2, sat_index);

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_3) !=0)
    {
        setiamp(0, &rfse3, sat_index);
        if ((opexsatparal & PSD_2_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_4) !=0) && (skip_next_sat ==0))
        setiamp(0, &rfse4, sat_index);

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_5) !=0)
    {
        setiamp(0, &rfse5, sat_index);
        if ((opexsatparal & PSD_3_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_6) !=0) && (skip_next_sat ==0))
        setiamp(0, &rfse6, sat_index);
    return;
}


void
SpSat_Saton( INT sat_index )
{
    INT skip_next_sat;

    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return;

    if (opsatx != 0)
    {
        setiamp(ia_rfsx1, &rfsx1, sat_index);
        if (opsatx == PSD_SATPARA)
            setiamp(ia_rfsx2, &rfsx2, sat_index);
    }
    if (opsaty != 0)
    {
        setiamp(ia_rfsy1, &rfsy1, sat_index);
        if (opsaty == PSD_SATPARA)
            setiamp(ia_rfsy2, &rfsy2, sat_index);
    }
    if (opsatz != 0)
    {
        setiamp(ia_rfsz1, &rfsz1, sat_index);
        if (opsatz == PSD_SATPARA)
            setiamp(ia_rfsz2, &rfsz2, sat_index);
    }

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_1) !=0)
    {
        setiamp(ia_rfse1, &rfse1, sat_index);
        if ((opexsatparal & PSD_1_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_2) !=0) && (skip_next_sat ==0))
        setiamp(ia_rfse2, &rfse2, sat_index);

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_3) !=0)
    {
        setiamp(ia_rfse3, &rfse3, sat_index);
        if ((opexsatparal & PSD_2_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_4) !=0) && (skip_next_sat ==0))
        setiamp(ia_rfse4, &rfse4, sat_index);

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_5) !=0)
    {
        setiamp(ia_rfse5, &rfse5, sat_index);
        if ((opexsatparal & PSD_3_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_6) !=0) && (skip_next_sat ==0))
        setiamp(ia_rfse6, &rfse6, sat_index);
    return;
}

void
SpSat_Satrfoff(INT sat_index)
{
    INT  skip_next_sat;

    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return;

    if (opsatx != PSD_SATOFF)
    {
        rfoff(&rfsx1, sat_index);
        if (opsatx == PSD_SATPARA)
            rfoff(&rfsx2, sat_index);
    }
    if (opsaty != PSD_SATOFF)
    {
        rfoff(&rfsy1, sat_index);
        if (opsaty == PSD_SATPARA)
            rfoff(&rfsy2, sat_index);
    }
    if (opsatz != PSD_SATOFF)
    {
        rfoff(&rfsz1, sat_index);
        if (opsatz == PSD_SATPARA)
            rfoff(&rfsz2, sat_index);
    }

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_1) !=0)
    {
        rfoff(&rfse1, sat_index);
        if ((opexsatparal & PSD_1_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_2) !=0) && (skip_next_sat ==0))
        rfoff(&rfse2, sat_index);

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_3) !=0)
    {
        rfoff(&rfse3, sat_index);
        if ((opexsatparal & PSD_2_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_4) !=0) && (skip_next_sat ==0))
        rfoff(&rfse4, sat_index);

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_5) !=0)
    {
        rfoff(&rfse5, sat_index);
        if ((opexsatparal & PSD_3_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_6) !=0) && (skip_next_sat ==0))
        rfoff(&rfse6, sat_index);
    return;
}


void
SpSat_Satrfon(INT sat_index)
{
    INT skip_next_sat;

    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return;

    if (opsatx != PSD_SATOFF)
    {
        rfon(&rfsx1, sat_index);
        if (opsatx == PSD_SATPARA)
            rfon(&rfsx2, sat_index);
    }
    if (opsaty != PSD_SATOFF)
    {
        rfon(&rfsy1, sat_index);
        if (opsaty == PSD_SATPARA)
            rfon(&rfsy2, sat_index);
    }
    if (opsatz != PSD_SATOFF)
    {
        rfon(&rfsz1, sat_index);
        if (opsatz == PSD_SATPARA)
            rfon(&rfsz2, sat_index);
    }

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_1) !=0)
    {
        rfon(&rfse1, sat_index);
        if ((opexsatparal & PSD_1_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_2) !=0) && (skip_next_sat ==0))
        rfon(&rfse2, sat_index);

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_3) !=0)
    {
        rfon(&rfse3, sat_index);
        if ((opexsatparal & PSD_2_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_4) !=0) && (skip_next_sat ==0))
        rfon(&rfse4, sat_index);

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_5) !=0)
    {
        rfon(&rfse5, sat_index);
        if ((opexsatparal & PSD_3_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_6) !=0) && (skip_next_sat ==0))
        rfon(&rfse6, sat_index);
    return;
}

STATUS ssRsp(void)
{
    INT temp_freq;  /* for debugging */
    if (ss_rf1 == PSD_ON) {
        if (fat_flag == PSD_ON) {
            rf1_freq[sliceindex] = fat_offset;
        } else {
            rf1_freq[sliceindex] = 0;
        }
        temp_freq = theta_freq[sliceindex];
        setiampall((int)(freqSign*theta_freq[sliceindex]), &thetarf1, 0);
    }
    return(SUCCESS);
}

STATUS ref( void )
{
    /* SXZ: turn on/off spin echo reference scan */
    if( oppseq == 1 || se_ref != 1 )
        refAsScan(); 
    else
        refSpinEcho();

    return SUCCESS;
}

/***************************  refSpinEcho  ******************************/
/* This function sets up a "spin-echo" reference scan regardless of the */
/* actual epi scan used to image. */
STATUS refSpinEcho( void )
{

  printdbg("Greetings from REF", debugstate);
  rspent = L_REF;
  rspdda = dda;

  if (cs_sat ==1)    /* Turn on ChemSat Y crusher */
      cstun=1;

  /* call to psdinit function for ref scan */
  psdinit();

  /* baselines */
  rspbas = rhbline;   /* used on blineacq only */

  rspasl = -1;
  rspgy1 = 1;
  rspnex = nex; /*jwg bb changed from 1 to allow averaging*/

  rspesl = -1;
  rspgyc = 0;

  /* pass to use */
  rspacqb = pre_pass;
  rspacq = pre_pass + 1;

  /* slice to use - closest to isocenter */
  rspslqb = pre_slice;
  rspslq = pre_slice + 1;

  /* phase to use */
  rspprp = 1;
  rsprep = 1;
 
  /* Turn off the phase encode axis - this function 0s the blips and prephaser */
  /* of the reference sequence */
  turnOffBlips(etl);

  /* ref_mode: set up the looping based on ref_mode */
  /* ref_mode = 0 -> loop over all slices prescribed */
  if(ref_mode == 0) { 
      
      /* passes */
      rspacqb = 0;  
      rspacq = acqs;
      
      /* slices */
      rspslqb = 0;
      rspslq = slquant1;
      
  } 
  
  /* ref_mode = 1 ->  acquire all the slices up to the slice closest to isocenter then stop */
  if(ref_mode == 1) { 
      
      /* passes */
      rspacqb = pre_pass;
      rspacq = pre_pass + 1;
      
      /* slices */
      rspslqb = 0;
      rspslq = pre_slice+1;
      
  }
  
  /* ref_mode = 2 -> acquire the slice closet to isocenter only */
  if(ref_mode == 2) {  
      
      /* passes */
      rspacqb = pre_pass;
      rspacq = pre_pass + 1;
      
      /* slices */
      rspslqb = pre_slice;
      rspslq = pre_slice+1;
  }
  
  /* rhpctemporal: which temporal phase to use for ref scan. 0 = first rep of sequence */
  if(rhpctemporal == 0) {
      
      /* Which phase loop to use */   
      if ( (mph_flag==1) && (acqmode==0) )
          rspprp = pass_reps;
      if ( (mph_flag==1) && (acqmode==1) )
          rsprep =  reps;
      
  } else if (rhpctemporal != 0 ) {
      
      /* rep to use */
      rsprep = rhpctemporal;
      
  } 

  /* rhpcileave: determine which interleaves */
  /* to use for multi-shot.  0 = all interleaves */
  if (rhpcileave == 0) {
      rspilv = intleaves;
  } else {
      rspilv = 1;
  }

  refloop();
  rspexit();

  return SUCCESS;
}

/***************************  RefAsScan  *******************************/
/* This function uses the same pulses used in the "scan" portion of the */
/* of the epi sequence.  Thus, if the scan is a gradient echo, the ref  */
/* scan will be gradient echo...This is a simple way to go back to the  */
/* previous implementation....*/
STATUS refAsScan( void )
{
  printdbg("Greetings from REF", debugstate);
  rspent = L_REF;
  rspdda = dda;
  if (cs_sat ==1)  /* Turn on ChemSat Y crusher */
      cstun=1;
  psdinit();

  /* baselines */
  rspbas = rhbline;   /* used on blineacq only */

  rspasl = -1;
  rspgy1 = 1;
  rspnex = nex; /*jwg bb changed from 1 to allow averaging*/

  rspesl = -1;
  rspgyc = 0;

  /* pass to use */
  rspacqb = pre_pass;
  rspacq = pre_pass + 1;

  /* slice to use - closest to isocenter */
  rspslqb = pre_slice;
  rspslq = pre_slice + 1;

  /* phase to use */
  rspprp = 1;
  rsprep = 1;

  ygradctrl(rspgyc, gyb_amp, etl);

  /* ref_mode: set up the looping based on ref_mode */
  /* ref_mode = 0 -> loop over all slices prescribed */
  if(ref_mode == 0) { 
      
      /* passes */
      rspacqb = 0;  
      rspacq = acqs;
      
      /* slices */
      rspslqb = 0;
      rspslq = slquant1;
      
  } 
  
  /* ref_mode = 1 ->  acquire all the slices up to the slice closest to isocenter then stop */
  if(ref_mode == 1) { 
      
      /* passes */
      rspacqb = pre_pass;
      rspacq = pre_pass + 1;
      
      /* slices */
      rspslqb = 0;
      rspslq = pre_slice+1;
      
  }
  
  /* ref_mode = 2 -> acquire the slice closet to isocenter only */
  if(ref_mode == 2) {  
      
      /* passes */
      rspacqb = pre_pass;
      rspacq = pre_pass + 1;
      
      /* slices */
      rspslqb = pre_slice;
      rspslq = pre_slice+1;
  }
  
  /* rhpctemporal: which temporal phase to use for ref scan. 0 = first rep of sequence */
  if(rhpctemporal == 0) {
      
      /* Which phase loop to use */   
      if ( (mph_flag==1) && (acqmode==0) )
          rspprp = pass_reps;
      if ( (mph_flag==1) && (acqmode==1) )
          rsprep =  reps;
      
  } else if (rhpctemporal != 0 ) {
      
      /* rep to use */
      rsprep = rhpctemporal;
      
  } 

  /* rhpcileave: determine which interleaves */
  /* to use for multi-shot.  0 = all interleaves */
  if (rhpcileave == 0) {
      rspilv = intleaves;
  } else {
      rspilv = 1;
  }

  scanloop();
  rspexit();

  return SUCCESS;
}

STATUS
#ifdef __STDC__ 
psdinit_ref( void )
#else /* !__STDC__ */
psdinit_ref() 
#endif /* __STDC__ */
{
    int icnt;
    float *refdata = NULL;  /* MRIge55996 - Changed array from static to dynamic */
    int refdata_size;
    int refdata_offset;

    strcpy(psdexitarg.text_arg, "psdinit_ref");  /* reset global error variable */

    timedelta = 0;

    /*
     * MRIge55996 - Allocate and initialize refdata array.
     */
    /* Set refdata array size and offset */
    if( rhpcspacial == 0 )  {

        refdata_size = 1024 * opslquant;
        refdata_offset = 1024;

    } else {

        refdata_size = 1024;
        refdata_offset = 0;
    }

    /* Allocate the needed memory for refdata */
    refdata = (float *)AllocNode( refdata_size * sizeof(float) );
    if( NULL == refdata )
    {
        psdexit( EM_PSD_ALLOC, 0, "", "PSD init entry point", 0 );
    }
    else
    {
        /* MRIge54033 - Zero entire array */
        for( icnt = 0; icnt < refdata_size; icnt++ )
        {
            refdata[icnt] = 0.0;
        }
    }

    if (RefDatCorrection == PSD_OFF)
    {
        int slc;

        /* No need to calculate refdattime */
        for( slc = 0; slc < opslquant; slc++ ) {
            refdattime[slc] = 0.0;
        }

    }

    /*
     * MRIge55996 - Free refdata array.
     */
    if ( NULL != refdata ) {
        FreeNode( refdata );
    }

    setrfconfig((short)rfconf);

    /* Clear the SSI routine. */
    if (opsat == PSD_ON)
        ssivector(ssisat, FALSE);
    else 
        ssivector(dummyssi, FALSE);

    /* turn off dithering */
    setditherrsp(dither_control,dither_value);

    /* Set ssi time.  This is time from eos to start of sequence interrupt
       in internal triggering.  The minimum time is 50us plus 2us*(number of
       waveform and instruction words modified in the update queue).
       Needs to be done per entry point. */
    setssitime((LONG)time_ssi/GRAD_UPDATE_TIME);

    scopeon(&seqrefcore);    /* reset all scope triggers */  
    syncon(&seqrefcore);     /* reset all synchronizations, not needed in pass */

    /* Inform the Tgt of the location of the trigger arrays. */
    settriggerarray((short)(opslquant*opphases), rsptrigger);

    /* Inform the Tgt of the rotation matrix array to be used */
    setrotatearray((short)(opslquant*opphases), rsprot[0]);

    pass = 0;
    pass_index = 0;
    rspacqb = 0;
    rspacq = acqs;
    rspprp = pass_reps;

    /* DAB initialization */
    dabop = 0;    /* Store data */
    dabecho = 0;  /* first dab packet is for echo 0 */

    /* use the autoincrement echo feature for subsequent echos */
    dabecho_multi = -1;

    rspgyc = gyctrl;
    rspslqb = 0;
    rspslq = slquant1;
    rspilvb = 0;
    rspilv = intleaves;
    rspbasb = 1;

    /* Update the exciter freq/phase tables */
    ref_switch = 1;

    xtr = 0.0;
    frt = frtime;

    /* BJM: MRIge54033
       refdattime now passed as array (one entry for each slice) */
    epiRecvFrqPhs( opslquant, intleaves, etl, xtr-timedelta,
                   refdattime, frt, opfov, opyres, opphasefov,
                   b0ditherval, rf_phase_spgr, dro, dpo, rsp_info, view1st,
                   viewskip, gradpol, ref_switch = (rspent==L_REF ? 1:0),
                   ky_dir, dc_chop, pepolar, recv_freq, recv_phase_angle,
                   recv_phase, gldelayfval, a_gxw, debugRecvFrqPhs,
                   ref_with_xoffset, 1.0, iref_etl );

    /* Call MaxwellCorrection Function (see epiMaxwellCorrection.e) */
    if( epiMaxwellCorrection() == FAILURE) return FAILURE; 

    ref_switch = 0; 
    rspe1st = 0;
    rspetot = tot_etl;

    /* Call to set filter in HSDAB packet for EPI */ 
    setEpifilter(scanslot,&hyperdabref); 

    return SUCCESS;  

} /* End psdinit_ref */

/*************************** SCANLOOP *******************************/
STATUS refloop( void )
{
    int pause; /* pause attribute storage loc */

    printdbg("Greetings from RefScan", debugstate);

    setiamp(ia_rf1, &rf1ref, 0);   /* Reset amplitudes */
    setiamp(ia_rf2, &rf2ref, 0);

    /* Turning spatial & chem SAT on */ 
    SpSat_Saton(0);

    if (cs_sat > 0)  
        setiamp(ia_rfcssat, &rfcssat, 0);

    strcpy(psdexitarg.text_arg, "scan");

    for (pass_rep = 0; pass_rep < rspprp; pass_rep++) {
        for (pass = rspacqb; pass < rspacq; pass++) {

            pass_index = pass + pass_rep*rspacq;

            boffset(off_seqrefcore);

            /* MRIge53529: initialize wait time and pass packet for disdacqs, etc.*/
            setwamp(SSPDS, &pass_pulseref, 0);
            setwamp(SSPD, &pass_pulseref, 2);
            setwamp(SSPDS, &pass_pulseref, 4);
            setperiod(1, &ssp_pass_delayref, 0);
            pause = MAY_PAUSE;
            printdbg("Pre core(): Null ssp pass packet", debugstate);

            refcore(); /* acquire the data */

            /* Return to standard trigger array and core offset */
            settriggerarray((SHORT)(opslquant*opphases), rsptrigger);

        } /* end pass loop */
    } /* end pass_rep loop */

    printdbg("Normal End of REF SCAN", debugstate);

    return SUCCESS;

} /* End REFLOOP */

/*****************************  REFCORE  *************************/
STATUS refcore( void )
{
    int pause = MAY_PAUSE;

    if (rspdda > 0) {

        acq_data = (int)DABOFF;
        dabrbaloadref();   

        setperiod((int)tf[0], &wgx, 0);
        setperiod((int)tf[0], &wgy, 0);
        setperiod((int)tf[0], &wgz, 0);
        setperiod((int)tf[0], &wssp, 0);
        setperiod((int)tf[0], &womega, 0);

        for (ileave = rspdda - 1; ileave >= 0; ileave--) {

            /* The % accounts for the case when dda > intleaves */
            if (rf_chop == PSD_ON && rspnex <= 1
                )
                setiamp(-rfpol[ileave % intleaves], &rf1ref, 0);
            else
                setiamp(rfpol[ileave % intleaves], &rf1ref, 0);

            for (slice = rspslqb; slice < rspslq; slice++) {    

                if (acqmode==0) /* interleaved */
                    sliceindex = (acq_ptr[pass_index] + slice)%opslquant;

                if (acqmode==1) /* sequential */
                    sliceindex = acq_ptr[pass_index];

                if (ss_rf1 == PSD_ON) {
                    if (fat_flag == PSD_ON)
                        rf1_freq[sliceindex] = fat_offset;
                    else
                        rf1_freq[sliceindex] = 0;      
                    setiampall(theta_freq[sliceindex], &thetarf1ref, 0);
                }

                setfrequency(rf1_freq[sliceindex], &rf1ref, 0);
                setfrequency(rf2_freq[sliceindex], &rf2ref, 0);
                startseq((short)sliceindex, (SHORT)MAY_PAUSE);

            } /* for slice= 0 */

        } /* for ileave = 0 */

    } /* if rspdda > 0 */

    /******* end disdaq block ***********************************/

    for (core_rep = 0; core_rep < rsprep; core_rep++) {
        for (ileave = rspilvb; ileave < rspilv; ileave++) {

            /* set sliding ssp/readout/phase/slice */
            setperiod((int)tf[ileave], &wgxref, 0);
            setperiod((int)tf[ileave], &wgyref, 0);
            setperiod((int)tf[ileave], &wgzref, 0);
            setperiod((int)tf[ileave], &wsspref, 0);
            setperiod((int)tf[ileave], &womegaref, 0);

            for (excitation=1-rspdex; excitation <= rspnex; excitation++) {

                if (rf_chop == PSD_ON && excitation % 2 == 0)
                    setiamp(-rfpol[ileave], &rf1ref, 0);  /* even excitation */
                else
                    setiamp(rfpol[ileave], &rf1ref, 0);   /* odd excitation */

                for (slice = rspslqb; slice < rspslq; slice++) {    

                    /* Determine which slice(s) to excite (find spot in 
                       rspinfo table) */
                    /* Remember slices & passes start at 0 */

                    if (acqmode==0) /* interleaved */
                        sliceindex = (acq_ptr[pass_index] + slice)%opslquant;

                    if (acqmode==1) /* sequential */
                        sliceindex = acq_ptr[pass_index];

                    if (( rspasl == -1) && (excitation > 0))
                        acq_data = (int)DABON;
                    else
                        acq_data = (int)DABOFF;

                    /* Set the rf pulse transmit frequencies */
                    if (ss_rf1 == PSD_ON) {
                        if (fat_flag == PSD_ON)
                            rf1_freq[sliceindex] = fat_offset;
                        else
                            rf1_freq[sliceindex] = 0;      
                        setiampall(theta_freq[sliceindex], &thetarf1ref, 0);
                    }

                    setfrequency(rf1_freq[sliceindex], &rf1ref, 0);
                    setfrequency(rf2_freq[sliceindex], &rf2ref, 0);

                    if (excitation == 1)
                    {
                        dabop = 0;
                    }
                    else if (rf_chop == PSD_OFF)
                    {
                        dabop = 1;
                    }
                    else
                    {
                        dabop = 3 - 2*(excitation % 2);
                    }
                    
                    slicerep = slice + core_rep*rspslq;
                    
                    if(setDataAcqDelays == PSD_ON) {
                        /* Update the delay on the SSP and Omega boards */
                        setperiod((int)((float)gldelaycval[sliceindex] + pw_sspdelay),
                                  &sspdelayref, 0);
                        
                        setperiod(RUP_RF((int)((float)gldelaycval[sliceindex] +
                                               pw_omegadelay)), &omegadelayref, 0);
                        
                        setperiod((int)((float)(pw_sspshift - gldelaycval[sliceindex])),
                                  &sspshiftref, 0);
                    }
                    
                    /* mod_rba = FALSE; */
                    dabrbaloadref();
                    
                    /* play out pass delay and send proper pass packet within seqcore.  We do
                       this to avoid having to play out a seperate pass sequence as is usually
                       done */
                    if ( (pass == (rspacq - 1)) && (pass_rep == (rspprp - 1)) &&
                         (slice == rspslq-1) && (excitation == rspnex) && 
                         (ileave == rspilv-1) && (core_rep == rsprep-1) ) {
                        
                        /* Set DAB pass packet to end of scan */
                        setwamp(SSPDS + DABDC, &pass_pulseref, 0);
                        setwamp(SSPD + DABPASS + DABSCAN, &pass_pulseref, 2);
                        setwamp(SSPDS + DABDC, &pass_pulseref, 4);
                        setperiod(1, &ssp_pass_delayref, 0);
                        pause = MAY_PAUSE;
                        printdbg("End of Scan and Pass", debugstate);
                        
                    } else if ( (slice == rspslq-1) && (excitation == rspnex) && 
                                (ileave == rspilv-1) && (core_rep == rsprep-1) ) {

                        /* Set DAB pass packet to end of pass */
                        setwamp(SSPDS + DABDC, &pass_pulseref, 0);
                        setwamp(SSPD + DABPASS, &pass_pulseref, 2);
                        setwamp(SSPDS + DABDC, &pass_pulseref, 4);
                        setperiod(1, &ssp_pass_delayref, 0);
                        pause = AUTO_PAUSE;
                        printdbg("End of Pass", debugstate);
                      
                    } else {

                        /* send null pass packet and use the minimum delay for pass_delay */
                        setwamp(SSPDS, &pass_pulseref, 0);
                        setwamp(SSPD, &pass_pulseref, 2);
                        setwamp(SSPDS, &pass_pulseref, 4);
                        setperiod(1, &ssp_pass_delayref, 0);
                        pause = MAY_PAUSE;
                        printdbg("Null ssp pass packet", debugstate);
                    }

                    startseq((short)sliceindex, (SHORT)pause);

                    syncoff(&seqrefcore); 
                }  /* slice */

            } /* excitation */

        } /* ileave */

    } /* core_rep */

    return SUCCESS;  

} /* End Ref Core */

/***************************** dabrbaloadref *************************/
STATUS dabrbaloadref(void)
{
    TYPDAB_PACKETS dabacqctrl;
    int echo;  /* loop counter */
    int freq_ctrl = 0;
    int phase_ctrl = 0;

    dabacqctrl = (TYPDAB_PACKETS)acq_data;
    loadhsdab(&hyperdabref,   /* load hyperdab */
              (LONG)slicerep,
              (LONG)0,
              (LONG)dabop,
              (LONG)view1st[ileave],
              (LONG)viewskip[ileave],
              (LONG)tot_etl,
              (LONG)1,
              (LONG)1,
              dabacqctrl,
              (LONG)hsdabmask);

    /* Load the receive frequency/phase and dab packets */
    for (echo=0; echo<tot_etl; echo++) {

        /* MRIge56894 - only set this stuff during real data acq */
        if(acq_data != DABOFF) { 
            /* BJM: we set the demod freq (sl_rcvcf) in the freq offset */
            /* register and then use omega to offset the slice along */
            /* the read axis.  For non-ramp sampled cases, the offset */
            /* waveform is a constant pulse.  For ramp sampled waveforms */
            /* the offset freq wavefrom is a trapezoid (freq mod on ramps */
            /* This simplifies the phase accumulation across the echo since */
            /* we no longer have to worry about the time it takes to latch */
            /* a freq. offset which leads to an uncertainty in how long we */
            /* accumulate phase across each echo in the train */

            freq_ctrl = sl_rcvcf;
            phase_ctrl = recv_phase[sliceindex][ileave][echo];

            /* load demod. frequnecy in packet xtr packet */
            setfreqphase(freq_ctrl,
                         phase_ctrl,
                         echotrainxtr_ref[echo]);

            /* frequency offset */ 
            tempamp=(short)((recv_freq[sliceindex][ileave][echo]-sl_rcvcf)/omega_scale);

            if (vrgfsamp) {

                /* offset waveform (omega) is a trapezoid */        
                setiampt(tempamp, &omega_flatref, echo);

            } else {

                /* simple constant offset waveform */
                setiamp(tempamp, &omega_flatref, echo);

            }

        } /* end acq_data condition */

        /* determine which echos will be collected */
        if ((echo >= rspe1st) && (echo < rspe1st + rspetot))
            dabacqctrl = (TYPDAB_PACKETS)acq_data;
        else
            dabacqctrl = DABOFF;

        /* set RBA bit for echos to acquire */
        acqctrl(dabacqctrl, fast_rec, echotrainrba_ref[echo]);

    } /* end echo loop for setting up xtr & rba packets */  

    return SUCCESS;

} /* End dabrbaloadref */

/***************************** turnOffBlips  *************************/
STATUS turnOffBlips( INT numblips )
{
    int bcnt;  

    /* Blips */
    for (bcnt=0;bcnt<numblips-1;bcnt++)
        setiampt((short)0, &refgyb, bcnt); 

    /* Prephaser */
    setiampt((short)0, &refgy1, 0);

    return SUCCESS;

} /* End turnOffBlips */


/* Add more MRE RSP info */
/* Start inline from touch.e TouchRsp */

void SlideTouchTrig( void )
{
    int slide, i;

    /* ************************************************** */
    /* move the trigger pulse from one offset to the next */
    /* ************************************************** */
    slide = (opacqo == 0) ? pass_rep : pass % multi_phases;
    for( i = 0; i < multi_phases; i++ )
    {
        setwave(wave_trigoff, &sync_on_2, i);
    }
    if( rspent != L_REF )
    {
        if( slide < multi_phases )
        {
            setwave(wave_trigon, &sync_on_2, slide);
        }
    }
}

void NullTouchAmp( void )
{

    if( touch_gnum > 0 )
    {
        if( touch_xdir )
        {
            if( touch_fcomp )
            {
                setiampt(0, &gxtouchf, INSTRALL);
                if( touch_gnum > 1 )
                    setiampt(0, &gxtouchu, INSTRALL);
            }
            else
            {
                setiampt(0, &gxtouchu, INSTRALL);
            }
            if( touch_gnum > 0.5 )
            {
                setiampt(0, &gxtouchd, INSTRALL);
            }
        }
        if( touch_ydir )
        {
            if( touch_fcomp )
            {
                setiampt(0, &gytouchf, INSTRALL);
                if( touch_gnum > 1 )
                    setiampt(0, &gytouchu, INSTRALL);
            }
            else
            {
                setiampt(0, &gytouchu, INSTRALL);
            }
            if( touch_gnum > 0.5 )
            {
                setiampt(0, &gytouchd, INSTRALL);
            }
        }
        if( touch_zdir )
        {
            if( touch_fcomp )
            {
                setiampt(0, &gztouchf, INSTRALL);
                if( touch_gnum > 1 )
                    setiampt(0, &gztouchu, INSTRALL);
            }
            else
            {
                setiampt(0, &gztouchu, INSTRALL);
            }
            if( touch_gnum > 0.5 )
            {
                setiampt(0, &gztouchd, INSTRALL);
            }
        }
    } /* ends if (touch_gnum > 0) */
    /* MEGs after RF2 */
    if( meg_mode > 0 )
    {
        if( touch_gnum > 0 )
        {
            if( touch_xdir )
            {
                if( touch_fcomp )
                {
                    setiampt(0, &gxtouchf2, INSTRALL);
                    if( touch_gnum > 1 )
                        setiampt(0, &gxtouchu2, INSTRALL);
                }
                else
                {
                    setiampt(0, &gxtouchu2, INSTRALL);
                }
                if( touch_gnum > 0.5 )
                {
                    setiampt(0, &gxtouchd2, INSTRALL);
                }
            }
            if( touch_ydir )
            {
                if( touch_fcomp )
                {
                    setiampt(0, &gytouchf2, INSTRALL);
                    if( touch_gnum > 1 )
                        setiampt(0, &gytouchu2, INSTRALL);
                }
                else
                {
                    setiampt(0, &gytouchu2, INSTRALL);
                }
                if( touch_gnum > 0.5 )
                {
                    setiampt(0, &gytouchd2, INSTRALL);
                }
            }
            if( touch_zdir )
            {
                if( touch_fcomp )
                {
                    setiampt(0, &gztouchf2, INSTRALL);
                    if( touch_gnum > 1 )
                        setiampt(0, &gztouchu2, INSTRALL);
                }
                else
                {
                    setiampt(0, &gztouchu2, INSTRALL);
                }
                if( touch_gnum > 0.5 )
                {
                    setiampt(0, &gztouchd2, INSTRALL);
                }
            }
        }
    }
}
/* End inline from touch.e TouchRsp */
/* Start inline from touch.e TouchPgInit */
STATUS SetTouchAmpUd( int dir )
{

    if( dir >= MAX_NUM_TOUCH_MOTION_DIRS )
    {
        return FAILURE;
    }
    else
    {
        if( touch_gnum > 0 )
        {
            if( touch_xdir )
            {
                setiampt((int)touchxuamp[dir], &gxtouchu, INSTRALL);
            }
            if( touch_ydir )
            {
                setiampt((int)touchyuamp[dir], &gytouchu, INSTRALL);
            }
            if( touch_zdir )
            {
                setiampt((int)touchzuamp[dir], &gztouchu, INSTRALL);
            }
            if( touch_gnum > 0.5 )
            {
                if( touch_xdir )
                {
                    setiampt((int)touchxdamp[dir], &gxtouchd, INSTRALL);
                }
                if( touch_ydir )
                {
                    setiampt((int)touchydamp[dir], &gytouchd, INSTRALL);
                }
                if( touch_zdir )
                {
                    setiampt((int)touchzdamp[dir], &gztouchd, INSTRALL);
                }
            }
            if( meg_mode >= 1 )
            {
                if( touch_xdir )
                {
                    setiampt((int)touchxuamp2[dir], &gxtouchu2, INSTRALL);
                }
                if( touch_ydir )
                {
                    setiampt((int)touchyuamp2[dir], &gytouchu2, INSTRALL);
                }
                if( touch_zdir )
                {
                    setiampt((int)touchzuamp2[dir], &gztouchu2, INSTRALL);
                }
                if( touch_gnum > 0.5 )
                {
                    if( touch_xdir )
                    {
                        setiampt((int)touchxdamp2[dir], &gxtouchd2, INSTRALL);
                    }
                    if( touch_ydir )
                    {
                        setiampt((int)touchydamp2[dir], &gytouchd2, INSTRALL);
                    }
                    if( touch_zdir )
                    {
                        setiampt((int)touchzdamp2[dir], &gztouchd2, INSTRALL);
                    }
                }
            }
        }
        return SUCCESS;
    }
}

STATUS SetTouchAmpUdf( int dir )
{

    if( dir >= MAX_NUM_TOUCH_MOTION_DIRS )
    {
        return FAILURE;
    }
    else
    {
        if( touch_gnum > 0 )
        {
            if( touch_gnum > 1 )
            {
                if( touch_xdir )
                    setiampt((int)touchxuamp[dir], &gxtouchu, INSTRALL);
                if( touch_ydir )
                    setiampt((int)touchyuamp[dir], &gytouchu, INSTRALL);
                if( touch_zdir )
                    setiampt((int)touchzuamp[dir], &gztouchu, INSTRALL);
            }
            if( touch_xdir )
                setiampt((int)touchxdamp[dir], &gxtouchd, INSTRALL);
            if( touch_ydir )
                setiampt((int)touchydamp[dir], &gytouchd, INSTRALL);
            if( touch_zdir )
                setiampt((int)touchzdamp[dir], &gztouchd, INSTRALL);
            if( touch_xdir )
                setiampt((int)touchxfamp[dir], &gxtouchf, INSTRALL);
            if( touch_ydir )
                setiampt((int)touchyfamp[dir], &gytouchf, INSTRALL);
            if( touch_zdir )
                setiampt((int)touchzfamp[dir], &gztouchf, INSTRALL);
            if( meg_mode >= 1 )
            {
                if( touch_gnum > 1 )
                {
                    if( touch_xdir )
                        setiampt((int)touchxuamp2[dir], &gxtouchu2, INSTRALL);
                    if( touch_ydir )
                        setiampt((int)touchyuamp2[dir], &gytouchu2, INSTRALL);
                    if( touch_zdir )
                        setiampt((int)touchzuamp2[dir], &gztouchu2, INSTRALL);
                }
                if( touch_xdir )
                    setiampt((int)touchxdamp2[dir], &gxtouchd2, INSTRALL);
                if( touch_ydir )
                    setiampt((int)touchydamp2[dir], &gytouchd2, INSTRALL);
                if( touch_zdir )
                    setiampt((int)touchzdamp2[dir], &gztouchd2, INSTRALL);
                if( touch_xdir )
                    setiampt((int)touchxfamp2[dir], &gxtouchf2, INSTRALL);
                if( touch_ydir )
                    setiampt((int)touchyfamp2[dir], &gytouchf2, INSTRALL);
                if( touch_zdir )
                    setiampt((int)touchzfamp2[dir], &gztouchf2, INSTRALL);
            }
        }
        return SUCCESS;
    }
}

void SetTouchAmp( int dir )
{
    if( touch_flag && (touch_gnum > 0) )
    {
        if( touch_fcomp )
        {
            SetTouchAmpUdf(dir);
        }
        else
        {
            SetTouchAmpUd(dir);
        }
    }
}
/* End inline from touch.e TouchPgInit */


void dummylinks( void )
{
    epic_loadcvs("thefile");            /* for downloading CVs */
}


/* Include special CV download code */
#include "bbepi.cvcopy.c"

